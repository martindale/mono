/*! For license information please see background.bundle.js.LICENSE.txt */
(() => { let e; let t; let n; let r; const i = { 4503: function (e) { e.exports = (() => { const e = { 8831: (e, t, n) => { e = n.nmd(e); const r = n(5108); const i = n(4155); (() => { if (void 0 !== n.g);else if (typeof window !== 'undefined')window.global = window; else { if (typeof self === 'undefined') throw new Error('cannot export Go (neither global, window nor self is defined)'); self.global = self } if (n.g.require || (n.g.require = n(5049)), !n.g.fs && n.g.require) { const e = n(2203); typeof e === 'object' && e !== null && Object.keys(e).length !== 0 && (n.g.fs = e) } const t = () => { const e = new Error('not implemented'); return e.code = 'ENOSYS', e }; if (!n.g.fs) { let e = ''; n.g.fs = { constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, writeSync (t, n) { e += a.decode(n); const i = e.lastIndexOf('\n'); return i != -1 && (r.log(e.substr(0, i)), e = e.substr(i + 1)), n.length }, write (e, n, r, i, o, a) { r === 0 && i === n.length && o === null ? a(null, this.writeSync(e, n)) : a(t()) }, chmod (e, n, r) { r(t()) }, chown (e, n, r, i) { i(t()) }, close (e, n) { n(t()) }, fchmod (e, n, r) { r(t()) }, fchown (e, n, r, i) { i(t()) }, fstat (e, n) { n(t()) }, fsync (e, t) { t(null) }, ftruncate (e, n, r) { r(t()) }, lchown (e, n, r, i) { i(t()) }, link (e, n, r) { r(t()) }, lstat (e, n) { n(t()) }, mkdir (e, n, r) { r(t()) }, open (e, n, r, i) { i(t()) }, read (e, n, r, i, o, a) { a(t()) }, readdir (e, n) { n(t()) }, readlink (e, n) { n(t()) }, rename (e, n, r) { r(t()) }, rmdir (e, n) { n(t()) }, stat (e, n) { n(t()) }, symlink (e, n, r) { r(t()) }, truncate (e, n, r) { r(t()) }, unlink (e, n) { n(t()) }, utimes (e, n, r, i) { i(t()) } } } if (n.g.process || (n.g.process = { getuid: () => -1, getgid: () => -1, geteuid: () => -1, getegid: () => -1, getgroups () { throw t() }, pid: -1, ppid: -1, umask () { throw t() }, cwd () { throw t() }, chdir () { throw t() } }), !n.g.crypto && n.g.require) { const e = n(4229); n.g.crypto = { getRandomValues (t) { e.randomFillSync(t) } } } if (!n.g.crypto) throw new Error('global.crypto is not available, polyfill required (getRandomValues only)'); if (n.g.performance || (n.g.performance = { now () { const [e, t] = i.hrtime(); return 1e3 * e + t / 1e6 } }), !n.g.TextEncoder && n.g.require && (n.g.TextEncoder = n(9539).TextEncoder), !n.g.TextEncoder) throw new Error('global.TextEncoder is not available, polyfill required'); if (!n.g.TextDecoder && n.g.require && (n.g.TextDecoder = n(9539).TextDecoder), !n.g.TextDecoder) throw new Error('global.TextDecoder is not available, polyfill required'); const o = new TextEncoder('utf-8'); const a = new TextDecoder('utf-8'); if (n.g.Go = class {constructor () { this.argv = ['js'], this.env = {}, this.exit = e => { e !== 0 && r.warn('exit code:', e) }, this._exitPromise = new Promise(e => { this._resolveExitPromise = e }), this._pendingEvent = null, this._scheduledTimeouts = new Map(), this._nextCallbackTimeoutID = 1; const e = (e, t) => { this.mem.setUint32(e + 0, t, !0), this.mem.setUint32(e + 4, Math.floor(t / 4294967296), !0) }; const t = e => this.mem.getUint32(e + 0, !0) + 4294967296 * this.mem.getInt32(e + 4, !0); const n = e => { const t = this.mem.getFloat64(e, !0); if (t === 0) return; if (!isNaN(t)) return t; const n = this.mem.getUint32(e, !0); return this._values[n] }; const i = (e, t) => { const n = 2146959360; if (typeof t === 'number' && t !== 0) return isNaN(t) ? (this.mem.setUint32(e + 4, n, !0), void this.mem.setUint32(e, 0, !0)) : void this.mem.setFloat64(e, t, !0); if (void 0 === t) return void this.mem.setFloat64(e, 0, !0); let r = this._ids.get(t); void 0 === r && (r = this._idPool.pop(), void 0 === r && (r = this._values.length), this._values[r] = t, this._goRefCounts[r] = 0, this._ids.set(t, r)), this._goRefCounts[r]++; let i = 0; switch (typeof t) { case 'object':t !== null && (i = 1); break; case 'string':i = 2; break; case 'symbol':i = 3; break; case 'function':i = 4 } this.mem.setUint32(e + 4, n | i, !0), this.mem.setUint32(e, r, !0) }; const s = e => { const n = t(e + 0); const r = t(e + 8); return new Uint8Array(this._inst.exports.mem.buffer, n, r) }; const c = e => { const r = t(e + 0); const i = t(e + 8); const o = new Array(i); for (let e = 0; e < i; e++)o[e] = n(r + 8 * e); return o }; const u = e => { const n = t(e + 0); const r = t(e + 8); return a.decode(new DataView(this._inst.exports.mem.buffer, n, r)) }; const l = Date.now() - performance.now(); this.importObject = { go: { 'runtime.wasmExit': e => { e >>>= 0; const t = this.mem.getInt32(e + 8, !0); this.exited = !0, delete this._inst, delete this._values, delete this._goRefCounts, delete this._ids, delete this._idPool, this.exit(t) }, 'runtime.wasmWrite': e => { const n = t(8 + (e >>>= 0)); const r = t(e + 16); const i = this.mem.getInt32(e + 24, !0); fs.writeSync(n, new Uint8Array(this._inst.exports.mem.buffer, r, i)) }, 'runtime.resetMemoryDataView': e => { this.mem = new DataView(this._inst.exports.mem.buffer) }, 'runtime.nanotime1': t => { e(8 + (t >>>= 0), 1e6 * (l + performance.now())) }, 'runtime.walltime': t => { t >>>= 0; const n = (new Date()).getTime(); e(t + 8, n / 1e3), this.mem.setInt32(t + 16, n % 1e3 * 1e6, !0) }, 'runtime.scheduleTimeoutEvent': e => { e >>>= 0; const n = this._nextCallbackTimeoutID; this._nextCallbackTimeoutID++, this._scheduledTimeouts.set(n, setTimeout(() => { for (this._resume(); this._scheduledTimeouts.has(n);)r.warn('scheduleTimeoutEvent: missed timeout event'), this._resume() }, t(e + 8) + 1)), this.mem.setInt32(e + 16, n, !0) }, 'runtime.clearTimeoutEvent': e => { e >>>= 0; const t = this.mem.getInt32(e + 8, !0); clearTimeout(this._scheduledTimeouts.get(t)), this._scheduledTimeouts.delete(t) }, 'runtime.getRandomData': e => { e >>>= 0, crypto.getRandomValues(s(e + 8)) }, 'syscall/js.finalizeRef': e => { e >>>= 0; const t = this.mem.getUint32(e + 8, !0); if (this._goRefCounts[t]--, this._goRefCounts[t] === 0) { const e = this._values[t]; this._values[t] = null, this._ids.delete(e), this._idPool.push(t) } }, 'syscall/js.stringVal': e => { i(24 + (e >>>= 0), u(e + 8)) }, 'syscall/js.valueGet': e => { e >>>= 0; const t = Reflect.get(n(e + 8), u(e + 16)); e = this._inst.exports.getsp() >>> 0, i(e + 32, t) }, 'syscall/js.valueSet': e => { e >>>= 0, Reflect.set(n(e + 8), u(e + 16), n(e + 32)) }, 'syscall/js.valueDelete': e => { e >>>= 0, Reflect.deleteProperty(n(e + 8), u(e + 16)) }, 'syscall/js.valueIndex': e => { i(24 + (e >>>= 0), Reflect.get(n(e + 8), t(e + 16))) }, 'syscall/js.valueSetIndex': e => { e >>>= 0, Reflect.set(n(e + 8), t(e + 16), n(e + 24)) }, 'syscall/js.valueCall': e => { e >>>= 0; try { const t = n(e + 8); const r = Reflect.get(t, u(e + 16)); const o = c(e + 32); const a = Reflect.apply(r, t, o); e = this._inst.exports.getsp() >>> 0, i(e + 56, a), this.mem.setUint8(e + 64, 1) } catch (t) { e = this._inst.exports.getsp() >>> 0, i(e + 56, t), this.mem.setUint8(e + 64, 0) } }, 'syscall/js.valueInvoke': e => { e >>>= 0; try { const t = n(e + 8); const r = c(e + 16); const o = Reflect.apply(t, void 0, r); e = this._inst.exports.getsp() >>> 0, i(e + 40, o), this.mem.setUint8(e + 48, 1) } catch (t) { e = this._inst.exports.getsp() >>> 0, i(e + 40, t), this.mem.setUint8(e + 48, 0) } }, 'syscall/js.valueNew': e => { e >>>= 0; try { const t = n(e + 8); const r = c(e + 16); const o = Reflect.construct(t, r); e = this._inst.exports.getsp() >>> 0, i(e + 40, o), this.mem.setUint8(e + 48, 1) } catch (t) { e = this._inst.exports.getsp() >>> 0, i(e + 40, t), this.mem.setUint8(e + 48, 0) } }, 'syscall/js.valueLength': t => { e(16 + (t >>>= 0), parseInt(n(t + 8).length)) }, 'syscall/js.valuePrepareString': t => { t >>>= 0; const r = o.encode(String(n(t + 8))); i(t + 16, r), e(t + 24, r.length) }, 'syscall/js.valueLoadString': e => { const t = n(8 + (e >>>= 0)); s(e + 16).set(t) }, 'syscall/js.valueInstanceOf': e => { e >>>= 0, this.mem.setUint8(e + 24, n(e + 8) instanceof n(e + 16) ? 1 : 0) }, 'syscall/js.copyBytesToGo': t => { const r = s(8 + (t >>>= 0)); const i = n(t + 32); if (!(i instanceof Uint8Array || i instanceof Uint8ClampedArray)) return void this.mem.setUint8(t + 48, 0); const o = i.subarray(0, r.length); r.set(o), e(t + 40, o.length), this.mem.setUint8(t + 48, 1) }, 'syscall/js.copyBytesToJS': t => { const r = n(8 + (t >>>= 0)); const i = s(t + 16); if (!(r instanceof Uint8Array || r instanceof Uint8ClampedArray)) return void this.mem.setUint8(t + 48, 0); const o = i.subarray(0, r.length); r.set(o), e(t + 40, o.length), this.mem.setUint8(t + 48, 1) }, debug: e => { r.log(e) } } } } async run (e) { if (!(e instanceof WebAssembly.Instance)) throw new Error('Go.run: WebAssembly.Instance expected'); this._inst = e, this.mem = new DataView(this._inst.exports.mem.buffer), this._values = [NaN, 0, null, !0, !1, n.g, this], this._goRefCounts = new Array(this._values.length).fill(1 / 0), this._ids = new Map([[0, 1], [null, 2], [!0, 3], [!1, 4], [n.g, 5], [this, 6]]), this._idPool = [], this.exited = !1; let t = 4096; const r = e => { const n = t; const r = o.encode(e + '\0'); return new Uint8Array(this.mem.buffer, t, r.length).set(r), t += r.length, t % 8 != 0 && (t += 8 - t % 8), n }; const i = this.argv.length; const a = []; this.argv.forEach(e => { a.push(r(e)) }), a.push(0), Object.keys(this.env).sort().forEach(e => { a.push(r(`${e}=${this.env[e]}`)) }), a.push(0); const s = t; if (a.forEach(e => { this.mem.setUint32(t, e, !0), this.mem.setUint32(t + 4, 0, !0), t += 8 }), t >= 8192) throw new Error('command line too long'); this._inst.exports.run(i, s), this.exited && this._resolveExitPromise(), await this._exitPromise }_resume () { if (this.exited) throw new Error('Go program has already exited'); this._inst.exports.resume(), this.exited && this._resolveExitPromise() }_makeFuncWrapper (e) { const t = this; return function () { const n = { id: e, this: this, args: arguments }; return t._pendingEvent = n, t._resume(), n.result } }}, n.g.require && n.g.require.main === e && n.g.process && n.g.process.versions && !n.g.process.versions.electron) { i.argv.length < 3 && (r.error('usage: go_js_wasm_exec [wasm binary] [arguments]'), i.exit(1)); const e = new Go(); e.argv = i.argv.slice(2), e.env = Object.assign({ TMPDIR: n(5381).tmpdir() }, i.env), e.exit = i.exit, WebAssembly.instantiate(fs.readFileSync(i.argv[2]), e.importObject).then(t => (i.on('exit', t => { t !== 0 || e.exited || (e._pendingEvent = { id: 0 }, e._resume()) }), e.run(t.instance))).catch(e => { r.error(e), i.exit(1) }) } })() }, 5049: e => { function t (e) { const t = new Error("Cannot find module '" + e + "'"); throw t.code = 'MODULE_NOT_FOUND', t }t.keys = () => [], t.resolve = t, t.id = 5049, e.exports = t }, 7923: function (e) { e.exports = (() => { 'use strict'; const e = { 877: (e, t, n) => { Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(644); t.default = function (e, t) { this.faradayServer = e(r.serviceNames.frdrpc.FaradayServer, t) } }, 382: function (e, t, n) { const r = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, '__esModule', { value: !0 }), t.LitApi = t.FaradayApi = t.PoolApi = t.LoopApi = t.LndApi = void 0; const i = n(152); Object.defineProperty(t, 'LndApi', { enumerable: !0, get: function () { return r(i).default } }); const o = n(343); Object.defineProperty(t, 'LoopApi', { enumerable: !0, get: function () { return r(o).default } }); const a = n(146); Object.defineProperty(t, 'PoolApi', { enumerable: !0, get: function () { return r(a).default } }); const s = n(877); Object.defineProperty(t, 'FaradayApi', { enumerable: !0, get: function () { return r(s).default } }); const c = n(929); Object.defineProperty(t, 'LitApi', { enumerable: !0, get: function () { return r(c).default } }) }, 929: (e, t, n) => { Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(644); t.default = function (e, t) { this.autopilot = e(r.serviceNames.litrpc.Autopilot, t), this.firewall = e(r.serviceNames.litrpc.Firewall, t), this.sessions = e(r.serviceNames.litrpc.Sessions, t) } }, 152: (e, t, n) => { Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(644); t.default = function (e, t) { this.autopilot = e(r.serviceNames.autopilotrpc.Autopilot, t), this.chainNotifier = e(r.serviceNames.chainrpc.ChainNotifier, t), this.invoices = e(r.serviceNames.invoicesrpc.Invoices, t), this.lightning = e(r.serviceNames.lnrpc.Lightning, t), this.router = e(r.serviceNames.routerrpc.Router, t), this.signer = e(r.serviceNames.signrpc.Signer, t), this.walletKit = e(r.serviceNames.walletrpc.WalletKit, t), this.walletUnlocker = e(r.serviceNames.lnrpc.WalletUnlocker, t), this.watchtower = e(r.serviceNames.watchtowerrpc.Watchtower, t), this.watchtowerClient = e(r.serviceNames.wtclientrpc.WatchtowerClient, t) } }, 343: (e, t, n) => { Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(644); t.default = function (e, t) { this.swapClient = e(r.serviceNames.looprpc.SwapClient, t), this.debug = e(r.serviceNames.looprpc.Debug, t) } }, 146: (e, t, n) => { Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(644); t.default = function (e, t) { this.trader = e(r.serviceNames.poolrpc.Trader, t), this.channelAuctioneer = e(r.serviceNames.poolrpc.ChannelAuctioneer, t), this.hashmail = e(r.serviceNames.poolrpc.HashMail, t) } }, 713: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), t.subscriptionMethods = t.LitApi = t.FaradayApi = t.PoolApi = t.LoopApi = t.LndApi = t.snakeKeysToCamel = t.isObject = t.camelKeysToSnake = void 0, i(n(894), t); const o = n(848); Object.defineProperty(t, 'camelKeysToSnake', { enumerable: !0, get: function () { return o.camelKeysToSnake } }), Object.defineProperty(t, 'isObject', { enumerable: !0, get: function () { return o.isObject } }), Object.defineProperty(t, 'snakeKeysToCamel', { enumerable: !0, get: function () { return o.snakeKeysToCamel } }); const a = n(382); Object.defineProperty(t, 'LndApi', { enumerable: !0, get: function () { return a.LndApi } }), Object.defineProperty(t, 'LoopApi', { enumerable: !0, get: function () { return a.LoopApi } }), Object.defineProperty(t, 'PoolApi', { enumerable: !0, get: function () { return a.PoolApi } }), Object.defineProperty(t, 'FaradayApi', { enumerable: !0, get: function () { return a.FaradayApi } }), Object.defineProperty(t, 'LitApi', { enumerable: !0, get: function () { return a.LitApi } }); const s = n(644); Object.defineProperty(t, 'subscriptionMethods', { enumerable: !0, get: function () { return s.subscriptionMethods } }) }, 273: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(726), t) }, 71: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(374), t) }, 76: (e, t) => { let n, r, i, o; Object.defineProperty(t, '__esModule', { value: !0 }), t.CloseRecommendationRequest_Metric = t.EntryType = t.FiatBackend = t.Granularity = void 0, (o = t.Granularity || (t.Granularity = {})).UNKNOWN_GRANULARITY = 'UNKNOWN_GRANULARITY', o.MINUTE = 'MINUTE', o.FIVE_MINUTES = 'FIVE_MINUTES', o.FIFTEEN_MINUTES = 'FIFTEEN_MINUTES', o.THIRTY_MINUTES = 'THIRTY_MINUTES', o.HOUR = 'HOUR', o.SIX_HOURS = 'SIX_HOURS', o.TWELVE_HOURS = 'TWELVE_HOURS', o.DAY = 'DAY', o.UNRECOGNIZED = 'UNRECOGNIZED', (i = t.FiatBackend || (t.FiatBackend = {})).UNKNOWN_FIATBACKEND = 'UNKNOWN_FIATBACKEND', i.COINCAP = 'COINCAP', i.COINDESK = 'COINDESK', i.CUSTOM = 'CUSTOM', i.COINGECKO = 'COINGECKO', i.UNRECOGNIZED = 'UNRECOGNIZED', (r = t.EntryType || (t.EntryType = {})).UNKNOWN = 'UNKNOWN', r.LOCAL_CHANNEL_OPEN = 'LOCAL_CHANNEL_OPEN', r.REMOTE_CHANNEL_OPEN = 'REMOTE_CHANNEL_OPEN', r.CHANNEL_OPEN_FEE = 'CHANNEL_OPEN_FEE', r.CHANNEL_CLOSE = 'CHANNEL_CLOSE', r.RECEIPT = 'RECEIPT', r.PAYMENT = 'PAYMENT', r.FEE = 'FEE', r.CIRCULAR_RECEIPT = 'CIRCULAR_RECEIPT', r.FORWARD = 'FORWARD', r.FORWARD_FEE = 'FORWARD_FEE', r.CIRCULAR_PAYMENT = 'CIRCULAR_PAYMENT', r.CIRCULAR_FEE = 'CIRCULAR_FEE', r.SWEEP = 'SWEEP', r.SWEEP_FEE = 'SWEEP_FEE', r.CHANNEL_CLOSE_FEE = 'CHANNEL_CLOSE_FEE', r.UNRECOGNIZED = 'UNRECOGNIZED', (n = t.CloseRecommendationRequest_Metric || (t.CloseRecommendationRequest_Metric = {})).UNKNOWN = 'UNKNOWN', n.UPTIME = 'UPTIME', n.REVENUE = 'REVENUE', n.INCOMING_VOLUME = 'INCOMING_VOLUME', n.OUTGOING_VOLUME = 'OUTGOING_VOLUME', n.TOTAL_VOLUME = 'TOTAL_VOLUME', n.UNRECOGNIZED = 'UNRECOGNIZED' }, 915: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(76), t) }, 894: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, 'default', { enumerable: !0, value: t }) } : function (e, t) { e.default = t }); const o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const n in e)n !== 'default' && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n); return i(t, e), t }; Object.defineProperty(t, '__esModule', { value: !0 }), t.poolrpc = t.looprpc = t.wtclientrpc = t.watchtowerrpc = t.walletrpc = t.signrpc = t.routerrpc = t.lnrpc = t.invoicesrpc = t.chainrpc = t.autopilotrpc = t.litrpc = t.frdrpc = void 0; const a = o(n(915)); t.frdrpc = a; const s = o(n(903)); t.litrpc = s; const c = o(n(273)); t.autopilotrpc = c; const u = o(n(71)); t.chainrpc = u; const l = o(n(312)); t.invoicesrpc = l; const d = o(n(452)); t.lnrpc = d; const f = o(n(226)); t.routerrpc = f; const h = o(n(207)); t.signrpc = h; const p = o(n(367)); t.walletrpc = p; const g = o(n(412)); t.watchtowerrpc = g; const m = o(n(946)); t.wtclientrpc = m; const y = o(n(11)); t.looprpc = y; const b = o(n(377)); t.poolrpc = b }, 312: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(212), t) }, 481: (e, t) => { let n; Object.defineProperty(t, '__esModule', { value: !0 }), t.ActionState = void 0, (n = t.ActionState || (t.ActionState = {})).STATE_UNKNOWN = 'STATE_UNKNOWN', n.STATE_PENDING = 'STATE_PENDING', n.STATE_DONE = 'STATE_DONE', n.STATE_ERROR = 'STATE_ERROR', n.UNRECOGNIZED = 'UNRECOGNIZED' }, 166: (e, t) => { Object.defineProperty(t, '__esModule', { value: !0 }) }, 199: (e, t) => { let n, r; Object.defineProperty(t, '__esModule', { value: !0 }), t.SessionState = t.SessionType = void 0, (r = t.SessionType || (t.SessionType = {})).TYPE_MACAROON_READONLY = 'TYPE_MACAROON_READONLY', r.TYPE_MACAROON_ADMIN = 'TYPE_MACAROON_ADMIN', r.TYPE_MACAROON_CUSTOM = 'TYPE_MACAROON_CUSTOM', r.TYPE_UI_PASSWORD = 'TYPE_UI_PASSWORD', r.TYPE_AUTOPILOT = 'TYPE_AUTOPILOT', r.TYPE_MACAROON_ACCOUNT = 'TYPE_MACAROON_ACCOUNT', r.UNRECOGNIZED = 'UNRECOGNIZED', (n = t.SessionState || (t.SessionState = {})).STATE_CREATED = 'STATE_CREATED', n.STATE_IN_USE = 'STATE_IN_USE', n.STATE_REVOKED = 'STATE_REVOKED', n.STATE_EXPIRED = 'STATE_EXPIRED', n.UNRECOGNIZED = 'UNRECOGNIZED' }, 903: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(481), t), i(n(166), t), i(n(199), t) }, 726: (e, t) => { Object.defineProperty(t, '__esModule', { value: !0 }) }, 374: (e, t) => { Object.defineProperty(t, '__esModule', { value: !0 }) }, 212: (e, t) => { let n; Object.defineProperty(t, '__esModule', { value: !0 }), t.LookupModifier = void 0, (n = t.LookupModifier || (t.LookupModifier = {})).DEFAULT = 'DEFAULT', n.HTLC_SET_ONLY = 'HTLC_SET_ONLY', n.HTLC_SET_BLANK = 'HTLC_SET_BLANK', n.UNRECOGNIZED = 'UNRECOGNIZED' }, 21: (e, t) => { let n, r, i, o, a, s, c, u, l, d, f, h, p, g, m, y, b, v, w, _; Object.defineProperty(t, '__esModule', { value: !0 }), t.Failure_FailureCode = t.HTLCAttempt_HTLCStatus = t.Payment_PaymentStatus = t.Invoice_InvoiceState = t.ChannelEventUpdate_UpdateType = t.PendingChannelsResponse_ForceClosedChannel_AnchorState = t.PeerEvent_EventType = t.Peer_SyncType = t.ChannelCloseSummary_ClosureType = t.UpdateFailure = t.FeatureBit = t.PaymentFailureReason = t.InvoiceHTLCState = t.NodeMetricType = t.ResolutionOutcome = t.ResolutionType = t.Initiator = t.CommitmentType = t.AddressType = t.OutputScriptType = void 0, (_ = t.OutputScriptType || (t.OutputScriptType = {})).SCRIPT_TYPE_PUBKEY_HASH = 'SCRIPT_TYPE_PUBKEY_HASH', _.SCRIPT_TYPE_SCRIPT_HASH = 'SCRIPT_TYPE_SCRIPT_HASH', _.SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH = 'SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH', _.SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH = 'SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH', _.SCRIPT_TYPE_PUBKEY = 'SCRIPT_TYPE_PUBKEY', _.SCRIPT_TYPE_MULTISIG = 'SCRIPT_TYPE_MULTISIG', _.SCRIPT_TYPE_NULLDATA = 'SCRIPT_TYPE_NULLDATA', _.SCRIPT_TYPE_NON_STANDARD = 'SCRIPT_TYPE_NON_STANDARD', _.SCRIPT_TYPE_WITNESS_UNKNOWN = 'SCRIPT_TYPE_WITNESS_UNKNOWN', _.SCRIPT_TYPE_WITNESS_V1_TAPROOT = 'SCRIPT_TYPE_WITNESS_V1_TAPROOT', _.UNRECOGNIZED = 'UNRECOGNIZED', (w = t.AddressType || (t.AddressType = {})).WITNESS_PUBKEY_HASH = 'WITNESS_PUBKEY_HASH', w.NESTED_PUBKEY_HASH = 'NESTED_PUBKEY_HASH', w.UNUSED_WITNESS_PUBKEY_HASH = 'UNUSED_WITNESS_PUBKEY_HASH', w.UNUSED_NESTED_PUBKEY_HASH = 'UNUSED_NESTED_PUBKEY_HASH', w.TAPROOT_PUBKEY = 'TAPROOT_PUBKEY', w.UNUSED_TAPROOT_PUBKEY = 'UNUSED_TAPROOT_PUBKEY', w.UNRECOGNIZED = 'UNRECOGNIZED', (v = t.CommitmentType || (t.CommitmentType = {})).UNKNOWN_COMMITMENT_TYPE = 'UNKNOWN_COMMITMENT_TYPE', v.LEGACY = 'LEGACY', v.STATIC_REMOTE_KEY = 'STATIC_REMOTE_KEY', v.ANCHORS = 'ANCHORS', v.SCRIPT_ENFORCED_LEASE = 'SCRIPT_ENFORCED_LEASE', v.UNRECOGNIZED = 'UNRECOGNIZED', (b = t.Initiator || (t.Initiator = {})).INITIATOR_UNKNOWN = 'INITIATOR_UNKNOWN', b.INITIATOR_LOCAL = 'INITIATOR_LOCAL', b.INITIATOR_REMOTE = 'INITIATOR_REMOTE', b.INITIATOR_BOTH = 'INITIATOR_BOTH', b.UNRECOGNIZED = 'UNRECOGNIZED', (y = t.ResolutionType || (t.ResolutionType = {})).TYPE_UNKNOWN = 'TYPE_UNKNOWN', y.ANCHOR = 'ANCHOR', y.INCOMING_HTLC = 'INCOMING_HTLC', y.OUTGOING_HTLC = 'OUTGOING_HTLC', y.COMMIT = 'COMMIT', y.UNRECOGNIZED = 'UNRECOGNIZED', (m = t.ResolutionOutcome || (t.ResolutionOutcome = {})).OUTCOME_UNKNOWN = 'OUTCOME_UNKNOWN', m.CLAIMED = 'CLAIMED', m.UNCLAIMED = 'UNCLAIMED', m.ABANDONED = 'ABANDONED', m.FIRST_STAGE = 'FIRST_STAGE', m.TIMEOUT = 'TIMEOUT', m.UNRECOGNIZED = 'UNRECOGNIZED', (g = t.NodeMetricType || (t.NodeMetricType = {})).UNKNOWN = 'UNKNOWN', g.BETWEENNESS_CENTRALITY = 'BETWEENNESS_CENTRALITY', g.UNRECOGNIZED = 'UNRECOGNIZED', (p = t.InvoiceHTLCState || (t.InvoiceHTLCState = {})).ACCEPTED = 'ACCEPTED', p.SETTLED = 'SETTLED', p.CANCELED = 'CANCELED', p.UNRECOGNIZED = 'UNRECOGNIZED', (h = t.PaymentFailureReason || (t.PaymentFailureReason = {})).FAILURE_REASON_NONE = 'FAILURE_REASON_NONE', h.FAILURE_REASON_TIMEOUT = 'FAILURE_REASON_TIMEOUT', h.FAILURE_REASON_NO_ROUTE = 'FAILURE_REASON_NO_ROUTE', h.FAILURE_REASON_ERROR = 'FAILURE_REASON_ERROR', h.FAILURE_REASON_INCORRECT_PAYMENT_DETAILS = 'FAILURE_REASON_INCORRECT_PAYMENT_DETAILS', h.FAILURE_REASON_INSUFFICIENT_BALANCE = 'FAILURE_REASON_INSUFFICIENT_BALANCE', h.UNRECOGNIZED = 'UNRECOGNIZED', (f = t.FeatureBit || (t.FeatureBit = {})).DATALOSS_PROTECT_REQ = 'DATALOSS_PROTECT_REQ', f.DATALOSS_PROTECT_OPT = 'DATALOSS_PROTECT_OPT', f.INITIAL_ROUING_SYNC = 'INITIAL_ROUING_SYNC', f.UPFRONT_SHUTDOWN_SCRIPT_REQ = 'UPFRONT_SHUTDOWN_SCRIPT_REQ', f.UPFRONT_SHUTDOWN_SCRIPT_OPT = 'UPFRONT_SHUTDOWN_SCRIPT_OPT', f.GOSSIP_QUERIES_REQ = 'GOSSIP_QUERIES_REQ', f.GOSSIP_QUERIES_OPT = 'GOSSIP_QUERIES_OPT', f.TLV_ONION_REQ = 'TLV_ONION_REQ', f.TLV_ONION_OPT = 'TLV_ONION_OPT', f.EXT_GOSSIP_QUERIES_REQ = 'EXT_GOSSIP_QUERIES_REQ', f.EXT_GOSSIP_QUERIES_OPT = 'EXT_GOSSIP_QUERIES_OPT', f.STATIC_REMOTE_KEY_REQ = 'STATIC_REMOTE_KEY_REQ', f.STATIC_REMOTE_KEY_OPT = 'STATIC_REMOTE_KEY_OPT', f.PAYMENT_ADDR_REQ = 'PAYMENT_ADDR_REQ', f.PAYMENT_ADDR_OPT = 'PAYMENT_ADDR_OPT', f.MPP_REQ = 'MPP_REQ', f.MPP_OPT = 'MPP_OPT', f.WUMBO_CHANNELS_REQ = 'WUMBO_CHANNELS_REQ', f.WUMBO_CHANNELS_OPT = 'WUMBO_CHANNELS_OPT', f.ANCHORS_REQ = 'ANCHORS_REQ', f.ANCHORS_OPT = 'ANCHORS_OPT', f.ANCHORS_ZERO_FEE_HTLC_REQ = 'ANCHORS_ZERO_FEE_HTLC_REQ', f.ANCHORS_ZERO_FEE_HTLC_OPT = 'ANCHORS_ZERO_FEE_HTLC_OPT', f.AMP_REQ = 'AMP_REQ', f.AMP_OPT = 'AMP_OPT', f.UNRECOGNIZED = 'UNRECOGNIZED', (d = t.UpdateFailure || (t.UpdateFailure = {})).UPDATE_FAILURE_UNKNOWN = 'UPDATE_FAILURE_UNKNOWN', d.UPDATE_FAILURE_PENDING = 'UPDATE_FAILURE_PENDING', d.UPDATE_FAILURE_NOT_FOUND = 'UPDATE_FAILURE_NOT_FOUND', d.UPDATE_FAILURE_INTERNAL_ERR = 'UPDATE_FAILURE_INTERNAL_ERR', d.UPDATE_FAILURE_INVALID_PARAMETER = 'UPDATE_FAILURE_INVALID_PARAMETER', d.UNRECOGNIZED = 'UNRECOGNIZED', (l = t.ChannelCloseSummary_ClosureType || (t.ChannelCloseSummary_ClosureType = {})).COOPERATIVE_CLOSE = 'COOPERATIVE_CLOSE', l.LOCAL_FORCE_CLOSE = 'LOCAL_FORCE_CLOSE', l.REMOTE_FORCE_CLOSE = 'REMOTE_FORCE_CLOSE', l.BREACH_CLOSE = 'BREACH_CLOSE', l.FUNDING_CANCELED = 'FUNDING_CANCELED', l.ABANDONED = 'ABANDONED', l.UNRECOGNIZED = 'UNRECOGNIZED', (u = t.Peer_SyncType || (t.Peer_SyncType = {})).UNKNOWN_SYNC = 'UNKNOWN_SYNC', u.ACTIVE_SYNC = 'ACTIVE_SYNC', u.PASSIVE_SYNC = 'PASSIVE_SYNC', u.PINNED_SYNC = 'PINNED_SYNC', u.UNRECOGNIZED = 'UNRECOGNIZED', (c = t.PeerEvent_EventType || (t.PeerEvent_EventType = {})).PEER_ONLINE = 'PEER_ONLINE', c.PEER_OFFLINE = 'PEER_OFFLINE', c.UNRECOGNIZED = 'UNRECOGNIZED', (s = t.PendingChannelsResponse_ForceClosedChannel_AnchorState || (t.PendingChannelsResponse_ForceClosedChannel_AnchorState = {})).LIMBO = 'LIMBO', s.RECOVERED = 'RECOVERED', s.LOST = 'LOST', s.UNRECOGNIZED = 'UNRECOGNIZED', (a = t.ChannelEventUpdate_UpdateType || (t.ChannelEventUpdate_UpdateType = {})).OPEN_CHANNEL = 'OPEN_CHANNEL', a.CLOSED_CHANNEL = 'CLOSED_CHANNEL', a.ACTIVE_CHANNEL = 'ACTIVE_CHANNEL', a.INACTIVE_CHANNEL = 'INACTIVE_CHANNEL', a.PENDING_OPEN_CHANNEL = 'PENDING_OPEN_CHANNEL', a.FULLY_RESOLVED_CHANNEL = 'FULLY_RESOLVED_CHANNEL', a.UNRECOGNIZED = 'UNRECOGNIZED', (o = t.Invoice_InvoiceState || (t.Invoice_InvoiceState = {})).OPEN = 'OPEN', o.SETTLED = 'SETTLED', o.CANCELED = 'CANCELED', o.ACCEPTED = 'ACCEPTED', o.UNRECOGNIZED = 'UNRECOGNIZED', (i = t.Payment_PaymentStatus || (t.Payment_PaymentStatus = {})).UNKNOWN = 'UNKNOWN', i.IN_FLIGHT = 'IN_FLIGHT', i.SUCCEEDED = 'SUCCEEDED', i.FAILED = 'FAILED', i.UNRECOGNIZED = 'UNRECOGNIZED', (r = t.HTLCAttempt_HTLCStatus || (t.HTLCAttempt_HTLCStatus = {})).IN_FLIGHT = 'IN_FLIGHT', r.SUCCEEDED = 'SUCCEEDED', r.FAILED = 'FAILED', r.UNRECOGNIZED = 'UNRECOGNIZED', (n = t.Failure_FailureCode || (t.Failure_FailureCode = {})).RESERVED = 'RESERVED', n.INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = 'INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS', n.INCORRECT_PAYMENT_AMOUNT = 'INCORRECT_PAYMENT_AMOUNT', n.FINAL_INCORRECT_CLTV_EXPIRY = 'FINAL_INCORRECT_CLTV_EXPIRY', n.FINAL_INCORRECT_HTLC_AMOUNT = 'FINAL_INCORRECT_HTLC_AMOUNT', n.FINAL_EXPIRY_TOO_SOON = 'FINAL_EXPIRY_TOO_SOON', n.INVALID_REALM = 'INVALID_REALM', n.EXPIRY_TOO_SOON = 'EXPIRY_TOO_SOON', n.INVALID_ONION_VERSION = 'INVALID_ONION_VERSION', n.INVALID_ONION_HMAC = 'INVALID_ONION_HMAC', n.INVALID_ONION_KEY = 'INVALID_ONION_KEY', n.AMOUNT_BELOW_MINIMUM = 'AMOUNT_BELOW_MINIMUM', n.FEE_INSUFFICIENT = 'FEE_INSUFFICIENT', n.INCORRECT_CLTV_EXPIRY = 'INCORRECT_CLTV_EXPIRY', n.CHANNEL_DISABLED = 'CHANNEL_DISABLED', n.TEMPORARY_CHANNEL_FAILURE = 'TEMPORARY_CHANNEL_FAILURE', n.REQUIRED_NODE_FEATURE_MISSING = 'REQUIRED_NODE_FEATURE_MISSING', n.REQUIRED_CHANNEL_FEATURE_MISSING = 'REQUIRED_CHANNEL_FEATURE_MISSING', n.UNKNOWN_NEXT_PEER = 'UNKNOWN_NEXT_PEER', n.TEMPORARY_NODE_FAILURE = 'TEMPORARY_NODE_FAILURE', n.PERMANENT_NODE_FAILURE = 'PERMANENT_NODE_FAILURE', n.PERMANENT_CHANNEL_FAILURE = 'PERMANENT_CHANNEL_FAILURE', n.EXPIRY_TOO_FAR = 'EXPIRY_TOO_FAR', n.MPP_TIMEOUT = 'MPP_TIMEOUT', n.INVALID_ONION_PAYLOAD = 'INVALID_ONION_PAYLOAD', n.INTERNAL_FAILURE = 'INTERNAL_FAILURE', n.UNKNOWN_FAILURE = 'UNKNOWN_FAILURE', n.UNREADABLE_FAILURE = 'UNREADABLE_FAILURE', n.UNRECOGNIZED = 'UNRECOGNIZED' }, 288: (e, t) => { let n, r, i, o, a, s; Object.defineProperty(t, '__esModule', { value: !0 }), t.HtlcEvent_EventType = t.MissionControlConfig_ProbabilityModel = t.ChanStatusAction = t.ResolveHoldForwardAction = t.PaymentState = t.FailureDetail = void 0, (s = t.FailureDetail || (t.FailureDetail = {})).UNKNOWN = 'UNKNOWN', s.NO_DETAIL = 'NO_DETAIL', s.ONION_DECODE = 'ONION_DECODE', s.LINK_NOT_ELIGIBLE = 'LINK_NOT_ELIGIBLE', s.ON_CHAIN_TIMEOUT = 'ON_CHAIN_TIMEOUT', s.HTLC_EXCEEDS_MAX = 'HTLC_EXCEEDS_MAX', s.INSUFFICIENT_BALANCE = 'INSUFFICIENT_BALANCE', s.INCOMPLETE_FORWARD = 'INCOMPLETE_FORWARD', s.HTLC_ADD_FAILED = 'HTLC_ADD_FAILED', s.FORWARDS_DISABLED = 'FORWARDS_DISABLED', s.INVOICE_CANCELED = 'INVOICE_CANCELED', s.INVOICE_UNDERPAID = 'INVOICE_UNDERPAID', s.INVOICE_EXPIRY_TOO_SOON = 'INVOICE_EXPIRY_TOO_SOON', s.INVOICE_NOT_OPEN = 'INVOICE_NOT_OPEN', s.MPP_INVOICE_TIMEOUT = 'MPP_INVOICE_TIMEOUT', s.ADDRESS_MISMATCH = 'ADDRESS_MISMATCH', s.SET_TOTAL_MISMATCH = 'SET_TOTAL_MISMATCH', s.SET_TOTAL_TOO_LOW = 'SET_TOTAL_TOO_LOW', s.SET_OVERPAID = 'SET_OVERPAID', s.UNKNOWN_INVOICE = 'UNKNOWN_INVOICE', s.INVALID_KEYSEND = 'INVALID_KEYSEND', s.MPP_IN_PROGRESS = 'MPP_IN_PROGRESS', s.CIRCULAR_ROUTE = 'CIRCULAR_ROUTE', s.UNRECOGNIZED = 'UNRECOGNIZED', (a = t.PaymentState || (t.PaymentState = {})).IN_FLIGHT = 'IN_FLIGHT', a.SUCCEEDED = 'SUCCEEDED', a.FAILED_TIMEOUT = 'FAILED_TIMEOUT', a.FAILED_NO_ROUTE = 'FAILED_NO_ROUTE', a.FAILED_ERROR = 'FAILED_ERROR', a.FAILED_INCORRECT_PAYMENT_DETAILS = 'FAILED_INCORRECT_PAYMENT_DETAILS', a.FAILED_INSUFFICIENT_BALANCE = 'FAILED_INSUFFICIENT_BALANCE', a.UNRECOGNIZED = 'UNRECOGNIZED', (o = t.ResolveHoldForwardAction || (t.ResolveHoldForwardAction = {})).SETTLE = 'SETTLE', o.FAIL = 'FAIL', o.RESUME = 'RESUME', o.UNRECOGNIZED = 'UNRECOGNIZED', (i = t.ChanStatusAction || (t.ChanStatusAction = {})).ENABLE = 'ENABLE', i.DISABLE = 'DISABLE', i.AUTO = 'AUTO', i.UNRECOGNIZED = 'UNRECOGNIZED', (r = t.MissionControlConfig_ProbabilityModel || (t.MissionControlConfig_ProbabilityModel = {})).APRIORI = 'APRIORI', r.BIMODAL = 'BIMODAL', r.UNRECOGNIZED = 'UNRECOGNIZED', (n = t.HtlcEvent_EventType || (t.HtlcEvent_EventType = {})).UNKNOWN = 'UNKNOWN', n.SEND = 'SEND', n.RECEIVE = 'RECEIVE', n.FORWARD = 'FORWARD', n.UNRECOGNIZED = 'UNRECOGNIZED' }, 885: (e, t) => { let n, r; Object.defineProperty(t, '__esModule', { value: !0 }), t.MuSig2Version = t.SignMethod = void 0, (r = t.SignMethod || (t.SignMethod = {})).SIGN_METHOD_WITNESS_V0 = 'SIGN_METHOD_WITNESS_V0', r.SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086 = 'SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086', r.SIGN_METHOD_TAPROOT_KEY_SPEND = 'SIGN_METHOD_TAPROOT_KEY_SPEND', r.SIGN_METHOD_TAPROOT_SCRIPT_SPEND = 'SIGN_METHOD_TAPROOT_SCRIPT_SPEND', r.UNRECOGNIZED = 'UNRECOGNIZED', (n = t.MuSig2Version || (t.MuSig2Version = {})).MUSIG2_VERSION_UNDEFINED = 'MUSIG2_VERSION_UNDEFINED', n.MUSIG2_VERSION_V040 = 'MUSIG2_VERSION_V040', n.MUSIG2_VERSION_V100RC2 = 'MUSIG2_VERSION_V100RC2', n.UNRECOGNIZED = 'UNRECOGNIZED' }, 213: (e, t) => { let n, r, i; Object.defineProperty(t, '__esModule', { value: !0 }), t.ChangeAddressType = t.WitnessType = t.AddressType = void 0, (i = t.AddressType || (t.AddressType = {})).UNKNOWN = 'UNKNOWN', i.WITNESS_PUBKEY_HASH = 'WITNESS_PUBKEY_HASH', i.NESTED_WITNESS_PUBKEY_HASH = 'NESTED_WITNESS_PUBKEY_HASH', i.HYBRID_NESTED_WITNESS_PUBKEY_HASH = 'HYBRID_NESTED_WITNESS_PUBKEY_HASH', i.TAPROOT_PUBKEY = 'TAPROOT_PUBKEY', i.UNRECOGNIZED = 'UNRECOGNIZED', (r = t.WitnessType || (t.WitnessType = {})).UNKNOWN_WITNESS = 'UNKNOWN_WITNESS', r.COMMITMENT_TIME_LOCK = 'COMMITMENT_TIME_LOCK', r.COMMITMENT_NO_DELAY = 'COMMITMENT_NO_DELAY', r.COMMITMENT_REVOKE = 'COMMITMENT_REVOKE', r.HTLC_OFFERED_REVOKE = 'HTLC_OFFERED_REVOKE', r.HTLC_ACCEPTED_REVOKE = 'HTLC_ACCEPTED_REVOKE', r.HTLC_OFFERED_TIMEOUT_SECOND_LEVEL = 'HTLC_OFFERED_TIMEOUT_SECOND_LEVEL', r.HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL = 'HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL', r.HTLC_OFFERED_REMOTE_TIMEOUT = 'HTLC_OFFERED_REMOTE_TIMEOUT', r.HTLC_ACCEPTED_REMOTE_SUCCESS = 'HTLC_ACCEPTED_REMOTE_SUCCESS', r.HTLC_SECOND_LEVEL_REVOKE = 'HTLC_SECOND_LEVEL_REVOKE', r.WITNESS_KEY_HASH = 'WITNESS_KEY_HASH', r.NESTED_WITNESS_KEY_HASH = 'NESTED_WITNESS_KEY_HASH', r.COMMITMENT_ANCHOR = 'COMMITMENT_ANCHOR', r.UNRECOGNIZED = 'UNRECOGNIZED', (n = t.ChangeAddressType || (t.ChangeAddressType = {})).CHANGE_ADDRESS_TYPE_UNSPECIFIED = 'CHANGE_ADDRESS_TYPE_UNSPECIFIED', n.CHANGE_ADDRESS_TYPE_P2TR = 'CHANGE_ADDRESS_TYPE_P2TR', n.UNRECOGNIZED = 'UNRECOGNIZED' }, 939: (e, t) => { Object.defineProperty(t, '__esModule', { value: !0 }) }, 482: (e, t) => { Object.defineProperty(t, '__esModule', { value: !0 }) }, 921: (e, t) => { let n; Object.defineProperty(t, '__esModule', { value: !0 }), t.PolicyType = void 0, (n = t.PolicyType || (t.PolicyType = {})).LEGACY = 'LEGACY', n.ANCHOR = 'ANCHOR', n.UNRECOGNIZED = 'UNRECOGNIZED' }, 452: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(21), t), i(n(939), t) }, 598: (e, t) => { let n, r, i, o, a; Object.defineProperty(t, '__esModule', { value: !0 }), t.AutoReason = t.LiquidityRuleType = t.FailureReason = t.SwapState = t.SwapType = void 0, (a = t.SwapType || (t.SwapType = {})).LOOP_OUT = 'LOOP_OUT', a.LOOP_IN = 'LOOP_IN', a.UNRECOGNIZED = 'UNRECOGNIZED', (o = t.SwapState || (t.SwapState = {})).INITIATED = 'INITIATED', o.PREIMAGE_REVEALED = 'PREIMAGE_REVEALED', o.HTLC_PUBLISHED = 'HTLC_PUBLISHED', o.SUCCESS = 'SUCCESS', o.FAILED = 'FAILED', o.INVOICE_SETTLED = 'INVOICE_SETTLED', o.UNRECOGNIZED = 'UNRECOGNIZED', (i = t.FailureReason || (t.FailureReason = {})).FAILURE_REASON_NONE = 'FAILURE_REASON_NONE', i.FAILURE_REASON_OFFCHAIN = 'FAILURE_REASON_OFFCHAIN', i.FAILURE_REASON_TIMEOUT = 'FAILURE_REASON_TIMEOUT', i.FAILURE_REASON_SWEEP_TIMEOUT = 'FAILURE_REASON_SWEEP_TIMEOUT', i.FAILURE_REASON_INSUFFICIENT_VALUE = 'FAILURE_REASON_INSUFFICIENT_VALUE', i.FAILURE_REASON_TEMPORARY = 'FAILURE_REASON_TEMPORARY', i.FAILURE_REASON_INCORRECT_AMOUNT = 'FAILURE_REASON_INCORRECT_AMOUNT', i.UNRECOGNIZED = 'UNRECOGNIZED', (r = t.LiquidityRuleType || (t.LiquidityRuleType = {})).UNKNOWN = 'UNKNOWN', r.THRESHOLD = 'THRESHOLD', r.UNRECOGNIZED = 'UNRECOGNIZED', (n = t.AutoReason || (t.AutoReason = {})).AUTO_REASON_UNKNOWN = 'AUTO_REASON_UNKNOWN', n.AUTO_REASON_BUDGET_NOT_STARTED = 'AUTO_REASON_BUDGET_NOT_STARTED', n.AUTO_REASON_SWEEP_FEES = 'AUTO_REASON_SWEEP_FEES', n.AUTO_REASON_BUDGET_ELAPSED = 'AUTO_REASON_BUDGET_ELAPSED', n.AUTO_REASON_IN_FLIGHT = 'AUTO_REASON_IN_FLIGHT', n.AUTO_REASON_SWAP_FEE = 'AUTO_REASON_SWAP_FEE', n.AUTO_REASON_MINER_FEE = 'AUTO_REASON_MINER_FEE', n.AUTO_REASON_PREPAY = 'AUTO_REASON_PREPAY', n.AUTO_REASON_FAILURE_BACKOFF = 'AUTO_REASON_FAILURE_BACKOFF', n.AUTO_REASON_LOOP_OUT = 'AUTO_REASON_LOOP_OUT', n.AUTO_REASON_LOOP_IN = 'AUTO_REASON_LOOP_IN', n.AUTO_REASON_LIQUIDITY_OK = 'AUTO_REASON_LIQUIDITY_OK', n.AUTO_REASON_BUDGET_INSUFFICIENT = 'AUTO_REASON_BUDGET_INSUFFICIENT', n.AUTO_REASON_FEE_INSUFFICIENT = 'AUTO_REASON_FEE_INSUFFICIENT', n.UNRECOGNIZED = 'UNRECOGNIZED' }, 283: (e, t) => { Object.defineProperty(t, '__esModule', { value: !0 }) }, 11: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(598), t), i(n(283), t) }, 927: (e, t) => { let n, r, i, o, a, s, c, u, l, d, f, h, p, g; Object.defineProperty(t, '__esModule', { value: !0 }), t.InvalidOrder_FailReason = t.AccountDiff_AccountState = t.SubscribeError_Error = t.OrderReject_OrderRejectReason = t.OrderMatchReject_RejectReason = t.DurationBucketState = t.OrderState = t.ChannelConfirmationConstraints = t.ChannelAnnouncementConstraints = t.NodeTier = t.AuctionType = t.OrderChannelType = t.AuctionAccountState = t.ChannelType = void 0, (g = t.ChannelType || (t.ChannelType = {})).TWEAKLESS = 'TWEAKLESS', g.ANCHORS = 'ANCHORS', g.SCRIPT_ENFORCED_LEASE = 'SCRIPT_ENFORCED_LEASE', g.UNRECOGNIZED = 'UNRECOGNIZED', (p = t.AuctionAccountState || (t.AuctionAccountState = {})).STATE_PENDING_OPEN = 'STATE_PENDING_OPEN', p.STATE_OPEN = 'STATE_OPEN', p.STATE_EXPIRED = 'STATE_EXPIRED', p.STATE_PENDING_UPDATE = 'STATE_PENDING_UPDATE', p.STATE_CLOSED = 'STATE_CLOSED', p.STATE_PENDING_BATCH = 'STATE_PENDING_BATCH', p.STATE_EXPIRED_PENDING_UPDATE = 'STATE_EXPIRED_PENDING_UPDATE', p.UNRECOGNIZED = 'UNRECOGNIZED', (h = t.OrderChannelType || (t.OrderChannelType = {})).ORDER_CHANNEL_TYPE_UNKNOWN = 'ORDER_CHANNEL_TYPE_UNKNOWN', h.ORDER_CHANNEL_TYPE_PEER_DEPENDENT = 'ORDER_CHANNEL_TYPE_PEER_DEPENDENT', h.ORDER_CHANNEL_TYPE_SCRIPT_ENFORCED = 'ORDER_CHANNEL_TYPE_SCRIPT_ENFORCED', h.UNRECOGNIZED = 'UNRECOGNIZED', (f = t.AuctionType || (t.AuctionType = {})).AUCTION_TYPE_BTC_INBOUND_LIQUIDITY = 'AUCTION_TYPE_BTC_INBOUND_LIQUIDITY', f.AUCTION_TYPE_BTC_OUTBOUND_LIQUIDITY = 'AUCTION_TYPE_BTC_OUTBOUND_LIQUIDITY', f.UNRECOGNIZED = 'UNRECOGNIZED', (d = t.NodeTier || (t.NodeTier = {})).TIER_DEFAULT = 'TIER_DEFAULT', d.TIER_0 = 'TIER_0', d.TIER_1 = 'TIER_1', d.UNRECOGNIZED = 'UNRECOGNIZED', (l = t.ChannelAnnouncementConstraints || (t.ChannelAnnouncementConstraints = {})).ANNOUNCEMENT_NO_PREFERENCE = 'ANNOUNCEMENT_NO_PREFERENCE', l.ONLY_ANNOUNCED = 'ONLY_ANNOUNCED', l.ONLY_UNANNOUNCED = 'ONLY_UNANNOUNCED', l.UNRECOGNIZED = 'UNRECOGNIZED', (u = t.ChannelConfirmationConstraints || (t.ChannelConfirmationConstraints = {})).CONFIRMATION_NO_PREFERENCE = 'CONFIRMATION_NO_PREFERENCE', u.ONLY_CONFIRMED = 'ONLY_CONFIRMED', u.ONLY_ZEROCONF = 'ONLY_ZEROCONF', u.UNRECOGNIZED = 'UNRECOGNIZED', (c = t.OrderState || (t.OrderState = {})).ORDER_SUBMITTED = 'ORDER_SUBMITTED', c.ORDER_CLEARED = 'ORDER_CLEARED', c.ORDER_PARTIALLY_FILLED = 'ORDER_PARTIALLY_FILLED', c.ORDER_EXECUTED = 'ORDER_EXECUTED', c.ORDER_CANCELED = 'ORDER_CANCELED', c.ORDER_EXPIRED = 'ORDER_EXPIRED', c.ORDER_FAILED = 'ORDER_FAILED', c.UNRECOGNIZED = 'UNRECOGNIZED', (s = t.DurationBucketState || (t.DurationBucketState = {})).NO_MARKET = 'NO_MARKET', s.MARKET_CLOSED = 'MARKET_CLOSED', s.ACCEPTING_ORDERS = 'ACCEPTING_ORDERS', s.MARKET_OPEN = 'MARKET_OPEN', s.UNRECOGNIZED = 'UNRECOGNIZED', (a = t.OrderMatchReject_RejectReason || (t.OrderMatchReject_RejectReason = {})).UNKNOWN = 'UNKNOWN', a.SERVER_MISBEHAVIOR = 'SERVER_MISBEHAVIOR', a.BATCH_VERSION_MISMATCH = 'BATCH_VERSION_MISMATCH', a.PARTIAL_REJECT = 'PARTIAL_REJECT', a.UNRECOGNIZED = 'UNRECOGNIZED', (o = t.OrderReject_OrderRejectReason || (t.OrderReject_OrderRejectReason = {})).DUPLICATE_PEER = 'DUPLICATE_PEER', o.CHANNEL_FUNDING_FAILED = 'CHANNEL_FUNDING_FAILED', o.UNRECOGNIZED = 'UNRECOGNIZED', (i = t.SubscribeError_Error || (t.SubscribeError_Error = {})).UNKNOWN = 'UNKNOWN', i.SERVER_SHUTDOWN = 'SERVER_SHUTDOWN', i.ACCOUNT_DOES_NOT_EXIST = 'ACCOUNT_DOES_NOT_EXIST', i.INCOMPLETE_ACCOUNT_RESERVATION = 'INCOMPLETE_ACCOUNT_RESERVATION', i.UNRECOGNIZED = 'UNRECOGNIZED', (r = t.AccountDiff_AccountState || (t.AccountDiff_AccountState = {})).OUTPUT_RECREATED = 'OUTPUT_RECREATED', r.OUTPUT_DUST_EXTENDED_OFFCHAIN = 'OUTPUT_DUST_EXTENDED_OFFCHAIN', r.OUTPUT_DUST_ADDED_TO_FEES = 'OUTPUT_DUST_ADDED_TO_FEES', r.OUTPUT_FULLY_SPENT = 'OUTPUT_FULLY_SPENT', r.UNRECOGNIZED = 'UNRECOGNIZED', (n = t.InvalidOrder_FailReason || (t.InvalidOrder_FailReason = {})).INVALID_AMT = 'INVALID_AMT', n.UNRECOGNIZED = 'UNRECOGNIZED' }, 961: (e, t) => { Object.defineProperty(t, '__esModule', { value: !0 }) }, 456: (e, t) => { let n, r, i, o; Object.defineProperty(t, '__esModule', { value: !0 }), t.MatchRejectReason = t.MatchState = t.AccountState = t.AccountVersion = void 0, (o = t.AccountVersion || (t.AccountVersion = {})).ACCOUNT_VERSION_LND_DEPENDENT = 'ACCOUNT_VERSION_LND_DEPENDENT', o.ACCOUNT_VERSION_LEGACY = 'ACCOUNT_VERSION_LEGACY', o.ACCOUNT_VERSION_TAPROOT = 'ACCOUNT_VERSION_TAPROOT', o.ACCOUNT_VERSION_TAPROOT_V2 = 'ACCOUNT_VERSION_TAPROOT_V2', o.UNRECOGNIZED = 'UNRECOGNIZED', (i = t.AccountState || (t.AccountState = {})).PENDING_OPEN = 'PENDING_OPEN', i.PENDING_UPDATE = 'PENDING_UPDATE', i.OPEN = 'OPEN', i.EXPIRED = 'EXPIRED', i.PENDING_CLOSED = 'PENDING_CLOSED', i.CLOSED = 'CLOSED', i.RECOVERY_FAILED = 'RECOVERY_FAILED', i.PENDING_BATCH = 'PENDING_BATCH', i.UNRECOGNIZED = 'UNRECOGNIZED', (r = t.MatchState || (t.MatchState = {})).PREPARE = 'PREPARE', r.ACCEPTED = 'ACCEPTED', r.REJECTED = 'REJECTED', r.SIGNED = 'SIGNED', r.FINALIZED = 'FINALIZED', r.UNRECOGNIZED = 'UNRECOGNIZED', (n = t.MatchRejectReason || (t.MatchRejectReason = {})).NONE = 'NONE', n.SERVER_MISBEHAVIOR = 'SERVER_MISBEHAVIOR', n.BATCH_VERSION_MISMATCH = 'BATCH_VERSION_MISMATCH', n.PARTIAL_REJECT_COLLATERAL = 'PARTIAL_REJECT_COLLATERAL', n.PARTIAL_REJECT_DUPLICATE_PEER = 'PARTIAL_REJECT_DUPLICATE_PEER', n.PARTIAL_REJECT_CHANNEL_FUNDING_FAILED = 'PARTIAL_REJECT_CHANNEL_FUNDING_FAILED', n.UNRECOGNIZED = 'UNRECOGNIZED' }, 377: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(927), t), i(n(961), t), i(n(456), t) }, 226: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(288), t) }, 644: (e, t) => { Object.defineProperty(t, '__esModule', { value: !0 }), t.subscriptionMethods = t.serviceNames = void 0, t.serviceNames = { frdrpc: { FaradayServer: 'frdrpc.FaradayServer' }, litrpc: { Firewall: 'litrpc.Firewall', Autopilot: 'litrpc.Autopilot', Sessions: 'litrpc.Sessions' }, autopilotrpc: { Autopilot: 'autopilotrpc.Autopilot' }, chainrpc: { ChainNotifier: 'chainrpc.ChainNotifier' }, invoicesrpc: { Invoices: 'invoicesrpc.Invoices' }, lnrpc: { Lightning: 'lnrpc.Lightning', WalletUnlocker: 'lnrpc.WalletUnlocker' }, routerrpc: { Router: 'routerrpc.Router' }, signrpc: { Signer: 'signrpc.Signer' }, walletrpc: { WalletKit: 'walletrpc.WalletKit' }, watchtowerrpc: { Watchtower: 'watchtowerrpc.Watchtower' }, wtclientrpc: { WatchtowerClient: 'wtclientrpc.WatchtowerClient' }, looprpc: { SwapClient: 'looprpc.SwapClient', Debug: 'looprpc.Debug' }, poolrpc: { ChannelAuctioneer: 'poolrpc.ChannelAuctioneer', HashMail: 'poolrpc.HashMail', Trader: 'poolrpc.Trader' } }, t.subscriptionMethods = ['chainrpc.ChainNotifier.RegisterConfirmationsNtfn', 'chainrpc.ChainNotifier.RegisterSpendNtfn', 'chainrpc.ChainNotifier.RegisterBlockEpochNtfn', 'invoicesrpc.Invoices.SubscribeSingleInvoice', 'lnrpc.Lightning.SubscribeTransactions', 'lnrpc.Lightning.SubscribePeerEvents', 'lnrpc.Lightning.SubscribeChannelEvents', 'lnrpc.Lightning.OpenChannel', 'lnrpc.Lightning.ChannelAcceptor', 'lnrpc.Lightning.CloseChannel', 'lnrpc.Lightning.SendPayment', 'lnrpc.Lightning.SendToRoute', 'lnrpc.Lightning.SubscribeInvoices', 'lnrpc.Lightning.SubscribeChannelGraph', 'lnrpc.Lightning.SubscribeChannelBackups', 'lnrpc.Lightning.RegisterRPCMiddleware', 'lnrpc.Lightning.SubscribeCustomMessages', 'routerrpc.Router.SendPaymentV2', 'routerrpc.Router.TrackPaymentV2', 'routerrpc.Router.TrackPayments', 'routerrpc.Router.SubscribeHtlcEvents', 'routerrpc.Router.SendPayment', 'routerrpc.Router.TrackPayment', 'routerrpc.Router.HtlcInterceptor', 'looprpc.SwapClient.Monitor', 'poolrpc.ChannelAuctioneer.SubscribeBatchAuction', 'poolrpc.ChannelAuctioneer.SubscribeSidecar', 'poolrpc.HashMail.RecvStream'] }, 207: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(885), t) }, 367: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(213), t) }, 412: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(482), t) }, 946: function (e, t, n) { const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; Object.defineProperty(t, '__esModule', { value: !0 }), i(n(921), t) }, 848: (e, t) => { Object.defineProperty(t, '__esModule', { value: !0 }), t.camelKeysToSnake = t.snakeKeysToCamel = t.isObject = void 0; const n = function (e) { return Array.isArray(e) }; t.isObject = function (e) { return e === Object(e) && !n(e) && typeof e !== 'function' }, t.snakeKeysToCamel = function (e) { if ((0, t.isObject)(e)) { const r = {}; return Object.keys(e).forEach(function (n) { let i; r[(i = n, i.replace(/([-_][a-z])/gi, function (e) { return e.toUpperCase().replace('-', '').replace('_', '') }))] = (0, t.snakeKeysToCamel)(e[n]) }), r } return n(e) ? e.map(function (e) { return (0, t.snakeKeysToCamel)(e) }) : e }, t.camelKeysToSnake = function (e) { if ((0, t.isObject)(e)) { const r = {}; return Object.keys(e).forEach(function (n) { let i; r[(i = n, i.replace(/[A-Z]/g, function (e) { return '_'.concat(e.toLowerCase()) }))] = (0, t.camelKeysToSnake)(e[n]) }), r } return n(e) ? e.map(function (e) { return (0, t.camelKeysToSnake)(e) }) : e } } }; const t = {}; return (function n (r) { const i = t[r]; if (void 0 !== i) return i.exports; const o = t[r] = { exports: {} }; return e[r].call(o.exports, o, o.exports, n), o.exports }(713)) })() }, 9282: (e, t, n) => { 'use strict'; const r = n(4155); const i = n(5108); function o (e) { return o = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }, o(e) } let a; let s; const c = n(2136).codes; const u = c.ERR_AMBIGUOUS_ARGUMENT; const l = c.ERR_INVALID_ARG_TYPE; const d = c.ERR_INVALID_ARG_VALUE; const f = c.ERR_INVALID_RETURN_VALUE; const h = c.ERR_MISSING_ARGS; const p = n(5961); const g = n(9539).inspect; const m = n(9539).types; const y = m.isPromise; const b = m.isRegExp; const v = Object.assign ? Object.assign : n(8091).assign; const w = Object.is ? Object.is : n(609); function _ () { const e = n(9158); a = e.isDeepEqual, s = e.isDeepStrictEqual } new Map(); let E = !1; const k = e.exports = x; const S = {}; function A (e) { if (e.message instanceof Error) throw e.message; throw new p(e) } function O (e, t, n, r) { if (!n) { let i = !1; if (t === 0)i = !0, r = 'No value argument passed to `assert.ok()`'; else if (r instanceof Error) throw r; const o = new p({ actual: n, expected: !0, message: r, operator: '==', stackStartFn: e }); throw o.generatedMessage = i, o } } function x () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; O.apply(void 0, [x, t.length].concat(t)) }k.fail = function e (t, n, o, a, s) { let c; const u = arguments.length; if (u === 0 ? c = 'Failed' : u === 1 ? (o = t, t = void 0) : (!1 === E && (E = !0, (r.emitWarning ? r.emitWarning : i.warn.bind(i))('assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094')), u === 2 && (a = '!=')), o instanceof Error) throw o; const l = { actual: t, expected: n, operator: void 0 === a ? 'fail' : a, stackStartFn: s || e }; void 0 !== o && (l.message = o); const d = new p(l); throw c && (d.message = c, d.generatedMessage = !0), d }, k.AssertionError = p, k.ok = x, k.equal = function e (t, n, r) { if (arguments.length < 2) throw new h('actual', 'expected'); t != n && A({ actual: t, expected: n, message: r, operator: '==', stackStartFn: e }) }, k.notEqual = function e (t, n, r) { if (arguments.length < 2) throw new h('actual', 'expected'); t == n && A({ actual: t, expected: n, message: r, operator: '!=', stackStartFn: e }) }, k.deepEqual = function e (t, n, r) { if (arguments.length < 2) throw new h('actual', 'expected'); void 0 === a && _(), a(t, n) || A({ actual: t, expected: n, message: r, operator: 'deepEqual', stackStartFn: e }) }, k.notDeepEqual = function e (t, n, r) { if (arguments.length < 2) throw new h('actual', 'expected'); void 0 === a && _(), a(t, n) && A({ actual: t, expected: n, message: r, operator: 'notDeepEqual', stackStartFn: e }) }, k.deepStrictEqual = function e (t, n, r) { if (arguments.length < 2) throw new h('actual', 'expected'); void 0 === a && _(), s(t, n) || A({ actual: t, expected: n, message: r, operator: 'deepStrictEqual', stackStartFn: e }) }, k.notDeepStrictEqual = function e (t, n, r) { if (arguments.length < 2) throw new h('actual', 'expected'); void 0 === a && _(), s(t, n) && A({ actual: t, expected: n, message: r, operator: 'notDeepStrictEqual', stackStartFn: e }) }, k.strictEqual = function e (t, n, r) { if (arguments.length < 2) throw new h('actual', 'expected'); w(t, n) || A({ actual: t, expected: n, message: r, operator: 'strictEqual', stackStartFn: e }) }, k.notStrictEqual = function e (t, n, r) { if (arguments.length < 2) throw new h('actual', 'expected'); w(t, n) && A({ actual: t, expected: n, message: r, operator: 'notStrictEqual', stackStartFn: e }) }; const I = function e (t, n, r) { const i = this; !(function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') }(this, e)), n.forEach(function (e) { e in t && (void 0 !== r && typeof r[e] === 'string' && b(t[e]) && t[e].test(r[e]) ? i[e] = r[e] : i[e] = t[e]) }) }; function N (e, t, n, r, i, o) { if (!(n in e) || !s(e[n], t[n])) { if (!r) { const a = new I(e, i); const c = new I(t, i, e); const u = new p({ actual: a, expected: c, operator: 'deepStrictEqual', stackStartFn: o }); throw u.actual = e, u.expected = t, u.operator = o.name, u }A({ actual: e, expected: t, message: r, operator: o.name, stackStartFn: o }) } } function T (e, t, n, r) { if (typeof t !== 'function') { if (b(t)) return t.test(e); if (arguments.length === 2) throw new l('expected', ['Function', 'RegExp'], t); if (o(e) !== 'object' || e === null) { const i = new p({ actual: e, expected: t, message: n, operator: 'deepStrictEqual', stackStartFn: r }); throw i.operator = r.name, i } const s = Object.keys(t); if (t instanceof Error)s.push('name', 'message'); else if (s.length === 0) throw new d('error', t, 'may not be an empty object'); return void 0 === a && _(), s.forEach(function (i) { typeof e[i] === 'string' && b(t[i]) && t[i].test(e[i]) || N(e, t, i, n, s, r) }), !0 } return void 0 !== t.prototype && e instanceof t || !Error.isPrototypeOf(t) && !0 === t.call({}, e) } function R (e) { if (typeof e !== 'function') throw new l('fn', 'Function', e); try { e() } catch (e) { return e } return S } function P (e) { return y(e) || e !== null && o(e) === 'object' && typeof e.then === 'function' && typeof e.catch === 'function' } function C (e) { return Promise.resolve().then(function () { let t; if (typeof e === 'function') { if (!P(t = e())) throw new f('instance of Promise', 'promiseFn', t) } else { if (!P(e)) throw new l('promiseFn', ['Function', 'Promise'], e); t = e } return Promise.resolve().then(function () { return t }).then(function () { return S }).catch(function (e) { return e }) }) } function B (e, t, n, r) { if (typeof n === 'string') { if (arguments.length === 4) throw new l('error', ['Object', 'Error', 'Function', 'RegExp'], n); if (o(t) === 'object' && t !== null) { if (t.message === n) throw new u('error/message', 'The error message "'.concat(t.message, '" is identical to the message.')) } else if (t === n) throw new u('error/message', 'The error "'.concat(t, '" is identical to the message.')); r = n, n = void 0 } else if (n != null && o(n) !== 'object' && typeof n !== 'function') throw new l('error', ['Object', 'Error', 'Function', 'RegExp'], n); if (t === S) { let i = ''; n && n.name && (i += ' ('.concat(n.name, ')')), i += r ? ': '.concat(r) : '.'; const a = e.name === 'rejects' ? 'rejection' : 'exception'; A({ actual: void 0, expected: n, operator: e.name, message: 'Missing expected '.concat(a).concat(i), stackStartFn: e }) } if (n && !T(t, n, r, e)) throw t } function L (e, t, n, r) { if (t !== S) { if (typeof n === 'string' && (r = n, n = void 0), !n || T(t, n)) { const i = r ? ': '.concat(r) : '.'; const o = e.name === 'doesNotReject' ? 'rejection' : 'exception'; A({ actual: t, expected: n, operator: e.name, message: 'Got unwanted '.concat(o).concat(i, '\n') + 'Actual message: "'.concat(t && t.message, '"'), stackStartFn: e }) } throw t } } function j () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; O.apply(void 0, [j, t.length].concat(t)) }k.throws = function e (t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; B.apply(void 0, [e, R(t)].concat(r)) }, k.rejects = function e (t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; return C(t).then(function (t) { return B.apply(void 0, [e, t].concat(r)) }) }, k.doesNotThrow = function e (t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; L.apply(void 0, [e, R(t)].concat(r)) }, k.doesNotReject = function e (t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; return C(t).then(function (t) { return L.apply(void 0, [e, t].concat(r)) }) }, k.ifError = function e (t) { if (t != null) { let n = 'ifError got unwanted exception: '; o(t) === 'object' && typeof t.message === 'string' ? t.message.length === 0 && t.constructor ? n += t.constructor.name : n += t.message : n += g(t); const r = new p({ actual: t, expected: null, operator: 'ifError', message: n, stackStartFn: e }); const i = t.stack; if (typeof i === 'string') { const a = i.split('\n'); a.shift(); for (var s = r.stack.split('\n'), c = 0; c < a.length; c++) { const u = s.indexOf(a[c]); if (u !== -1) { s = s.slice(0, u); break } }r.stack = ''.concat(s.join('\n'), '\n').concat(a.join('\n')) } throw r } }, k.strict = v(j, k, { equal: k.strictEqual, deepEqual: k.deepStrictEqual, notEqual: k.notStrictEqual, notDeepEqual: k.notDeepStrictEqual }), k.strict.strict = k.strict }, 5961: (e, t, n) => { 'use strict'; const r = n(4155); function i (e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function o (e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } function a (e, t) { return !t || h(t) !== 'object' && typeof t !== 'function' ? s(e) : t } function s (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function c (e) { const t = typeof Map === 'function' ? new Map() : void 0; return c = function (e) { if (e === null || (n = e, Function.toString.call(n).indexOf('[native code]') === -1)) return e; let n; if (typeof e !== 'function') throw new TypeError('Super expression must either be null or a function'); if (void 0 !== t) { if (t.has(e)) return t.get(e); t.set(e, r) } function r () { return l(e, arguments, f(this).constructor) } return r.prototype = Object.create(e.prototype, { constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 } }), d(r, e) }, c(e) } function u () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0 } catch (e) { return !1 } } function l (e, t, n) { return l = u() ? Reflect.construct : function (e, t, n) { const r = [null]; r.push.apply(r, t); const i = new (Function.bind.apply(e, r))(); return n && d(i, n.prototype), i }, l.apply(null, arguments) } function d (e, t) { return d = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e }, d(e, t) } function f (e) { return f = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, f(e) } function h (e) { return h = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }, h(e) } const p = n(9539).inspect; const g = n(2136).codes.ERR_INVALID_ARG_TYPE; function m (e, t, n) { return (void 0 === n || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t } let y = ''; let b = ''; let v = ''; let w = ''; const _ = { deepStrictEqual: 'Expected values to be strictly deep-equal:', strictEqual: 'Expected values to be strictly equal:', strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: 'Expected values to be loosely deep-equal:', equal: 'Expected values to be loosely equal:', notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: 'Values identical but not reference-equal:' }; function E (e) { const t = Object.keys(e); const n = Object.create(Object.getPrototypeOf(e)); return t.forEach(function (t) { n[t] = e[t] }), Object.defineProperty(n, 'message', { value: e.message }), n } function k (e) { return p(e, { compact: !1, customInspect: !1, depth: 1e3, maxArrayLength: 1 / 0, showHidden: !1, breakLength: 1 / 0, showProxy: !1, sorted: !0, getters: !0 }) } const S = (function (e) { function t (e) { let n; if ((function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') }(this, t)), h(e) !== 'object' || e === null) throw new g('options', 'Object', e); const i = e.message; const o = e.operator; const c = e.stackStartFn; let u = e.actual; let l = e.expected; const d = Error.stackTraceLimit; if (Error.stackTraceLimit = 0, i != null)n = a(this, f(t).call(this, String(i))); else if (r.stderr && r.stderr.isTTY && (r.stderr && r.stderr.getColorDepth && r.stderr.getColorDepth() !== 1 ? (y = '[34m', b = '[32m', w = '[39m', v = '[31m') : (y = '', b = '', w = '', v = '')), h(u) === 'object' && u !== null && h(l) === 'object' && l !== null && 'stack' in u && u instanceof Error && 'stack' in l && l instanceof Error && (u = E(u), l = E(l)), o === 'deepStrictEqual' || o === 'strictEqual')n = a(this, f(t).call(this, (function (e, t, n) { let i = ''; let o = ''; let a = 0; let s = ''; let c = !1; const u = k(e); const l = u.split('\n'); const d = k(t).split('\n'); let f = 0; let p = ''; if (n === 'strictEqual' && h(e) === 'object' && h(t) === 'object' && e !== null && t !== null && (n = 'strictEqualObject'), l.length === 1 && d.length === 1 && l[0] !== d[0]) { const g = l[0].length + d[0].length; if (g <= 10) { if (!(h(e) === 'object' && e !== null || h(t) === 'object' && t !== null || e === 0 && t === 0)) return ''.concat(_[n], '\n\n') + ''.concat(l[0], ' !== ').concat(d[0], '\n') } else if (n !== 'strictEqualObject' && g < (r.stderr && r.stderr.isTTY ? r.stderr.columns : 80)) { for (;l[0][f] === d[0][f];)f++; f > 2 && (p = '\n  '.concat((function (e, t) { if (t = Math.floor(t), e.length == 0 || t == 0) return ''; const n = e.length * t; for (t = Math.floor(Math.log(t) / Math.log(2)); t;)e += e, t--; return e + e.substring(0, n - e.length) }(' ', f)), '^'), f = 0) } } for (let E = l[l.length - 1], S = d[d.length - 1]; E === S && (f++ < 2 ? s = '\n  '.concat(E).concat(s) : i = E, l.pop(), d.pop(), l.length !== 0 && d.length !== 0);)E = l[l.length - 1], S = d[d.length - 1]; const A = Math.max(l.length, d.length); if (A === 0) { const O = u.split('\n'); if (O.length > 30) for (O[26] = ''.concat(y, '...').concat(w); O.length > 27;)O.pop(); return ''.concat(_.notIdentical, '\n\n').concat(O.join('\n'), '\n') }f > 3 && (s = '\n'.concat(y, '...').concat(w).concat(s), c = !0), i !== '' && (s = '\n  '.concat(i).concat(s), i = ''); let x = 0; const I = _[n] + '\n'.concat(b, '+ actual').concat(w, ' ').concat(v, '- expected').concat(w); const N = ' '.concat(y, '...').concat(w, ' Lines skipped'); for (f = 0; f < A; f++) { const T = f - a; if (l.length < f + 1)T > 1 && f > 2 && (T > 4 ? (o += '\n'.concat(y, '...').concat(w), c = !0) : T > 3 && (o += '\n  '.concat(d[f - 2]), x++), o += '\n  '.concat(d[f - 1]), x++), a = f, i += '\n'.concat(v, '-').concat(w, ' ').concat(d[f]), x++; else if (d.length < f + 1)T > 1 && f > 2 && (T > 4 ? (o += '\n'.concat(y, '...').concat(w), c = !0) : T > 3 && (o += '\n  '.concat(l[f - 2]), x++), o += '\n  '.concat(l[f - 1]), x++), a = f, o += '\n'.concat(b, '+').concat(w, ' ').concat(l[f]), x++; else { const R = d[f]; let P = l[f]; let C = P !== R && (!m(P, ',') || P.slice(0, -1) !== R); C && m(R, ',') && R.slice(0, -1) === P && (C = !1, P += ','), C ? (T > 1 && f > 2 && (T > 4 ? (o += '\n'.concat(y, '...').concat(w), c = !0) : T > 3 && (o += '\n  '.concat(l[f - 2]), x++), o += '\n  '.concat(l[f - 1]), x++), a = f, o += '\n'.concat(b, '+').concat(w, ' ').concat(P), i += '\n'.concat(v, '-').concat(w, ' ').concat(R), x += 2) : (o += i, i = '', T !== 1 && f !== 0 || (o += '\n  '.concat(P), x++)) } if (x > 20 && f < A - 2) return ''.concat(I).concat(N, '\n').concat(o, '\n').concat(y, '...').concat(w).concat(i, '\n') + ''.concat(y, '...').concat(w) } return ''.concat(I).concat(c ? N : '', '\n').concat(o).concat(i).concat(s).concat(p) }(u, l, o)))); else if (o === 'notDeepStrictEqual' || o === 'notStrictEqual') { let p = _[o]; const S = k(u).split('\n'); if (o === 'notStrictEqual' && h(u) === 'object' && u !== null && (p = _.notStrictEqualObject), S.length > 30) for (S[26] = ''.concat(y, '...').concat(w); S.length > 27;)S.pop(); n = S.length === 1 ? a(this, f(t).call(this, ''.concat(p, ' ').concat(S[0]))) : a(this, f(t).call(this, ''.concat(p, '\n\n').concat(S.join('\n'), '\n'))) } else { let A = k(u); let O = ''; const x = _[o]; o === 'notDeepEqual' || o === 'notEqual' ? (A = ''.concat(_[o], '\n\n').concat(A)).length > 1024 && (A = ''.concat(A.slice(0, 1021), '...')) : (O = ''.concat(k(l)), A.length > 512 && (A = ''.concat(A.slice(0, 509), '...')), O.length > 512 && (O = ''.concat(O.slice(0, 509), '...')), o === 'deepEqual' || o === 'equal' ? A = ''.concat(x, '\n\n').concat(A, '\n\nshould equal\n\n') : O = ' '.concat(o, ' ').concat(O)), n = a(this, f(t).call(this, ''.concat(A).concat(O))) } return Error.stackTraceLimit = d, n.generatedMessage = !i, Object.defineProperty(s(n), 'name', { value: 'AssertionError [ERR_ASSERTION]', enumerable: !1, writable: !0, configurable: !0 }), n.code = 'ERR_ASSERTION', n.actual = u, n.expected = l, n.operator = o, Error.captureStackTrace && Error.captureStackTrace(s(n), c), n.stack, n.name = 'AssertionError', a(n) } let n, c; return (function (e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Super expression must either be null or a function'); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && d(e, t) }(t, e)), n = t, c = [{ key: 'toString', value: function () { return ''.concat(this.name, ' [').concat(this.code, ']: ').concat(this.message) } }, { key: p.custom, value: function (e, t) { return p(this, (function (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; let r = Object.keys(n); typeof Object.getOwnPropertySymbols === 'function' && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function (e) { return Object.getOwnPropertyDescriptor(n, e).enumerable }))), r.forEach(function (t) { i(e, t, n[t]) }) } return e }({}, t, { customInspect: !1, depth: 0 }))) } }], c && o(n.prototype, c), t }(c(Error))); e.exports = S }, 2136: (e, t, n) => { 'use strict'; function r (e) { return r = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }, r(e) } function i (e) { return i = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, i(e) } function o (e, t) { return o = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e }, o(e, t) } let a; let s; const c = {}; function u (e, t, n) { n || (n = Error); const a = (function (n) { function a (n, o, s) { let c; return (function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') }(this, a)), c = (function (e, t) { return !t || r(t) !== 'object' && typeof t !== 'function' ? (function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e)) : t }(this, i(a).call(this, (function (e, n, r) { return typeof t==='string' ? t : t(e, n, r) }(n, o, s))))), c.code = e, c } return (function (e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Super expression must either be null or a function'); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && o(e, t) }(a, n)), a }(n)); c[e] = a } function l (e, t) { if (Array.isArray(e)) { const n = e.length; return e = e.map(function (e) { return String(e) }), n > 2 ? 'one of '.concat(t, ' ').concat(e.slice(0, n - 1).join(', '), ', or ') + e[n - 1] : n === 2 ? 'one of '.concat(t, ' ').concat(e[0], ' or ').concat(e[1]) : 'of '.concat(t, ' ').concat(e[0]) } return 'of '.concat(t, ' ').concat(String(e)) }u('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError), u('ERR_INVALID_ARG_TYPE', function (e, t, i) { let o, s, c, u, d; if (void 0 === a && (a = n(9282)), a(typeof e === 'string', "'name' must be a string"), typeof t === 'string' && (s = 'not ', t.substr(0, s.length) === s) ? (o = 'must not be', t = t.replace(/^not /, '')) : o = 'must be', (function (e, t, n) { return (void 0 === n || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t }(e, ' argument')))c = 'The '.concat(e, ' ').concat(o, ' ').concat(l(t, 'type')); else { const f = (typeof d !== 'number' && (d = 0), d + 1 > (u = e).length || u.indexOf('.', d) === -1 ? 'argument' : 'property'); c = 'The "'.concat(e, '" ').concat(f, ' ').concat(o, ' ').concat(l(t, 'type')) } return c + '. Received type '.concat(r(i)) }, TypeError), u('ERR_INVALID_ARG_VALUE', function (e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'is invalid'; void 0 === s && (s = n(9539)); let i = s.inspect(t); return i.length > 128 && (i = ''.concat(i.slice(0, 128), '...')), "The argument '".concat(e, "' ").concat(r, '. Received ').concat(i) }, TypeError, RangeError), u('ERR_INVALID_RETURN_VALUE', function (e, t, n) { let i; return i = n && n.constructor && n.constructor.name ? 'instance of '.concat(n.constructor.name) : 'type '.concat(r(n)), 'Expected '.concat(e, ' to be returned from the "').concat(t, '"') + ' function but got '.concat(i, '.') }, TypeError), u('ERR_MISSING_ARGS', function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; void 0 === a && (a = n(9282)), a(t.length > 0, 'At least one arg needs to be specified'); let i = 'The '; const o = t.length; switch (t = t.map(function (e) { return '"'.concat(e, '"') }), o) { case 1:i += ''.concat(t[0], ' argument'); break; case 2:i += ''.concat(t[0], ' and ').concat(t[1], ' arguments'); break; default:i += t.slice(0, o - 1).join(', '), i += ', and '.concat(t[o - 1], ' arguments') } return ''.concat(i, ' must be specified') }, TypeError), e.exports.codes = c }, 9158: (e, t, n) => { 'use strict'; function r (e, t) { return (function (e) { if (Array.isArray(e)) return e }(e)) || (function (e, t) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !t || n.length !== t); r = !0); } catch (e) { i = !0, o = e } finally { try { r || s.return == null || s.return() } finally { if (i) throw o } } return n }(e, t)) || (function () { throw new TypeError('Invalid attempt to destructure non-iterable instance') }()) } function i (e) { return i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }, i(e) } const o = void 0 !== /a/g.flags; const a = function (e) { const t = []; return e.forEach(function (e) { return t.push(e) }), t }; const s = function (e) { const t = []; return e.forEach(function (e, n) { return t.push([n, e]) }), t }; const c = Object.is ? Object.is : n(609); const u = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () { return [] }; const l = Number.isNaN ? Number.isNaN : n(360); function d (e) { return e.call.bind(e) } const f = d(Object.prototype.hasOwnProperty); const h = d(Object.prototype.propertyIsEnumerable); const p = d(Object.prototype.toString); const g = n(9539).types; const m = g.isAnyArrayBuffer; const y = g.isArrayBufferView; const b = g.isDate; const v = g.isMap; const w = g.isRegExp; const _ = g.isSet; const E = g.isNativeError; const k = g.isBoxedPrimitive; const S = g.isNumberObject; const A = g.isStringObject; const O = g.isBooleanObject; const x = g.isBigIntObject; const I = g.isSymbolObject; const N = g.isFloat32Array; const T = g.isFloat64Array; function R (e) { if (e.length === 0 || e.length > 10) return !0; for (let t = 0; t < e.length; t++) { const n = e.charCodeAt(t); if (n < 48 || n > 57) return !0 } return e.length === 10 && e >= Math.pow(2, 32) } function P (e) { return Object.keys(e).filter(R).concat(u(e).filter(Object.prototype.propertyIsEnumerable.bind(e))) } function C (e, t) { if (e === t) return 0; for (var n = e.length, r = t.length, i = 0, o = Math.min(n, r); i < o; ++i) if (e[i] !== t[i]) { n = e[i], r = t[i]; break } return n < r ? -1 : r < n ? 1 : 0 } function B (e, t, n, r) { if (e === t) return e !== 0 || !n || c(e, t); if (n) { if (i(e) !== 'object') return typeof e === 'number' && l(e) && l(t); if (i(t) !== 'object' || e === null || t === null) return !1; if (Object.getPrototypeOf(e) !== Object.getPrototypeOf(t)) return !1 } else { if (e === null || i(e) !== 'object') return (t === null || i(t) !== 'object') && e == t; if (t === null || i(t) !== 'object') return !1 } let a; let s; let u; let d; const f = p(e); if (f !== p(t)) return !1; if (Array.isArray(e)) { if (e.length !== t.length) return !1; const h = P(e); const g = P(t); return h.length === g.length && j(e, t, n, r, 1, h) } if (f === '[object Object]' && (!v(e) && v(t) || !_(e) && _(t))) return !1; if (b(e)) { if (!b(t) || Date.prototype.getTime.call(e) !== Date.prototype.getTime.call(t)) return !1 } else if (w(e)) { if (!w(t) || (u = e, d = t, !(o ? u.source === d.source && u.flags === d.flags : RegExp.prototype.toString.call(u) === RegExp.prototype.toString.call(d)))) return !1 } else if (E(e) || e instanceof Error) { if (e.message !== t.message || e.name !== t.name) return !1 } else { if (y(e)) { if (n || !N(e) && !T(e)) { if (!(function (e, t) { return e.byteLength === t.byteLength && C(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), new Uint8Array(t.buffer, t.byteOffset, t.byteLength)) === 0 }(e, t))) return !1 } else if (!(function (e, t) { if (e.byteLength !== t.byteLength) return !1; for (let n = 0; n < e.byteLength; n++) if (e[n] !== t[n]) return !1; return !0 }(e, t))) return !1; const R = P(e); const B = P(t); return R.length === B.length && j(e, t, n, r, 0, R) } if (_(e)) return !(!_(t) || e.size !== t.size) && j(e, t, n, r, 2); if (v(e)) return !(!v(t) || e.size !== t.size) && j(e, t, n, r, 3); if (m(e)) { if (s = t, (a = e).byteLength !== s.byteLength || C(new Uint8Array(a), new Uint8Array(s)) !== 0) return !1 } else if (k(e) && !(function (e, t) { return S(e) ? S(t) && c(Number.prototype.valueOf.call(e), Number.prototype.valueOf.call(t)) : A(e) ? A(t) && String.prototype.valueOf.call(e) === String.prototype.valueOf.call(t) : O(e) ? O(t) && Boolean.prototype.valueOf.call(e) === Boolean.prototype.valueOf.call(t) : x(e) ? x(t) && BigInt.prototype.valueOf.call(e) === BigInt.prototype.valueOf.call(t) : I(t) && Symbol.prototype.valueOf.call(e) === Symbol.prototype.valueOf.call(t) }(e, t))) return !1 } return j(e, t, n, r, 0) } function L (e, t) { return t.filter(function (t) { return h(e, t) }) } function j (e, t, n, r, i, o) { if (arguments.length === 5) { o = Object.keys(e); const a = Object.keys(t); if (o.length !== a.length) return !1 } for (var s = 0; s < o.length; s++) if (!f(t, o[s])) return !1; if (n && arguments.length === 5) { const c = u(e); if (c.length !== 0) { let l = 0; for (s = 0; s < c.length; s++) { const d = c[s]; if (h(e, d)) { if (!h(t, d)) return !1; o.push(d), l++ } else if (h(t, d)) return !1 } const p = u(t); if (c.length !== p.length && L(t, p).length !== l) return !1 } else { const g = u(t); if (g.length !== 0 && L(t, g).length !== 0) return !1 } } if (o.length === 0 && (i === 0 || i === 1 && e.length === 0 || e.size === 0)) return !0; if (void 0 === r)r = { val1: new Map(), val2: new Map(), position: 0 }; else { const m = r.val1.get(e); if (void 0 !== m) { const y = r.val2.get(t); if (void 0 !== y) return m === y }r.position++ }r.val1.set(e, r.position), r.val2.set(t, r.position); const b = H(e, t, n, o, r, i); return r.val1.delete(e), r.val2.delete(t), b } function D (e, t, n, r) { for (let i = a(e), o = 0; o < i.length; o++) { const s = i[o]; if (B(t, s, n, r)) return e.delete(s), !0 } return !1 } function U (e) { switch (i(e)) { case 'undefined':return null; case 'object':return; case 'symbol':return !1; case 'string':e = +e; case 'number':if (l(e)) return !1 } return !0 } function M (e, t, n) { const r = U(n); return r != null ? r : t.has(r) && !e.has(r) } function z (e, t, n, r, i) { const o = U(n); if (o != null) return o; const a = t.get(o); return !(void 0 === a && !t.has(o) || !B(r, a, !1, i)) && !e.has(o) && B(r, a, !1, i) } function F (e, t, n, r, i, o) { for (let s = a(e), c = 0; c < s.length; c++) { const u = s[c]; if (B(n, u, i, o) && B(r, t.get(u), i, o)) return e.delete(u), !0 } return !1 } function H (e, t, n, o, c, u) { let l = 0; if (u === 2) { if (!(function (e, t, n, r) { for (var o = null, s = a(e), c = 0; c < s.length; c++) { const u = s[c]; if (i(u) === 'object' && u !== null)o === null && (o = new Set()), o.add(u); else if (!t.has(u)) { if (n) return !1; if (!M(e, t, u)) return !1; o === null && (o = new Set()), o.add(u) } } if (o !== null) { for (let l = a(t), d = 0; d < l.length; d++) { const f = l[d]; if (i(f) === 'object' && f !== null) { if (!D(o, f, n, r)) return !1 } else if (!n && !e.has(f) && !D(o, f, n, r)) return !1 } return o.size === 0 } return !0 }(e, t, n, c))) return !1 } else if (u === 3) { if (!(function (e, t, n, o) { for (var a = null, c = s(e), u = 0; u < c.length; u++) { const l = r(c[u], 2); var d = l[0]; const f = l[1]; if (i(d) === 'object' && d !== null)a === null && (a = new Set()), a.add(d); else { const h = t.get(d); if (void 0 === h && !t.has(d) || !B(f, h, n, o)) { if (n) return !1; if (!z(e, t, d, f, o)) return !1; a === null && (a = new Set()), a.add(d) } } } if (a !== null) { for (let p = s(t), g = 0; g < p.length; g++) { const m = r(p[g], 2); const y = (d = m[0], m[1]); if (i(d) === 'object' && d !== null) { if (!F(a, e, d, y, n, o)) return !1 } else if (!(n || e.has(d) && B(e.get(d), y, !1, o) || F(a, e, d, y, !1, o))) return !1 } return a.size === 0 } return !0 }(e, t, n, c))) return !1 } else if (u === 1) for (;l < e.length; l++) { if (!f(e, l)) { if (f(t, l)) return !1; for (var d = Object.keys(e); l < d.length; l++) { const h = d[l]; if (!f(t, h) || !B(e[h], t[h], n, c)) return !1 } return d.length === Object.keys(t).length } if (!f(t, l) || !B(e[l], t[l], n, c)) return !1 } for (l = 0; l < o.length; l++) { const p = o[l]; if (!B(e[p], t[p], n, c)) return !1 } return !0 }e.exports = { isDeepEqual: function (e, t) { return B(e, t, !1) }, isDeepStrictEqual: function (e, t) { return B(e, t, !0) } } }, 1924: (e, t, n) => { 'use strict'; const r = n(210); const i = n(5559); const o = i(r('String.prototype.indexOf')); e.exports = function (e, t) { const n = r(e, !!t); return typeof n === 'function' && o(e, '.prototype.') > -1 ? i(n) : n } }, 5559: (e, t, n) => { 'use strict'; const r = n(8612); const i = n(210); const o = i('%Function.prototype.apply%'); const a = i('%Function.prototype.call%'); const s = i('%Reflect.apply%', !0) || r.call(a, o); const c = i('%Object.getOwnPropertyDescriptor%', !0); let u = i('%Object.defineProperty%', !0); const l = i('%Math.max%'); if (u) try { u({}, 'a', { value: 1 }) } catch (e) { u = null }e.exports = function (e) { const t = s(r, a, arguments); return c && u && c(t, 'length').configurable && u(t, 'length', { value: 1 + l(0, e.length - (arguments.length - 1)) }), t }; const d = function () { return s(r, o, arguments) }; u ? u(e.exports, 'apply', { value: d }) : e.exports.apply = d }, 5108: (e, t, n) => { const r = n(9539); const i = n(9282); function o () { return (new Date()).getTime() } let a; const s = Array.prototype.slice; const c = {}; a = void 0 !== n.g && n.g.console ? n.g.console : typeof window !== 'undefined' && window.console ? window.console : {}; for (let u = [[function () {}, 'log'], [function () { a.log.apply(a, arguments) }, 'info'], [function () { a.log.apply(a, arguments) }, 'warn'], [function () { a.warn.apply(a, arguments) }, 'error'], [function (e) { c[e] = o() }, 'time'], [function (e) { const t = c[e]; if (!t) throw new Error('No such label: ' + e); delete c[e]; const n = o() - t; a.log(e + ': ' + n + 'ms') }, 'timeEnd'], [function () { const e = new Error(); e.name = 'Trace', e.message = r.format.apply(null, arguments), a.error(e.stack) }, 'trace'], [function (e) { a.log(r.inspect(e) + '\n') }, 'dir'], [function (e) { if (!e) { const t = s.call(arguments, 1); i.ok(!1, r.format.apply(null, t)) } }, 'assert']], l = 0; l < u.length; l++) { const d = u[l]; const f = d[0]; const h = d[1]; a[h] || (a[h] = f) }e.exports = a }, 452: function (e, t, n) { let r; e.exports = (r = n(8249), n(8269), n(8214), n(888), n(5109), (function () { const e = r; const t = e.lib.BlockCipher; const n = e.algo; const i = []; const o = []; const a = []; const s = []; const c = []; const u = []; const l = []; const d = []; const f = []; const h = []; !(function () { for (var e = [], t = 0; t < 256; t++)e[t] = t < 128 ? t << 1 : t << 1 ^ 283; let n = 0; let r = 0; for (t = 0; t < 256; t++) { let p = r ^ r << 1 ^ r << 2 ^ r << 3 ^ r << 4; p = p >>> 8 ^ 255 & p ^ 99, i[n] = p, o[p] = n; const g = e[n]; const m = e[g]; const y = e[m]; let b = 257 * e[p] ^ 16843008 * p; a[n] = b << 24 | b >>> 8, s[n] = b << 16 | b >>> 16, c[n] = b << 8 | b >>> 24, u[n] = b, b = 16843009 * y ^ 65537 * m ^ 257 * g ^ 16843008 * n, l[p] = b << 24 | b >>> 8, d[p] = b << 16 | b >>> 16, f[p] = b << 8 | b >>> 24, h[p] = b, n ? (n = g ^ e[e[e[y ^ g]]], r ^= e[e[r]]) : n = r = 1 } }()); const p = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]; const g = n.AES = t.extend({ _doReset: function () { if (!this._nRounds || this._keyPriorReset !== this._key) { for (var e = this._keyPriorReset = this._key, t = e.words, n = e.sigBytes / 4, r = 4 * ((this._nRounds = n + 6) + 1), o = this._keySchedule = [], a = 0; a < r; a++)a < n ? o[a] = t[a] : (u = o[a - 1], a % n ? n > 6 && a % n == 4 && (u = i[u >>> 24] << 24 | i[u >>> 16 & 255] << 16 | i[u >>> 8 & 255] << 8 | i[255 & u]) : (u = i[(u = u << 8 | u >>> 24) >>> 24] << 24 | i[u >>> 16 & 255] << 16 | i[u >>> 8 & 255] << 8 | i[255 & u], u ^= p[a / n | 0] << 24), o[a] = o[a - n] ^ u); for (let s = this._invKeySchedule = [], c = 0; c < r; c++) { if (a = r - c, c % 4) var u = o[a]; else u = o[a - 4]; s[c] = c < 4 || a <= 4 ? u : l[i[u >>> 24]] ^ d[i[u >>> 16 & 255]] ^ f[i[u >>> 8 & 255]] ^ h[i[255 & u]] } } }, encryptBlock: function (e, t) { this._doCryptBlock(e, t, this._keySchedule, a, s, c, u, i) }, decryptBlock: function (e, t) { let n = e[t + 1]; e[t + 1] = e[t + 3], e[t + 3] = n, this._doCryptBlock(e, t, this._invKeySchedule, l, d, f, h, o), n = e[t + 1], e[t + 1] = e[t + 3], e[t + 3] = n }, _doCryptBlock: function (e, t, n, r, i, o, a, s) { for (var c = this._nRounds, u = e[t] ^ n[0], l = e[t + 1] ^ n[1], d = e[t + 2] ^ n[2], f = e[t + 3] ^ n[3], h = 4, p = 1; p < c; p++) { var g = r[u >>> 24] ^ i[l >>> 16 & 255] ^ o[d >>> 8 & 255] ^ a[255 & f] ^ n[h++]; var m = r[l >>> 24] ^ i[d >>> 16 & 255] ^ o[f >>> 8 & 255] ^ a[255 & u] ^ n[h++]; var y = r[d >>> 24] ^ i[f >>> 16 & 255] ^ o[u >>> 8 & 255] ^ a[255 & l] ^ n[h++]; var b = r[f >>> 24] ^ i[u >>> 16 & 255] ^ o[l >>> 8 & 255] ^ a[255 & d] ^ n[h++]; u = g, l = m, d = y, f = b }g = (s[u >>> 24] << 24 | s[l >>> 16 & 255] << 16 | s[d >>> 8 & 255] << 8 | s[255 & f]) ^ n[h++], m = (s[l >>> 24] << 24 | s[d >>> 16 & 255] << 16 | s[f >>> 8 & 255] << 8 | s[255 & u]) ^ n[h++], y = (s[d >>> 24] << 24 | s[f >>> 16 & 255] << 16 | s[u >>> 8 & 255] << 8 | s[255 & l]) ^ n[h++], b = (s[f >>> 24] << 24 | s[u >>> 16 & 255] << 16 | s[l >>> 8 & 255] << 8 | s[255 & d]) ^ n[h++], e[t] = g, e[t + 1] = m, e[t + 2] = y, e[t + 3] = b }, keySize: 8 }); e.AES = t._createHelper(g) }()), r.AES) }, 5109: function (e, t, n) { let r, i, o, a, s, c, u, l, d, f, h, p, g, m, y, b, v, w, _; e.exports = (r = n(8249), n(888), void (r.lib.Cipher || (i = r, o = i.lib, a = o.Base, s = o.WordArray, c = o.BufferedBlockAlgorithm, u = i.enc, u.Utf8, l = u.Base64, d = i.algo.EvpKDF, f = o.Cipher = c.extend({ cfg: a.extend(), createEncryptor: function (e, t) { return this.create(this._ENC_XFORM_MODE, e, t) }, createDecryptor: function (e, t) { return this.create(this._DEC_XFORM_MODE, e, t) }, init: function (e, t, n) { this.cfg = this.cfg.extend(n), this._xformMode = e, this._key = t, this.reset() }, reset: function () { c.reset.call(this), this._doReset() }, process: function (e) { return this._append(e), this._process() }, finalize: function (e) { return e && this._append(e), this._doFinalize() }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: (function () { function e (e) { return typeof e === 'string' ? _ : v } return function (t) { return { encrypt: function (n, r, i) { return e(r).encrypt(t, n, r, i) }, decrypt: function (n, r, i) { return e(r).decrypt(t, n, r, i) } } } }()) }), o.StreamCipher = f.extend({ _doFinalize: function () { return this._process(!0) }, blockSize: 1 }), h = i.mode = {}, p = o.BlockCipherMode = a.extend({ createEncryptor: function (e, t) { return this.Encryptor.create(e, t) }, createDecryptor: function (e, t) { return this.Decryptor.create(e, t) }, init: function (e, t) { this._cipher = e, this._iv = t } }), g = h.CBC = (function () { const e = p.extend(); function t (e, t, n) { let r; const i = this._iv; i ? (r = i, this._iv = void 0) : r = this._prevBlock; for (let o = 0; o < n; o++)e[t + o] ^= r[o] } return e.Encryptor = e.extend({ processBlock: function (e, n) { const r = this._cipher; const i = r.blockSize; t.call(this, e, n, i), r.encryptBlock(e, n), this._prevBlock = e.slice(n, n + i) } }), e.Decryptor = e.extend({ processBlock: function (e, n) { const r = this._cipher; const i = r.blockSize; const o = e.slice(n, n + i); r.decryptBlock(e, n), t.call(this, e, n, i), this._prevBlock = o } }), e }()), m = (i.pad = {}).Pkcs7 = { pad: function (e, t) { for (var n = 4 * t, r = n - e.sigBytes % n, i = r << 24 | r << 16 | r << 8 | r, o = [], a = 0; a < r; a += 4)o.push(i); const c = s.create(o, r); e.concat(c) }, unpad: function (e) { const t = 255 & e.words[e.sigBytes - 1 >>> 2]; e.sigBytes -= t } }, o.BlockCipher = f.extend({ cfg: f.cfg.extend({ mode: g, padding: m }), reset: function () { let e; f.reset.call(this); const t = this.cfg; const n = t.iv; const r = t.mode; this._xformMode == this._ENC_XFORM_MODE ? e = r.createEncryptor : (e = r.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == e ? this._mode.init(this, n && n.words) : (this._mode = e.call(r, this, n && n.words), this._mode.__creator = e) }, _doProcessBlock: function (e, t) { this._mode.processBlock(e, t) }, _doFinalize: function () { let e; const t = this.cfg.padding; return this._xformMode == this._ENC_XFORM_MODE ? (t.pad(this._data, this.blockSize), e = this._process(!0)) : (e = this._process(!0), t.unpad(e)), e }, blockSize: 4 }), y = o.CipherParams = a.extend({ init: function (e) { this.mixIn(e) }, toString: function (e) { return (e || this.formatter).stringify(this) } }), b = (i.format = {}).OpenSSL = { stringify: function (e) { const t = e.ciphertext; const n = e.salt; return (n ? s.create([1398893684, 1701076831]).concat(n).concat(t) : t).toString(l) }, parse: function (e) { let t; const n = l.parse(e); const r = n.words; return r[0] == 1398893684 && r[1] == 1701076831 && (t = s.create(r.slice(2, 4)), r.splice(0, 4), n.sigBytes -= 16), y.create({ ciphertext: n, salt: t }) } }, v = o.SerializableCipher = a.extend({ cfg: a.extend({ format: b }), encrypt: function (e, t, n, r) { r = this.cfg.extend(r); const i = e.createEncryptor(n, r); const o = i.finalize(t); const a = i.cfg; return y.create({ ciphertext: o, key: n, iv: a.iv, algorithm: e, mode: a.mode, padding: a.padding, blockSize: e.blockSize, formatter: r.format }) }, decrypt: function (e, t, n, r) { return r = this.cfg.extend(r), t = this._parse(t, r.format), e.createDecryptor(n, r).finalize(t.ciphertext) }, _parse: function (e, t) { return typeof e === 'string' ? t.parse(e, this) : e } }), w = (i.kdf = {}).OpenSSL = { execute: function (e, t, n, r) { r || (r = s.random(8)); const i = d.create({ keySize: t + n }).compute(e, r); const o = s.create(i.words.slice(t), 4 * n); return i.sigBytes = 4 * t, y.create({ key: i, iv: o, salt: r }) } }, _ = o.PasswordBasedCipher = v.extend({ cfg: v.cfg.extend({ kdf: w }), encrypt: function (e, t, n, r) { const i = (r = this.cfg.extend(r)).kdf.execute(n, e.keySize, e.ivSize); r.iv = i.iv; const o = v.encrypt.call(this, e, t, i.key, r); return o.mixIn(i), o }, decrypt: function (e, t, n, r) { r = this.cfg.extend(r), t = this._parse(t, r.format); const i = r.kdf.execute(n, e.keySize, e.ivSize, t.salt); return r.iv = i.iv, v.decrypt.call(this, e, t, i.key, r) } })))) }, 8249: function (e, t, n) { let r; e.exports = (r = r || (function (e, t) { let r; if (typeof window !== 'undefined' && window.crypto && (r = window.crypto), typeof self !== 'undefined' && self.crypto && (r = self.crypto), typeof globalThis !== 'undefined' && globalThis.crypto && (r = globalThis.crypto), !r && typeof window !== 'undefined' && window.msCrypto && (r = window.msCrypto), !r && void 0 !== n.g && n.g.crypto && (r = n.g.crypto), !r) try { r = n(2480) } catch (e) {} const i = function () { if (r) { if (typeof r.getRandomValues === 'function') try { return r.getRandomValues(new Uint32Array(1))[0] } catch (e) {} if (typeof r.randomBytes === 'function') try { return r.randomBytes(4).readInt32LE() } catch (e) {} } throw new Error('Native crypto module could not be used to get secure random number.') }; const o = Object.create || (function () { function e () {} return function (t) { let n; return e.prototype = t, n = new e(), e.prototype = null, n } }()); const a = {}; const s = a.lib = {}; const c = s.Base = { extend: function (e) { const t = o(this); return e && t.mixIn(e), t.hasOwnProperty('init') && this.init !== t.init || (t.init = function () { t.$super.init.apply(this, arguments) }), t.init.prototype = t, t.$super = this, t }, create: function () { const e = this.extend(); return e.init.apply(e, arguments), e }, init: function () {}, mixIn: function (e) { for (const t in e)e.hasOwnProperty(t) && (this[t] = e[t]); e.hasOwnProperty('toString') && (this.toString = e.toString) }, clone: function () { return this.init.prototype.extend(this) } }; var u = s.WordArray = c.extend({ init: function (e, t) { e = this.words = e || [], this.sigBytes = t != null ? t : 4 * e.length }, toString: function (e) { return (e || d).stringify(this) }, concat: function (e) { const t = this.words; const n = e.words; const r = this.sigBytes; const i = e.sigBytes; if (this.clamp(), r % 4) for (let o = 0; o < i; o++) { const a = n[o >>> 2] >>> 24 - o % 4 * 8 & 255; t[r + o >>> 2] |= a << 24 - (r + o) % 4 * 8 } else for (let s = 0; s < i; s += 4)t[r + s >>> 2] = n[s >>> 2]; return this.sigBytes += i, this }, clamp: function () { const t = this.words; const n = this.sigBytes; t[n >>> 2] &= 4294967295 << 32 - n % 4 * 8, t.length = e.ceil(n / 4) }, clone: function () { const e = c.clone.call(this); return e.words = this.words.slice(0), e }, random: function (e) { for (var t = [], n = 0; n < e; n += 4)t.push(i()); return new u.init(t, e) } }); const l = a.enc = {}; var d = l.Hex = { stringify: function (e) { for (var t = e.words, n = e.sigBytes, r = [], i = 0; i < n; i++) { const o = t[i >>> 2] >>> 24 - i % 4 * 8 & 255; r.push((o >>> 4).toString(16)), r.push((15 & o).toString(16)) } return r.join('') }, parse: function (e) { for (var t = e.length, n = [], r = 0; r < t; r += 2)n[r >>> 3] |= parseInt(e.substr(r, 2), 16) << 24 - r % 8 * 4; return new u.init(n, t / 2) } }; const f = l.Latin1 = { stringify: function (e) { for (var t = e.words, n = e.sigBytes, r = [], i = 0; i < n; i++) { const o = t[i >>> 2] >>> 24 - i % 4 * 8 & 255; r.push(String.fromCharCode(o)) } return r.join('') }, parse: function (e) { for (var t = e.length, n = [], r = 0; r < t; r++)n[r >>> 2] |= (255 & e.charCodeAt(r)) << 24 - r % 4 * 8; return new u.init(n, t) } }; const h = l.Utf8 = { stringify: function (e) { try { return decodeURIComponent(escape(f.stringify(e))) } catch (e) { throw new Error('Malformed UTF-8 data') } }, parse: function (e) { return f.parse(unescape(encodeURIComponent(e))) } }; const p = s.BufferedBlockAlgorithm = c.extend({ reset: function () { this._data = new u.init(), this._nDataBytes = 0 }, _append: function (e) { typeof e === 'string' && (e = h.parse(e)), this._data.concat(e), this._nDataBytes += e.sigBytes }, _process: function (t) { let n; const r = this._data; const i = r.words; const o = r.sigBytes; const a = this.blockSize; let s = o / (4 * a); const c = (s = t ? e.ceil(s) : e.max((0 | s) - this._minBufferSize, 0)) * a; const l = e.min(4 * c, o); if (c) { for (let d = 0; d < c; d += a) this._doProcessBlock(i, d); n = i.splice(0, c), r.sigBytes -= l } return new u.init(n, l) }, clone: function () { const e = c.clone.call(this); return e._data = this._data.clone(), e }, _minBufferSize: 0 }); var g = (s.Hasher = p.extend({ cfg: c.extend(), init: function (e) { this.cfg = this.cfg.extend(e), this.reset() }, reset: function () { p.reset.call(this), this._doReset() }, update: function (e) { return this._append(e), this._process(), this }, finalize: function (e) { return e && this._append(e), this._doFinalize() }, blockSize: 16, _createHelper: function (e) { return function (t, n) { return new e.init(n).finalize(t) } }, _createHmacHelper: function (e) { return function (t, n) { return new g.HMAC.init(e, n).finalize(t) } } }), a.algo = {}); return a }(Math)), r) }, 8269: function (e, t, n) { let r, i, o; e.exports = (r = n(8249), o = (i = r).lib.WordArray, i.enc.Base64 = { stringify: function (e) { const t = e.words; const n = e.sigBytes; const r = this._map; e.clamp(); for (var i = [], o = 0; o < n; o += 3) for (let a = (t[o >>> 2] >>> 24 - o % 4 * 8 & 255) << 16 | (t[o + 1 >>> 2] >>> 24 - (o + 1) % 4 * 8 & 255) << 8 | t[o + 2 >>> 2] >>> 24 - (o + 2) % 4 * 8 & 255, s = 0; s < 4 && o + 0.75 * s < n; s++)i.push(r.charAt(a >>> 6 * (3 - s) & 63)); const c = r.charAt(64); if (c) for (;i.length % 4;)i.push(c); return i.join('') }, parse: function (e) { let t = e.length; const n = this._map; let r = this._reverseMap; if (!r) { r = this._reverseMap = []; for (let i = 0; i < n.length; i++)r[n.charCodeAt(i)] = i } const a = n.charAt(64); if (a) { const s = e.indexOf(a); s !== -1 && (t = s) } return (function (e, t, n) { for (var r = [], i = 0, a = 0; a < t; a++) if (a % 4) { const s = n[e.charCodeAt(a - 1)] << a % 4 * 2 | n[e.charCodeAt(a)] >>> 6 - a % 4 * 2; r[i >>> 2] |= s << 24 - i % 4 * 8, i++ } return o.create(r, i) }(e, t, r)) }, _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' }, r.enc.Base64) }, 3786: function (e, t, n) { let r, i, o; e.exports = (r = n(8249), o = (i = r).lib.WordArray, i.enc.Base64url = { stringify: function (e, t = !0) { const n = e.words; const r = e.sigBytes; const i = t ? this._safe_map : this._map; e.clamp(); for (var o = [], a = 0; a < r; a += 3) for (let s = (n[a >>> 2] >>> 24 - a % 4 * 8 & 255) << 16 | (n[a + 1 >>> 2] >>> 24 - (a + 1) % 4 * 8 & 255) << 8 | n[a + 2 >>> 2] >>> 24 - (a + 2) % 4 * 8 & 255, c = 0; c < 4 && a + 0.75 * c < r; c++)o.push(i.charAt(s >>> 6 * (3 - c) & 63)); const u = i.charAt(64); if (u) for (;o.length % 4;)o.push(u); return o.join('') }, parse: function (e, t = !0) { let n = e.length; const r = t ? this._safe_map : this._map; let i = this._reverseMap; if (!i) { i = this._reverseMap = []; for (let a = 0; a < r.length; a++)i[r.charCodeAt(a)] = a } const s = r.charAt(64); if (s) { const c = e.indexOf(s); c !== -1 && (n = c) } return (function (e, t, n) { for (var r = [], i = 0, a = 0; a < t; a++) if (a % 4) { const s = n[e.charCodeAt(a - 1)] << a % 4 * 2 | n[e.charCodeAt(a)] >>> 6 - a % 4 * 2; r[i >>> 2] |= s << 24 - i % 4 * 8, i++ } return o.create(r, i) }(e, n, i)) }, _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=', _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_' }, r.enc.Base64url) }, 298: function (e, t, n) { let r; e.exports = (r = n(8249), (function () { const e = r; const t = e.lib.WordArray; const n = e.enc; function i (e) { return e << 8 & 4278255360 | e >>> 8 & 16711935 }n.Utf16 = n.Utf16BE = { stringify: function (e) { for (var t = e.words, n = e.sigBytes, r = [], i = 0; i < n; i += 2) { const o = t[i >>> 2] >>> 16 - i % 4 * 8 & 65535; r.push(String.fromCharCode(o)) } return r.join('') }, parse: function (e) { for (var n = e.length, r = [], i = 0; i < n; i++)r[i >>> 1] |= e.charCodeAt(i) << 16 - i % 2 * 16; return t.create(r, 2 * n) } }, n.Utf16LE = { stringify: function (e) { for (var t = e.words, n = e.sigBytes, r = [], o = 0; o < n; o += 2) { const a = i(t[o >>> 2] >>> 16 - o % 4 * 8 & 65535); r.push(String.fromCharCode(a)) } return r.join('') }, parse: function (e) { for (var n = e.length, r = [], o = 0; o < n; o++)r[o >>> 1] |= i(e.charCodeAt(o) << 16 - o % 2 * 16); return t.create(r, 2 * n) } } }()), r.enc.Utf16) }, 888: function (e, t, n) { let r, i, o, a, s, c, u, l; e.exports = (l = n(8249), n(2783), n(9824), o = (i = (r = l).lib).Base, a = i.WordArray, c = (s = r.algo).MD5, u = s.EvpKDF = o.extend({ cfg: o.extend({ keySize: 4, hasher: c, iterations: 1 }), init: function (e) { this.cfg = this.cfg.extend(e) }, compute: function (e, t) { for (var n, r = this.cfg, i = r.hasher.create(), o = a.create(), s = o.words, c = r.keySize, u = r.iterations; s.length < c;) { n && i.update(n), n = i.update(e).finalize(t), i.reset(); for (let l = 1; l < u; l++)n = i.finalize(n), i.reset(); o.concat(n) } return o.sigBytes = 4 * c, o } }), r.EvpKDF = function (e, t, n) { return u.create(n).compute(e, t) }, l.EvpKDF) }, 2209: function (e, t, n) { let r, i, o, a; e.exports = (a = n(8249), n(5109), i = (r = a).lib.CipherParams, o = r.enc.Hex, r.format.Hex = { stringify: function (e) { return e.ciphertext.toString(o) }, parse: function (e) { const t = o.parse(e); return i.create({ ciphertext: t }) } }, a.format.Hex) }, 9824: function (e, t, n) { let r, i, o; e.exports = (i = (r = n(8249)).lib.Base, o = r.enc.Utf8, void (r.algo.HMAC = i.extend({ init: function (e, t) { e = this._hasher = new e.init(), typeof t === 'string' && (t = o.parse(t)); const n = e.blockSize; const r = 4 * n; t.sigBytes > r && (t = e.finalize(t)), t.clamp(); for (var i = this._oKey = t.clone(), a = this._iKey = t.clone(), s = i.words, c = a.words, u = 0; u < n; u++)s[u] ^= 1549556828, c[u] ^= 909522486; i.sigBytes = a.sigBytes = r, this.reset() }, reset: function () { const e = this._hasher; e.reset(), e.update(this._iKey) }, update: function (e) { return this._hasher.update(e), this }, finalize: function (e) { const t = this._hasher; const n = t.finalize(e); return t.reset(), t.finalize(this._oKey.clone().concat(n)) } }))) }, 1354: function (e, t, n) { let r; e.exports = (r = n(8249), n(4938), n(4433), n(298), n(8269), n(3786), n(8214), n(2783), n(2153), n(7792), n(34), n(7460), n(3327), n(706), n(9824), n(2112), n(888), n(5109), n(8568), n(4242), n(9968), n(7660), n(1148), n(3615), n(2807), n(1077), n(6475), n(6991), n(2209), n(452), n(4253), n(1857), n(4454), n(3974), r) }, 4433: function (e, t, n) { let r; e.exports = (r = n(8249), (function () { if (typeof ArrayBuffer === 'function') { const e = r.lib.WordArray; const t = e.init; const n = e.init = function (e) { if (e instanceof ArrayBuffer && (e = new Uint8Array(e)), (e instanceof Int8Array || typeof Uint8ClampedArray !== 'undefined' && e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array || e instanceof Float64Array) && (e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength)), e instanceof Uint8Array) { for (var n = e.byteLength, r = [], i = 0; i < n; i++)r[i >>> 2] |= e[i] << 24 - i % 4 * 8; t.call(this, r, n) } else t.apply(this, arguments) }; n.prototype = e } }()), r.lib.WordArray) }, 8214: function (e, t, n) { let r; e.exports = (r = n(8249), (function (e) { const t = r; const n = t.lib; const i = n.WordArray; const o = n.Hasher; const a = t.algo; const s = []; !(function () { for (let t = 0; t < 64; t++)s[t] = 4294967296 * e.abs(e.sin(t + 1)) | 0 }()); const c = a.MD5 = o.extend({ _doReset: function () { this._hash = new i.init([1732584193, 4023233417, 2562383102, 271733878]) }, _doProcessBlock: function (e, t) { for (let n = 0; n < 16; n++) { const r = t + n; const i = e[r]; e[r] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8) } const o = this._hash.words; const a = e[t + 0]; const c = e[t + 1]; const h = e[t + 2]; const p = e[t + 3]; const g = e[t + 4]; const m = e[t + 5]; const y = e[t + 6]; const b = e[t + 7]; const v = e[t + 8]; const w = e[t + 9]; const _ = e[t + 10]; const E = e[t + 11]; const k = e[t + 12]; const S = e[t + 13]; const A = e[t + 14]; const O = e[t + 15]; let x = o[0]; let I = o[1]; let N = o[2]; let T = o[3]; x = u(x, I, N, T, a, 7, s[0]), T = u(T, x, I, N, c, 12, s[1]), N = u(N, T, x, I, h, 17, s[2]), I = u(I, N, T, x, p, 22, s[3]), x = u(x, I, N, T, g, 7, s[4]), T = u(T, x, I, N, m, 12, s[5]), N = u(N, T, x, I, y, 17, s[6]), I = u(I, N, T, x, b, 22, s[7]), x = u(x, I, N, T, v, 7, s[8]), T = u(T, x, I, N, w, 12, s[9]), N = u(N, T, x, I, _, 17, s[10]), I = u(I, N, T, x, E, 22, s[11]), x = u(x, I, N, T, k, 7, s[12]), T = u(T, x, I, N, S, 12, s[13]), N = u(N, T, x, I, A, 17, s[14]), x = l(x, I = u(I, N, T, x, O, 22, s[15]), N, T, c, 5, s[16]), T = l(T, x, I, N, y, 9, s[17]), N = l(N, T, x, I, E, 14, s[18]), I = l(I, N, T, x, a, 20, s[19]), x = l(x, I, N, T, m, 5, s[20]), T = l(T, x, I, N, _, 9, s[21]), N = l(N, T, x, I, O, 14, s[22]), I = l(I, N, T, x, g, 20, s[23]), x = l(x, I, N, T, w, 5, s[24]), T = l(T, x, I, N, A, 9, s[25]), N = l(N, T, x, I, p, 14, s[26]), I = l(I, N, T, x, v, 20, s[27]), x = l(x, I, N, T, S, 5, s[28]), T = l(T, x, I, N, h, 9, s[29]), N = l(N, T, x, I, b, 14, s[30]), x = d(x, I = l(I, N, T, x, k, 20, s[31]), N, T, m, 4, s[32]), T = d(T, x, I, N, v, 11, s[33]), N = d(N, T, x, I, E, 16, s[34]), I = d(I, N, T, x, A, 23, s[35]), x = d(x, I, N, T, c, 4, s[36]), T = d(T, x, I, N, g, 11, s[37]), N = d(N, T, x, I, b, 16, s[38]), I = d(I, N, T, x, _, 23, s[39]), x = d(x, I, N, T, S, 4, s[40]), T = d(T, x, I, N, a, 11, s[41]), N = d(N, T, x, I, p, 16, s[42]), I = d(I, N, T, x, y, 23, s[43]), x = d(x, I, N, T, w, 4, s[44]), T = d(T, x, I, N, k, 11, s[45]), N = d(N, T, x, I, O, 16, s[46]), x = f(x, I = d(I, N, T, x, h, 23, s[47]), N, T, a, 6, s[48]), T = f(T, x, I, N, b, 10, s[49]), N = f(N, T, x, I, A, 15, s[50]), I = f(I, N, T, x, m, 21, s[51]), x = f(x, I, N, T, k, 6, s[52]), T = f(T, x, I, N, p, 10, s[53]), N = f(N, T, x, I, _, 15, s[54]), I = f(I, N, T, x, c, 21, s[55]), x = f(x, I, N, T, v, 6, s[56]), T = f(T, x, I, N, O, 10, s[57]), N = f(N, T, x, I, y, 15, s[58]), I = f(I, N, T, x, S, 21, s[59]), x = f(x, I, N, T, g, 6, s[60]), T = f(T, x, I, N, E, 10, s[61]), N = f(N, T, x, I, h, 15, s[62]), I = f(I, N, T, x, w, 21, s[63]), o[0] = o[0] + x | 0, o[1] = o[1] + I | 0, o[2] = o[2] + N | 0, o[3] = o[3] + T | 0 }, _doFinalize: function () { const t = this._data; const n = t.words; const r = 8 * this._nDataBytes; const i = 8 * t.sigBytes; n[i >>> 5] |= 128 << 24 - i % 32; const o = e.floor(r / 4294967296); const a = r; n[15 + (i + 64 >>> 9 << 4)] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8), n[14 + (i + 64 >>> 9 << 4)] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8), t.sigBytes = 4 * (n.length + 1), this._process(); for (var s = this._hash, c = s.words, u = 0; u < 4; u++) { const l = c[u]; c[u] = 16711935 & (l << 8 | l >>> 24) | 4278255360 & (l << 24 | l >>> 8) } return s }, clone: function () { const e = o.clone.call(this); return e._hash = this._hash.clone(), e } }); function u (e, t, n, r, i, o, a) { const s = e + (t & n | ~t & r) + i + a; return (s << o | s >>> 32 - o) + t } function l (e, t, n, r, i, o, a) { const s = e + (t & r | n & ~r) + i + a; return (s << o | s >>> 32 - o) + t } function d (e, t, n, r, i, o, a) { const s = e + (t ^ n ^ r) + i + a; return (s << o | s >>> 32 - o) + t } function f (e, t, n, r, i, o, a) { const s = e + (n ^ (t | ~r)) + i + a; return (s << o | s >>> 32 - o) + t }t.MD5 = o._createHelper(c), t.HmacMD5 = o._createHmacHelper(c) }(Math)), r.MD5) }, 8568: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.mode.CFB = (function () { const e = r.lib.BlockCipherMode.extend(); function t (e, t, n, r) { let i; const o = this._iv; o ? (i = o.slice(0), this._iv = void 0) : i = this._prevBlock, r.encryptBlock(i, 0); for (let a = 0; a < n; a++)e[t + a] ^= i[a] } return e.Encryptor = e.extend({ processBlock: function (e, n) { const r = this._cipher; const i = r.blockSize; t.call(this, e, n, i, r), this._prevBlock = e.slice(n, n + i) } }), e.Decryptor = e.extend({ processBlock: function (e, n) { const r = this._cipher; const i = r.blockSize; const o = e.slice(n, n + i); t.call(this, e, n, i, r), this._prevBlock = o } }), e }()), r.mode.CFB) }, 9968: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.mode.CTRGladman = (function () { const e = r.lib.BlockCipherMode.extend(); function t (e) { if ((e >> 24 & 255) == 255) { let t = e >> 16 & 255; let n = e >> 8 & 255; let r = 255 & e; t === 255 ? (t = 0, n === 255 ? (n = 0, r === 255 ? r = 0 : ++r) : ++n) : ++t, e = 0, e += t << 16, e += n << 8, e += r } else e += 1 << 24; return e } const n = e.Encryptor = e.extend({ processBlock: function (e, n) { const r = this._cipher; const i = r.blockSize; const o = this._iv; let a = this._counter; o && (a = this._counter = o.slice(0), this._iv = void 0), (function (e) { (e[0] = t(e[0])) === 0 && (e[1] = t(e[1])) }(a)); const s = a.slice(0); r.encryptBlock(s, 0); for (let c = 0; c < i; c++)e[n + c] ^= s[c] } }); return e.Decryptor = n, e }()), r.mode.CTRGladman) }, 4242: function (e, t, n) { let r, i, o; e.exports = (o = n(8249), n(5109), o.mode.CTR = (i = (r = o.lib.BlockCipherMode.extend()).Encryptor = r.extend({ processBlock: function (e, t) { const n = this._cipher; const r = n.blockSize; const i = this._iv; let o = this._counter; i && (o = this._counter = i.slice(0), this._iv = void 0); const a = o.slice(0); n.encryptBlock(a, 0), o[r - 1] = o[r - 1] + 1 | 0; for (let s = 0; s < r; s++)e[t + s] ^= a[s] } }), r.Decryptor = i, r), o.mode.CTR) }, 1148: function (e, t, n) { let r, i; e.exports = (i = n(8249), n(5109), i.mode.ECB = ((r = i.lib.BlockCipherMode.extend()).Encryptor = r.extend({ processBlock: function (e, t) { this._cipher.encryptBlock(e, t) } }), r.Decryptor = r.extend({ processBlock: function (e, t) { this._cipher.decryptBlock(e, t) } }), r), i.mode.ECB) }, 7660: function (e, t, n) { let r, i, o; e.exports = (o = n(8249), n(5109), o.mode.OFB = (i = (r = o.lib.BlockCipherMode.extend()).Encryptor = r.extend({ processBlock: function (e, t) { const n = this._cipher; const r = n.blockSize; const i = this._iv; let o = this._keystream; i && (o = this._keystream = i.slice(0), this._iv = void 0), n.encryptBlock(o, 0); for (let a = 0; a < r; a++)e[t + a] ^= o[a] } }), r.Decryptor = i, r), o.mode.OFB) }, 3615: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.pad.AnsiX923 = { pad: function (e, t) { const n = e.sigBytes; const r = 4 * t; const i = r - n % r; const o = n + i - 1; e.clamp(), e.words[o >>> 2] |= i << 24 - o % 4 * 8, e.sigBytes += i }, unpad: function (e) { const t = 255 & e.words[e.sigBytes - 1 >>> 2]; e.sigBytes -= t } }, r.pad.Ansix923) }, 2807: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.pad.Iso10126 = { pad: function (e, t) { const n = 4 * t; const i = n - e.sigBytes % n; e.concat(r.lib.WordArray.random(i - 1)).concat(r.lib.WordArray.create([i << 24], 1)) }, unpad: function (e) { const t = 255 & e.words[e.sigBytes - 1 >>> 2]; e.sigBytes -= t } }, r.pad.Iso10126) }, 1077: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.pad.Iso97971 = { pad: function (e, t) { e.concat(r.lib.WordArray.create([2147483648], 1)), r.pad.ZeroPadding.pad(e, t) }, unpad: function (e) { r.pad.ZeroPadding.unpad(e), e.sigBytes-- } }, r.pad.Iso97971) }, 6991: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.pad.NoPadding = { pad: function () {}, unpad: function () {} }, r.pad.NoPadding) }, 6475: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.pad.ZeroPadding = { pad: function (e, t) { const n = 4 * t; e.clamp(), e.sigBytes += n - (e.sigBytes % n || n) }, unpad: function (e) { const t = e.words; let n = e.sigBytes - 1; for (n = e.sigBytes - 1; n >= 0; n--) if (t[n >>> 2] >>> 24 - n % 4 * 8 & 255) { e.sigBytes = n + 1; break } } }, r.pad.ZeroPadding) }, 2112: function (e, t, n) { let r, i, o, a, s, c, u, l, d; e.exports = (d = n(8249), n(2783), n(9824), o = (i = (r = d).lib).Base, a = i.WordArray, c = (s = r.algo).SHA1, u = s.HMAC, l = s.PBKDF2 = o.extend({ cfg: o.extend({ keySize: 4, hasher: c, iterations: 1 }), init: function (e) { this.cfg = this.cfg.extend(e) }, compute: function (e, t) { for (var n = this.cfg, r = u.create(n.hasher, e), i = a.create(), o = a.create([1]), s = i.words, c = o.words, l = n.keySize, d = n.iterations; s.length < l;) { const f = r.update(t).finalize(o); r.reset(); for (let h = f.words, p = h.length, g = f, m = 1; m < d; m++) { g = r.finalize(g), r.reset(); for (let y = g.words, b = 0; b < p; b++)h[b] ^= y[b] }i.concat(f), c[0]++ } return i.sigBytes = 4 * l, i } }), r.PBKDF2 = function (e, t, n) { return l.create(n).compute(e, t) }, d.PBKDF2) }, 3974: function (e, t, n) { let r; e.exports = (r = n(8249), n(8269), n(8214), n(888), n(5109), (function () { const e = r; const t = e.lib.StreamCipher; const n = e.algo; const i = []; const o = []; const a = []; const s = n.RabbitLegacy = t.extend({ _doReset: function () { const e = this._key.words; const t = this.cfg.iv; const n = this._X = [e[0], e[3] << 16 | e[2] >>> 16, e[1], e[0] << 16 | e[3] >>> 16, e[2], e[1] << 16 | e[0] >>> 16, e[3], e[2] << 16 | e[1] >>> 16]; const r = this._C = [e[2] << 16 | e[2] >>> 16, 4294901760 & e[0] | 65535 & e[1], e[3] << 16 | e[3] >>> 16, 4294901760 & e[1] | 65535 & e[2], e[0] << 16 | e[0] >>> 16, 4294901760 & e[2] | 65535 & e[3], e[1] << 16 | e[1] >>> 16, 4294901760 & e[3] | 65535 & e[0]]; this._b = 0; for (var i = 0; i < 4; i++)c.call(this); for (i = 0; i < 8; i++)r[i] ^= n[i + 4 & 7]; if (t) { const o = t.words; const a = o[0]; const s = o[1]; const u = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8); const l = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8); const d = u >>> 16 | 4294901760 & l; const f = l << 16 | 65535 & u; for (r[0] ^= u, r[1] ^= d, r[2] ^= l, r[3] ^= f, r[4] ^= u, r[5] ^= d, r[6] ^= l, r[7] ^= f, i = 0; i < 4; i++)c.call(this) } }, _doProcessBlock: function (e, t) { const n = this._X; c.call(this), i[0] = n[0] ^ n[5] >>> 16 ^ n[3] << 16, i[1] = n[2] ^ n[7] >>> 16 ^ n[5] << 16, i[2] = n[4] ^ n[1] >>> 16 ^ n[7] << 16, i[3] = n[6] ^ n[3] >>> 16 ^ n[1] << 16; for (let r = 0; r < 4; r++)i[r] = 16711935 & (i[r] << 8 | i[r] >>> 24) | 4278255360 & (i[r] << 24 | i[r] >>> 8), e[t + r] ^= i[r] }, blockSize: 4, ivSize: 2 }); function c () { for (var e = this._X, t = this._C, n = 0; n < 8; n++)o[n] = t[n]; for (t[0] = t[0] + 1295307597 + this._b | 0, t[1] = t[1] + 3545052371 + (t[0] >>> 0 < o[0] >>> 0 ? 1 : 0) | 0, t[2] = t[2] + 886263092 + (t[1] >>> 0 < o[1] >>> 0 ? 1 : 0) | 0, t[3] = t[3] + 1295307597 + (t[2] >>> 0 < o[2] >>> 0 ? 1 : 0) | 0, t[4] = t[4] + 3545052371 + (t[3] >>> 0 < o[3] >>> 0 ? 1 : 0) | 0, t[5] = t[5] + 886263092 + (t[4] >>> 0 < o[4] >>> 0 ? 1 : 0) | 0, t[6] = t[6] + 1295307597 + (t[5] >>> 0 < o[5] >>> 0 ? 1 : 0) | 0, t[7] = t[7] + 3545052371 + (t[6] >>> 0 < o[6] >>> 0 ? 1 : 0) | 0, this._b = t[7] >>> 0 < o[7] >>> 0 ? 1 : 0, n = 0; n < 8; n++) { const r = e[n] + t[n]; const i = 65535 & r; const s = r >>> 16; const c = ((i * i >>> 17) + i * s >>> 15) + s * s; const u = ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0); a[n] = c ^ u }e[0] = a[0] + (a[7] << 16 | a[7] >>> 16) + (a[6] << 16 | a[6] >>> 16) | 0, e[1] = a[1] + (a[0] << 8 | a[0] >>> 24) + a[7] | 0, e[2] = a[2] + (a[1] << 16 | a[1] >>> 16) + (a[0] << 16 | a[0] >>> 16) | 0, e[3] = a[3] + (a[2] << 8 | a[2] >>> 24) + a[1] | 0, e[4] = a[4] + (a[3] << 16 | a[3] >>> 16) + (a[2] << 16 | a[2] >>> 16) | 0, e[5] = a[5] + (a[4] << 8 | a[4] >>> 24) + a[3] | 0, e[6] = a[6] + (a[5] << 16 | a[5] >>> 16) + (a[4] << 16 | a[4] >>> 16) | 0, e[7] = a[7] + (a[6] << 8 | a[6] >>> 24) + a[5] | 0 }e.RabbitLegacy = t._createHelper(s) }()), r.RabbitLegacy) }, 4454: function (e, t, n) { let r; e.exports = (r = n(8249), n(8269), n(8214), n(888), n(5109), (function () { const e = r; const t = e.lib.StreamCipher; const n = e.algo; const i = []; const o = []; const a = []; const s = n.Rabbit = t.extend({ _doReset: function () { for (var e = this._key.words, t = this.cfg.iv, n = 0; n < 4; n++)e[n] = 16711935 & (e[n] << 8 | e[n] >>> 24) | 4278255360 & (e[n] << 24 | e[n] >>> 8); const r = this._X = [e[0], e[3] << 16 | e[2] >>> 16, e[1], e[0] << 16 | e[3] >>> 16, e[2], e[1] << 16 | e[0] >>> 16, e[3], e[2] << 16 | e[1] >>> 16]; const i = this._C = [e[2] << 16 | e[2] >>> 16, 4294901760 & e[0] | 65535 & e[1], e[3] << 16 | e[3] >>> 16, 4294901760 & e[1] | 65535 & e[2], e[0] << 16 | e[0] >>> 16, 4294901760 & e[2] | 65535 & e[3], e[1] << 16 | e[1] >>> 16, 4294901760 & e[3] | 65535 & e[0]]; for (this._b = 0, n = 0; n < 4; n++)c.call(this); for (n = 0; n < 8; n++)i[n] ^= r[n + 4 & 7]; if (t) { const o = t.words; const a = o[0]; const s = o[1]; const u = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8); const l = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8); const d = u >>> 16 | 4294901760 & l; const f = l << 16 | 65535 & u; for (i[0] ^= u, i[1] ^= d, i[2] ^= l, i[3] ^= f, i[4] ^= u, i[5] ^= d, i[6] ^= l, i[7] ^= f, n = 0; n < 4; n++)c.call(this) } }, _doProcessBlock: function (e, t) { const n = this._X; c.call(this), i[0] = n[0] ^ n[5] >>> 16 ^ n[3] << 16, i[1] = n[2] ^ n[7] >>> 16 ^ n[5] << 16, i[2] = n[4] ^ n[1] >>> 16 ^ n[7] << 16, i[3] = n[6] ^ n[3] >>> 16 ^ n[1] << 16; for (let r = 0; r < 4; r++)i[r] = 16711935 & (i[r] << 8 | i[r] >>> 24) | 4278255360 & (i[r] << 24 | i[r] >>> 8), e[t + r] ^= i[r] }, blockSize: 4, ivSize: 2 }); function c () { for (var e = this._X, t = this._C, n = 0; n < 8; n++)o[n] = t[n]; for (t[0] = t[0] + 1295307597 + this._b | 0, t[1] = t[1] + 3545052371 + (t[0] >>> 0 < o[0] >>> 0 ? 1 : 0) | 0, t[2] = t[2] + 886263092 + (t[1] >>> 0 < o[1] >>> 0 ? 1 : 0) | 0, t[3] = t[3] + 1295307597 + (t[2] >>> 0 < o[2] >>> 0 ? 1 : 0) | 0, t[4] = t[4] + 3545052371 + (t[3] >>> 0 < o[3] >>> 0 ? 1 : 0) | 0, t[5] = t[5] + 886263092 + (t[4] >>> 0 < o[4] >>> 0 ? 1 : 0) | 0, t[6] = t[6] + 1295307597 + (t[5] >>> 0 < o[5] >>> 0 ? 1 : 0) | 0, t[7] = t[7] + 3545052371 + (t[6] >>> 0 < o[6] >>> 0 ? 1 : 0) | 0, this._b = t[7] >>> 0 < o[7] >>> 0 ? 1 : 0, n = 0; n < 8; n++) { const r = e[n] + t[n]; const i = 65535 & r; const s = r >>> 16; const c = ((i * i >>> 17) + i * s >>> 15) + s * s; const u = ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0); a[n] = c ^ u }e[0] = a[0] + (a[7] << 16 | a[7] >>> 16) + (a[6] << 16 | a[6] >>> 16) | 0, e[1] = a[1] + (a[0] << 8 | a[0] >>> 24) + a[7] | 0, e[2] = a[2] + (a[1] << 16 | a[1] >>> 16) + (a[0] << 16 | a[0] >>> 16) | 0, e[3] = a[3] + (a[2] << 8 | a[2] >>> 24) + a[1] | 0, e[4] = a[4] + (a[3] << 16 | a[3] >>> 16) + (a[2] << 16 | a[2] >>> 16) | 0, e[5] = a[5] + (a[4] << 8 | a[4] >>> 24) + a[3] | 0, e[6] = a[6] + (a[5] << 16 | a[5] >>> 16) + (a[4] << 16 | a[4] >>> 16) | 0, e[7] = a[7] + (a[6] << 8 | a[6] >>> 24) + a[5] | 0 }e.Rabbit = t._createHelper(s) }()), r.Rabbit) }, 1857: function (e, t, n) { let r; e.exports = (r = n(8249), n(8269), n(8214), n(888), n(5109), (function () { const e = r; const t = e.lib.StreamCipher; const n = e.algo; const i = n.RC4 = t.extend({ _doReset: function () { for (var e = this._key, t = e.words, n = e.sigBytes, r = this._S = [], i = 0; i < 256; i++)r[i] = i; i = 0; for (let o = 0; i < 256; i++) { const a = i % n; const s = t[a >>> 2] >>> 24 - a % 4 * 8 & 255; o = (o + r[i] + s) % 256; const c = r[i]; r[i] = r[o], r[o] = c } this._i = this._j = 0 }, _doProcessBlock: function (e, t) { e[t] ^= o.call(this) }, keySize: 8, ivSize: 0 }); function o () { for (var e = this._S, t = this._i, n = this._j, r = 0, i = 0; i < 4; i++) { n = (n + e[t = (t + 1) % 256]) % 256; const o = e[t]; e[t] = e[n], e[n] = o, r |= e[(e[t] + e[n]) % 256] << 24 - 8 * i } return this._i = t, this._j = n, r }e.RC4 = t._createHelper(i); const a = n.RC4Drop = i.extend({ cfg: i.cfg.extend({ drop: 192 }), _doReset: function () { i._doReset.call(this); for (let e = this.cfg.drop; e > 0; e--)o.call(this) } }); e.RC4Drop = t._createHelper(a) }()), r.RC4) }, 706: function (e, t, n) { let r; e.exports = (r = n(8249), (function (e) { const t = r; const n = t.lib; const i = n.WordArray; const o = n.Hasher; const a = t.algo; const s = i.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]); const c = i.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]); const u = i.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]); const l = i.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]); const d = i.create([0, 1518500249, 1859775393, 2400959708, 2840853838]); const f = i.create([1352829926, 1548603684, 1836072691, 2053994217, 0]); const h = a.RIPEMD160 = o.extend({ _doReset: function () { this._hash = i.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (e, t) { for (var n = 0; n < 16; n++) { const r = t + n; const i = e[r]; e[r] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8) } let o; let a; let h; let w; let _; let E; let k; let S; let A; let O; let x; const I = this._hash.words; const N = d.words; const T = f.words; const R = s.words; const P = c.words; const C = u.words; const B = l.words; for (E = o = I[0], k = a = I[1], S = h = I[2], A = w = I[3], O = _ = I[4], n = 0; n < 80; n += 1)x = o + e[t + R[n]] | 0, x += n < 16 ? p(a, h, w) + N[0] : n < 32 ? g(a, h, w) + N[1] : n < 48 ? m(a, h, w) + N[2] : n < 64 ? y(a, h, w) + N[3] : b(a, h, w) + N[4], x = (x = v(x |= 0, C[n])) + _ | 0, o = _, _ = w, w = v(h, 10), h = a, a = x, x = E + e[t + P[n]] | 0, x += n < 16 ? b(k, S, A) + T[0] : n < 32 ? y(k, S, A) + T[1] : n < 48 ? m(k, S, A) + T[2] : n < 64 ? g(k, S, A) + T[3] : p(k, S, A) + T[4], x = (x = v(x |= 0, B[n])) + O | 0, E = O, O = A, A = v(S, 10), S = k, k = x; x = I[1] + h + A | 0, I[1] = I[2] + w + O | 0, I[2] = I[3] + _ + E | 0, I[3] = I[4] + o + k | 0, I[4] = I[0] + a + S | 0, I[0] = x }, _doFinalize: function () { const e = this._data; const t = e.words; const n = 8 * this._nDataBytes; const r = 8 * e.sigBytes; t[r >>> 5] |= 128 << 24 - r % 32, t[14 + (r + 64 >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8), e.sigBytes = 4 * (t.length + 1), this._process(); for (var i = this._hash, o = i.words, a = 0; a < 5; a++) { const s = o[a]; o[a] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8) } return i }, clone: function () { const e = o.clone.call(this); return e._hash = this._hash.clone(), e } }); function p (e, t, n) { return e ^ t ^ n } function g (e, t, n) { return e & t | ~e & n } function m (e, t, n) { return (e | ~t) ^ n } function y (e, t, n) { return e & n | t & ~n } function b (e, t, n) { return e ^ (t | ~n) } function v (e, t) { return e << t | e >>> 32 - t }t.RIPEMD160 = o._createHelper(h), t.HmacRIPEMD160 = o._createHmacHelper(h) }(Math)), r.RIPEMD160) }, 2783: function (e, t, n) { let r, i, o, a, s, c, u, l; e.exports = (i = (r = l = n(8249)).lib, o = i.WordArray, a = i.Hasher, s = r.algo, c = [], u = s.SHA1 = a.extend({ _doReset: function () { this._hash = new o.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (e, t) { for (var n = this._hash.words, r = n[0], i = n[1], o = n[2], a = n[3], s = n[4], u = 0; u < 80; u++) { if (u < 16)c[u] = 0 | e[t + u]; else { const l = c[u - 3] ^ c[u - 8] ^ c[u - 14] ^ c[u - 16]; c[u] = l << 1 | l >>> 31 } let d = (r << 5 | r >>> 27) + s + c[u]; d += u < 20 ? 1518500249 + (i & o | ~i & a) : u < 40 ? 1859775393 + (i ^ o ^ a) : u < 60 ? (i & o | i & a | o & a) - 1894007588 : (i ^ o ^ a) - 899497514, s = a, a = o, o = i << 30 | i >>> 2, i = r, r = d }n[0] = n[0] + r | 0, n[1] = n[1] + i | 0, n[2] = n[2] + o | 0, n[3] = n[3] + a | 0, n[4] = n[4] + s | 0 }, _doFinalize: function () { const e = this._data; const t = e.words; const n = 8 * this._nDataBytes; const r = 8 * e.sigBytes; return t[r >>> 5] |= 128 << 24 - r % 32, t[14 + (r + 64 >>> 9 << 4)] = Math.floor(n / 4294967296), t[15 + (r + 64 >>> 9 << 4)] = n, e.sigBytes = 4 * t.length, this._process(), this._hash }, clone: function () { const e = a.clone.call(this); return e._hash = this._hash.clone(), e } }), r.SHA1 = a._createHelper(u), r.HmacSHA1 = a._createHmacHelper(u), l.SHA1) }, 7792: function (e, t, n) { let r, i, o, a, s, c; e.exports = (c = n(8249), n(2153), i = (r = c).lib.WordArray, o = r.algo, a = o.SHA256, s = o.SHA224 = a.extend({ _doReset: function () { this._hash = new i.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]) }, _doFinalize: function () { const e = a._doFinalize.call(this); return e.sigBytes -= 4, e } }), r.SHA224 = a._createHelper(s), r.HmacSHA224 = a._createHmacHelper(s), c.SHA224) }, 2153: function (e, t, n) { let r; e.exports = (r = n(8249), (function (e) { const t = r; const n = t.lib; const i = n.WordArray; const o = n.Hasher; const a = t.algo; const s = []; const c = []; !(function () { function t (t) { for (let n = e.sqrt(t), r = 2; r <= n; r++) if (!(t % r)) return !1; return !0 } function n (e) { return 4294967296 * (e - (0 | e)) | 0 } for (let r = 2, i = 0; i < 64;)t(r) && (i < 8 && (s[i] = n(e.pow(r, 0.5))), c[i] = n(e.pow(r, 1 / 3)), i++), r++ }()); const u = []; const l = a.SHA256 = o.extend({ _doReset: function () { this._hash = new i.init(s.slice(0)) }, _doProcessBlock: function (e, t) { for (var n = this._hash.words, r = n[0], i = n[1], o = n[2], a = n[3], s = n[4], l = n[5], d = n[6], f = n[7], h = 0; h < 64; h++) { if (h < 16)u[h] = 0 | e[t + h]; else { const p = u[h - 15]; const g = (p << 25 | p >>> 7) ^ (p << 14 | p >>> 18) ^ p >>> 3; const m = u[h - 2]; const y = (m << 15 | m >>> 17) ^ (m << 13 | m >>> 19) ^ m >>> 10; u[h] = g + u[h - 7] + y + u[h - 16] } const b = r & i ^ r & o ^ i & o; const v = (r << 30 | r >>> 2) ^ (r << 19 | r >>> 13) ^ (r << 10 | r >>> 22); const w = f + ((s << 26 | s >>> 6) ^ (s << 21 | s >>> 11) ^ (s << 7 | s >>> 25)) + (s & l ^ ~s & d) + c[h] + u[h]; f = d, d = l, l = s, s = a + w | 0, a = o, o = i, i = r, r = w + (v + b) | 0 }n[0] = n[0] + r | 0, n[1] = n[1] + i | 0, n[2] = n[2] + o | 0, n[3] = n[3] + a | 0, n[4] = n[4] + s | 0, n[5] = n[5] + l | 0, n[6] = n[6] + d | 0, n[7] = n[7] + f | 0 }, _doFinalize: function () { const t = this._data; const n = t.words; const r = 8 * this._nDataBytes; const i = 8 * t.sigBytes; return n[i >>> 5] |= 128 << 24 - i % 32, n[14 + (i + 64 >>> 9 << 4)] = e.floor(r / 4294967296), n[15 + (i + 64 >>> 9 << 4)] = r, t.sigBytes = 4 * n.length, this._process(), this._hash }, clone: function () { const e = o.clone.call(this); return e._hash = this._hash.clone(), e } }); t.SHA256 = o._createHelper(l), t.HmacSHA256 = o._createHmacHelper(l) }(Math)), r.SHA256) }, 3327: function (e, t, n) { let r; e.exports = (r = n(8249), n(4938), (function (e) { const t = r; const n = t.lib; const i = n.WordArray; const o = n.Hasher; const a = t.x64.Word; const s = t.algo; const c = []; const u = []; const l = []; !(function () { for (var e = 1, t = 0, n = 0; n < 24; n++) { c[e + 5 * t] = (n + 1) * (n + 2) / 2 % 64; const r = (2 * e + 3 * t) % 5; e = t % 5, t = r } for (e = 0; e < 5; e++) for (t = 0; t < 5; t++)u[e + 5 * t] = t + (2 * e + 3 * t) % 5 * 5; for (let i = 1, o = 0; o < 24; o++) { for (var s = 0, d = 0, f = 0; f < 7; f++) { if (1 & i) { const h = (1 << f) - 1; h < 32 ? d ^= 1 << h : s ^= 1 << h - 32 }128 & i ? i = i << 1 ^ 113 : i <<= 1 }l[o] = a.create(s, d) } }()); const d = []; !(function () { for (let e = 0; e < 25; e++)d[e] = a.create() }()); const f = s.SHA3 = o.extend({ cfg: o.cfg.extend({ outputLength: 512 }), _doReset: function () { for (let e = this._state = [], t = 0; t < 25; t++)e[t] = new a.init(); this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32 }, _doProcessBlock: function (e, t) { for (var n = this._state, r = this.blockSize / 2, i = 0; i < r; i++) { let o = e[t + 2 * i]; let a = e[t + 2 * i + 1]; o = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8), a = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8), (I = n[i]).high ^= a, I.low ^= o } for (let s = 0; s < 24; s++) { for (var f = 0; f < 5; f++) { for (var h = 0, p = 0, g = 0; g < 5; g++)h ^= (I = n[f + 5 * g]).high, p ^= I.low; const m = d[f]; m.high = h, m.low = p } for (f = 0; f < 5; f++) { const y = d[(f + 4) % 5]; const b = d[(f + 1) % 5]; const v = b.high; const w = b.low; for (h = y.high ^ (v << 1 | w >>> 31), p = y.low ^ (w << 1 | v >>> 31), g = 0; g < 5; g++)(I = n[f + 5 * g]).high ^= h, I.low ^= p } for (var _ = 1; _ < 25; _++) { const E = (I = n[_]).high; const k = I.low; const S = c[_]; S < 32 ? (h = E << S | k >>> 32 - S, p = k << S | E >>> 32 - S) : (h = k << S - 32 | E >>> 64 - S, p = E << S - 32 | k >>> 64 - S); const A = d[u[_]]; A.high = h, A.low = p } const O = d[0]; const x = n[0]; for (O.high = x.high, O.low = x.low, f = 0; f < 5; f++) for (g = 0; g < 5; g++) { var I = n[_ = f + 5 * g]; const N = d[_]; const T = d[(f + 1) % 5 + 5 * g]; const R = d[(f + 2) % 5 + 5 * g]; I.high = N.high ^ ~T.high & R.high, I.low = N.low ^ ~T.low & R.low }I = n[0]; const P = l[s]; I.high ^= P.high, I.low ^= P.low } }, _doFinalize: function () { const t = this._data; const n = t.words; const r = (this._nDataBytes, 8 * t.sigBytes); const o = 32 * this.blockSize; n[r >>> 5] |= 1 << 24 - r % 32, n[(e.ceil((r + 1) / o) * o >>> 5) - 1] |= 128, t.sigBytes = 4 * n.length, this._process(); for (var a = this._state, s = this.cfg.outputLength / 8, c = s / 8, u = [], l = 0; l < c; l++) { const d = a[l]; let f = d.high; let h = d.low; f = 16711935 & (f << 8 | f >>> 24) | 4278255360 & (f << 24 | f >>> 8), h = 16711935 & (h << 8 | h >>> 24) | 4278255360 & (h << 24 | h >>> 8), u.push(h), u.push(f) } return new i.init(u, s) }, clone: function () { for (var e = o.clone.call(this), t = e._state = this._state.slice(0), n = 0; n < 25; n++)t[n] = t[n].clone(); return e } }); t.SHA3 = o._createHelper(f), t.HmacSHA3 = o._createHmacHelper(f) }(Math)), r.SHA3) }, 7460: function (e, t, n) { let r, i, o, a, s, c, u, l; e.exports = (l = n(8249), n(4938), n(34), i = (r = l).x64, o = i.Word, a = i.WordArray, s = r.algo, c = s.SHA512, u = s.SHA384 = c.extend({ _doReset: function () { this._hash = new a.init([new o.init(3418070365, 3238371032), new o.init(1654270250, 914150663), new o.init(2438529370, 812702999), new o.init(355462360, 4144912697), new o.init(1731405415, 4290775857), new o.init(2394180231, 1750603025), new o.init(3675008525, 1694076839), new o.init(1203062813, 3204075428)]) }, _doFinalize: function () { const e = c._doFinalize.call(this); return e.sigBytes -= 16, e } }), r.SHA384 = c._createHelper(u), r.HmacSHA384 = c._createHmacHelper(u), l.SHA384) }, 34: function (e, t, n) { let r; e.exports = (r = n(8249), n(4938), (function () { const e = r; const t = e.lib.Hasher; const n = e.x64; const i = n.Word; const o = n.WordArray; const a = e.algo; function s () { return i.create.apply(i, arguments) } const c = [s(1116352408, 3609767458), s(1899447441, 602891725), s(3049323471, 3964484399), s(3921009573, 2173295548), s(961987163, 4081628472), s(1508970993, 3053834265), s(2453635748, 2937671579), s(2870763221, 3664609560), s(3624381080, 2734883394), s(310598401, 1164996542), s(607225278, 1323610764), s(1426881987, 3590304994), s(1925078388, 4068182383), s(2162078206, 991336113), s(2614888103, 633803317), s(3248222580, 3479774868), s(3835390401, 2666613458), s(4022224774, 944711139), s(264347078, 2341262773), s(604807628, 2007800933), s(770255983, 1495990901), s(1249150122, 1856431235), s(1555081692, 3175218132), s(1996064986, 2198950837), s(2554220882, 3999719339), s(2821834349, 766784016), s(2952996808, 2566594879), s(3210313671, 3203337956), s(3336571891, 1034457026), s(3584528711, 2466948901), s(113926993, 3758326383), s(338241895, 168717936), s(666307205, 1188179964), s(773529912, 1546045734), s(1294757372, 1522805485), s(1396182291, 2643833823), s(1695183700, 2343527390), s(1986661051, 1014477480), s(2177026350, 1206759142), s(2456956037, 344077627), s(2730485921, 1290863460), s(2820302411, 3158454273), s(3259730800, 3505952657), s(3345764771, 106217008), s(3516065817, 3606008344), s(3600352804, 1432725776), s(4094571909, 1467031594), s(275423344, 851169720), s(430227734, 3100823752), s(506948616, 1363258195), s(659060556, 3750685593), s(883997877, 3785050280), s(958139571, 3318307427), s(1322822218, 3812723403), s(1537002063, 2003034995), s(1747873779, 3602036899), s(1955562222, 1575990012), s(2024104815, 1125592928), s(2227730452, 2716904306), s(2361852424, 442776044), s(2428436474, 593698344), s(2756734187, 3733110249), s(3204031479, 2999351573), s(3329325298, 3815920427), s(3391569614, 3928383900), s(3515267271, 566280711), s(3940187606, 3454069534), s(4118630271, 4000239992), s(116418474, 1914138554), s(174292421, 2731055270), s(289380356, 3203993006), s(460393269, 320620315), s(685471733, 587496836), s(852142971, 1086792851), s(1017036298, 365543100), s(1126000580, 2618297676), s(1288033470, 3409855158), s(1501505948, 4234509866), s(1607167915, 987167468), s(1816402316, 1246189591)]; const u = []; !(function () { for (let e = 0; e < 80; e++)u[e] = s() }()); const l = a.SHA512 = t.extend({ _doReset: function () { this._hash = new o.init([new i.init(1779033703, 4089235720), new i.init(3144134277, 2227873595), new i.init(1013904242, 4271175723), new i.init(2773480762, 1595750129), new i.init(1359893119, 2917565137), new i.init(2600822924, 725511199), new i.init(528734635, 4215389547), new i.init(1541459225, 327033209)]) }, _doProcessBlock: function (e, t) { for (var n = this._hash.words, r = n[0], i = n[1], o = n[2], a = n[3], s = n[4], l = n[5], d = n[6], f = n[7], h = r.high, p = r.low, g = i.high, m = i.low, y = o.high, b = o.low, v = a.high, w = a.low, _ = s.high, E = s.low, k = l.high, S = l.low, A = d.high, O = d.low, x = f.high, I = f.low, N = h, T = p, R = g, P = m, C = y, B = b, L = v, j = w, D = _, U = E, M = k, z = S, F = A, H = O, q = x, K = I, V = 0; V < 80; V++) { var W; var $; const G = u[V]; if (V < 16)$ = G.high = 0 | e[t + 2 * V], W = G.low = 0 | e[t + 2 * V + 1]; else { const Y = u[V - 15]; const Z = Y.high; const J = Y.low; const X = (Z >>> 1 | J << 31) ^ (Z >>> 8 | J << 24) ^ Z >>> 7; const Q = (J >>> 1 | Z << 31) ^ (J >>> 8 | Z << 24) ^ (J >>> 7 | Z << 25); const ee = u[V - 2]; const te = ee.high; const ne = ee.low; const re = (te >>> 19 | ne << 13) ^ (te << 3 | ne >>> 29) ^ te >>> 6; const ie = (ne >>> 19 | te << 13) ^ (ne << 3 | te >>> 29) ^ (ne >>> 6 | te << 26); const oe = u[V - 7]; const ae = oe.high; const se = oe.low; const ce = u[V - 16]; const ue = ce.high; const le = ce.low; $ = ($ = ($ = X + ae + ((W = Q + se) >>> 0 < Q >>> 0 ? 1 : 0)) + re + ((W += ie) >>> 0 < ie >>> 0 ? 1 : 0)) + ue + ((W += le) >>> 0 < le >>> 0 ? 1 : 0), G.high = $, G.low = W } var de; const fe = D & M ^ ~D & F; const he = U & z ^ ~U & H; const pe = N & R ^ N & C ^ R & C; const ge = T & P ^ T & B ^ P & B; const me = (N >>> 28 | T << 4) ^ (N << 30 | T >>> 2) ^ (N << 25 | T >>> 7); const ye = (T >>> 28 | N << 4) ^ (T << 30 | N >>> 2) ^ (T << 25 | N >>> 7); const be = (D >>> 14 | U << 18) ^ (D >>> 18 | U << 14) ^ (D << 23 | U >>> 9); const ve = (U >>> 14 | D << 18) ^ (U >>> 18 | D << 14) ^ (U << 23 | D >>> 9); const we = c[V]; const _e = we.high; const Ee = we.low; let ke = q + be + ((de = K + ve) >>> 0 < K >>> 0 ? 1 : 0); const Se = ye + ge; q = F, K = H, F = M, H = z, M = D, z = U, D = L + (ke = (ke = (ke = ke + fe + ((de += he) >>> 0 < he >>> 0 ? 1 : 0)) + _e + ((de += Ee) >>> 0 < Ee >>> 0 ? 1 : 0)) + $ + ((de += W) >>> 0 < W >>> 0 ? 1 : 0)) + ((U = j + de | 0) >>> 0 < j >>> 0 ? 1 : 0) | 0, L = C, j = B, C = R, B = P, R = N, P = T, N = ke + (me + pe + (Se >>> 0 < ye >>> 0 ? 1 : 0)) + ((T = de + Se | 0) >>> 0 < de >>> 0 ? 1 : 0) | 0 }p = r.low = p + T, r.high = h + N + (p >>> 0 < T >>> 0 ? 1 : 0), m = i.low = m + P, i.high = g + R + (m >>> 0 < P >>> 0 ? 1 : 0), b = o.low = b + B, o.high = y + C + (b >>> 0 < B >>> 0 ? 1 : 0), w = a.low = w + j, a.high = v + L + (w >>> 0 < j >>> 0 ? 1 : 0), E = s.low = E + U, s.high = _ + D + (E >>> 0 < U >>> 0 ? 1 : 0), S = l.low = S + z, l.high = k + M + (S >>> 0 < z >>> 0 ? 1 : 0), O = d.low = O + H, d.high = A + F + (O >>> 0 < H >>> 0 ? 1 : 0), I = f.low = I + K, f.high = x + q + (I >>> 0 < K >>> 0 ? 1 : 0) }, _doFinalize: function () { const e = this._data; const t = e.words; const n = 8 * this._nDataBytes; const r = 8 * e.sigBytes; return t[r >>> 5] |= 128 << 24 - r % 32, t[30 + (r + 128 >>> 10 << 5)] = Math.floor(n / 4294967296), t[31 + (r + 128 >>> 10 << 5)] = n, e.sigBytes = 4 * t.length, this._process(), this._hash.toX32() }, clone: function () { const e = t.clone.call(this); return e._hash = this._hash.clone(), e }, blockSize: 32 }); e.SHA512 = t._createHelper(l), e.HmacSHA512 = t._createHmacHelper(l) }()), r.SHA512) }, 4253: function (e, t, n) { let r; e.exports = (r = n(8249), n(8269), n(8214), n(888), n(5109), (function () { const e = r; const t = e.lib; const n = t.WordArray; const i = t.BlockCipher; const o = e.algo; const a = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]; const s = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]; const c = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28]; const u = [{ 0: 8421888, 268435456: 32768, 536870912: 8421378, 805306368: 2, 1073741824: 512, 1342177280: 8421890, 1610612736: 8389122, 1879048192: 8388608, 2147483648: 514, 2415919104: 8389120, 2684354560: 33280, 2952790016: 8421376, 3221225472: 32770, 3489660928: 8388610, 3758096384: 0, 4026531840: 33282, 134217728: 0, 402653184: 8421890, 671088640: 33282, 939524096: 32768, 1207959552: 8421888, 1476395008: 512, 1744830464: 8421378, 2013265920: 2, 2281701376: 8389120, 2550136832: 33280, 2818572288: 8421376, 3087007744: 8389122, 3355443200: 8388610, 3623878656: 32770, 3892314112: 514, 4160749568: 8388608, 1: 32768, 268435457: 2, 536870913: 8421888, 805306369: 8388608, 1073741825: 8421378, 1342177281: 33280, 1610612737: 512, 1879048193: 8389122, 2147483649: 8421890, 2415919105: 8421376, 2684354561: 8388610, 2952790017: 33282, 3221225473: 514, 3489660929: 8389120, 3758096385: 32770, 4026531841: 0, 134217729: 8421890, 402653185: 8421376, 671088641: 8388608, 939524097: 512, 1207959553: 32768, 1476395009: 8388610, 1744830465: 2, 2013265921: 33282, 2281701377: 32770, 2550136833: 8389122, 2818572289: 514, 3087007745: 8421888, 3355443201: 8389120, 3623878657: 0, 3892314113: 33280, 4160749569: 8421378 }, { 0: 1074282512, 16777216: 16384, 33554432: 524288, 50331648: 1074266128, 67108864: 1073741840, 83886080: 1074282496, 100663296: 1073758208, 117440512: 16, 134217728: 540672, 150994944: 1073758224, 167772160: 1073741824, 184549376: 540688, 201326592: 524304, 218103808: 0, 234881024: 16400, 251658240: 1074266112, 8388608: 1073758208, 25165824: 540688, 41943040: 16, 58720256: 1073758224, 75497472: 1074282512, 92274688: 1073741824, 109051904: 524288, 125829120: 1074266128, 142606336: 524304, 159383552: 0, 176160768: 16384, 192937984: 1074266112, 209715200: 1073741840, 226492416: 540672, 243269632: 1074282496, 260046848: 16400, 268435456: 0, 285212672: 1074266128, 301989888: 1073758224, 318767104: 1074282496, 335544320: 1074266112, 352321536: 16, 369098752: 540688, 385875968: 16384, 402653184: 16400, 419430400: 524288, 436207616: 524304, 452984832: 1073741840, 469762048: 540672, 486539264: 1073758208, 503316480: 1073741824, 520093696: 1074282512, 276824064: 540688, 293601280: 524288, 310378496: 1074266112, 327155712: 16384, 343932928: 1073758208, 360710144: 1074282512, 377487360: 16, 394264576: 1073741824, 411041792: 1074282496, 427819008: 1073741840, 444596224: 1073758224, 461373440: 524304, 478150656: 0, 494927872: 16400, 511705088: 1074266128, 528482304: 540672 }, { 0: 260, 1048576: 0, 2097152: 67109120, 3145728: 65796, 4194304: 65540, 5242880: 67108868, 6291456: 67174660, 7340032: 67174400, 8388608: 67108864, 9437184: 67174656, 10485760: 65792, 11534336: 67174404, 12582912: 67109124, 13631488: 65536, 14680064: 4, 15728640: 256, 524288: 67174656, 1572864: 67174404, 2621440: 0, 3670016: 67109120, 4718592: 67108868, 5767168: 65536, 6815744: 65540, 7864320: 260, 8912896: 4, 9961472: 256, 11010048: 67174400, 12058624: 65796, 13107200: 65792, 14155776: 67109124, 15204352: 67174660, 16252928: 67108864, 16777216: 67174656, 17825792: 65540, 18874368: 65536, 19922944: 67109120, 20971520: 256, 22020096: 67174660, 23068672: 67108868, 24117248: 0, 25165824: 67109124, 26214400: 67108864, 27262976: 4, 28311552: 65792, 29360128: 67174400, 30408704: 260, 31457280: 65796, 32505856: 67174404, 17301504: 67108864, 18350080: 260, 19398656: 67174656, 20447232: 0, 21495808: 65540, 22544384: 67109120, 23592960: 256, 24641536: 67174404, 25690112: 65536, 26738688: 67174660, 27787264: 65796, 28835840: 67108868, 29884416: 67109124, 30932992: 67174400, 31981568: 4, 33030144: 65792 }, { 0: 2151682048, 65536: 2147487808, 131072: 4198464, 196608: 2151677952, 262144: 0, 327680: 4198400, 393216: 2147483712, 458752: 4194368, 524288: 2147483648, 589824: 4194304, 655360: 64, 720896: 2147487744, 786432: 2151678016, 851968: 4160, 917504: 4096, 983040: 2151682112, 32768: 2147487808, 98304: 64, 163840: 2151678016, 229376: 2147487744, 294912: 4198400, 360448: 2151682112, 425984: 0, 491520: 2151677952, 557056: 4096, 622592: 2151682048, 688128: 4194304, 753664: 4160, 819200: 2147483648, 884736: 4194368, 950272: 4198464, 1015808: 2147483712, 1048576: 4194368, 1114112: 4198400, 1179648: 2147483712, 1245184: 0, 1310720: 4160, 1376256: 2151678016, 1441792: 2151682048, 1507328: 2147487808, 1572864: 2151682112, 1638400: 2147483648, 1703936: 2151677952, 1769472: 4198464, 1835008: 2147487744, 1900544: 4194304, 1966080: 64, 2031616: 4096, 1081344: 2151677952, 1146880: 2151682112, 1212416: 0, 1277952: 4198400, 1343488: 4194368, 1409024: 2147483648, 1474560: 2147487808, 1540096: 64, 1605632: 2147483712, 1671168: 4096, 1736704: 2147487744, 1802240: 2151678016, 1867776: 4160, 1933312: 2151682048, 1998848: 4194304, 2064384: 4198464 }, { 0: 128, 4096: 17039360, 8192: 262144, 12288: 536870912, 16384: 537133184, 20480: 16777344, 24576: 553648256, 28672: 262272, 32768: 16777216, 36864: 537133056, 40960: 536871040, 45056: 553910400, 49152: 553910272, 53248: 0, 57344: 17039488, 61440: 553648128, 2048: 17039488, 6144: 553648256, 10240: 128, 14336: 17039360, 18432: 262144, 22528: 537133184, 26624: 553910272, 30720: 536870912, 34816: 537133056, 38912: 0, 43008: 553910400, 47104: 16777344, 51200: 536871040, 55296: 553648128, 59392: 16777216, 63488: 262272, 65536: 262144, 69632: 128, 73728: 536870912, 77824: 553648256, 81920: 16777344, 86016: 553910272, 90112: 537133184, 94208: 16777216, 98304: 553910400, 102400: 553648128, 106496: 17039360, 110592: 537133056, 114688: 262272, 118784: 536871040, 122880: 0, 126976: 17039488, 67584: 553648256, 71680: 16777216, 75776: 17039360, 79872: 537133184, 83968: 536870912, 88064: 17039488, 92160: 128, 96256: 553910272, 100352: 262272, 104448: 553910400, 108544: 0, 112640: 553648128, 116736: 16777344, 120832: 262144, 124928: 537133056, 129024: 536871040 }, { 0: 268435464, 256: 8192, 512: 270532608, 768: 270540808, 1024: 268443648, 1280: 2097152, 1536: 2097160, 1792: 268435456, 2048: 0, 2304: 268443656, 2560: 2105344, 2816: 8, 3072: 270532616, 3328: 2105352, 3584: 8200, 3840: 270540800, 128: 270532608, 384: 270540808, 640: 8, 896: 2097152, 1152: 2105352, 1408: 268435464, 1664: 268443648, 1920: 8200, 2176: 2097160, 2432: 8192, 2688: 268443656, 2944: 270532616, 3200: 0, 3456: 270540800, 3712: 2105344, 3968: 268435456, 4096: 268443648, 4352: 270532616, 4608: 270540808, 4864: 8200, 5120: 2097152, 5376: 268435456, 5632: 268435464, 5888: 2105344, 6144: 2105352, 6400: 0, 6656: 8, 6912: 270532608, 7168: 8192, 7424: 268443656, 7680: 270540800, 7936: 2097160, 4224: 8, 4480: 2105344, 4736: 2097152, 4992: 268435464, 5248: 268443648, 5504: 8200, 5760: 270540808, 6016: 270532608, 6272: 270540800, 6528: 270532616, 6784: 8192, 7040: 2105352, 7296: 2097160, 7552: 0, 7808: 268435456, 8064: 268443656 }, { 0: 1048576, 16: 33555457, 32: 1024, 48: 1049601, 64: 34604033, 80: 0, 96: 1, 112: 34603009, 128: 33555456, 144: 1048577, 160: 33554433, 176: 34604032, 192: 34603008, 208: 1025, 224: 1049600, 240: 33554432, 8: 34603009, 24: 0, 40: 33555457, 56: 34604032, 72: 1048576, 88: 33554433, 104: 33554432, 120: 1025, 136: 1049601, 152: 33555456, 168: 34603008, 184: 1048577, 200: 1024, 216: 34604033, 232: 1, 248: 1049600, 256: 33554432, 272: 1048576, 288: 33555457, 304: 34603009, 320: 1048577, 336: 33555456, 352: 34604032, 368: 1049601, 384: 1025, 400: 34604033, 416: 1049600, 432: 1, 448: 0, 464: 34603008, 480: 33554433, 496: 1024, 264: 1049600, 280: 33555457, 296: 34603009, 312: 1, 328: 33554432, 344: 1048576, 360: 1025, 376: 34604032, 392: 33554433, 408: 34603008, 424: 0, 440: 34604033, 456: 1049601, 472: 1024, 488: 33555456, 504: 1048577 }, { 0: 134219808, 1: 131072, 2: 134217728, 3: 32, 4: 131104, 5: 134350880, 6: 134350848, 7: 2048, 8: 134348800, 9: 134219776, 10: 133120, 11: 134348832, 12: 2080, 13: 0, 14: 134217760, 15: 133152, 2147483648: 2048, 2147483649: 134350880, 2147483650: 134219808, 2147483651: 134217728, 2147483652: 134348800, 2147483653: 133120, 2147483654: 133152, 2147483655: 32, 2147483656: 134217760, 2147483657: 2080, 2147483658: 131104, 2147483659: 134350848, 2147483660: 0, 2147483661: 134348832, 2147483662: 134219776, 2147483663: 131072, 16: 133152, 17: 134350848, 18: 32, 19: 2048, 20: 134219776, 21: 134217760, 22: 134348832, 23: 131072, 24: 0, 25: 131104, 26: 134348800, 27: 134219808, 28: 134350880, 29: 133120, 30: 2080, 31: 134217728, 2147483664: 131072, 2147483665: 2048, 2147483666: 134348832, 2147483667: 133152, 2147483668: 32, 2147483669: 134348800, 2147483670: 134217728, 2147483671: 134219808, 2147483672: 134350880, 2147483673: 134217760, 2147483674: 134219776, 2147483675: 0, 2147483676: 133120, 2147483677: 2080, 2147483678: 131104, 2147483679: 134350848 }]; const l = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679]; const d = o.DES = i.extend({ _doReset: function () { for (var e = this._key.words, t = [], n = 0; n < 56; n++) { const r = a[n] - 1; t[n] = e[r >>> 5] >>> 31 - r % 32 & 1 } for (var i = this._subKeys = [], o = 0; o < 16; o++) { const u = i[o] = []; const l = c[o]; for (n = 0; n < 24; n++)u[n / 6 | 0] |= t[(s[n] - 1 + l) % 28] << 31 - n % 6, u[4 + (n / 6 | 0)] |= t[28 + (s[n + 24] - 1 + l) % 28] << 31 - n % 6; for (u[0] = u[0] << 1 | u[0] >>> 31, n = 1; n < 7; n++)u[n] = u[n] >>> 4 * (n - 1) + 3; u[7] = u[7] << 5 | u[7] >>> 27 } const d = this._invSubKeys = []; for (n = 0; n < 16; n++)d[n] = i[15 - n] }, encryptBlock: function (e, t) { this._doCryptBlock(e, t, this._subKeys) }, decryptBlock: function (e, t) { this._doCryptBlock(e, t, this._invSubKeys) }, _doCryptBlock: function (e, t, n) { this._lBlock = e[t], this._rBlock = e[t + 1], f.call(this, 4, 252645135), f.call(this, 16, 65535), h.call(this, 2, 858993459), h.call(this, 8, 16711935), f.call(this, 1, 1431655765); for (let r = 0; r < 16; r++) { for (var i = n[r], o = this._lBlock, a = this._rBlock, s = 0, c = 0; c < 8; c++)s |= u[c][((a ^ i[c]) & l[c]) >>> 0]; this._lBlock = a, this._rBlock = o ^ s } const d = this._lBlock; this._lBlock = this._rBlock, this._rBlock = d, f.call(this, 1, 1431655765), h.call(this, 8, 16711935), h.call(this, 2, 858993459), f.call(this, 16, 65535), f.call(this, 4, 252645135), e[t] = this._lBlock, e[t + 1] = this._rBlock }, keySize: 2, ivSize: 2, blockSize: 2 }); function f (e, t) { const n = (this._lBlock >>> e ^ this._rBlock) & t; this._rBlock ^= n, this._lBlock ^= n << e } function h (e, t) { const n = (this._rBlock >>> e ^ this._lBlock) & t; this._lBlock ^= n, this._rBlock ^= n << e }e.DES = i._createHelper(d); const p = o.TripleDES = i.extend({ _doReset: function () { const e = this._key.words; if (e.length !== 2 && e.length !== 4 && e.length < 6) throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.'); const t = e.slice(0, 2); const r = e.length < 4 ? e.slice(0, 2) : e.slice(2, 4); const i = e.length < 6 ? e.slice(0, 2) : e.slice(4, 6); this._des1 = d.createEncryptor(n.create(t)), this._des2 = d.createEncryptor(n.create(r)), this._des3 = d.createEncryptor(n.create(i)) }, encryptBlock: function (e, t) { this._des1.encryptBlock(e, t), this._des2.decryptBlock(e, t), this._des3.encryptBlock(e, t) }, decryptBlock: function (e, t) { this._des3.decryptBlock(e, t), this._des2.encryptBlock(e, t), this._des1.decryptBlock(e, t) }, keySize: 6, ivSize: 2, blockSize: 2 }); e.TripleDES = i._createHelper(p) }()), r.TripleDES) }, 4938: function (e, t, n) { let r, i, o, a, s, c; e.exports = (o = (i = r = n(8249)).lib, a = o.Base, s = o.WordArray, (c = i.x64 = {}).Word = a.extend({ init: function (e, t) { this.high = e, this.low = t } }), c.WordArray = a.extend({ init: function (e, t) { e = this.words = e || [], this.sigBytes = t != null ? t : 8 * e.length }, toX32: function () { for (var e = this.words, t = e.length, n = [], r = 0; r < t; r++) { const i = e[r]; n.push(i.high), n.push(i.low) } return s.create(n, this.sigBytes) }, clone: function () { for (var e = a.clone.call(this), t = e.words = this.words.slice(0), n = t.length, r = 0; r < n; r++)t[r] = t[r].clone(); return e } }), r) }, 9435: e => { const t = 1e3; const n = 60 * t; const r = 60 * n; const i = 24 * r; function o (e, t, n, r) { const i = t >= 1.5 * n; return Math.round(e / n) + ' ' + r + (i ? 's' : '') }e.exports = function (e, a) { a = a || {}; let s; let c; const u = typeof e; if (u === 'string' && e.length > 0) return (function (e) { if (!((e = String(e)).length > 100)) { const o = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e); if (o) { const a = parseFloat(o[1]); switch ((o[2] || 'ms').toLowerCase()) { case 'years':case 'year':case 'yrs':case 'yr':case 'y':return 315576e5 * a; case 'weeks':case 'week':case 'w':return 6048e5 * a; case 'days':case 'day':case 'd':return a * i; case 'hours':case 'hour':case 'hrs':case 'hr':case 'h':return a * r; case 'minutes':case 'minute':case 'mins':case 'min':case 'm':return a * n; case 'seconds':case 'second':case 'secs':case 'sec':case 's':return a * t; case 'milliseconds':case 'millisecond':case 'msecs':case 'msec':case 'ms':return a; default: } } } }(e)); if (u === 'number' && isFinite(e)) return a.long ? (s = e, (c = Math.abs(s)) >= i ? o(s, c, i, 'day') : c >= r ? o(s, c, r, 'hour') : c >= n ? o(s, c, n, 'minute') : c >= t ? o(s, c, t, 'second') : s + ' ms') : (function (e) { const o = Math.abs(e); return o >= i ? Math.round(e / i) + 'd' : o >= r ? Math.round(e / r) + 'h' : o >= n ? Math.round(e / n) + 'm' : o >= t ? Math.round(e / t) + 's' : e + 'ms' }(e)); throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(e)) } }, 1227: (e, t, n) => { const r = n(5108); const i = n(4155); t.formatArgs = function (t) { if (t[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + t[0] + (this.useColors ? '%c ' : ' ') + '+' + e.exports.humanize(this.diff), !this.useColors) return; const n = 'color: ' + this.color; t.splice(1, 0, n, 'color: inherit'); let r = 0; let i = 0; t[0].replace(/%[a-zA-Z%]/g, e => { e !== '%%' && (r++, e === '%c' && (i = r)) }), t.splice(i, 0, n) }, t.save = function (e) { try { e ? t.storage.setItem('debug', e) : t.storage.removeItem('debug') } catch (e) {} }, t.load = function () { let e; try { e = t.storage.getItem('debug') } catch (e) {} return !e && void 0 !== i && 'env' in i && (e = i.env.DEBUG), e }, t.useColors = function () { return !(typeof window === 'undefined' || !window.process || window.process.type !== 'renderer' && !window.process.__nwjs) || (typeof navigator === 'undefined' || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)) }, t.storage = (function () { try { return localStorage } catch (e) {} }()), t.destroy = (() => { let e = !1; return () => { e || (e = !0, r.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.')) } })(), t.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'], t.log = r.debug || r.log || (() => {}), e.exports = n(2447)(t); const { formatters: o } = e.exports; o.j = function (e) { try { return JSON.stringify(e) } catch (e) { return '[UnexpectedJSONParseError]: ' + e.message } } }, 2447: (e, t, n) => { const r = n(5108); e.exports = function (e) { function t (e) { let n; let r; let o; let a = null; function s (...e) { if (!s.enabled) return; const r = s; const i = Number(new Date()); const o = i - (n || i); r.diff = o, r.prev = n, r.curr = i, n = i, e[0] = t.coerce(e[0]), typeof e[0] !== 'string' && e.unshift('%O'); let a = 0; e[0] = e[0].replace(/%([a-zA-Z%])/g, (n, i) => { if (n === '%%') return '%'; a++; const o = t.formatters[i]; if (typeof o === 'function') { const t = e[a]; n = o.call(r, t), e.splice(a, 1), a-- } return n }), t.formatArgs.call(r, e), (r.log || t.log).apply(r, e) } return s.namespace = e, s.useColors = t.useColors(), s.color = t.selectColor(e), s.extend = i, s.destroy = t.destroy, Object.defineProperty(s, 'enabled', { enumerable: !0, configurable: !1, get: () => a !== null ? a : (r !== t.namespaces && (r = t.namespaces, o = t.enabled(e)), o), set: e => { a = e } }), typeof t.init === 'function' && t.init(s), s } function i (e, n) { const r = t(this.namespace + (void 0 === n ? ':' : n) + e); return r.log = this.log, r } function o (e) { return e.toString().substring(2, e.toString().length - 2).replace(/\.\*\?$/, '*') } return t.debug = t, t.default = t, t.coerce = function (e) { return e instanceof Error ? e.stack || e.message : e }, t.disable = function () { const e = [...t.names.map(o), ...t.skips.map(o).map(e => '-' + e)].join(','); return t.enable(''), e }, t.enable = function (e) { let n; t.save(e), t.namespaces = e, t.names = [], t.skips = []; const r = (typeof e === 'string' ? e : '').split(/[\s,]+/); const i = r.length; for (n = 0; n < i; n++)r[n] && ((e = r[n].replace(/\*/g, '.*?'))[0] === '-' ? t.skips.push(new RegExp('^' + e.substr(1) + '$')) : t.names.push(new RegExp('^' + e + '$'))) }, t.enabled = function (e) { if (e[e.length - 1] === '*') return !0; let n, r; for (n = 0, r = t.skips.length; n < r; n++) if (t.skips[n].test(e)) return !1; for (n = 0, r = t.names.length; n < r; n++) if (t.names[n].test(e)) return !0; return !1 }, t.humanize = n(9435), t.destroy = function () { r.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.') }, Object.keys(e).forEach(n => { t[n] = e[n] }), t.names = [], t.skips = [], t.formatters = {}, t.selectColor = function (e) { let n = 0; for (let t = 0; t < e.length; t++)n = (n << 5) - n + e.charCodeAt(t), n |= 0; return t.colors[Math.abs(n) % t.colors.length] }, t.enable(t.load()), t } }, 4289: (e, t, n) => { 'use strict'; const r = n(2215); const i = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol'; const o = Object.prototype.toString; const a = Array.prototype.concat; const s = Object.defineProperty; const c = n(1044)(); const u = s && c; const l = function (e, t, n, r) { let i; (!(t in e) || typeof (i = r) === 'function' && o.call(i) === '[object Function]' && r()) && (u ? s(e, t, { configurable: !0, enumerable: !1, value: n, writable: !0 }) : e[t] = n) }; const d = function (e, t) { const n = arguments.length > 2 ? arguments[2] : {}; let o = r(t); i && (o = a.call(o, Object.getOwnPropertySymbols(t))); for (let s = 0; s < o.length; s += 1)l(e, o[s], t[o[s]], n[o[s]]) }; d.supportsDescriptors = !!u, e.exports = d }, 8091: e => { 'use strict'; function t (e, t) { if (e == null) throw new TypeError('Cannot convert first argument to object'); for (var n = Object(e), r = 1; r < arguments.length; r++) { const i = arguments[r]; if (i != null) for (let o = Object.keys(Object(i)), a = 0, s = o.length; a < s; a++) { const c = o[a]; const u = Object.getOwnPropertyDescriptor(i, c); void 0 !== u && u.enumerable && (n[c] = i[c]) } } return n }e.exports = { assign: t, polyfill: function () { Object.assign || Object.defineProperty(Object, 'assign', { enumerable: !1, configurable: !0, writable: !0, value: t }) } } }, 4029: (e, t, n) => { 'use strict'; const r = n(5320); const i = Object.prototype.toString; const o = Object.prototype.hasOwnProperty; const a = function (e, t, n) { for (let r = 0, i = e.length; r < i; r++)o.call(e, r) && (n == null ? t(e[r], r, e) : t.call(n, e[r], r, e)) }; const s = function (e, t, n) { for (let r = 0, i = e.length; r < i; r++)n == null ? t(e.charAt(r), r, e) : t.call(n, e.charAt(r), r, e) }; const c = function (e, t, n) { for (const r in e)o.call(e, r) && (n == null ? t(e[r], r, e) : t.call(n, e[r], r, e)) }; e.exports = function (e, t, n) { if (!r(t)) throw new TypeError('iterator must be a function'); let o; arguments.length >= 3 && (o = n), i.call(e) === '[object Array]' ? a(e, t, o) : typeof e === 'string' ? s(e, t, o) : c(e, t, o) } }, 7648: e => { 'use strict'; const t = 'Function.prototype.bind called on incompatible '; const n = Array.prototype.slice; const r = Object.prototype.toString; const i = '[object Function]'; e.exports = function (e) { const o = this; if (typeof o !== 'function' || r.call(o) !== i) throw new TypeError(t + o); for (var a, s = n.call(arguments, 1), c = function () { if (this instanceof a) { const t = o.apply(this, s.concat(n.call(arguments))); return Object(t) === t ? t : this } return o.apply(e, s.concat(n.call(arguments))) }, u = Math.max(0, o.length - s.length), l = [], d = 0; d < u; d++)l.push('$' + d); if (a = Function('binder', 'return function (' + l.join(',') + '){ return binder.apply(this,arguments); }')(c), o.prototype) { const f = function () {}; f.prototype = o.prototype, a.prototype = new f(), f.prototype = null } return a } }, 8612: (e, t, n) => { 'use strict'; const r = n(7648); e.exports = Function.prototype.bind || r }, 210: (e, t, n) => { 'use strict'; let r; const i = SyntaxError; const o = Function; const a = TypeError; const s = function (e) { try { return o('"use strict"; return (' + e + ').constructor;')() } catch (e) {} }; let c = Object.getOwnPropertyDescriptor; if (c) try { c({}, '') } catch (e) { c = null } const u = function () { throw new a() }; const l = c ? (function () { try { return u } catch (e) { try { return c(arguments, 'callee').get } catch (e) { return u } } }()) : u; const d = n(1405)(); const f = Object.getPrototypeOf || function (e) { return e.__proto__ }; const h = {}; const p = typeof Uint8Array === 'undefined' ? r : f(Uint8Array); const g = { '%AggregateError%': typeof AggregateError === 'undefined' ? r : AggregateError, '%Array%': Array, '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? r : ArrayBuffer, '%ArrayIteratorPrototype%': d ? f([][Symbol.iterator]()) : r, '%AsyncFromSyncIteratorPrototype%': r, '%AsyncFunction%': h, '%AsyncGenerator%': h, '%AsyncGeneratorFunction%': h, '%AsyncIteratorPrototype%': h, '%Atomics%': typeof Atomics === 'undefined' ? r : Atomics, '%BigInt%': typeof BigInt === 'undefined' ? r : BigInt, '%Boolean%': Boolean, '%DataView%': typeof DataView === 'undefined' ? r : DataView, '%Date%': Date, '%decodeURI%': decodeURI, '%decodeURIComponent%': decodeURIComponent, '%encodeURI%': encodeURI, '%encodeURIComponent%': encodeURIComponent, '%Error%': Error, '%eval%': eval, '%EvalError%': EvalError, '%Float32Array%': typeof Float32Array === 'undefined' ? r : Float32Array, '%Float64Array%': typeof Float64Array === 'undefined' ? r : Float64Array, '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? r : FinalizationRegistry, '%Function%': o, '%GeneratorFunction%': h, '%Int8Array%': typeof Int8Array === 'undefined' ? r : Int8Array, '%Int16Array%': typeof Int16Array === 'undefined' ? r : Int16Array, '%Int32Array%': typeof Int32Array === 'undefined' ? r : Int32Array, '%isFinite%': isFinite, '%isNaN%': isNaN, '%IteratorPrototype%': d ? f(f([][Symbol.iterator]())) : r, '%JSON%': typeof JSON === 'object' ? JSON : r, '%Map%': typeof Map === 'undefined' ? r : Map, '%MapIteratorPrototype%': typeof Map !== 'undefined' && d ? f((new Map())[Symbol.iterator]()) : r, '%Math%': Math, '%Number%': Number, '%Object%': Object, '%parseFloat%': parseFloat, '%parseInt%': parseInt, '%Promise%': typeof Promise === 'undefined' ? r : Promise, '%Proxy%': typeof Proxy === 'undefined' ? r : Proxy, '%RangeError%': RangeError, '%ReferenceError%': ReferenceError, '%Reflect%': typeof Reflect === 'undefined' ? r : Reflect, '%RegExp%': RegExp, '%Set%': typeof Set === 'undefined' ? r : Set, '%SetIteratorPrototype%': typeof Set !== 'undefined' && d ? f((new Set())[Symbol.iterator]()) : r, '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? r : SharedArrayBuffer, '%String%': String, '%StringIteratorPrototype%': d ? f(''[Symbol.iterator]()) : r, '%Symbol%': d ? Symbol : r, '%SyntaxError%': i, '%ThrowTypeError%': l, '%TypedArray%': p, '%TypeError%': a, '%Uint8Array%': typeof Uint8Array === 'undefined' ? r : Uint8Array, '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? r : Uint8ClampedArray, '%Uint16Array%': typeof Uint16Array === 'undefined' ? r : Uint16Array, '%Uint32Array%': typeof Uint32Array === 'undefined' ? r : Uint32Array, '%URIError%': URIError, '%WeakMap%': typeof WeakMap === 'undefined' ? r : WeakMap, '%WeakRef%': typeof WeakRef === 'undefined' ? r : WeakRef, '%WeakSet%': typeof WeakSet === 'undefined' ? r : WeakSet }; const m = function e (t) { let n; if (t === '%AsyncFunction%')n = s('async function () {}'); else if (t === '%GeneratorFunction%')n = s('function* () {}'); else if (t === '%AsyncGeneratorFunction%')n = s('async function* () {}'); else if (t === '%AsyncGenerator%') { const r = e('%AsyncGeneratorFunction%'); r && (n = r.prototype) } else if (t === '%AsyncIteratorPrototype%') { const i = e('%AsyncGenerator%'); i && (n = f(i.prototype)) } return g[t] = n, n }; const y = { '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'], '%ArrayPrototype%': ['Array', 'prototype'], '%ArrayProto_entries%': ['Array', 'prototype', 'entries'], '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'], '%ArrayProto_keys%': ['Array', 'prototype', 'keys'], '%ArrayProto_values%': ['Array', 'prototype', 'values'], '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'], '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'], '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'], '%BooleanPrototype%': ['Boolean', 'prototype'], '%DataViewPrototype%': ['DataView', 'prototype'], '%DatePrototype%': ['Date', 'prototype'], '%ErrorPrototype%': ['Error', 'prototype'], '%EvalErrorPrototype%': ['EvalError', 'prototype'], '%Float32ArrayPrototype%': ['Float32Array', 'prototype'], '%Float64ArrayPrototype%': ['Float64Array', 'prototype'], '%FunctionPrototype%': ['Function', 'prototype'], '%Generator%': ['GeneratorFunction', 'prototype'], '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'], '%Int8ArrayPrototype%': ['Int8Array', 'prototype'], '%Int16ArrayPrototype%': ['Int16Array', 'prototype'], '%Int32ArrayPrototype%': ['Int32Array', 'prototype'], '%JSONParse%': ['JSON', 'parse'], '%JSONStringify%': ['JSON', 'stringify'], '%MapPrototype%': ['Map', 'prototype'], '%NumberPrototype%': ['Number', 'prototype'], '%ObjectPrototype%': ['Object', 'prototype'], '%ObjProto_toString%': ['Object', 'prototype', 'toString'], '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'], '%PromisePrototype%': ['Promise', 'prototype'], '%PromiseProto_then%': ['Promise', 'prototype', 'then'], '%Promise_all%': ['Promise', 'all'], '%Promise_reject%': ['Promise', 'reject'], '%Promise_resolve%': ['Promise', 'resolve'], '%RangeErrorPrototype%': ['RangeError', 'prototype'], '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'], '%RegExpPrototype%': ['RegExp', 'prototype'], '%SetPrototype%': ['Set', 'prototype'], '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'], '%StringPrototype%': ['String', 'prototype'], '%SymbolPrototype%': ['Symbol', 'prototype'], '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'], '%TypedArrayPrototype%': ['TypedArray', 'prototype'], '%TypeErrorPrototype%': ['TypeError', 'prototype'], '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'], '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'], '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'], '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'], '%URIErrorPrototype%': ['URIError', 'prototype'], '%WeakMapPrototype%': ['WeakMap', 'prototype'], '%WeakSetPrototype%': ['WeakSet', 'prototype'] }; const b = n(8612); const v = n(7642); const w = b.call(Function.call, Array.prototype.concat); const _ = b.call(Function.apply, Array.prototype.splice); const E = b.call(Function.call, String.prototype.replace); const k = b.call(Function.call, String.prototype.slice); const S = b.call(Function.call, RegExp.prototype.exec); const A = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g; const O = /\\(\\)?/g; const x = function (e) { const t = k(e, 0, 1); const n = k(e, -1); if (t === '%' && n !== '%') throw new i('invalid intrinsic syntax, expected closing `%`'); if (n === '%' && t !== '%') throw new i('invalid intrinsic syntax, expected opening `%`'); const r = []; return E(e, A, function (e, t, n, i) { r[r.length] = n ? E(i, O, '$1') : t || e }), r }; const I = function (e, t) { let n; let r = e; if (v(y, r) && (r = '%' + (n = y[r])[0] + '%'), v(g, r)) { let o = g[r]; if (o === h && (o = m(r)), void 0 === o && !t) throw new a('intrinsic ' + e + ' exists, but is not available. Please file an issue!'); return { alias: n, name: r, value: o } } throw new i('intrinsic ' + e + ' does not exist!') }; e.exports = function (e, t) { if (typeof e !== 'string' || e.length === 0) throw new a('intrinsic name must be a non-empty string'); if (arguments.length > 1 && typeof t !== 'boolean') throw new a('"allowMissing" argument must be a boolean'); if (S(/^%?[^%]*%?$/, e) === null) throw new i('`%` may not be present anywhere but at the beginning and end of the intrinsic name'); const n = x(e); let r = n.length > 0 ? n[0] : ''; const o = I('%' + r + '%', t); let s = o.name; let u = o.value; let l = !1; const d = o.alias; d && (r = d[0], _(n, w([0, 1], d))); for (let f = 1, h = !0; f < n.length; f += 1) { const p = n[f]; const m = k(p, 0, 1); const y = k(p, -1); if ((m === '"' || m === "'" || m === '`' || y === '"' || y === "'" || y === '`') && m !== y) throw new i('property names with quotes must have matching quotes'); if (p !== 'constructor' && h || (l = !0), v(g, s = '%' + (r += '.' + p) + '%'))u = g[s]; else if (u != null) { if (!(p in u)) { if (!t) throw new a('base intrinsic for ' + e + ' exists, but the property is not available.'); return } if (c && f + 1 >= n.length) { const b = c(u, p); u = (h = !!b) && 'get' in b && !('originalValue' in b.get) ? b.get : u[p] } else h = v(u, p), u = u[p]; h && !l && (g[s] = u) } } return u } }, 7296: (e, t, n) => { 'use strict'; let r = n(210)('%Object.getOwnPropertyDescriptor%', !0); if (r) try { r([], 'length') } catch (e) { r = null }e.exports = r }, 1044: (e, t, n) => { 'use strict'; const r = n(210)('%Object.defineProperty%', !0); const i = function () { if (r) try { return r({}, 'a', { value: 1 }), !0 } catch (e) { return !1 } return !1 }; i.hasArrayLengthDefineBug = function () { if (!i()) return null; try { return r([], 'length', { value: 1 }).length !== 1 } catch (e) { return !0 } }, e.exports = i }, 1405: (e, t, n) => { 'use strict'; const r = typeof Symbol !== 'undefined' && Symbol; const i = n(5419); e.exports = function () { return typeof r === 'function' && typeof Symbol === 'function' && typeof r('foo') === 'symbol' && typeof Symbol('bar') === 'symbol' && i() } }, 5419: e => { 'use strict'; e.exports = function () { if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') return !1; if (typeof Symbol.iterator === 'symbol') return !0; const e = {}; let t = Symbol('test'); const n = Object(t); if (typeof t === 'string') return !1; if (Object.prototype.toString.call(t) !== '[object Symbol]') return !1; if (Object.prototype.toString.call(n) !== '[object Symbol]') return !1; for (t in e[t] = 42, e) return !1; if (typeof Object.keys === 'function' && Object.keys(e).length !== 0) return !1; if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(e).length !== 0) return !1; const r = Object.getOwnPropertySymbols(e); if (r.length !== 1 || r[0] !== t) return !1; if (!Object.prototype.propertyIsEnumerable.call(e, t)) return !1; if (typeof Object.getOwnPropertyDescriptor === 'function') { const i = Object.getOwnPropertyDescriptor(e, t); if (i.value !== 42 || !0 !== i.enumerable) return !1 } return !0 } }, 6410: (e, t, n) => { 'use strict'; const r = n(5419); e.exports = function () { return r() && !!Symbol.toStringTag } }, 7642: (e, t, n) => { 'use strict'; const r = n(8612); e.exports = r.call(Function.call, Object.prototype.hasOwnProperty) }, 5717: e => { typeof Object.create === 'function' ? e.exports = function (e, t) { t && (e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })) } : e.exports = function (e, t) { if (t) { e.super_ = t; const n = function () {}; n.prototype = t.prototype, e.prototype = new n(), e.prototype.constructor = e } } }, 2584: (e, t, n) => { 'use strict'; const r = n(6410)(); const i = n(1924)('Object.prototype.toString'); const o = function (e) { return !(r && e && typeof e === 'object' && Symbol.toStringTag in e) && i(e) === '[object Arguments]' }; const a = function (e) { return !!o(e) || e !== null && typeof e === 'object' && typeof e.length === 'number' && e.length >= 0 && i(e) !== '[object Array]' && i(e.callee) === '[object Function]' }; const s = (function () { return o(arguments) }()); o.isLegacyArguments = a, e.exports = s ? o : a }, 5320: e => { 'use strict'; let t; let n; const r = Function.prototype.toString; let i = typeof Reflect === 'object' && Reflect !== null && Reflect.apply; if (typeof i === 'function' && typeof Object.defineProperty === 'function') try { t = Object.defineProperty({}, 'length', { get: function () { throw n } }), n = {}, i(function () { throw 42 }, null, t) } catch (e) { e !== n && (i = null) } else i = null; const o = /^\s*class\b/; const a = function (e) { try { const t = r.call(e); return o.test(t) } catch (e) { return !1 } }; const s = function (e) { try { return !a(e) && (r.call(e), !0) } catch (e) { return !1 } }; const c = Object.prototype.toString; const u = typeof Symbol === 'function' && !!Symbol.toStringTag; const l = !(0 in [,]); let d = function () { return !1 }; if (typeof document === 'object') { const f = document.all; c.call(f) === c.call(document.all) && (d = function (e) { if ((l || !e) && (void 0 === e || typeof e === 'object')) try { const t = c.call(e); return (t === '[object HTMLAllCollection]' || t === '[object HTML document.all class]' || t === '[object HTMLCollection]' || t === '[object Object]') && e('') == null } catch (e) {} return !1 }) }e.exports = i ? function (e) { if (d(e)) return !0; if (!e) return !1; if (typeof e !== 'function' && typeof e !== 'object') return !1; try { i(e, null, t) } catch (e) { if (e !== n) return !1 } return !a(e) && s(e) } : function (e) { if (d(e)) return !0; if (!e) return !1; if (typeof e !== 'function' && typeof e !== 'object') return !1; if (u) return s(e); if (a(e)) return !1; const t = c.call(e); return !(t !== '[object Function]' && t !== '[object GeneratorFunction]' && !/^\[object HTML/.test(t)) && s(e) } }, 8662: (e, t, n) => { 'use strict'; let r; const i = Object.prototype.toString; const o = Function.prototype.toString; const a = /^\s*(?:function)?\*/; const s = n(6410)(); const c = Object.getPrototypeOf; e.exports = function (e) { if (typeof e !== 'function') return !1; if (a.test(o.call(e))) return !0; if (!s) return i.call(e) === '[object GeneratorFunction]'; if (!c) return !1; if (void 0 === r) { const t = (function () { if (!s) return !1; try { return Function('return function*() {}')() } catch (e) {} }()); r = !!t && c(t) } return c(e) === r } }, 8611: e => { 'use strict'; e.exports = function (e) { return e != e } }, 360: (e, t, n) => { 'use strict'; const r = n(5559); const i = n(4289); const o = n(8611); const a = n(9415); const s = n(3194); const c = r(a(), Number); i(c, { getPolyfill: a, implementation: o, shim: s }), e.exports = c }, 9415: (e, t, n) => { 'use strict'; const r = n(8611); e.exports = function () { return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a') ? Number.isNaN : r } }, 3194: (e, t, n) => { 'use strict'; const r = n(4289); const i = n(9415); e.exports = function () { const e = i(); return r(Number, { isNaN: e }, { isNaN: function () { return Number.isNaN !== e } }), e } }, 5692: (e, t, n) => { 'use strict'; const r = n(4029); const i = n(3083); const o = n(1924); const a = o('Object.prototype.toString'); const s = n(6410)(); const c = n(7296); const u = typeof globalThis === 'undefined' ? n.g : globalThis; const l = i(); const d = o('Array.prototype.indexOf', !0) || function (e, t) { for (let n = 0; n < e.length; n += 1) if (e[n] === t) return n; return -1 }; const f = o('String.prototype.slice'); const h = {}; const p = Object.getPrototypeOf; s && c && p && r(l, function (e) { const t = new u[e](); if (Symbol.toStringTag in t) { const n = p(t); let r = c(n, Symbol.toStringTag); if (!r) { const i = p(n); r = c(i, Symbol.toStringTag) }h[e] = r.get } }), e.exports = function (e) { if (!e || typeof e !== 'object') return !1; if (!s || !(Symbol.toStringTag in e)) { const t = f(a(e), 8, -1); return d(l, t) > -1 } return !!c && (function (e) { let t = !1; return r(h, function (n, r) { if (!t) try { t = n.call(e) === r } catch (e) {} }), t }(e)) } }, 4244: e => { 'use strict'; const t = function (e) { return e != e }; e.exports = function (e, n) { return e === 0 && n === 0 ? 1 / e == 1 / n : e === n || !(!t(e) || !t(n)) } }, 609: (e, t, n) => { 'use strict'; const r = n(4289); const i = n(5559); const o = n(4244); const a = n(5624); const s = n(2281); const c = i(a(), Object); r(c, { getPolyfill: a, implementation: o, shim: s }), e.exports = c }, 5624: (e, t, n) => { 'use strict'; const r = n(4244); e.exports = function () { return typeof Object.is === 'function' ? Object.is : r } }, 2281: (e, t, n) => { 'use strict'; const r = n(5624); const i = n(4289); e.exports = function () { const e = r(); return i(Object, { is: e }, { is: function () { return Object.is !== e } }), e } }, 8987: (e, t, n) => { 'use strict'; let r; if (!Object.keys) { const i = Object.prototype.hasOwnProperty; const o = Object.prototype.toString; const a = n(1414); const s = Object.prototype.propertyIsEnumerable; const c = !s.call({ toString: null }, 'toString'); const u = s.call(function () {}, 'prototype'); const l = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor']; const d = function (e) { const t = e.constructor; return t && t.prototype === e }; const f = { $applicationCache: !0, $console: !0, $external: !0, $frame: !0, $frameElement: !0, $frames: !0, $innerHeight: !0, $innerWidth: !0, $onmozfullscreenchange: !0, $onmozfullscreenerror: !0, $outerHeight: !0, $outerWidth: !0, $pageXOffset: !0, $pageYOffset: !0, $parent: !0, $scrollLeft: !0, $scrollTop: !0, $scrollX: !0, $scrollY: !0, $self: !0, $webkitIndexedDB: !0, $webkitStorageInfo: !0, $window: !0 }; const h = (function () { if (typeof window === 'undefined') return !1; for (const e in window) try { if (!f['$' + e] && i.call(window, e) && window[e] !== null && typeof window[e] === 'object') try { d(window[e]) } catch (e) { return !0 } } catch (e) { return !0 } return !1 }()); r = function (e) { const t = e !== null && typeof e === 'object'; const n = o.call(e) === '[object Function]'; const r = a(e); const s = t && o.call(e) === '[object String]'; const f = []; if (!t && !n && !r) throw new TypeError('Object.keys called on a non-object'); const p = u && n; if (s && e.length > 0 && !i.call(e, 0)) for (let g = 0; g < e.length; ++g)f.push(String(g)); if (r && e.length > 0) for (let m = 0; m < e.length; ++m)f.push(String(m)); else for (const y in e)p && y === 'prototype' || !i.call(e, y) || f.push(String(y)); if (c) for (let b = (function (e) { if (typeof window === 'undefined' || !h) return d(e); try { return d(e) } catch (e) { return !1 } }(e)), v = 0; v < l.length; ++v)b && l[v] === 'constructor' || !i.call(e, l[v]) || f.push(l[v]); return f } }e.exports = r }, 2215: (e, t, n) => { 'use strict'; const r = Array.prototype.slice; const i = n(1414); const o = Object.keys; const a = o ? function (e) { return o(e) } : n(8987); const s = Object.keys; a.shim = function () { if (Object.keys) { const e = (function () { const e = Object.keys(arguments); return e && e.length === arguments.length }(1, 2)); e || (Object.keys = function (e) { return i(e) ? s(r.call(e)) : s(e) }) } else Object.keys = a; return Object.keys || a }, e.exports = a }, 1414: e => { 'use strict'; const t = Object.prototype.toString; e.exports = function (e) { const n = t.call(e); let r = n === '[object Arguments]'; return r || (r = n !== '[object Array]' && e !== null && typeof e === 'object' && typeof e.length === 'number' && e.length >= 0 && t.call(e.callee) === '[object Function]'), r } }, 4155: e => { let t; let n; const r = e.exports = {}; function i () { throw new Error('setTimeout has not been defined') } function o () { throw new Error('clearTimeout has not been defined') } function a (e) { if (t === setTimeout) return setTimeout(e, 0); if ((t === i || !t) && setTimeout) return t = setTimeout, setTimeout(e, 0); try { return t(e, 0) } catch (n) { try { return t.call(null, e, 0) } catch (n) { return t.call(this, e, 0) } } }!(function () { try { t = typeof setTimeout === 'function' ? setTimeout : i } catch (e) { t = i } try { n = typeof clearTimeout === 'function' ? clearTimeout : o } catch (e) { n = o } }()); let s; let c = []; let u = !1; let l = -1; function d () { u && s && (u = !1, s.length ? c = s.concat(c) : l = -1, c.length && f()) } function f () { if (!u) { const e = a(d); u = !0; for (let t = c.length; t;) { for (s = c, c = []; ++l < t;)s && s[l].run(); l = -1, t = c.length }s = null, u = !1, (function (e) { if (n === clearTimeout) return clearTimeout(e); if ((n === o || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e); try { n(e) } catch (t) { try { return n.call(null, e) } catch (t) { return n.call(this, e) } } }(e)) } } function h (e, t) { this.fun = e, this.array = t } function p () {}r.nextTick = function (e) { const t = new Array(arguments.length - 1); if (arguments.length > 1) for (let n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; c.push(new h(e, t)), c.length !== 1 || u || a(f) }, h.prototype.run = function () { this.fun.apply(null, this.array) }, r.title = 'browser', r.browser = !0, r.env = {}, r.argv = [], r.version = '', r.versions = {}, r.on = p, r.addListener = p, r.once = p, r.off = p, r.removeListener = p, r.removeAllListeners = p, r.emit = p, r.prependListener = p, r.prependOnceListener = p, r.listeners = function (e) { return [] }, r.binding = function (e) { throw new Error('process.binding is not supported') }, r.cwd = function () { return '/' }, r.chdir = function (e) { throw new Error('process.chdir is not supported') }, r.umask = function () { return 0 } }, 380: function (e, t, n) { 'use strict'; const r = this && this.__awaiter || function (e, t, n, r) { return new (n || (n = Promise))(function (i, o) { function a (e) { try { c(r.next(e)) } catch (e) { o(e) } } function s (e) { try { c(r.throw(e)) } catch (e) { o(e) } } function c (e) { let t; e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) { e(t) })).then(a, s) }c((r = r.apply(e, t || [])).next()) }) }; const i = this && this.__generator || function (e, t) { let n; let r; let i; let o; let a = { label: 0, sent: function () { if (1 & i[0]) throw i[1]; return i[1] }, trys: [], ops: [] }; return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol === 'function' && (o[Symbol.iterator] = function () { return this }), o; function s (o) { return function (s) { return (function (o) { if (n) throw new TypeError('Generator is already executing.'); for (;a;) try { if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i; switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) { case 0:case 1:i = o; break; case 4:return a.label++, { value: o[1], done: !1 }; case 5:a.label++, r = o[1], o = [0]; continue; case 7:o = a.ops.pop(), a.trys.pop(); continue; default:if (!((i = (i = a.trys).length > 0 && i[i.length - 1]) || o[0] !== 6 && o[0] !== 2)) { a = 0; continue } if (o[0] === 3 && (!i || o[1] > i[0] && o[1] < i[3])) { a.label = o[1]; break } if (o[0] === 6 && a.label < i[1]) { a.label = i[1], i = o; break } if (i && a.label < i[2]) { a.label = i[2], a.ops.push(o); break }i[2] && a.ops.pop(), a.trys.pop(); continue }o = t.call(e, a) } catch (e) { o = [6, e], r = 0 } finally { n = i = 0 } if (5 & o[0]) throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 } }([o, s])) } } }; Object.defineProperty(t, '__esModule', { value: !0 }), t.createRpc = void 0; const o = n(7923); function a (e, t) { return new Proxy({}, { get: function (n, a, s) { let c; const u = this; const l = (c = a.toString()) && c[0].toUpperCase() + c.slice(1); const d = ''.concat(e, '.').concat(l); return o.subscriptionMethods.includes(d) ? function (e, n, r) { t.subscribe(d, e, n, r) } : function (e) { return r(u, void 0, void 0, function () { return i(this, function (n) { switch (n.label) { case 0:return [4, t.request(d, e)]; case 1:return [2, n.sent()] } }) }) } } }) }t.createRpc = a, t.default = a }, 8713: function (e, t, n) { 'use strict'; const r = this && this.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n] } }) } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n] }); const i = this && this.__exportStar || function (e, t) { for (const n in e)n === 'default' || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n) }; const o = this && this.__awaiter || function (e, t, n, r) { return new (n || (n = Promise))(function (i, o) { function a (e) { try { c(r.next(e)) } catch (e) { o(e) } } function s (e) { try { c(r.throw(e)) } catch (e) { o(e) } } function c (e) { let t; e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) { e(t) })).then(a, s) }c((r = r.apply(e, t || [])).next()) }) }; const a = this && this.__generator || function (e, t) { let n; let r; let i; let o; let a = { label: 0, sent: function () { if (1 & i[0]) throw i[1]; return i[1] }, trys: [], ops: [] }; return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol === 'function' && (o[Symbol.iterator] = function () { return this }), o; function s (o) { return function (s) { return (function (o) { if (n) throw new TypeError('Generator is already executing.'); for (;a;) try { if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i; switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) { case 0:case 1:i = o; break; case 4:return a.label++, { value: o[1], done: !1 }; case 5:a.label++, r = o[1], o = [0]; continue; case 7:o = a.ops.pop(), a.trys.pop(); continue; default:if (!((i = (i = a.trys).length > 0 && i[i.length - 1]) || o[0] !== 6 && o[0] !== 2)) { a = 0; continue } if (o[0] === 3 && (!i || o[1] > i[0] && o[1] < i[3])) { a.label = o[1]; break } if (o[0] === 6 && a.label < i[1]) { a.label = i[1], i = o; break } if (i && a.label < i[2]) { a.label = i[2], a.ops.push(o); break }i[2] && a.ops.pop(), a.trys.pop(); continue }o = t.call(e, a) } catch (e) { o = [6, e], r = 0 } finally { n = i = 0 } if (5 & o[0]) throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 } }([o, s])) } } }; const s = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, '__esModule', { value: !0 }), n(8831); const c = s(n(2262)); WebAssembly.instantiateStreaming || (WebAssembly.instantiateStreaming = function (e, t) { return o(void 0, void 0, void 0, function () { let n; return a(this, function (r) { switch (r.label) { case 0:return [4, e]; case 1:return [4, r.sent().arrayBuffer()]; case 2:return n = r.sent(), [4, WebAssembly.instantiate(n, t)]; case 3:return [2, r.sent()] } }) }) }), i(n(7923), t), t.default = c.default }, 2262: function (e, t, n) { 'use strict'; const r = this && this.__awaiter || function (e, t, n, r) { return new (n || (n = Promise))(function (i, o) { function a (e) { try { c(r.next(e)) } catch (e) { o(e) } } function s (e) { try { c(r.throw(e)) } catch (e) { o(e) } } function c (e) { let t; e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) { e(t) })).then(a, s) }c((r = r.apply(e, t || [])).next()) }) }; const i = this && this.__generator || function (e, t) { let n; let r; let i; let o; let a = { label: 0, sent: function () { if (1 & i[0]) throw i[1]; return i[1] }, trys: [], ops: [] }; return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol === 'function' && (o[Symbol.iterator] = function () { return this }), o; function s (o) { return function (s) { return (function (o) { if (n) throw new TypeError('Generator is already executing.'); for (;a;) try { if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i; switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) { case 0:case 1:i = o; break; case 4:return a.label++, { value: o[1], done: !1 }; case 5:a.label++, r = o[1], o = [0]; continue; case 7:o = a.ops.pop(), a.trys.pop(); continue; default:if (!((i = (i = a.trys).length > 0 && i[i.length - 1]) || o[0] !== 6 && o[0] !== 2)) { a = 0; continue } if (o[0] === 3 && (!i || o[1] > i[0] && o[1] < i[3])) { a.label = o[1]; break } if (o[0] === 6 && a.label < i[1]) { a.label = i[1], i = o; break } if (i && a.label < i[2]) { a.label = i[2], a.ops.push(o); break }i[2] && a.ops.pop(), a.trys.pop(); continue }o = t.call(e, a) } catch (e) { o = [6, e], r = 0 } finally { n = i = 0 } if (5 & o[0]) throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 } }([o, s])) } } }; const o = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, '__esModule', { value: !0 }); const a = n(7923); const s = n(380); const c = o(n(1712)); const u = n(1095); const l = { wasmClientCode: 'https://lightning.engineering/lnc-v0.2.4-alpha.wasm', namespace: 'default', serverHost: 'mailbox.terminal.lightning.today:443' }; const d = (function () { function e (e) { const t = Object.assign({}, l, e); this._wasmClientCode = t.wasmClientCode, this._namespace = t.namespace, t.credentialStore ? this.credentials = t.credentialStore : (this.credentials = new c.default(t.namespace, t.password), this.credentials.isPaired || (this.credentials.serverHost = t.serverHost), t.pairingPhrase && (this.credentials.pairingPhrase = t.pairingPhrase)); const r = n.g || window || self; this.go = new r.Go(), this.lnd = new a.LndApi(s.createRpc, this), this.loop = new a.LoopApi(s.createRpc, this), this.pool = new a.PoolApi(s.createRpc, this), this.faraday = new a.FaradayApi(s.createRpc, this), this.lit = new a.LitApi(s.createRpc, this) } return Object.defineProperty(e.prototype, 'wasm', { get: function () { return globalThis[this._namespace] }, set: function (e) { globalThis[this._namespace] = e }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'isReady', { get: function () { return this.wasm && this.wasm.wasmClientIsReady && this.wasm.wasmClientIsReady() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'isConnected', { get: function () { return this.wasm && this.wasm.wasmClientIsConnected && this.wasm.wasmClientIsConnected() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'status', { get: function () { return this.wasm && this.wasm.wasmClientStatus && this.wasm.wasmClientStatus() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'expiry', { get: function () { return this.wasm && this.wasm.wasmClientGetExpiry && new Date(1e3 * this.wasm.wasmClientGetExpiry()) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'isReadOnly', { get: function () { return this.wasm && this.wasm.wasmClientIsReadOnly && this.wasm.wasmClientIsReadOnly() }, enumerable: !1, configurable: !0 }), e.prototype.hasPerms = function (e) { return this.wasm && this.wasm.wasmClientHasPerms && this.wasm.wasmClientHasPerms(e) }, e.prototype.preload = function () { return r(this, void 0, void 0, function () { let e; return i(this, function (t) { switch (t.label) { case 0:return e = this, [4, WebAssembly.instantiateStreaming(fetch(this._wasmClientCode), this.go.importObject)]; case 1:return e.result = t.sent(), u.wasmLog.info('downloaded WASM file'), [2] } }) }) }, e.prototype.run = function () { return r(this, void 0, void 0, function () { const e = this; return i(this, function (t) { switch (t.label) { case 0:return this.isReady ? [3, 2] : [4, this.preload()]; case 1:t.sent(), t.label = 2; case 2:return typeof this.wasm!=='object' && (this.wasm = {}), this.wasm.onLocalPrivCreate || (this.wasm.onLocalPrivCreate = function (t) { u.wasmLog.debug('local private key created: ' + t), e.credentials.localKey = t }), this.wasm.onRemoteKeyReceive || (this.wasm.onRemoteKeyReceive = function (t) { u.wasmLog.debug('remote key received: ' + t), e.credentials.remoteKey = t }), this.wasm.onAuthData || (this.wasm.onAuthData = function (e) { u.wasmLog.debug('auth data received: ' + e) }), this.go.argv = ['wasm-client', '--debuglevel=trace', '--namespace=' + this._namespace, '--onlocalprivcreate='.concat(this._namespace, '.onLocalPrivCreate'), '--onremotekeyreceive='.concat(this._namespace, '.onRemoteKeyReceive'), '--onauthdata='.concat(this._namespace, '.onAuthData')], this.result ? (this.go.run(this.result.instance), [4, WebAssembly.instantiate(this.result.module, this.go.importObject)]) : [3, 4]; case 3:return t.sent(), [3, 5]; case 4:throw new Error("Can't find WASM instance."); case 5:return [2] } }) }) }, e.prototype.connect = function () { return r(this, void 0, void 0, function () { let e; let t; let n; let r; let o; const a = this; return i(this, function (i) { switch (i.label) { case 0:return this.isConnected ? [2] : this.isReady ? [3, 3] : [4, this.run()]; case 1:return i.sent(), [4, this.waitTilReady()]; case 2:i.sent(), i.label = 3; case 3:return e = this.credentials, t = e.pairingPhrase, n = e.localKey, r = e.remoteKey, o = e.serverHost, this.wasm.wasmClientConnectServer(o, !1, t, n, r), typeof window!=='undefined' ? window.addEventListener('unload', this.wasm.wasmClientDisconnect) : u.wasmLog.info('No unload event listener added. window is not available'), [2, new Promise(function (e, t) { let n = 0; var r = setInterval(function () { n++, a.isConnected ? (clearInterval(r), e(), u.wasmLog.info('The WASM client is connected to the server')) : n > 20 && (clearInterval(r), t(new Error('Failed to connect the WASM client to the proxy server'))) }, 500) })] } }) }) }, e.prototype.disconnect = function () { this.wasm.wasmClientDisconnect() }, e.prototype.waitTilReady = function () { return r(this, void 0, void 0, function () { const e = this; return i(this, function (t) { return [2, new Promise(function (t, n) { let r = 0; var i = setInterval(function () { r++, e.isReady ? (clearInterval(i), t(), u.wasmLog.info('The WASM client is ready')) : r > 20 && (clearInterval(i), n(new Error('Failed to load the WASM client'))) }, 500) })] }) }) }, e.prototype.request = function (e, t) { const n = this; return new Promise(function (r, i) { u.wasmLog.debug(''.concat(e, ' request'), t); const o = JSON.stringify(t || {}); n.wasm.wasmClientInvokeRPC(e, o, function (t) { try { const n = JSON.parse(t); const o = (0, a.snakeKeysToCamel)(n); u.wasmLog.debug(''.concat(e, ' response'), o), r(o) } catch (n) { return u.wasmLog.debug(''.concat(e, ' raw response'), t), void i(new Error(t)) } }) }) }, e.prototype.subscribe = function (e, t, n, r) { u.wasmLog.debug(''.concat(e, ' request'), t); const i = JSON.stringify(t || {}); this.wasm.wasmClientInvokeRPC(e, i, function (t) { try { const i = JSON.parse(t); const o = (0, a.snakeKeysToCamel)(i); u.wasmLog.debug(''.concat(e, ' response'), o), n && n(o) } catch (n) { u.wasmLog.debug(''.concat(e, ' error'), n); const s = new Error(t); r && r(s) } }) }, e }()); t.default = d }, 1712: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(5121); const i = 'lnc-web'; const o = (function () { function e (e, t) { this.persisted = { salt: '', cipher: '', serverHost: '', localKey: '', remoteKey: '', pairingPhrase: '' }, this._localKey = '', this._remoteKey = '', this._pairingPhrase = '', this.namespace = 'default', e && (this.namespace = e), this._load(), t && (this.password = t) } return Object.defineProperty(e.prototype, 'password', { get: function () { return this._password || '' }, set: function (e) { if (this.persisted.cipher) { const t = this.persisted; const n = t.cipher; const i = t.salt; if (!(0, r.verifyTestCipher)(n, e, i)) throw new Error('The password provided is not valid'); this._password = e, this._pairingPhrase = this._decrypt(this.persisted.pairingPhrase), this._localKey = this._decrypt(this.persisted.localKey), this._remoteKey = this._decrypt(this.persisted.remoteKey) } else this._password = e, this.persisted.salt = (0, r.generateSalt)(), this.persisted.cipher = (0, r.createTestCipher)(e, this.persisted.salt), this.pairingPhrase && (this.persisted.pairingPhrase = this._encrypt(this.pairingPhrase)), this.localKey && (this.persisted.localKey = this._encrypt(this.localKey)), this.remoteKey && (this.persisted.remoteKey = this._encrypt(this.remoteKey)), this._save() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'serverHost', { get: function () { return this.persisted.serverHost }, set: function (e) { this.persisted.serverHost = e, this._save() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'pairingPhrase', { get: function () { return this._pairingPhrase }, set: function (e) { this._pairingPhrase = e, this._password && (this.persisted.pairingPhrase = this._encrypt(e), this._save()) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'localKey', { get: function () { return this._localKey }, set: function (e) { this._localKey = e, this._password && (this.persisted.localKey = this._encrypt(e), this._save()) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'remoteKey', { get: function () { return this._remoteKey }, set: function (e) { this._remoteKey = e, this._password && (this.persisted.remoteKey = this._encrypt(e), this._save()) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'isPaired', { get: function () { return !!this.persisted.remoteKey || !!this.persisted.pairingPhrase }, enumerable: !1, configurable: !0 }), e.prototype.clear = function () { const e = ''.concat(i, ':').concat(this.namespace); localStorage.removeItem(e), this.persisted = { salt: '', cipher: '', serverHost: this.persisted.serverHost, localKey: '', remoteKey: '', pairingPhrase: '' }, this._localKey = '', this._remoteKey = '', this._pairingPhrase = '', this._password = void 0 }, e.prototype._load = function () { if (typeof localStorage !== 'undefined') try { const e = ''.concat(i, ':').concat(this.namespace); const t = localStorage.getItem(e); if (!t) return; this.persisted = JSON.parse(t) } catch (e) { const n = e.message; throw new Error('Failed to load secure data: '.concat(n)) } }, e.prototype._save = function () { if (typeof localStorage !== 'undefined') { const e = ''.concat(i, ':').concat(this.namespace); localStorage.setItem(e, JSON.stringify(this.persisted)) } }, e.prototype._encrypt = function (e) { return e && this._password ? (0, r.encrypt)(e, this._password, this.persisted.salt) : '' }, e.prototype._decrypt = function (e) { return e && this._password ? (0, r.decrypt)(e, this._password, this.persisted.salt) : '' }, e }()); t.default = o }, 5121: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.verifyTestCipher = t.createTestCipher = t.decrypt = t.encrypt = t.generateSalt = void 0; const r = n(1354); const i = 'Irrelevant data for password verification'; t.generateSalt = function () { const e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; let t = new Uint8Array(32); return globalThis.crypto.getRandomValues(t), t = t.map(function (t) { return e.charCodeAt(t % e.length) }), String.fromCharCode.apply(null, t) }, t.encrypt = function (e, t, n) { return r.AES.encrypt(JSON.stringify(e), t + n).toString() }, t.decrypt = function (e, t, n) { const i = r.AES.decrypt(e, t + n); return JSON.parse(i.toString(r.enc.Utf8)) }, t.createTestCipher = function (e, n) { return (0, t.encrypt)(i, e, n) }, t.verifyTestCipher = function (e, n, r) { try { return (0, t.decrypt)(e, n, r) === i } catch (e) { return !1 } } }, 1095: function (e, t, n) { 'use strict'; const r = this && this.__spreadArray || function (e, t, n) { if (n || arguments.length === 2) for (var r, i = 0, o = t.length; i < o; i++)!r && i in t || (r || (r = Array.prototype.slice.call(t, 0, i)), r[i] = t[i]); return e.concat(r || Array.prototype.slice.call(t)) }; const i = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, '__esModule', { value: !0 }), t.actionLog = t.wasmLog = t.grpcLog = t.log = t.Logger = t.LogLevel = void 0; let o; const a = i(n(1227)); !(function (e) { e[e.debug = 1] = 'debug', e[e.info = 2] = 'info', e[e.warn = 3] = 'warn', e[e.error = 4] = 'error', e[e.none = 5] = 'none' }(o = t.LogLevel || (t.LogLevel = {}))); const s = (function () { function e (e, t) { const n = this; this.debug = function (e) { for (var t = [], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; return n._log(o.debug, e, t) }, this.info = function (e) { for (var t = [], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; return n._log(o.info, e, t) }, this.warn = function (e) { for (var t = [], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; return n._log(o.warn, e, t) }, this.error = function (e) { for (var t = [], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; return n._log(o.error, e, t) }, this._levelToOutput = e, this._logger = (0, a.default)(t) } return e.fromEnv = function (t) { let n = o.none; if (globalThis.localStorage && globalThis.localStorage.getItem('debug')) { const r = globalThis.localStorage.getItem('debug-level') || 'debug'; n = o[r] } return new e(n, t) }, e.prototype._log = function (e, t, n) { if (!(this._levelToOutput > e)) { const i = Object.keys(o).reduce(function (t, n) { return e === o[n] ? n : t }, '??'); this._logger.apply(this, r(['['.concat(i, '] ').concat(t)], n, !1)) } }, e }()); t.Logger = s, t.log = s.fromEnv('main'), t.grpcLog = s.fromEnv('grpc'), t.wasmLog = s.fromEnv('wasm'), t.actionLog = s.fromEnv('action') }, 384: e => { e.exports = function (e) { return e && typeof e === 'object' && typeof e.copy === 'function' && typeof e.fill === 'function' && typeof e.readUInt8 === 'function' } }, 5955: (e, t, n) => { 'use strict'; const r = n(2584); const i = n(8662); const o = n(6430); const a = n(5692); function s (e) { return e.call.bind(e) } const c = typeof BigInt !== 'undefined'; const u = typeof Symbol !== 'undefined'; const l = s(Object.prototype.toString); const d = s(Number.prototype.valueOf); const f = s(String.prototype.valueOf); const h = s(Boolean.prototype.valueOf); if (c) var p = s(BigInt.prototype.valueOf); if (u) var g = s(Symbol.prototype.valueOf); function m (e, t) { if (typeof e !== 'object') return !1; try { return t(e), !0 } catch (e) { return !1 } } function y (e) { return l(e) === '[object Map]' } function b (e) { return l(e) === '[object Set]' } function v (e) { return l(e) === '[object WeakMap]' } function w (e) { return l(e) === '[object WeakSet]' } function _ (e) { return l(e) === '[object ArrayBuffer]' } function E (e) { return typeof ArrayBuffer !== 'undefined' && (_.working ? _(e) : e instanceof ArrayBuffer) } function k (e) { return l(e) === '[object DataView]' } function S (e) { return typeof DataView !== 'undefined' && (k.working ? k(e) : e instanceof DataView) }t.isArgumentsObject = r, t.isGeneratorFunction = i, t.isTypedArray = a, t.isPromise = function (e) { return typeof Promise !== 'undefined' && e instanceof Promise || e !== null && typeof e === 'object' && typeof e.then === 'function' && typeof e.catch === 'function' }, t.isArrayBufferView = function (e) { return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView ? ArrayBuffer.isView(e) : a(e) || S(e) }, t.isUint8Array = function (e) { return o(e) === 'Uint8Array' }, t.isUint8ClampedArray = function (e) { return o(e) === 'Uint8ClampedArray' }, t.isUint16Array = function (e) { return o(e) === 'Uint16Array' }, t.isUint32Array = function (e) { return o(e) === 'Uint32Array' }, t.isInt8Array = function (e) { return o(e) === 'Int8Array' }, t.isInt16Array = function (e) { return o(e) === 'Int16Array' }, t.isInt32Array = function (e) { return o(e) === 'Int32Array' }, t.isFloat32Array = function (e) { return o(e) === 'Float32Array' }, t.isFloat64Array = function (e) { return o(e) === 'Float64Array' }, t.isBigInt64Array = function (e) { return o(e) === 'BigInt64Array' }, t.isBigUint64Array = function (e) { return o(e) === 'BigUint64Array' }, y.working = typeof Map !== 'undefined' && y(new Map()), t.isMap = function (e) { return typeof Map !== 'undefined' && (y.working ? y(e) : e instanceof Map) }, b.working = typeof Set !== 'undefined' && b(new Set()), t.isSet = function (e) { return typeof Set !== 'undefined' && (b.working ? b(e) : e instanceof Set) }, v.working = typeof WeakMap !== 'undefined' && v(new WeakMap()), t.isWeakMap = function (e) { return typeof WeakMap !== 'undefined' && (v.working ? v(e) : e instanceof WeakMap) }, w.working = typeof WeakSet !== 'undefined' && w(new WeakSet()), t.isWeakSet = function (e) { return w(e) }, _.working = typeof ArrayBuffer !== 'undefined' && _(new ArrayBuffer()), t.isArrayBuffer = E, k.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && k(new DataView(new ArrayBuffer(1), 0, 1)), t.isDataView = S; const A = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : void 0; function O (e) { return l(e) === '[object SharedArrayBuffer]' } function x (e) { return void 0 !== A && (void 0 === O.working && (O.working = O(new A())), O.working ? O(e) : e instanceof A) } function I (e) { return m(e, d) } function N (e) { return m(e, f) } function T (e) { return m(e, h) } function R (e) { return c && m(e, p) } function P (e) { return u && m(e, g) }t.isSharedArrayBuffer = x, t.isAsyncFunction = function (e) { return l(e) === '[object AsyncFunction]' }, t.isMapIterator = function (e) { return l(e) === '[object Map Iterator]' }, t.isSetIterator = function (e) { return l(e) === '[object Set Iterator]' }, t.isGeneratorObject = function (e) { return l(e) === '[object Generator]' }, t.isWebAssemblyCompiledModule = function (e) { return l(e) === '[object WebAssembly.Module]' }, t.isNumberObject = I, t.isStringObject = N, t.isBooleanObject = T, t.isBigIntObject = R, t.isSymbolObject = P, t.isBoxedPrimitive = function (e) { return I(e) || N(e) || T(e) || R(e) || P(e) }, t.isAnyArrayBuffer = function (e) { return typeof Uint8Array !== 'undefined' && (E(e) || x(e)) }, ['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (e) { Object.defineProperty(t, e, { enumerable: !1, value: function () { throw new Error(e + ' is not supported in userland') } }) }) }, 9539: (e, t, n) => { const r = n(4155); const i = n(5108); const o = Object.getOwnPropertyDescriptors || function (e) { for (var t = Object.keys(e), n = {}, r = 0; r < t.length; r++)n[t[r]] = Object.getOwnPropertyDescriptor(e, t[r]); return n }; const a = /%[sdj%]/g; t.format = function (e) { if (!w(e)) { for (var t = [], n = 0; n < arguments.length; n++)t.push(l(arguments[n])); return t.join(' ') }n = 1; for (var r = arguments, i = r.length, o = String(e).replace(a, function (e) { if (e === '%%') return '%'; if (n >= i) return e; switch (e) { case '%s':return String(r[n++]); case '%d':return Number(r[n++]); case '%j':try { return JSON.stringify(r[n++]) } catch (e) { return '[Circular]' } default:return e } }), s = r[n]; n < i; s = r[++n])b(s) || !k(s) ? o += ' ' + s : o += ' ' + l(s); return o }, t.deprecate = function (e, n) { if (void 0 !== r && !0 === r.noDeprecation) return e; if (void 0 === r) return function () { return t.deprecate(e, n).apply(this, arguments) }; let o = !1; return function () { if (!o) { if (r.throwDeprecation) throw new Error(n); r.traceDeprecation ? i.trace(n) : i.error(n), o = !0 } return e.apply(this, arguments) } }; const s = {}; let c = /^$/; if (r.env.NODE_DEBUG) { let u = r.env.NODE_DEBUG; u = u.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase(), c = new RegExp('^' + u + '$', 'i') } function l (e, n) { const r = { seen: [], stylize: f }; return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), y(n) ? r.showHidden = n : n && t._extend(r, n), _(r.showHidden) && (r.showHidden = !1), _(r.depth) && (r.depth = 2), _(r.colors) && (r.colors = !1), _(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = d), h(r, e, r.depth) } function d (e, t) { const n = l.styles[t]; return n ? '[' + l.colors[n][0] + 'm' + e + '[' + l.colors[n][1] + 'm' : e } function f (e, t) { return e } function h (e, n, r) { if (e.customInspect && n && O(n.inspect) && n.inspect !== t.inspect && (!n.constructor || n.constructor.prototype !== n)) { let i = n.inspect(r, e); return w(i) || (i = h(e, i, r)), i } const o = (function (e, t) { if (_(t)) return e.stylize('undefined', 'undefined'); if (w(t)) { const n = "'" + JSON.stringify(t).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'"; return e.stylize(n, 'string') } return v(t) ? e.stylize('' + t, 'number') : y(t) ? e.stylize('' + t, 'boolean') : b(t) ? e.stylize('null', 'null') : void 0 }(e, n)); if (o) return o; let a = Object.keys(n); const s = (function (e) { const t = {}; return e.forEach(function (e, n) { t[e] = !0 }), t }(a)); if (e.showHidden && (a = Object.getOwnPropertyNames(n)), A(n) && (a.indexOf('message') >= 0 || a.indexOf('description') >= 0)) return p(n); if (a.length === 0) { if (O(n)) { const c = n.name ? ': ' + n.name : ''; return e.stylize('[Function' + c + ']', 'special') } if (E(n)) return e.stylize(RegExp.prototype.toString.call(n), 'regexp'); if (S(n)) return e.stylize(Date.prototype.toString.call(n), 'date'); if (A(n)) return p(n) } let u; let l = ''; let d = !1; let f = ['{', '}']; return m(n) && (d = !0, f = ['[', ']']), O(n) && (l = ' [Function' + (n.name ? ': ' + n.name : '') + ']'), E(n) && (l = ' ' + RegExp.prototype.toString.call(n)), S(n) && (l = ' ' + Date.prototype.toUTCString.call(n)), A(n) && (l = ' ' + p(n)), a.length !== 0 || d && n.length != 0 ? r < 0 ? E(n) ? e.stylize(RegExp.prototype.toString.call(n), 'regexp') : e.stylize('[Object]', 'special') : (e.seen.push(n), u = d ? (function (e, t, n, r, i) { for (var o = [], a = 0, s = t.length; a < s; ++a)R(t, String(a)) ? o.push(g(e, t, n, r, String(a), !0)) : o.push(''); return i.forEach(function (i) { i.match(/^\d+$/) || o.push(g(e, t, n, r, i, !0)) }), o }(e, n, r, s, a)) : a.map(function (t) { return g(e, n, r, s, t, d) }), e.seen.pop(), (function (e, t, n) { return e.reduce(function (e, t) { return t.indexOf('\n'), e + t.replace(/\u001b\[\d\d?m/g, '').length + 1 }, 0) > 60 ? n[0] + (t === '' ? '' : t + '\n ') + ' ' + e.join(',\n  ') + ' ' + n[1] : n[0] + t + ' ' + e.join(', ') + ' ' + n[1] }(u, l, f))) : f[0] + l + f[1] } function p (e) { return '[' + Error.prototype.toString.call(e) + ']' } function g (e, t, n, r, i, o) { let a, s, c; if ((c = Object.getOwnPropertyDescriptor(t, i) || { value: t[i] }).get ? s = c.set ? e.stylize('[Getter/Setter]', 'special') : e.stylize('[Getter]', 'special') : c.set && (s = e.stylize('[Setter]', 'special')), R(r, i) || (a = '[' + i + ']'), s || (e.seen.indexOf(c.value) < 0 ? (s = b(n) ? h(e, c.value, null) : h(e, c.value, n - 1)).indexOf('\n') > -1 && (s = o ? s.split('\n').map(function (e) { return '  ' + e }).join('\n').slice(2) : '\n' + s.split('\n').map(function (e) { return '   ' + e }).join('\n')) : s = e.stylize('[Circular]', 'special')), _(a)) { if (o && i.match(/^\d+$/)) return s; (a = JSON.stringify('' + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a = a.slice(1, -1), a = e.stylize(a, 'name')) : (a = a.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a = e.stylize(a, 'string')) } return a + ': ' + s } function m (e) { return Array.isArray(e) } function y (e) { return typeof e === 'boolean' } function b (e) { return e === null } function v (e) { return typeof e === 'number' } function w (e) { return typeof e === 'string' } function _ (e) { return void 0 === e } function E (e) { return k(e) && x(e) === '[object RegExp]' } function k (e) { return typeof e === 'object' && e !== null } function S (e) { return k(e) && x(e) === '[object Date]' } function A (e) { return k(e) && (x(e) === '[object Error]' || e instanceof Error) } function O (e) { return typeof e === 'function' } function x (e) { return Object.prototype.toString.call(e) } function I (e) { return e < 10 ? '0' + e.toString(10) : e.toString(10) }t.debuglog = function (e) { if (e = e.toUpperCase(), !s[e]) if (c.test(e)) { const n = r.pid; s[e] = function () { const r = t.format.apply(t, arguments); i.error('%s %d: %s', e, n, r) } } else s[e] = function () {}; return s[e] }, t.inspect = l, l.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, l.styles = { special: 'cyan', number: 'yellow', boolean: 'yellow', undefined: 'grey', null: 'bold', string: 'green', date: 'magenta', regexp: 'red' }, t.types = n(5955), t.isArray = m, t.isBoolean = y, t.isNull = b, t.isNullOrUndefined = function (e) { return e == null }, t.isNumber = v, t.isString = w, t.isSymbol = function (e) { return typeof e === 'symbol' }, t.isUndefined = _, t.isRegExp = E, t.types.isRegExp = E, t.isObject = k, t.isDate = S, t.types.isDate = S, t.isError = A, t.types.isNativeError = A, t.isFunction = O, t.isPrimitive = function (e) { return e === null || typeof e === 'boolean' || typeof e === 'number' || typeof e === 'string' || typeof e === 'symbol' || void 0 === e }, t.isBuffer = n(384); const N = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; function T () { const e = new Date(); const t = [I(e.getHours()), I(e.getMinutes()), I(e.getSeconds())].join(':'); return [e.getDate(), N[e.getMonth()], t].join(' ') } function R (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }t.log = function () { i.log('%s - %s', T(), t.format.apply(t, arguments)) }, t.inherits = n(5717), t._extend = function (e, t) { if (!t || !k(t)) return e; for (let n = Object.keys(t), r = n.length; r--;)e[n[r]] = t[n[r]]; return e }; const P = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : void 0; function C (e, t) { if (!e) { const n = new Error('Promise was rejected with a falsy value'); n.reason = e, e = n } return t(e) }t.promisify = function (e) { if (typeof e !== 'function') throw new TypeError('The "original" argument must be of type Function'); if (P && e[P]) { var t; if (typeof (t = e[P]) !== 'function') throw new TypeError('The "util.promisify.custom" argument must be of type Function'); return Object.defineProperty(t, P, { value: t, enumerable: !1, writable: !1, configurable: !0 }), t } function t () { for (var t, n, r = new Promise(function (e, r) { t = e, n = r }), i = [], o = 0; o < arguments.length; o++)i.push(arguments[o]); i.push(function (e, r) { e ? n(e) : t(r) }); try { e.apply(this, i) } catch (e) { n(e) } return r } return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), P && Object.defineProperty(t, P, { value: t, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(t, o(e)) }, t.promisify.custom = P, t.callbackify = function (e) { if (typeof e !== 'function') throw new TypeError('The "original" argument must be of type Function'); function t () { for (var t = [], n = 0; n < arguments.length; n++)t.push(arguments[n]); const i = t.pop(); if (typeof i !== 'function') throw new TypeError('The last argument must be of type Function'); const o = this; const a = function () { return i.apply(o, arguments) }; e.apply(this, t).then(function (e) { r.nextTick(a.bind(null, null, e)) }, function (e) { r.nextTick(C.bind(null, e, a)) }) } return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Object.defineProperties(t, o(e)), t } }, 6430: (e, t, n) => { 'use strict'; const r = n(4029); const i = n(3083); const o = n(1924); const a = n(7296); const s = o('Object.prototype.toString'); const c = n(6410)(); const u = typeof globalThis === 'undefined' ? n.g : globalThis; const l = i(); const d = o('String.prototype.slice'); const f = {}; const h = Object.getPrototypeOf; c && a && h && r(l, function (e) { if (typeof u[e] === 'function') { const t = new u[e](); if (Symbol.toStringTag in t) { const n = h(t); let r = a(n, Symbol.toStringTag); if (!r) { const i = h(n); r = a(i, Symbol.toStringTag) }f[e] = r.get } } }); const p = n(5692); e.exports = function (e) { return !!p(e) && (c && Symbol.toStringTag in e ? (function (e) { let t = !1; return r(f, function (n, r) { if (!t) try { const i = n.call(e); i === r && (t = i) } catch (e) {} }), t }(e)) : d(s(e), 8, -1)) } }, 4229: () => {}, 2203: () => {}, 5381: () => {}, 2480: () => {}, 3083: (e, t, n) => { 'use strict'; const r = ['BigInt64Array', 'BigUint64Array', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray']; const i = typeof globalThis === 'undefined' ? n.g : globalThis; e.exports = function () { for (var e = [], t = 0; t < r.length; t++) typeof i[r[t]] === 'function' && (e[e.length] = r[t]); return e } } }; const t = {}; function n (r) { const i = t[r]; if (void 0 !== i) return i.exports; const o = t[r] = { id: r, loaded: !1, exports: {} }; return e[r].call(o.exports, o, o.exports, n), o.loaded = !0, o.exports } return n.g = (function () { if (typeof globalThis === 'object') return globalThis; try { return this || new Function('return this')() } catch (e) { if (typeof window === 'object') return window } }()), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.nmd = e => (e.paths = [], e.children || (e.children = []), e), n(8713) })() }, 9187: (e, t) => { 'use strict'; function n (e) { if (!Number.isSafeInteger(e)) throw new Error(`Wrong integer: ${e}`) } function r (...e) { const t = (e, t) => n => e(t(n)); return { encode: Array.from(e).reverse().reduce((e, n) => e ? t(e, n.encode) : n.encode, void 0), decode: e.reduce((e, n) => e ? t(e, n.decode) : n.decode, void 0) } } function i (e) { return { encode: t => { if (!Array.isArray(t) || t.length && typeof t[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers'); return t.map(t => { if (n(t), t < 0 || t >= e.length) throw new Error(`Digit index outside alphabet: ${t} (alphabet: ${e.length})`); return e[t] }) }, decode: t => { if (!Array.isArray(t) || t.length && typeof t[0] !== 'string') throw new Error('alphabet.decode input should be array of strings'); return t.map(t => { if (typeof t !== 'string') throw new Error(`alphabet.decode: not string element=${t}`); const n = e.indexOf(t); if (n === -1) throw new Error(`Unknown letter: "${t}". Allowed: ${e}`); return n }) } } } function o (e = '') { if (typeof e !== 'string') throw new Error('join separator should be string'); return { encode: t => { if (!Array.isArray(t) || t.length && typeof t[0] !== 'string') throw new Error('join.encode input should be array of strings'); for (const e of t) if (typeof e !== 'string') throw new Error(`join.encode: non-string input=${e}`); return t.join(e) }, decode: t => { if (typeof t !== 'string') throw new Error('join.decode input should be string'); return t.split(e) } } } function a (e, t = '=') { if (n(e), typeof t !== 'string') throw new Error('padding chr should be string'); return { encode (n) { if (!Array.isArray(n) || n.length && typeof n[0] !== 'string') throw new Error('padding.encode input should be array of strings'); for (const e of n) if (typeof e !== 'string') throw new Error(`padding.encode: non-string input=${e}`); for (;n.length * e % 8;)n.push(t); return n }, decode (n) { if (!Array.isArray(n) || n.length && typeof n[0] !== 'string') throw new Error('padding.encode input should be array of strings'); for (const e of n) if (typeof e !== 'string') throw new Error(`padding.decode: non-string input=${e}`); let r = n.length; if (r * e % 8) throw new Error('Invalid padding: string should have whole number of bytes'); for (;r > 0 && n[r - 1] === t; r--) if (!((r - 1) * e % 8)) throw new Error('Invalid padding: string has too much padding'); return n.slice(0, r) } } } function s (e) { if (typeof e !== 'function') throw new Error('normalize fn should be function'); return { encode: e => e, decode: t => e(t) } } function c (e, t, r) { if (t < 2) throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`); if (r < 2) throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`); if (!Array.isArray(e)) throw new Error('convertRadix: data should be array'); if (!e.length) return []; let i = 0; const o = []; const a = Array.from(e); for (a.forEach(e => { if (n(e), e < 0 || e >= t) throw new Error(`Wrong integer: ${e}`) }); ;) { let e = 0; let n = !0; for (let o = i; o < a.length; o++) { const s = a[o]; const c = t * e + s; if (!Number.isSafeInteger(c) || t * e / t !== e || c - s != t * e) throw new Error('convertRadix: carry overflow'); if (e = c % r, a[o] = Math.floor(c / r), !Number.isSafeInteger(a[o]) || a[o] * r + e !== c) throw new Error('convertRadix: carry overflow'); n && (a[o] ? n = !1 : i = o) } if (o.push(e), n) break } for (let t = 0; t < e.length - 1 && e[t] === 0; t++)o.push(0); return o.reverse() }Object.defineProperty(t, '__esModule', { value: !0 }), t.bytes = t.stringToBytes = t.str = t.bytesToString = t.hex = t.utf8 = t.bech32m = t.bech32 = t.base58check = t.base58xmr = t.base58xrp = t.base58flickr = t.base58 = t.base64url = t.base64 = t.base32crockford = t.base32hex = t.base32 = t.base16 = t.utils = t.assertNumber = void 0, t.assertNumber = n; const u = (e, t) => t ? u(t, e % t) : e; const l = (e, t) => e + (t - u(e, t)); function d (e, t, r, i) { if (!Array.isArray(e)) throw new Error('convertRadix2: data should be array'); if (t <= 0 || t > 32) throw new Error(`convertRadix2: wrong from=${t}`); if (r <= 0 || r > 32) throw new Error(`convertRadix2: wrong to=${r}`); if (l(t, r) > 32) throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${l(t, r)}`); let o = 0; let a = 0; const s = 2 ** r - 1; const c = []; for (const i of e) { if (n(i), i >= 2 ** t) throw new Error(`convertRadix2: invalid data word=${i} from=${t}`); if (o = o << t | i, a + t > 32) throw new Error(`convertRadix2: carry overflow pos=${a} from=${t}`); for (a += t; a >= r; a -= r)c.push((o >> a - r & s) >>> 0); o &= 2 ** a - 1 } if (o = o << r - a & s, !i && a >= t) throw new Error('Excess padding'); if (!i && o) throw new Error(`Non-zero padding: ${o}`); return i && a > 0 && c.push(o >>> 0), c } function f (e) { return n(e), { encode: t => { if (!(t instanceof Uint8Array)) throw new Error('radix.encode input should be Uint8Array'); return c(Array.from(t), 256, e) }, decode: t => { if (!Array.isArray(t) || t.length && typeof t[0] !== 'number') throw new Error('radix.decode input should be array of strings'); return Uint8Array.from(c(t, e, 256)) } } } function h (e, t = !1) { if (n(e), e <= 0 || e > 32) throw new Error('radix2: bits should be in (0..32]'); if (l(8, e) > 32 || l(e, 8) > 32) throw new Error('radix2: carry overflow'); return { encode: n => { if (!(n instanceof Uint8Array)) throw new Error('radix2.encode input should be Uint8Array'); return d(Array.from(n), 8, e, !t) }, decode: n => { if (!Array.isArray(n) || n.length && typeof n[0] !== 'number') throw new Error('radix2.decode input should be array of strings'); return Uint8Array.from(d(n, e, 8, t)) } } } function p (e) { if (typeof e !== 'function') throw new Error('unsafeWrapper fn should be function'); return function (...t) { try { return e.apply(null, t) } catch (e) {} } } function g (e, t) { if (n(e), typeof t !== 'function') throw new Error('checksum fn should be function'); return { encode (n) { if (!(n instanceof Uint8Array)) throw new Error('checksum.encode: input should be Uint8Array'); const r = t(n).slice(0, e); const i = new Uint8Array(n.length + e); return i.set(n), i.set(r, n.length), i }, decode (n) { if (!(n instanceof Uint8Array)) throw new Error('checksum.decode: input should be Uint8Array'); const r = n.slice(0, -e); const i = t(r).slice(0, e); const o = n.slice(-e); for (let t = 0; t < e; t++) if (i[t] !== o[t]) throw new Error('Invalid checksum'); return r } } }t.utils = { alphabet: i, chain: r, checksum: g, radix: f, radix2: h, join: o, padding: a }, t.base16 = r(h(4), i('0123456789ABCDEF'), o('')), t.base32 = r(h(5), i('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), a(5), o('')), t.base32hex = r(h(5), i('0123456789ABCDEFGHIJKLMNOPQRSTUV'), a(5), o('')), t.base32crockford = r(h(5), i('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), o(''), s(e => e.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))), t.base64 = r(h(6), i('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), a(6), o('')), t.base64url = r(h(6), i('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), a(6), o('')); const m = e => r(f(58), i(e), o('')); t.base58 = m('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'), t.base58flickr = m('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'), t.base58xrp = m('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'); const y = [0, 2, 3, 5, 6, 7, 9, 10, 11]; t.base58xmr = { encode (e) { let n = ''; for (let r = 0; r < e.length; r += 8) { const i = e.subarray(r, r + 8); n += t.base58.encode(i).padStart(y[i.length], '1') } return n }, decode (e) { let n = []; for (let r = 0; r < e.length; r += 11) { const i = e.slice(r, r + 11); const o = y.indexOf(i.length); const a = t.base58.decode(i); for (let e = 0; e < a.length - o; e++) if (a[e] !== 0) throw new Error('base58xmr: wrong padding'); n = n.concat(Array.from(a.slice(a.length - o))) } return Uint8Array.from(n) } }; t.base58check = e => r(g(4, t => e(e(t))), t.base58); const b = r(i('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), o('')); const v = [996825010, 642813549, 513874426, 1027748829, 705979059]; function w (e) { const t = e >> 25; let n = (33554431 & e) << 5; for (let e = 0; e < v.length; e++)(t >> e & 1) == 1 && (n ^= v[e]); return n } function _ (e, t, n = 1) { const r = e.length; let i = 1; for (let t = 0; t < r; t++) { const n = e.charCodeAt(t); if (n < 33 || n > 126) throw new Error(`Invalid prefix (${e})`); i = w(i) ^ n >> 5 }i = w(i); for (let t = 0; t < r; t++)i = w(i) ^ 31 & e.charCodeAt(t); for (const e of t)i = w(i) ^ e; for (let e = 0; e < 6; e++)i = w(i); return i ^= n, b.encode(d([i % 2 ** 30], 30, 5, !1)) } function E (e) { const t = e === 'bech32' ? 1 : 734539939; const n = h(5); const r = n.decode; const i = n.encode; const o = p(r); function a (e, n = 90) { if (typeof e !== 'string') throw new Error('bech32.decode input should be string, not ' + typeof e); if (e.length < 8 || !1 !== n && e.length > n) throw new TypeError(`Wrong string length: ${e.length} (${e}). Expected (8..${n})`); const r = e.toLowerCase(); if (e !== r && e !== e.toUpperCase()) throw new Error('String must be lowercase or uppercase'); const i = (e = r).lastIndexOf('1'); if (i === 0 || i === -1) throw new Error('Letter "1" must be present between prefix and data only'); const o = e.slice(0, i); const a = e.slice(i + 1); if (a.length < 6) throw new Error('Data must be at least 6 characters long'); const s = b.decode(a).slice(0, -6); const c = _(o, s, t); if (!a.endsWith(c)) throw new Error(`Invalid checksum in ${e}: expected "${c}"`); return { prefix: o, words: s } } return { encode: function (e, n, r = 90) { if (typeof e !== 'string') throw new Error('bech32.encode prefix should be string, not ' + typeof e); if (!Array.isArray(n) || n.length && typeof n[0] !== 'number') throw new Error('bech32.encode words should be array of numbers, not ' + typeof n); const i = e.length + 7 + n.length; if (!1 !== r && i > r) throw new TypeError(`Length ${i} exceeds limit ${r}`); return `${e = e.toLowerCase()}1${b.encode(n)}${_(e, n, t)}` }, decode: a, decodeToBytes: function (e) { const { prefix: t, words: n } = a(e, !1); return { prefix: t, words: n, bytes: r(n) } }, decodeUnsafe: p(a), fromWords: r, fromWordsUnsafe: o, toWords: i } }t.bech32 = E('bech32'), t.bech32m = E('bech32m'), t.utf8 = { encode: e => (new TextDecoder()).decode(e), decode: e => (new TextEncoder()).encode(e) }, t.hex = r(h(4), i('0123456789abcdef'), o(''), s(e => { if (typeof e !== 'string' || e.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`); return e.toLowerCase() })); const k = { utf8: t.utf8, hex: t.hex, base16: t.base16, base32: t.base32, base64: t.base64, base64url: t.base64url, base58: t.base58, base58xmr: t.base58xmr }; const S = `Invalid encoding type. Available types: ${Object.keys(k).join(', ')}`; t.bytesToString = (e, t) => { if (typeof e !== 'string' || !k.hasOwnProperty(e)) throw new TypeError(S); if (!(t instanceof Uint8Array)) throw new TypeError('bytesToString() expects Uint8Array'); return k[e].encode(t) }, t.str = t.bytesToString; t.stringToBytes = (e, t) => { if (!k.hasOwnProperty(e)) throw new TypeError(S); if (typeof t !== 'string') throw new TypeError('stringToBytes() expects string'); return k[e].decode(t) }, t.bytes = t.stringToBytes }, 9669: (e, t, n) => { e.exports = n(1609) }, 5448: (e, t, n) => { 'use strict'; const r = n(4867); const i = n(6026); const o = n(4372); const a = n(5327); const s = n(4097); const c = n(4109); const u = n(7985); const l = n(7874); const d = n(2648); const f = n(644); const h = n(205); e.exports = function (e) { return new Promise(function (t, n) { let p; let g = e.data; const m = e.headers; const y = e.responseType; function b () { e.cancelToken && e.cancelToken.unsubscribe(p), e.signal && e.signal.removeEventListener('abort', p) }r.isFormData(g) && r.isStandardBrowserEnv() && delete m['Content-Type']; let v = new XMLHttpRequest(); if (e.auth) { const w = e.auth.username || ''; const _ = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : ''; m.Authorization = 'Basic ' + btoa(w + ':' + _) } const E = s(e.baseURL, e.url); function k () { if (v) { const r = 'getAllResponseHeaders' in v ? c(v.getAllResponseHeaders()) : null; const o = { data: y && y !== 'text' && y !== 'json' ? v.response : v.responseText, status: v.status, statusText: v.statusText, headers: r, config: e, request: v }; i(function (e) { t(e), b() }, function (e) { n(e), b() }, o), v = null } } if (v.open(e.method.toUpperCase(), a(E, e.params, e.paramsSerializer), !0), v.timeout = e.timeout, 'onloadend' in v ? v.onloadend = k : v.onreadystatechange = function () { v && v.readyState === 4 && (v.status !== 0 || v.responseURL && v.responseURL.indexOf('file:') === 0) && setTimeout(k) }, v.onabort = function () { v && (n(new d('Request aborted', d.ECONNABORTED, e, v)), v = null) }, v.onerror = function () { n(new d('Network Error', d.ERR_NETWORK, e, v, v)), v = null }, v.ontimeout = function () { let t = e.timeout ? 'timeout of ' + e.timeout + 'ms exceeded' : 'timeout exceeded'; const r = e.transitional || l; e.timeoutErrorMessage && (t = e.timeoutErrorMessage), n(new d(t, r.clarifyTimeoutError ? d.ETIMEDOUT : d.ECONNABORTED, e, v)), v = null }, r.isStandardBrowserEnv()) { const S = (e.withCredentials || u(E)) && e.xsrfCookieName ? o.read(e.xsrfCookieName) : void 0; S && (m[e.xsrfHeaderName] = S) }'setRequestHeader' in v && r.forEach(m, function (e, t) { void 0 === g && t.toLowerCase() === 'content-type' ? delete m[t] : v.setRequestHeader(t, e) }), r.isUndefined(e.withCredentials) || (v.withCredentials = !!e.withCredentials), y && y !== 'json' && (v.responseType = e.responseType), typeof e.onDownloadProgress === 'function' && v.addEventListener('progress', e.onDownloadProgress), typeof e.onUploadProgress === 'function' && v.upload && v.upload.addEventListener('progress', e.onUploadProgress), (e.cancelToken || e.signal) && (p = function (e) { v && (n(!e || e && e.type ? new f() : e), v.abort(), v = null) }, e.cancelToken && e.cancelToken.subscribe(p), e.signal && (e.signal.aborted ? p() : e.signal.addEventListener('abort', p))), g || (g = null); const A = h(E); A && ['http', 'https', 'file'].indexOf(A) === -1 ? n(new d('Unsupported protocol ' + A + ':', d.ERR_BAD_REQUEST, e)) : v.send(g) }) } }, 1609: (e, t, n) => { 'use strict'; const r = n(4867); const i = n(1849); const o = n(321); const a = n(7185); const s = (function e (t) { const n = new o(t); const s = i(o.prototype.request, n); return r.extend(s, o.prototype, n), r.extend(s, n), s.create = function (n) { return e(a(t, n)) }, s }(n(5546))); s.Axios = o, s.CanceledError = n(644), s.CancelToken = n(4972), s.isCancel = n(6502), s.VERSION = n(7288).version, s.toFormData = n(7675), s.AxiosError = n(2648), s.Cancel = s.CanceledError, s.all = function (e) { return Promise.all(e) }, s.spread = n(8713), s.isAxiosError = n(6268), e.exports = s, e.exports.default = s }, 4972: (e, t, n) => { 'use strict'; const r = n(644); function i (e) { if (typeof e !== 'function') throw new TypeError('executor must be a function.'); let t; this.promise = new Promise(function (e) { t = e }); const n = this; this.promise.then(function (e) { if (n._listeners) { let t; const r = n._listeners.length; for (t = 0; t < r; t++)n._listeners[t](e); n._listeners = null } }), this.promise.then = function (e) { let t; const r = new Promise(function (e) { n.subscribe(e), t = e }).then(e); return r.cancel = function () { n.unsubscribe(t) }, r }, e(function (e) { n.reason || (n.reason = new r(e), t(n.reason)) }) }i.prototype.throwIfRequested = function () { if (this.reason) throw this.reason }, i.prototype.subscribe = function (e) { this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e] }, i.prototype.unsubscribe = function (e) { if (this._listeners) { const t = this._listeners.indexOf(e); t !== -1 && this._listeners.splice(t, 1) } }, i.source = function () { let e; return { token: new i(function (t) { e = t }), cancel: e } }, e.exports = i }, 644: (e, t, n) => { 'use strict'; const r = n(2648); function i (e) { r.call(this, e == null ? 'canceled' : e, r.ERR_CANCELED), this.name = 'CanceledError' }n(4867).inherits(i, r, { __CANCEL__: !0 }), e.exports = i }, 6502: e => { 'use strict'; e.exports = function (e) { return !(!e || !e.__CANCEL__) } }, 321: (e, t, n) => { 'use strict'; const r = n(4867); const i = n(5327); const o = n(782); const a = n(3572); const s = n(7185); const c = n(4097); const u = n(4875); const l = u.validators; function d (e) { this.defaults = e, this.interceptors = { request: new o(), response: new o() } }d.prototype.request = function (e, t) { typeof e === 'string' ? (t = t || {}).url = e : t = e || {}, (t = s(this.defaults, t)).method ? t.method = t.method.toLowerCase() : this.defaults.method ? t.method = this.defaults.method.toLowerCase() : t.method = 'get'; const n = t.transitional; void 0 !== n && u.assertOptions(n, { silentJSONParsing: l.transitional(l.boolean), forcedJSONParsing: l.transitional(l.boolean), clarifyTimeoutError: l.transitional(l.boolean) }, !1); const r = []; let i = !0; this.interceptors.request.forEach(function (e) { typeof e.runWhen === 'function' && !1 === e.runWhen(t) || (i = i && e.synchronous, r.unshift(e.fulfilled, e.rejected)) }); let o; const c = []; if (this.interceptors.response.forEach(function (e) { c.push(e.fulfilled, e.rejected) }), !i) { let d = [a, void 0]; for (Array.prototype.unshift.apply(d, r), d = d.concat(c), o = Promise.resolve(t); d.length;)o = o.then(d.shift(), d.shift()); return o } for (var f = t; r.length;) { const h = r.shift(); const p = r.shift(); try { f = h(f) } catch (e) { p(e); break } } try { o = a(f) } catch (e) { return Promise.reject(e) } for (;c.length;)o = o.then(c.shift(), c.shift()); return o }, d.prototype.getUri = function (e) { e = s(this.defaults, e); const t = c(e.baseURL, e.url); return i(t, e.params, e.paramsSerializer) }, r.forEach(['delete', 'get', 'head', 'options'], function (e) { d.prototype[e] = function (t, n) { return this.request(s(n || {}, { method: e, url: t, data: (n || {}).data })) } }), r.forEach(['post', 'put', 'patch'], function (e) { function t (t) { return function (n, r, i) { return this.request(s(i || {}, { method: e, headers: t ? { 'Content-Type': 'multipart/form-data' } : {}, url: n, data: r })) } }d.prototype[e] = t(), d.prototype[e + 'Form'] = t(!0) }), e.exports = d }, 2648: (e, t, n) => { 'use strict'; const r = n(4867); function i (e, t, n, r, i) { Error.call(this), this.message = e, this.name = 'AxiosError', t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i) }r.inherits(i, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null } } }); const o = i.prototype; const a = {}; ['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED'].forEach(function (e) { a[e] = { value: e } }), Object.defineProperties(i, a), Object.defineProperty(o, 'isAxiosError', { value: !0 }), i.from = function (e, t, n, a, s, c) { const u = Object.create(o); return r.toFlatObject(e, u, function (e) { return e !== Error.prototype }), i.call(u, e.message, t, n, a, s), u.name = e.name, c && Object.assign(u, c), u }, e.exports = i }, 782: (e, t, n) => { 'use strict'; const r = n(4867); function i () { this.handlers = [] }i.prototype.use = function (e, t, n) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: !!n && n.synchronous, runWhen: n ? n.runWhen : null }), this.handlers.length - 1 }, i.prototype.eject = function (e) { this.handlers[e] && (this.handlers[e] = null) }, i.prototype.forEach = function (e) { r.forEach(this.handlers, function (t) { t !== null && e(t) }) }, e.exports = i }, 4097: (e, t, n) => { 'use strict'; const r = n(1793); const i = n(7303); e.exports = function (e, t) { return e && !r(t) ? i(e, t) : t } }, 3572: (e, t, n) => { 'use strict'; const r = n(4867); const i = n(8527); const o = n(6502); const a = n(5546); const s = n(644); function c (e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new s() }e.exports = function (e) { return c(e), e.headers = e.headers || {}, e.data = i.call(e, e.data, e.headers, e.transformRequest), e.headers = r.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers), r.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function (t) { delete e.headers[t] }), (e.adapter || a.adapter)(e).then(function (t) { return c(e), t.data = i.call(e, t.data, t.headers, e.transformResponse), t }, function (t) { return o(t) || (c(e), t && t.response && (t.response.data = i.call(e, t.response.data, t.response.headers, e.transformResponse))), Promise.reject(t) }) } }, 7185: (e, t, n) => { 'use strict'; const r = n(4867); e.exports = function (e, t) { t = t || {}; const n = {}; function i (e, t) { return r.isPlainObject(e) && r.isPlainObject(t) ? r.merge(e, t) : r.isPlainObject(t) ? r.merge({}, t) : r.isArray(t) ? t.slice() : t } function o (n) { return r.isUndefined(t[n]) ? r.isUndefined(e[n]) ? void 0 : i(void 0, e[n]) : i(e[n], t[n]) } function a (e) { if (!r.isUndefined(t[e])) return i(void 0, t[e]) } function s (n) { return r.isUndefined(t[n]) ? r.isUndefined(e[n]) ? void 0 : i(void 0, e[n]) : i(void 0, t[n]) } function c (n) { return n in t ? i(e[n], t[n]) : n in e ? i(void 0, e[n]) : void 0 } const u = { url: a, method: a, data: a, baseURL: s, transformRequest: s, transformResponse: s, paramsSerializer: s, timeout: s, timeoutMessage: s, withCredentials: s, adapter: s, responseType: s, xsrfCookieName: s, xsrfHeaderName: s, onUploadProgress: s, onDownloadProgress: s, decompress: s, maxContentLength: s, maxBodyLength: s, beforeRedirect: s, transport: s, httpAgent: s, httpsAgent: s, cancelToken: s, socketPath: s, responseEncoding: s, validateStatus: c }; return r.forEach(Object.keys(e).concat(Object.keys(t)), function (e) { const t = u[e] || o; const i = t(e); r.isUndefined(i) && t !== c || (n[e] = i) }), n } }, 6026: (e, t, n) => { 'use strict'; const r = n(2648); e.exports = function (e, t, n) { const i = n.config.validateStatus; n.status && i && !i(n.status) ? t(new r('Request failed with status code ' + n.status, [r.ERR_BAD_REQUEST, r.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) : e(n) } }, 8527: (e, t, n) => { 'use strict'; const r = n(4867); const i = n(5546); e.exports = function (e, t, n) { const o = this || i; return r.forEach(n, function (n) { e = n.call(o, e, t) }), e } }, 5546: (e, t, n) => { 'use strict'; const r = n(4155); const i = n(4867); const o = n(6016); const a = n(2648); const s = n(7874); const c = n(7675); const u = { 'Content-Type': 'application/x-www-form-urlencoded' }; function l (e, t) { !i.isUndefined(e) && i.isUndefined(e['Content-Type']) && (e['Content-Type'] = t) } let d; var f = { transitional: s, adapter: ((typeof XMLHttpRequest !== 'undefined' || void 0 !== r && Object.prototype.toString.call(r) === '[object process]') && (d = n(5448)), d), transformRequest: [function (e, t) { if (o(t, 'Accept'), o(t, 'Content-Type'), i.isFormData(e) || i.isArrayBuffer(e) || i.isBuffer(e) || i.isStream(e) || i.isFile(e) || i.isBlob(e)) return e; if (i.isArrayBufferView(e)) return e.buffer; if (i.isURLSearchParams(e)) return l(t, 'application/x-www-form-urlencoded;charset=utf-8'), e.toString(); let n; const r = i.isObject(e); const a = t && t['Content-Type']; if ((n = i.isFileList(e)) || r && a === 'multipart/form-data') { const s = this.env && this.env.FormData; return c(n ? { 'files[]': e } : e, s && new s()) } return r || a === 'application/json' ? (l(t, 'application/json'), (function (e, t, n) { if (i.isString(e)) try { return (t || JSON.parse)(e), i.trim(e) } catch (e) { if (e.name !== 'SyntaxError') throw e } return (n || JSON.stringify)(e) }(e))) : e }], transformResponse: [function (e) { const t = this.transitional || f.transitional; const n = t && t.silentJSONParsing; const r = t && t.forcedJSONParsing; const o = !n && this.responseType === 'json'; if (o || r && i.isString(e) && e.length) try { return JSON.parse(e) } catch (e) { if (o) { if (e.name === 'SyntaxError') throw a.from(e, a.ERR_BAD_RESPONSE, this, null, this.response); throw e } } return e }], timeout: 0, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, maxBodyLength: -1, env: { FormData: n(1623) }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: 'application/json, text/plain, */*' } } }; i.forEach(['delete', 'get', 'head'], function (e) { f.headers[e] = {} }), i.forEach(['post', 'put', 'patch'], function (e) { f.headers[e] = i.merge(u) }), e.exports = f }, 7874: e => { 'use strict'; e.exports = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 } }, 7288: e => { e.exports = { version: '0.27.2' } }, 1849: e => { 'use strict'; e.exports = function (e, t) { return function () { for (var n = new Array(arguments.length), r = 0; r < n.length; r++)n[r] = arguments[r]; return e.apply(t, n) } } }, 5327: (e, t, n) => { 'use strict'; const r = n(4867); function i (e) { return encodeURIComponent(e).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']') }e.exports = function (e, t, n) { if (!t) return e; let o; if (n)o = n(t); else if (r.isURLSearchParams(t))o = t.toString(); else { const a = []; r.forEach(t, function (e, t) { e != null && (r.isArray(e) ? t += '[]' : e = [e], r.forEach(e, function (e) { r.isDate(e) ? e = e.toISOString() : r.isObject(e) && (e = JSON.stringify(e)), a.push(i(t) + '=' + i(e)) })) }), o = a.join('&') } if (o) { const s = e.indexOf('#'); s !== -1 && (e = e.slice(0, s)), e += (e.indexOf('?') === -1 ? '?' : '&') + o } return e } }, 7303: e => { 'use strict'; e.exports = function (e, t) { return t ? e.replace(/\/+$/, '') + '/' + t.replace(/^\/+/, '') : e } }, 4372: (e, t, n) => { 'use strict'; const r = n(4867); e.exports = r.isStandardBrowserEnv() ? { write: function (e, t, n, i, o, a) { const s = []; s.push(e + '=' + encodeURIComponent(t)), r.isNumber(n) && s.push('expires=' + new Date(n).toGMTString()), r.isString(i) && s.push('path=' + i), r.isString(o) && s.push('domain=' + o), !0 === a && s.push('secure'), document.cookie = s.join('; ') }, read: function (e) { const t = document.cookie.match(new RegExp('(^|;\\s*)(' + e + ')=([^;]*)')); return t ? decodeURIComponent(t[3]) : null }, remove: function (e) { this.write(e, '', Date.now() - 864e5) } } : { write: function () {}, read: function () { return null }, remove: function () {} } }, 1793: e => { 'use strict'; e.exports = function (e) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) } }, 6268: (e, t, n) => { 'use strict'; const r = n(4867); e.exports = function (e) { return r.isObject(e) && !0 === e.isAxiosError } }, 7985: (e, t, n) => { 'use strict'; const r = n(4867); e.exports = r.isStandardBrowserEnv() ? (function () { let e; const t = /(msie|trident)/i.test(navigator.userAgent); const n = document.createElement('a'); function i (e) { let r = e; return t && (n.setAttribute('href', r), r = n.href), n.setAttribute('href', r), { href: n.href, protocol: n.protocol ? n.protocol.replace(/:$/, '') : '', host: n.host, search: n.search ? n.search.replace(/^\?/, '') : '', hash: n.hash ? n.hash.replace(/^#/, '') : '', hostname: n.hostname, port: n.port, pathname: n.pathname.charAt(0) === '/' ? n.pathname : '/' + n.pathname } } return e = i(window.location.href), function (t) { const n = r.isString(t) ? i(t) : t; return n.protocol === e.protocol && n.host === e.host } }()) : function () { return !0 } }, 6016: (e, t, n) => { 'use strict'; const r = n(4867); e.exports = function (e, t) { r.forEach(e, function (n, r) { r !== t && r.toUpperCase() === t.toUpperCase() && (e[t] = n, delete e[r]) }) } }, 1623: e => { e.exports = null }, 4109: (e, t, n) => { 'use strict'; const r = n(4867); const i = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']; e.exports = function (e) { let t; let n; let o; const a = {}; return e ? (r.forEach(e.split('\n'), function (e) { if (o = e.indexOf(':'), t = r.trim(e.substr(0, o)).toLowerCase(), n = r.trim(e.substr(o + 1)), t) { if (a[t] && i.indexOf(t) >= 0) return; a[t] = t === 'set-cookie' ? (a[t] ? a[t] : []).concat([n]) : a[t] ? a[t] + ', ' + n : n } }), a) : a } }, 205: e => { 'use strict'; e.exports = function (e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || '' } }, 8713: e => { 'use strict'; e.exports = function (e) { return function (t) { return e.apply(null, t) } } }, 7675: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; const i = n(4867); e.exports = function (e, t) { t = t || new FormData(); const n = []; function o (e) { return e === null ? '' : i.isDate(e) ? e.toISOString() : i.isArrayBuffer(e) || i.isTypedArray(e) ? typeof Blob === 'function' ? new Blob([e]) : r.from(e) : e } return (function e (r, a) { if (i.isPlainObject(r) || i.isArray(r)) { if (n.indexOf(r) !== -1) throw Error('Circular reference detected in ' + a); n.push(r), i.forEach(r, function (n, r) { if (!i.isUndefined(n)) { let s; const c = a ? a + '.' + r : r; if (n && !a && typeof n === 'object') if (i.endsWith(r, '{}'))n = JSON.stringify(n); else if (i.endsWith(r, '[]') && (s = i.toArray(n))) return void s.forEach(function (e) { !i.isUndefined(e) && t.append(c, o(e)) }); e(n, c) } }), n.pop() } else t.append(a, o(r)) }(e)), t } }, 4875: (e, t, n) => { 'use strict'; const r = n(7288).version; const i = n(2648); const o = {}; ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (e, t) { o[e] = function (n) { return typeof n === e || 'a' + (t < 1 ? 'n ' : ' ') + e } }); const a = {}; o.transitional = function (e, t, n) { function o (e, t) { return '[Axios v' + r + "] Transitional option '" + e + "'" + t + (n ? '. ' + n : '') } return function (n, r, s) { if (!1 === e) throw new i(o(r, ' has been removed' + (t ? ' in ' + t : '')), i.ERR_DEPRECATED); return t && !a[r] && (a[r] = !0, console.warn(o(r, ' has been deprecated since v' + t + ' and will be removed in the near future'))), !e || e(n, r, s) } }, e.exports = { assertOptions: function (e, t, n) { if (typeof e !== 'object') throw new i('options must be an object', i.ERR_BAD_OPTION_VALUE); for (let r = Object.keys(e), o = r.length; o-- > 0;) { const a = r[o]; const s = t[a]; if (s) { const c = e[a]; const u = void 0 === c || s(c, a, e); if (!0 !== u) throw new i('option ' + a + ' must be ' + u, i.ERR_BAD_OPTION_VALUE) } else if (!0 !== n) throw new i('Unknown option ' + a, i.ERR_BAD_OPTION) } }, validators: o } }, 4867: (e, t, n) => { 'use strict'; let r; const i = n(1849); const o = Object.prototype.toString; const a = (r = Object.create(null), function (e) { const t = o.call(e); return r[t] || (r[t] = t.slice(8, -1).toLowerCase()) }); function s (e) { return e = e.toLowerCase(), function (t) { return a(t) === e } } function c (e) { return Array.isArray(e) } function u (e) { return void 0 === e } const l = s('ArrayBuffer'); function d (e) { return e !== null && typeof e === 'object' } function f (e) { if (a(e) !== 'object') return !1; const t = Object.getPrototypeOf(e); return t === null || t === Object.prototype } const h = s('Date'); const p = s('File'); const g = s('Blob'); const m = s('FileList'); function y (e) { return o.call(e) === '[object Function]' } const b = s('URLSearchParams'); function v (e, t) { if (e != null) if (typeof e !== 'object' && (e = [e]), c(e)) for (let n = 0, r = e.length; n < r; n++)t.call(null, e[n], n, e); else for (const i in e)Object.prototype.hasOwnProperty.call(e, i) && t.call(null, e[i], i, e) } let w; const _ = (w = typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array), function (e) { return w && e instanceof w }); e.exports = { isArray: c, isArrayBuffer: l, isBuffer: function (e) { return e !== null && !u(e) && e.constructor !== null && !u(e.constructor) && typeof e.constructor.isBuffer === 'function' && e.constructor.isBuffer(e) }, isFormData: function (e) { const t = '[object FormData]'; return e && (typeof FormData === 'function' && e instanceof FormData || o.call(e) === t || y(e.toString) && e.toString() === t) }, isArrayBufferView: function (e) { return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && l(e.buffer) }, isString: function (e) { return typeof e === 'string' }, isNumber: function (e) { return typeof e === 'number' }, isObject: d, isPlainObject: f, isUndefined: u, isDate: h, isFile: p, isBlob: g, isFunction: y, isStream: function (e) { return d(e) && y(e.pipe) }, isURLSearchParams: b, isStandardBrowserEnv: function () { return (typeof navigator === 'undefined' || navigator.product !== 'ReactNative' && navigator.product !== 'NativeScript' && navigator.product !== 'NS') && (typeof window !== 'undefined' && typeof document !== 'undefined') }, forEach: v, merge: function e () { const t = {}; function n (n, r) { f(t[r]) && f(n) ? t[r] = e(t[r], n) : f(n) ? t[r] = e({}, n) : c(n) ? t[r] = n.slice() : t[r] = n } for (let r = 0, i = arguments.length; r < i; r++)v(arguments[r], n); return t }, extend: function (e, t, n) { return v(t, function (t, r) { e[r] = n && typeof t === 'function' ? i(t, n) : t }), e }, trim: function (e) { return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, '') }, stripBOM: function (e) { return e.charCodeAt(0) === 65279 && (e = e.slice(1)), e }, inherits: function (e, t, n, r) { e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, n && Object.assign(e.prototype, n) }, toFlatObject: function (e, t, n) { let r; let i; let o; const a = {}; t = t || {}; do { for (i = (r = Object.getOwnPropertyNames(e)).length; i-- > 0;)a[o = r[i]] || (t[o] = e[o], a[o] = !0); e = Object.getPrototypeOf(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, kindOf: a, kindOfTest: s, endsWith: function (e, t, n) { e = String(e), (void 0 === n || n > e.length) && (n = e.length), n -= t.length; const r = e.indexOf(t, n); return r !== -1 && r === n }, toArray: function (e) { if (!e) return null; let t = e.length; if (u(t)) return null; for (var n = new Array(t); t-- > 0;)n[t] = e[t]; return n }, isTypedArray: _, isFileList: m } }, 8162: (e, t, n) => { 'use strict'; const r = n(9509).Buffer; e.exports = function (e) { if (e.length >= 255) throw new TypeError('Alphabet too long'); for (var t = new Uint8Array(256), n = 0; n < t.length; n++)t[n] = 255; for (let i = 0; i < e.length; i++) { const o = e.charAt(i); const a = o.charCodeAt(0); if (t[a] !== 255) throw new TypeError(o + ' is ambiguous'); t[a] = i } const s = e.length; const c = e.charAt(0); const u = Math.log(s) / Math.log(256); const l = Math.log(256) / Math.log(s); function d (e) { if (typeof e !== 'string') throw new TypeError('Expected String'); if (e.length === 0) return r.alloc(0); let n = 0; if (e[n] !== ' ') { for (var i = 0, o = 0; e[n] === c;)i++, n++; for (var a = (e.length - n) * u + 1 >>> 0, l = new Uint8Array(a); e[n];) { let d = t[e.charCodeAt(n)]; if (d === 255) return; for (var f = 0, h = a - 1; (d !== 0 || f < o) && h !== -1; h--, f++)d += s * l[h] >>> 0, l[h] = d % 256 >>> 0, d = d / 256 >>> 0; if (d !== 0) throw new Error('Non-zero carry'); o = f, n++ } if (e[n] !== ' ') { for (var p = a - o; p !== a && l[p] === 0;)p++; const g = r.allocUnsafe(i + (a - p)); g.fill(0, 0, i); for (let m = i; p !== a;)g[m++] = l[p++]; return g } } } return { encode: function (t) { if ((Array.isArray(t) || t instanceof Uint8Array) && (t = r.from(t)), !r.isBuffer(t)) throw new TypeError('Expected Buffer'); if (t.length === 0) return ''; for (var n = 0, i = 0, o = 0, a = t.length; o !== a && t[o] === 0;)o++, n++; for (var u = (a - o) * l + 1 >>> 0, d = new Uint8Array(u); o !== a;) { for (var f = t[o], h = 0, p = u - 1; (f !== 0 || h < i) && p !== -1; p--, h++)f += 256 * d[p] >>> 0, d[p] = f % s >>> 0, f = f / s >>> 0; if (f !== 0) throw new Error('Non-zero carry'); i = h, o++ } for (var g = u - i; g !== u && d[g] === 0;)g++; for (var m = c.repeat(n); g < u; ++g)m += e.charAt(d[g]); return m }, decodeUnsafe: d, decode: function (e) { const t = d(e); if (t) return t; throw new Error('Non-base' + s + ' character') } } } }, 9742: (e, t) => { 'use strict'; t.byteLength = function (e) { const t = s(e); const n = t[0]; const r = t[1]; return 3 * (n + r) / 4 - r }, t.toByteArray = function (e) { let t; let n; const o = s(e); const a = o[0]; const c = o[1]; const u = new i(function (e, t, n) { return 3 * (t + n) / 4 - n }(0, a, c)); let l = 0; const d = c > 0 ? a - 4 : a; for (n = 0; n < d; n += 4)t = r[e.charCodeAt(n)] << 18 | r[e.charCodeAt(n + 1)] << 12 | r[e.charCodeAt(n + 2)] << 6 | r[e.charCodeAt(n + 3)], u[l++] = t >> 16 & 255, u[l++] = t >> 8 & 255, u[l++] = 255 & t; c === 2 && (t = r[e.charCodeAt(n)] << 2 | r[e.charCodeAt(n + 1)] >> 4, u[l++] = 255 & t); c === 1 && (t = r[e.charCodeAt(n)] << 10 | r[e.charCodeAt(n + 1)] << 4 | r[e.charCodeAt(n + 2)] >> 2, u[l++] = t >> 8 & 255, u[l++] = 255 & t); return u }, t.fromByteArray = function (e) { for (var t, r = e.length, i = r % 3, o = [], a = 16383, s = 0, u = r - i; s < u; s += a)o.push(c(e, s, s + a > u ? u : s + a)); i === 1 ? (t = e[r - 1], o.push(n[t >> 2] + n[t << 4 & 63] + '==')) : i === 2 && (t = (e[r - 2] << 8) + e[r - 1], o.push(n[t >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + '=')); return o.join('') }; for (var n = [], r = [], i = typeof Uint8Array !== 'undefined' ? Uint8Array : Array, o = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', a = 0; a < 64; ++a)n[a] = o[a], r[o.charCodeAt(a)] = a; function s (e) { const t = e.length; if (t % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4'); let n = e.indexOf('='); return n === -1 && (n = t), [n, n === t ? 0 : 4 - n % 4] } function c (e, t, r) { for (var i, o, a = [], s = t; s < r; s += 3)i = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (255 & e[s + 2]), a.push(n[(o = i) >> 18 & 63] + n[o >> 12 & 63] + n[o >> 6 & 63] + n[63 & o]); return a.join('') }r['-'.charCodeAt(0)] = 62, r['_'.charCodeAt(0)] = 63 }, 7715: (e, t) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.bech32m = t.bech32 = void 0; const n = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'; const r = {}; for (let e = 0; e < 32; e++) { const t = n.charAt(e); r[t] = e } function i (e) { const t = e >> 25; return (33554431 & e) << 5 ^ 996825010 & -(t >> 0 & 1) ^ 642813549 & -(t >> 1 & 1) ^ 513874426 & -(t >> 2 & 1) ^ 1027748829 & -(t >> 3 & 1) ^ 705979059 & -(t >> 4 & 1) } function o (e) { let t = 1; for (let n = 0; n < e.length; ++n) { const r = e.charCodeAt(n); if (r < 33 || r > 126) return 'Invalid prefix (' + e + ')'; t = i(t) ^ r >> 5 }t = i(t); for (let n = 0; n < e.length; ++n) { const r = e.charCodeAt(n); t = i(t) ^ 31 & r } return t } function a (e, t, n, r) { let i = 0; let o = 0; const a = (1 << n) - 1; const s = []; for (let r = 0; r < e.length; ++r) for (i = i << t | e[r], o += t; o >= n;)o -= n, s.push(i >> o & a); if (r)o > 0 && s.push(i << n - o & a); else { if (o >= t) return 'Excess padding'; if (i << n - o & a) return 'Non-zero padding' } return s } function s (e) { return a(e, 8, 5, !0) } function c (e) { const t = a(e, 5, 8, !1); if (Array.isArray(t)) return t } function u (e) { const t = a(e, 5, 8, !1); if (Array.isArray(t)) return t; throw new Error(t) } function l (e) { let t; function a (e, n) { if (n = n || 90, e.length < 8) return e + ' too short'; if (e.length > n) return 'Exceeds length limit'; const a = e.toLowerCase(); const s = e.toUpperCase(); if (e !== a && e !== s) return 'Mixed-case string ' + e; const c = (e = a).lastIndexOf('1'); if (c === -1) return 'No separator character for ' + e; if (c === 0) return 'Missing prefix for ' + e; const u = e.slice(0, c); const l = e.slice(c + 1); if (l.length < 6) return 'Data too short'; let d = o(u); if (typeof d === 'string') return d; const f = []; for (let e = 0; e < l.length; ++e) { const t = l.charAt(e); const n = r[t]; if (void 0 === n) return 'Unknown character ' + t; d = i(d) ^ n, e + 6 >= l.length || f.push(n) } return d !== t ? 'Invalid checksum for ' + e : { prefix: u, words: f } } return t = e === 'bech32' ? 1 : 734539939, { decodeUnsafe: function (e, t) { const n = a(e, t); if (typeof n === 'object') return n }, decode: function (e, t) { const n = a(e, t); if (typeof n === 'object') return n; throw new Error(n) }, encode: function (e, r, a) { if (a = a || 90, e.length + 7 + r.length > a) throw new TypeError('Exceeds length limit'); let s = o(e = e.toLowerCase()); if (typeof s === 'string') throw new Error(s); let c = e + '1'; for (let e = 0; e < r.length; ++e) { const t = r[e]; if (t >> 5 != 0) throw new Error('Non 5-bit word'); s = i(s) ^ t, c += n.charAt(t) } for (let e = 0; e < 6; ++e)s = i(s); s ^= t; for (let e = 0; e < 6; ++e) { c += n.charAt(s >> 5 * (5 - e) & 31) } return c }, toWords: s, fromWordsUnsafe: c, fromWords: u } }t.bech32 = l('bech32'), t.bech32m = l('bech32m') }, 2190: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(6574); function i (e, t, n) { return r => { if (e.has(r)) return; const i = n.filter(e => e.key.toString('hex') === r)[0]; t.push(i), e.add(r) } } function o (e) { return e.globalMap.unsignedTx } function a (e) { const t = new Set(); return e.forEach(e => { const n = e.key.toString('hex'); if (t.has(n)) throw new Error('Combine: KeyValue Map keys should be unique'); t.add(n) }), t }t.combine = function (e) { const t = e[0]; const n = r.psbtToKeyVals(t); const s = e.slice(1); if (s.length === 0) throw new Error('Combine: Nothing to combine'); const c = o(t); if (void 0 === c) throw new Error('Combine: Self missing transaction'); const u = a(n.globalKeyVals); const l = n.inputKeyVals.map(a); const d = n.outputKeyVals.map(a); for (const e of s) { const t = o(e); if (void 0 === t || !t.toBuffer().equals(c.toBuffer())) throw new Error('Combine: One of the Psbts does not have the same transaction.'); const s = r.psbtToKeyVals(e); a(s.globalKeyVals).forEach(i(u, n.globalKeyVals, s.globalKeyVals)); s.inputKeyVals.map(a).forEach((e, t) => e.forEach(i(l[t], n.inputKeyVals[t], s.inputKeyVals[t]))); s.outputKeyVals.map(a).forEach((e, t) => e.forEach(i(d[t], n.outputKeyVals[t], s.outputKeyVals[t]))) } return r.psbtFromKeyVals(c, { globalMapKeyVals: n.globalKeyVals, inputKeyVals: n.inputKeyVals, outputKeyVals: n.outputKeyVals }) } }, 4041: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(1847); t.decode = function (e) { if (e.key[0] !== i.GlobalTypes.GLOBAL_XPUB) throw new Error('Decode Error: could not decode globalXpub with key 0x' + e.key.toString('hex')); if (e.key.length !== 79 || ![2, 3].includes(e.key[46])) throw new Error('Decode Error: globalXpub has invalid extended pubkey in key 0x' + e.key.toString('hex')); if (e.value.length / 4 % 1 != 0) throw new Error('Decode Error: Global GLOBAL_XPUB value length should be multiple of 4'); const t = e.key.slice(1); const n = { masterFingerprint: e.value.slice(0, 4), extendedPubkey: t, path: 'm' }; for (const t of (r = e.value.length / 4 - 1, [...Array(r).keys()])) { const r = e.value.readUInt32LE(4 * t + 4); const i = !!(2147483648 & r); const o = 2147483647 & r; n.path += '/' + o.toString(10) + (i ? "'" : '') } let r; return n }, t.encode = function (e) { const t = r.from([i.GlobalTypes.GLOBAL_XPUB]); const n = r.concat([t, e.extendedPubkey]); const o = e.path.split('/'); const a = r.allocUnsafe(4 * o.length); e.masterFingerprint.copy(a, 0); let s = 4; return o.slice(1).forEach(e => { const t = e.slice(-1) === "'"; let n = 2147483647 & parseInt(t ? e.slice(0, -1) : e, 10); t && (n += 2147483648), a.writeUInt32LE(n, s), s += 4 }), { key: n, value: a } }, t.expected = '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }', t.check = function (e) { const t = e.extendedPubkey; const n = e.masterFingerprint; const i = e.path; return r.isBuffer(t) && t.length === 78 && [2, 3].indexOf(t[45]) > -1 && r.isBuffer(n) && n.length === 4 && typeof i === 'string' && !!i.match(/^m(\/\d+'?)+$/) }, t.canAddToArray = function (e, t, n) { const r = t.extendedPubkey.toString('hex'); return !n.has(r) && (n.add(r), e.filter(e => e.extendedPubkey.equals(t.extendedPubkey)).length === 0) } }, 4480: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(1847); t.encode = function (e) { return { key: r.from([i.GlobalTypes.UNSIGNED_TX]), value: e.toBuffer() } } }, 1528: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(1847); const i = n(4041); const o = n(4480); const a = n(859); const s = n(8248); const c = n(537); const u = n(1511); const l = n(5896); const d = n(1243); const f = n(2954); const h = n(4799); const p = n(9595); const g = n(9705); const m = n(6327); const y = { unsignedTx: o, globalXpub: i, checkPubkey: p.makeChecker([]) }; t.globals = y; const b = { nonWitnessUtxo: c, partialSig: u, sighashType: d, finalScriptSig: a, finalScriptWitness: s, porCommitment: l, witnessUtxo: f, bip32Derivation: h.makeConverter(r.InputTypes.BIP32_DERIVATION), redeemScript: g.makeConverter(r.InputTypes.REDEEM_SCRIPT), witnessScript: m.makeConverter(r.InputTypes.WITNESS_SCRIPT), checkPubkey: p.makeChecker([r.InputTypes.PARTIAL_SIG, r.InputTypes.BIP32_DERIVATION]) }; t.inputs = b; const v = { bip32Derivation: h.makeConverter(r.OutputTypes.BIP32_DERIVATION), redeemScript: g.makeConverter(r.OutputTypes.REDEEM_SCRIPT), witnessScript: m.makeConverter(r.OutputTypes.WITNESS_SCRIPT), checkPubkey: p.makeChecker([r.OutputTypes.BIP32_DERIVATION]) }; t.outputs = v }, 859: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(1847); t.decode = function (e) { if (e.key[0] !== i.InputTypes.FINAL_SCRIPTSIG) throw new Error('Decode Error: could not decode finalScriptSig with key 0x' + e.key.toString('hex')); return e.value }, t.encode = function (e) { return { key: r.from([i.InputTypes.FINAL_SCRIPTSIG]), value: e } }, t.expected = 'Buffer', t.check = function (e) { return r.isBuffer(e) }, t.canAdd = function (e, t) { return !!e && !!t && void 0 === e.finalScriptSig } }, 8248: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(1847); t.decode = function (e) { if (e.key[0] !== i.InputTypes.FINAL_SCRIPTWITNESS) throw new Error('Decode Error: could not decode finalScriptWitness with key 0x' + e.key.toString('hex')); return e.value }, t.encode = function (e) { return { key: r.from([i.InputTypes.FINAL_SCRIPTWITNESS]), value: e } }, t.expected = 'Buffer', t.check = function (e) { return r.isBuffer(e) }, t.canAdd = function (e, t) { return !!e && !!t && void 0 === e.finalScriptWitness } }, 537: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(1847); t.decode = function (e) { if (e.key[0] !== i.InputTypes.NON_WITNESS_UTXO) throw new Error('Decode Error: could not decode nonWitnessUtxo with key 0x' + e.key.toString('hex')); return e.value }, t.encode = function (e) { return { key: r.from([i.InputTypes.NON_WITNESS_UTXO]), value: e } }, t.expected = 'Buffer', t.check = function (e) { return r.isBuffer(e) }, t.canAdd = function (e, t) { return !!e && !!t && void 0 === e.nonWitnessUtxo } }, 1511: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(1847); t.decode = function (e) { if (e.key[0] !== i.InputTypes.PARTIAL_SIG) throw new Error('Decode Error: could not decode partialSig with key 0x' + e.key.toString('hex')); if (e.key.length !== 34 && e.key.length !== 66 || ![2, 3, 4].includes(e.key[1])) throw new Error('Decode Error: partialSig has invalid pubkey in key 0x' + e.key.toString('hex')); return { pubkey: e.key.slice(1), signature: e.value } }, t.encode = function (e) { const t = r.from([i.InputTypes.PARTIAL_SIG]); return { key: r.concat([t, e.pubkey]), value: e.signature } }, t.expected = '{ pubkey: Buffer; signature: Buffer; }', t.check = function (e) { return r.isBuffer(e.pubkey) && r.isBuffer(e.signature) && [33, 65].includes(e.pubkey.length) && [2, 3, 4].includes(e.pubkey[0]) && (function (e) { if (!r.isBuffer(e) || e.length < 9) return !1; if (e[0] !== 48) return !1; if (e.length !== e[1] + 3) return !1; if (e[2] !== 2) return !1; const t = e[3]; if (t > 33 || t < 1) return !1; if (e[3 + t + 1] !== 2) return !1; const n = e[3 + t + 2]; return !(n > 33 || n < 1) && e.length === 3 + t + 2 + n + 2 }(e.signature)) }, t.canAddToArray = function (e, t, n) { const r = t.pubkey.toString('hex'); return !n.has(r) && (n.add(r), e.filter(e => e.pubkey.equals(t.pubkey)).length === 0) } }, 5896: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(1847); t.decode = function (e) { if (e.key[0] !== i.InputTypes.POR_COMMITMENT) throw new Error('Decode Error: could not decode porCommitment with key 0x' + e.key.toString('hex')); return e.value.toString('utf8') }, t.encode = function (e) { return { key: r.from([i.InputTypes.POR_COMMITMENT]), value: r.from(e, 'utf8') } }, t.expected = 'string', t.check = function (e) { return typeof e === 'string' }, t.canAdd = function (e, t) { return !!e && !!t && void 0 === e.porCommitment } }, 1243: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(1847); t.decode = function (e) { if (e.key[0] !== i.InputTypes.SIGHASH_TYPE) throw new Error('Decode Error: could not decode sighashType with key 0x' + e.key.toString('hex')); return e.value.readUInt32LE(0) }, t.encode = function (e) { const t = r.from([i.InputTypes.SIGHASH_TYPE]); const n = r.allocUnsafe(4); return n.writeUInt32LE(e, 0), { key: t, value: n } }, t.expected = 'number', t.check = function (e) { return typeof e === 'number' }, t.canAdd = function (e, t) { return !!e && !!t && void 0 === e.sighashType } }, 2954: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(1847); const o = n(9254); const a = n(3493); t.decode = function (e) { if (e.key[0] !== i.InputTypes.WITNESS_UTXO) throw new Error('Decode Error: could not decode witnessUtxo with key 0x' + e.key.toString('hex')); const t = o.readUInt64LE(e.value, 0); let n = 8; const r = a.decode(e.value, n); n += a.encodingLength(r); const s = e.value.slice(n); if (s.length !== r) throw new Error('Decode Error: WITNESS_UTXO script is not proper length'); return { script: s, value: t } }, t.encode = function (e) { const { script: t, value: n } = e; const s = a.encodingLength(t.length); const c = r.allocUnsafe(8 + s + t.length); return o.writeUInt64LE(c, n, 0), a.encode(t.length, c, 8), t.copy(c, 8 + s), { key: r.from([i.InputTypes.WITNESS_UTXO]), value: c } }, t.expected = '{ script: Buffer; value: number; }', t.check = function (e) { return r.isBuffer(e.script) && typeof e.value === 'number' }, t.canAdd = function (e, t) { return !!e && !!t && void 0 === e.witnessUtxo } }, 4799: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); t.makeConverter = function (e) { return { decode: function (t) { if (t.key[0] !== e) throw new Error('Decode Error: could not decode bip32Derivation with key 0x' + t.key.toString('hex')); if (t.key.length !== 34 && t.key.length !== 66 || ![2, 3, 4].includes(t.key[1])) throw new Error('Decode Error: bip32Derivation has invalid pubkey in key 0x' + t.key.toString('hex')); if (t.value.length / 4 % 1 != 0) throw new Error('Decode Error: Input BIP32_DERIVATION value length should be multiple of 4'); const n = t.key.slice(1); const r = { masterFingerprint: t.value.slice(0, 4), pubkey: n, path: 'm' }; for (const e of (i = t.value.length / 4 - 1, [...Array(i).keys()])) { const n = t.value.readUInt32LE(4 * e + 4); const i = !!(2147483648 & n); const o = 2147483647 & n; r.path += '/' + o.toString(10) + (i ? "'" : '') } let i; return r }, encode: function (t) { const n = r.from([e]); const i = r.concat([n, t.pubkey]); const o = t.path.split('/'); const a = r.allocUnsafe(4 * o.length); t.masterFingerprint.copy(a, 0); let s = 4; return o.slice(1).forEach(e => { const t = e.slice(-1) === "'"; let n = 2147483647 & parseInt(t ? e.slice(0, -1) : e, 10); t && (n += 2147483648), a.writeUInt32LE(n, s), s += 4 }), { key: i, value: a } }, check: function (e) { return r.isBuffer(e.pubkey) && r.isBuffer(e.masterFingerprint) && typeof e.path === 'string' && [33, 65].includes(e.pubkey.length) && [2, 3, 4].includes(e.pubkey[0]) && e.masterFingerprint.length === 4 }, expected: '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }', canAddToArray: function (e, t, n) { const r = t.pubkey.toString('hex'); return !n.has(r) && (n.add(r), e.filter(e => e.pubkey.equals(t.pubkey)).length === 0) } } } }, 9595: (e, t) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.makeChecker = function (e) { return function (t) { let n; if (e.includes(t.key[0]) && (n = t.key.slice(1), n.length !== 33 && n.length !== 65 || ![2, 3, 4].includes(n[0]))) throw new Error('Format Error: invalid pubkey in key 0x' + t.key.toString('hex')); return n } } }, 9705: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.makeConverter = function (e) { return { decode: function (t) { if (t.key[0] !== e) throw new Error('Decode Error: could not decode redeemScript with key 0x' + t.key.toString('hex')); return t.value }, encode: function (t) { return { key: r.from([e]), value: t } }, check: function (e) { return r.isBuffer(e) }, expected: 'Buffer', canAdd: function (e, t) { return !!e && !!t && void 0 === e.redeemScript } } } }, 6327: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.makeConverter = function (e) { return { decode: function (t) { if (t.key[0] !== e) throw new Error('Decode Error: could not decode witnessScript with key 0x' + t.key.toString('hex')); return t.value }, encode: function (t) { return { key: r.from([e]), value: t } }, check: function (e) { return r.isBuffer(e) }, expected: 'Buffer', canAdd: function (e, t) { return !!e && !!t && void 0 === e.witnessScript } } } }, 9254: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(3493); function o (e) { const t = e.key.length; const n = e.value.length; const o = i.encodingLength(t); const a = i.encodingLength(n); const s = r.allocUnsafe(o + t + a + n); return i.encode(t, s, 0), e.key.copy(s, o), i.encode(n, s, o + t), e.value.copy(s, o + t + a), s } function a (e, t) { if (typeof e !== 'number') throw new Error('cannot write a non-number as a number'); if (e < 0) throw new Error('specified a negative value for writing an unsigned value'); if (e > t) throw new Error('RangeError: value out of range'); if (Math.floor(e) !== e) throw new Error('value has a fractional component') }t.range = e => [...Array(e).keys()], t.reverseBuffer = function (e) { if (e.length < 1) return e; let t = e.length - 1; let n = 0; for (let r = 0; r < e.length / 2; r++)n = e[r], e[r] = e[t], e[t] = n, t--; return e }, t.keyValsToBuffer = function (e) { const t = e.map(o); return t.push(r.from([0])), r.concat(t) }, t.keyValToBuffer = o, t.readUInt64LE = function (e, t) { const n = e.readUInt32LE(t); let r = e.readUInt32LE(t + 4); return r *= 4294967296, a(r + n, 9007199254740991), r + n }, t.writeUInt64LE = function (e, t, n) { return a(t, 9007199254740991), e.writeInt32LE(-1 & t, n), e.writeUInt32LE(Math.floor(t / 4294967296), n + 4), n + 8 } }, 3493: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = 9007199254740991; function o (e) { if (e < 0 || e > i || e % 1 != 0) throw new RangeError('value out of range') } function a (e) { return o(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9 }t.encode = function e (t, n, i) { if (o(t), n || (n = r.allocUnsafe(a(t))), !r.isBuffer(n)) throw new TypeError('buffer must be a Buffer instance'); return i || (i = 0), t < 253 ? (n.writeUInt8(t, i), Object.assign(e, { bytes: 1 })) : t <= 65535 ? (n.writeUInt8(253, i), n.writeUInt16LE(t, i + 1), Object.assign(e, { bytes: 3 })) : t <= 4294967295 ? (n.writeUInt8(254, i), n.writeUInt32LE(t, i + 1), Object.assign(e, { bytes: 5 })) : (n.writeUInt8(255, i), n.writeUInt32LE(t >>> 0, i + 1), n.writeUInt32LE(t / 4294967296 | 0, i + 5), Object.assign(e, { bytes: 9 })), n }, t.decode = function e (t, n) { if (!r.isBuffer(t)) throw new TypeError('buffer must be a Buffer instance'); n || (n = 0); const i = t.readUInt8(n); if (i < 253) return Object.assign(e, { bytes: 1 }), i; if (i === 253) return Object.assign(e, { bytes: 3 }), t.readUInt16LE(n + 1); if (i === 254) return Object.assign(e, { bytes: 5 }), t.readUInt32LE(n + 1); { Object.assign(e, { bytes: 9 }); const r = t.readUInt32LE(n + 1); const i = 4294967296 * t.readUInt32LE(n + 5) + r; return o(i), i } }, t.encodingLength = a }, 2974: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(1528); const o = n(9254); const a = n(3493); const s = n(1847); function c (e, t, n) { if (!t.equals(r.from([n]))) throw new Error(`Format Error: Invalid ${e} key: ${t.toString('hex')}`) } function u (e, { globalMapKeyVals: t, inputKeyVals: n, outputKeyVals: r }) { const a = { unsignedTx: e }; let u = 0; for (const e of t) switch (e.key[0]) { case s.GlobalTypes.UNSIGNED_TX:if (c('global', e.key, s.GlobalTypes.UNSIGNED_TX), u > 0) throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX'); u++; break; case s.GlobalTypes.GLOBAL_XPUB:void 0 === a.globalXpub && (a.globalXpub = []), a.globalXpub.push(i.globals.globalXpub.decode(e)); break; default:a.unknownKeyVals || (a.unknownKeyVals = []), a.unknownKeyVals.push(e) } const l = n.length; const d = r.length; const f = []; const h = []; for (const e of o.range(l)) { const t = {}; for (const r of n[e]) switch (i.inputs.checkPubkey(r), r.key[0]) { case s.InputTypes.NON_WITNESS_UTXO:if (c('input', r.key, s.InputTypes.NON_WITNESS_UTXO), void 0 !== t.nonWitnessUtxo) throw new Error('Format Error: Input has multiple NON_WITNESS_UTXO'); t.nonWitnessUtxo = i.inputs.nonWitnessUtxo.decode(r); break; case s.InputTypes.WITNESS_UTXO:if (c('input', r.key, s.InputTypes.WITNESS_UTXO), void 0 !== t.witnessUtxo) throw new Error('Format Error: Input has multiple WITNESS_UTXO'); t.witnessUtxo = i.inputs.witnessUtxo.decode(r); break; case s.InputTypes.PARTIAL_SIG:void 0 === t.partialSig && (t.partialSig = []), t.partialSig.push(i.inputs.partialSig.decode(r)); break; case s.InputTypes.SIGHASH_TYPE:if (c('input', r.key, s.InputTypes.SIGHASH_TYPE), void 0 !== t.sighashType) throw new Error('Format Error: Input has multiple SIGHASH_TYPE'); t.sighashType = i.inputs.sighashType.decode(r); break; case s.InputTypes.REDEEM_SCRIPT:if (c('input', r.key, s.InputTypes.REDEEM_SCRIPT), void 0 !== t.redeemScript) throw new Error('Format Error: Input has multiple REDEEM_SCRIPT'); t.redeemScript = i.inputs.redeemScript.decode(r); break; case s.InputTypes.WITNESS_SCRIPT:if (c('input', r.key, s.InputTypes.WITNESS_SCRIPT), void 0 !== t.witnessScript) throw new Error('Format Error: Input has multiple WITNESS_SCRIPT'); t.witnessScript = i.inputs.witnessScript.decode(r); break; case s.InputTypes.BIP32_DERIVATION:void 0 === t.bip32Derivation && (t.bip32Derivation = []), t.bip32Derivation.push(i.inputs.bip32Derivation.decode(r)); break; case s.InputTypes.FINAL_SCRIPTSIG:c('input', r.key, s.InputTypes.FINAL_SCRIPTSIG), t.finalScriptSig = i.inputs.finalScriptSig.decode(r); break; case s.InputTypes.FINAL_SCRIPTWITNESS:c('input', r.key, s.InputTypes.FINAL_SCRIPTWITNESS), t.finalScriptWitness = i.inputs.finalScriptWitness.decode(r); break; case s.InputTypes.POR_COMMITMENT:c('input', r.key, s.InputTypes.POR_COMMITMENT), t.porCommitment = i.inputs.porCommitment.decode(r); break; default:t.unknownKeyVals || (t.unknownKeyVals = []), t.unknownKeyVals.push(r) }f.push(t) } for (const e of o.range(d)) { const t = {}; for (const n of r[e]) switch (i.outputs.checkPubkey(n), n.key[0]) { case s.OutputTypes.REDEEM_SCRIPT:if (c('output', n.key, s.OutputTypes.REDEEM_SCRIPT), void 0 !== t.redeemScript) throw new Error('Format Error: Output has multiple REDEEM_SCRIPT'); t.redeemScript = i.outputs.redeemScript.decode(n); break; case s.OutputTypes.WITNESS_SCRIPT:if (c('output', n.key, s.OutputTypes.WITNESS_SCRIPT), void 0 !== t.witnessScript) throw new Error('Format Error: Output has multiple WITNESS_SCRIPT'); t.witnessScript = i.outputs.witnessScript.decode(n); break; case s.OutputTypes.BIP32_DERIVATION:void 0 === t.bip32Derivation && (t.bip32Derivation = []), t.bip32Derivation.push(i.outputs.bip32Derivation.decode(n)); break; default:t.unknownKeyVals || (t.unknownKeyVals = []), t.unknownKeyVals.push(n) }h.push(t) } return { globalMap: a, inputs: f, outputs: h } }t.psbtFromBuffer = function (e, t) { let n = 0; function r () { const t = a.decode(e, n); n += a.encodingLength(t); const r = e.slice(n, n + t); return n += t, r } function i () { return { key: r(), value: r() } } function c () { if (n >= e.length) throw new Error('Format Error: Unexpected End of PSBT'); const t = e.readUInt8(n) === 0; return t && n++, t } if ((function () { const t = e.readUInt32BE(n); return n += 4, t }()) !== 1886610036) throw new Error('Format Error: Invalid Magic Number'); if ((function () { const t = e.readUInt8(n); return n += 1, t }()) !== 255) throw new Error('Format Error: Magic Number must be followed by 0xff separator'); const l = []; const d = {}; for (;!c();) { const e = i(); const t = e.key.toString('hex'); if (d[t]) throw new Error('Format Error: Keys must be unique for global keymap: key ' + t); d[t] = 1, l.push(e) } const f = l.filter(e => e.key[0] === s.GlobalTypes.UNSIGNED_TX); if (f.length !== 1) throw new Error('Format Error: Only one UNSIGNED_TX allowed'); const h = t(f[0].value); const { inputCount: p, outputCount: g } = h.getInputOutputCounts(); const m = []; const y = []; for (const e of o.range(p)) { const t = {}; const n = []; for (;!c();) { const r = i(); const o = r.key.toString('hex'); if (t[o]) throw new Error('Format Error: Keys must be unique for each input: input index ' + e + ' key ' + o); t[o] = 1, n.push(r) }m.push(n) } for (const e of o.range(g)) { const t = {}; const n = []; for (;!c();) { const r = i(); const o = r.key.toString('hex'); if (t[o]) throw new Error('Format Error: Keys must be unique for each output: output index ' + e + ' key ' + o); t[o] = 1, n.push(r) }y.push(n) } return u(h, { globalMapKeyVals: l, inputKeyVals: m, outputKeyVals: y }) }, t.checkKeyBuffer = c, t.psbtFromKeyVals = u }, 6574: (e, t, n) => { 'use strict'; function r (e) { for (const n in e)t.hasOwnProperty(n) || (t[n] = e[n]) }Object.defineProperty(t, '__esModule', { value: !0 }), r(n(2974)), r(n(5312)) }, 5312: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(1528); const o = n(9254); t.psbtToBuffer = function ({ globalMap: e, inputs: t, outputs: n }) { const { globalKeyVals: i, inputKeyVals: a, outputKeyVals: s } = c({ globalMap: e, inputs: t, outputs: n }); const u = o.keyValsToBuffer(i); const l = e => e.length === 0 ? [r.from([0])] : e.map(o.keyValsToBuffer); const d = l(a); const f = l(s); const h = r.allocUnsafe(5); return h.writeUIntBE(482972169471, 0, 5), r.concat([h, u].concat(d, f)) }; const a = (e, t) => e.key.compare(t.key); function s (e, t) { const n = new Set(); const r = Object.entries(e).reduce((e, [r, i]) => { if (r === 'unknownKeyVals') return e; const o = t[r]; if (void 0 === o) return e; const a = (Array.isArray(i) ? i : [i]).map(o.encode); return a.map(e => e.key.toString('hex')).forEach(e => { if (n.has(e)) throw new Error('Serialize Error: Duplicate key: ' + e); n.add(e) }), e.concat(a) }, []); const i = e.unknownKeyVals ? e.unknownKeyVals.filter(e => !n.has(e.key.toString('hex'))) : []; return r.concat(i).sort(a) } function c ({ globalMap: e, inputs: t, outputs: n }) { return { globalKeyVals: s(e, i.globals), inputKeyVals: t.map(e => s(e, i.inputs)), outputKeyVals: n.map(e => s(e, i.outputs)) } }t.psbtToKeyVals = c }, 5011: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(2190); const o = n(6574); const a = n(1847); const s = n(1532); t.Psbt = class {constructor (e) { this.inputs = [], this.outputs = [], this.globalMap = { unsignedTx: e } } static fromBase64 (e, t) { const n = r.from(e, 'base64'); return this.fromBuffer(n, t) } static fromHex (e, t) { const n = r.from(e, 'hex'); return this.fromBuffer(n, t) } static fromBuffer (e, t) { const n = o.psbtFromBuffer(e, t); const r = new this(n.globalMap.unsignedTx); return Object.assign(r, n), r }toBase64 () { return this.toBuffer().toString('base64') }toHex () { return this.toBuffer().toString('hex') }toBuffer () { return o.psbtToBuffer(this) }updateGlobal (e) { return s.updateGlobal(e, this.globalMap), this }updateInput (e, t) { const n = s.checkForInput(this.inputs, e); return s.updateInput(t, n), this }updateOutput (e, t) { const n = s.checkForOutput(this.outputs, e); return s.updateOutput(t, n), this }addUnknownKeyValToGlobal (e) { return s.checkHasKey(e, this.globalMap.unknownKeyVals, s.getEnumLength(a.GlobalTypes)), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(e), this }addUnknownKeyValToInput (e, t) { const n = s.checkForInput(this.inputs, e); return s.checkHasKey(t, n.unknownKeyVals, s.getEnumLength(a.InputTypes)), n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(t), this }addUnknownKeyValToOutput (e, t) { const n = s.checkForOutput(this.outputs, e); return s.checkHasKey(t, n.unknownKeyVals, s.getEnumLength(a.OutputTypes)), n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(t), this }addInput (e) { this.globalMap.unsignedTx.addInput(e), this.inputs.push({ unknownKeyVals: [] }); const t = e.unknownKeyVals || []; const n = this.inputs.length - 1; if (!Array.isArray(t)) throw new Error('unknownKeyVals must be an Array'); return t.forEach(e => this.addUnknownKeyValToInput(n, e)), s.addInputAttributes(this.inputs, e), this }addOutput (e) { this.globalMap.unsignedTx.addOutput(e), this.outputs.push({ unknownKeyVals: [] }); const t = e.unknownKeyVals || []; const n = this.outputs.length - 1; if (!Array.isArray(t)) throw new Error('unknownKeyVals must be an Array'); return t.forEach(e => this.addUnknownKeyValToInput(n, e)), s.addOutputAttributes(this.outputs, e), this }clearFinalizedInput (e) { const t = s.checkForInput(this.inputs, e); s.inputCheckUncleanFinalized(e, t); for (const e of Object.keys(t))['witnessUtxo', 'nonWitnessUtxo', 'finalScriptSig', 'finalScriptWitness', 'unknownKeyVals'].includes(e) || delete t[e]; return this }combine (...e) { const t = i.combine([this].concat(e)); return Object.assign(this, t), this }getTransaction () { return this.globalMap.unsignedTx.toBuffer() }} }, 1847: (e, t) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), (function (e) { e[e.UNSIGNED_TX = 0] = 'UNSIGNED_TX', e[e.GLOBAL_XPUB = 1] = 'GLOBAL_XPUB' }(t.GlobalTypes || (t.GlobalTypes = {}))), t.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'], (function (e) { e[e.NON_WITNESS_UTXO = 0] = 'NON_WITNESS_UTXO', e[e.WITNESS_UTXO = 1] = 'WITNESS_UTXO', e[e.PARTIAL_SIG = 2] = 'PARTIAL_SIG', e[e.SIGHASH_TYPE = 3] = 'SIGHASH_TYPE', e[e.REDEEM_SCRIPT = 4] = 'REDEEM_SCRIPT', e[e.WITNESS_SCRIPT = 5] = 'WITNESS_SCRIPT', e[e.BIP32_DERIVATION = 6] = 'BIP32_DERIVATION', e[e.FINAL_SCRIPTSIG = 7] = 'FINAL_SCRIPTSIG', e[e.FINAL_SCRIPTWITNESS = 8] = 'FINAL_SCRIPTWITNESS', e[e.POR_COMMITMENT = 9] = 'POR_COMMITMENT' }(t.InputTypes || (t.InputTypes = {}))), t.INPUT_TYPE_NAMES = ['nonWitnessUtxo', 'witnessUtxo', 'partialSig', 'sighashType', 'redeemScript', 'witnessScript', 'bip32Derivation', 'finalScriptSig', 'finalScriptWitness', 'porCommitment'], (function (e) { e[e.REDEEM_SCRIPT = 0] = 'REDEEM_SCRIPT', e[e.WITNESS_SCRIPT = 1] = 'WITNESS_SCRIPT', e[e.BIP32_DERIVATION = 2] = 'BIP32_DERIVATION' }(t.OutputTypes || (t.OutputTypes = {}))), t.OUTPUT_TYPE_NAMES = ['redeemScript', 'witnessScript', 'bip32Derivation'] }, 1532: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(1528); function o (e, t) { const n = e[t]; if (void 0 === n) throw new Error(`No input #${t}`); return n } function a (e, t, n, r) { throw new Error(`Data for ${e} key ${t} is incorrect: Expected ${n} and got ${JSON.stringify(r)}`) } function s (e) { return (t, n) => { for (const r of Object.keys(t)) { const o = t[r]; const { canAdd: s, canAddToArray: c, check: u, expected: l } = i[e + 's'][r] || {}; if (u) if (c) { if (!Array.isArray(o) || n[r] && !Array.isArray(n[r])) throw new Error(`Key type ${r} must be an array`); o.every(u) || a(e, r, l, o); const t = n[r] || []; const i = new Set(); if (!o.every(e => c(t, e, i))) throw new Error('Can not add duplicate data to array'); n[r] = t.concat(o) } else { if (u(o) || a(e, r, l, o), !s(n, o)) throw new Error(`Can not add duplicate data to ${e}`); n[r] = o } } } }t.checkForInput = o, t.checkForOutput = function (e, t) { const n = e[t]; if (void 0 === n) throw new Error(`No output #${t}`); return n }, t.checkHasKey = function (e, t, n) { if (e.key[0] < n) throw new Error('Use the method for your specific key instead of addUnknownKeyVal*'); if (t && t.filter(t => t.key.equals(e.key)).length !== 0) throw new Error(`Duplicate Key: ${e.key.toString('hex')}`) }, t.getEnumLength = function (e) { let t = 0; return Object.keys(e).forEach(e => { Number(isNaN(Number(e))) && t++ }), t }, t.inputCheckUncleanFinalized = function (e, t) { let n = !1; if (t.nonWitnessUtxo || t.witnessUtxo) { const e = !!t.redeemScript; const r = !!t.witnessScript; const i = !e || !!t.finalScriptSig; const o = !r || !!t.finalScriptWitness; const a = !!t.finalScriptSig || !!t.finalScriptWitness; n = i && o && a } if (!1 === n) throw new Error(`Input #${e} has too much or too little data to clean`) }, t.updateGlobal = s('global'), t.updateInput = s('input'), t.updateOutput = s('output'), t.addInputAttributes = function (e, n) { const r = o(e, e.length - 1); t.updateInput(n, r) }, t.addOutputAttributes = function (e, n) { const r = o(e, e.length - 1); t.updateOutput(n, r) }, t.defaultVersionSetter = function (e, t) { if (!r.isBuffer(t) || t.length < 4) throw new Error('Set Version: Invalid Transaction'); return t.writeUInt32LE(e, 0), t }, t.defaultLocktimeSetter = function (e, t) { if (!r.isBuffer(t) || t.length < 4) throw new Error('Set Locktime: Invalid Transaction'); return t.writeUInt32LE(e, t.length - 4), t } }, 5488: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.toOutputScript = t.fromOutputScript = t.toBech32 = t.toBase58Check = t.fromBech32 = t.fromBase58Check = void 0; const i = n(4378); const o = n(3348); const a = n(3357); const s = n(1838); const c = n(7715); const u = n(8334); const { typeforce: l } = s; const d = 40; const f = 2; const h = 16; const p = 1; const g = 80; const m = 'WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.'; function y (e) { const t = u.decode(e); if (t.length < 21) throw new TypeError(e + ' is too short'); if (t.length > 21) throw new TypeError(e + ' is too long'); return { version: t.readUInt8(0), hash: t.slice(1) } } function b (e) { let t, n; try { t = c.bech32.decode(e) } catch (e) {} if (t) { if (n = t.words[0], n !== 0) throw new TypeError(e + ' uses wrong encoding') } else if (t = c.bech32m.decode(e), n = t.words[0], n === 0) throw new TypeError(e + ' uses wrong encoding'); const i = c.bech32.fromWords(t.words.slice(1)); return { version: n, prefix: t.prefix, data: r.from(i) } } function v (e, t, n) { const r = c.bech32.toWords(e); return r.unshift(t), t === 0 ? c.bech32.encode(n, r) : c.bech32m.encode(n, r) }t.fromBase58Check = y, t.fromBech32 = b, t.toBase58Check = function (e, t) { l(s.tuple(s.Hash160bit, s.UInt8), arguments); const n = r.allocUnsafe(21); return n.writeUInt8(t, 0), e.copy(n, 1), u.encode(n) }, t.toBech32 = v, t.fromOutputScript = function (e, t) { t = t || i.bitcoin; try { return o.p2pkh({ output: e, network: t }).address } catch (e) {} try { return o.p2sh({ output: e, network: t }).address } catch (e) {} try { return o.p2wpkh({ output: e, network: t }).address } catch (e) {} try { return o.p2wsh({ output: e, network: t }).address } catch (e) {} try { return (function (e, t) { const n = e.slice(2); if (n.length < f || n.length > d) throw new TypeError('Invalid program length for segwit address'); const r = e[0] - g; if (r < p || r > h) throw new TypeError('Invalid version for segwit address'); if (e[1] !== n.length) throw new TypeError('Invalid script for segwit address'); return console.warn(m), v(n, r, t.bech32) }(e, t)) } catch (e) {} throw new Error(a.toASM(e) + ' has no matching Address') }, t.toOutputScript = function (e, t) { let n, r; t = t || i.bitcoin; try { n = y(e) } catch (e) {} if (n) { if (n.version === t.pubKeyHash) return o.p2pkh({ hash: n.hash }).output; if (n.version === t.scriptHash) return o.p2sh({ hash: n.hash }).output } else { try { r = b(e) } catch (e) {} if (r) { if (r.prefix !== t.bech32) throw new Error(e + ' has an invalid prefix'); if (r.version === 0) { if (r.data.length === 20) return o.p2wpkh({ hash: r.data }).output; if (r.data.length === 32) return o.p2wsh({ hash: r.data }).output } else if (r.version >= p && r.version <= h && r.data.length >= f && r.data.length <= d) return console.warn(m), a.compile([r.version + g, r.data]) } } throw new Error(e + ' has no matching Script') } }, 7617: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.encode = t.decode = t.check = void 0, t.check = function (e) { if (e.length < 8) return !1; if (e.length > 72) return !1; if (e[0] !== 48) return !1; if (e[1] !== e.length - 2) return !1; if (e[2] !== 2) return !1; const t = e[3]; if (t === 0) return !1; if (5 + t >= e.length) return !1; if (e[4 + t] !== 2) return !1; const n = e[5 + t]; return n !== 0 && (6 + t + n === e.length && (!(128 & e[4]) && (!(t > 1 && e[4] === 0 && !(128 & e[5])) && (!(128 & e[t + 6]) && !(n > 1 && e[t + 6] === 0 && !(128 & e[t + 7])))))) }, t.decode = function (e) { if (e.length < 8) throw new Error('DER sequence length is too short'); if (e.length > 72) throw new Error('DER sequence length is too long'); if (e[0] !== 48) throw new Error('Expected DER sequence'); if (e[1] !== e.length - 2) throw new Error('DER sequence length is invalid'); if (e[2] !== 2) throw new Error('Expected DER integer'); const t = e[3]; if (t === 0) throw new Error('R length is zero'); if (5 + t >= e.length) throw new Error('R length is too long'); if (e[4 + t] !== 2) throw new Error('Expected DER integer (2)'); const n = e[5 + t]; if (n === 0) throw new Error('S length is zero'); if (6 + t + n !== e.length) throw new Error('S length is invalid'); if (128 & e[4]) throw new Error('R value is negative'); if (t > 1 && e[4] === 0 && !(128 & e[5])) throw new Error('R value excessively padded'); if (128 & e[t + 6]) throw new Error('S value is negative'); if (n > 1 && e[t + 6] === 0 && !(128 & e[t + 7])) throw new Error('S value excessively padded'); return { r: e.slice(4, 4 + t), s: e.slice(6 + t) } }, t.encode = function (e, t) { const n = e.length; const i = t.length; if (n === 0) throw new Error('R length is zero'); if (i === 0) throw new Error('S length is zero'); if (n > 33) throw new Error('R length is too long'); if (i > 33) throw new Error('S length is too long'); if (128 & e[0]) throw new Error('R value is negative'); if (128 & t[0]) throw new Error('S value is negative'); if (n > 1 && e[0] === 0 && !(128 & e[1])) throw new Error('R value excessively padded'); if (i > 1 && t[0] === 0 && !(128 & t[1])) throw new Error('S value excessively padded'); const o = r.allocUnsafe(6 + n + i); return o[0] = 48, o[1] = o.length - 2, o[2] = 2, o[3] = e.length, e.copy(o, 4), o[4 + n] = 2, o[5 + n] = t.length, t.copy(o, 6 + n), o } }, 7949: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.Block = void 0; const i = n(9357); const o = n(5525); const a = n(5381); const s = n(2737); const c = n(1838); const { typeforce: u } = c; const l = new TypeError('Cannot compute merkle root for zero transactions'); const d = new TypeError('Cannot compute witness commit for non-segwit block'); class f {constructor () { this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0 } static fromBuffer (e) { if (e.length < 80) throw new Error('Buffer too small (< 80 bytes)'); const t = new i.BufferReader(e); const n = new f(); if (n.version = t.readInt32(), n.prevHash = t.readSlice(32), n.merkleRoot = t.readSlice(32), n.timestamp = t.readUInt32(), n.bits = t.readUInt32(), n.nonce = t.readUInt32(), e.length === 80) return n; const r = () => { const e = s.Transaction.fromBuffer(t.buffer.slice(t.offset), !0); return t.offset += e.byteLength(), e }; const o = t.readVarInt(); n.transactions = []; for (let e = 0; e < o; ++e) { const e = r(); n.transactions.push(e) } const a = n.getWitnessCommit(); return a && (n.witnessCommit = a), n } static fromHex (e) { return f.fromBuffer(r.from(e, 'hex')) } static calculateTarget (e) { const t = ((4278190080 & e) >> 24) - 3; const n = 8388607 & e; const i = r.alloc(32, 0); return i.writeUIntBE(n, 29 - t, 3), i } static calculateMerkleRoot (e, t) { if (u([{ getHash: c.Function }], e), e.length === 0) throw l; if (t && !h(e)) throw d; const n = e.map(e => e.getHash(t)); const i = (0, a.fastMerkleRoot)(n, o.hash256); return t ? o.hash256(r.concat([i, e[0].ins[0].witness[0]])) : i }getWitnessCommit () { if (!h(this.transactions)) return null; const e = this.transactions[0].outs.filter(e => e.script.slice(0, 6).equals(r.from('6a24aa21a9ed', 'hex'))).map(e => e.script.slice(6, 38)); if (e.length === 0) return null; const t = e[e.length - 1]; return t instanceof r && t.length === 32 ? t : null }hasWitnessCommit () { return this.witnessCommit instanceof r && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null }hasWitness () { return (e = this.transactions) instanceof Array && e.some(e => typeof e === 'object' && e.ins instanceof Array && e.ins.some(e => typeof e === 'object' && e.witness instanceof Array && e.witness.length > 0)); let e }weight () { return 3 * this.byteLength(!1, !1) + this.byteLength(!1, !0) }byteLength (e, t = !0) { return e || !this.transactions ? 80 : 80 + i.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((e, n) => e + n.byteLength(t), 0) }getHash () { return o.hash256(this.toBuffer(!0)) }getId () { return (0, i.reverseBuffer)(this.getHash()).toString('hex') }getUTCDate () { const e = new Date(0); return e.setUTCSeconds(this.timestamp), e }toBuffer (e) { const t = r.allocUnsafe(this.byteLength(e)); const n = new i.BufferWriter(t); return n.writeInt32(this.version), n.writeSlice(this.prevHash), n.writeSlice(this.merkleRoot), n.writeUInt32(this.timestamp), n.writeUInt32(this.bits), n.writeUInt32(this.nonce), e || !this.transactions || (i.varuint.encode(this.transactions.length, t, n.offset), n.offset += i.varuint.encode.bytes, this.transactions.forEach(e => { const r = e.byteLength(); e.toBuffer(t, n.offset), n.offset += r })), t }toHex (e) { return this.toBuffer(e).toString('hex') }checkTxRoots () { const e = this.hasWitnessCommit(); return !(!e && this.hasWitness()) && (this.__checkMerkleRoot() && (!e || this.__checkWitnessCommit())) }checkProofOfWork () { const e = (0, i.reverseBuffer)(this.getHash()); const t = f.calculateTarget(this.bits); return e.compare(t) <= 0 }__checkMerkleRoot () { if (!this.transactions) throw l; const e = f.calculateMerkleRoot(this.transactions); return this.merkleRoot.compare(e) === 0 }__checkWitnessCommit () { if (!this.transactions) throw l; if (!this.hasWitnessCommit()) throw d; const e = f.calculateMerkleRoot(this.transactions, !0); return this.witnessCommit.compare(e) === 0 }} function h (e) { return e instanceof Array && e[0] && e[0].ins && e[0].ins instanceof Array && e[0].ins[0] && e[0].ins[0].witness && e[0].ins[0].witness instanceof Array && e[0].ins[0].witness.length > 0 }t.Block = f }, 9357: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.BufferReader = t.BufferWriter = t.cloneBuffer = t.reverseBuffer = t.writeUInt64LE = t.readUInt64LE = t.varuint = void 0; const i = n(1838); const { typeforce: o } = i; const a = n(7795); function s (e, t) { if (typeof e !== 'number') throw new Error('cannot write a non-number as a number'); if (e < 0) throw new Error('specified a negative value for writing an unsigned value'); if (e > t) throw new Error('RangeError: value out of range'); if (Math.floor(e) !== e) throw new Error('value has a fractional component') } function c (e, t) { const n = e.readUInt32LE(t); let r = e.readUInt32LE(t + 4); return r *= 4294967296, s(r + n, 9007199254740991), r + n } function u (e, t, n) { return s(t, 9007199254740991), e.writeInt32LE(-1 & t, n), e.writeUInt32LE(Math.floor(t / 4294967296), n + 4), n + 8 }t.varuint = a, t.readUInt64LE = c, t.writeUInt64LE = u, t.reverseBuffer = function (e) { if (e.length < 1) return e; let t = e.length - 1; let n = 0; for (let r = 0; r < e.length / 2; r++)n = e[r], e[r] = e[t], e[t] = n, t--; return e }, t.cloneBuffer = function (e) { const t = r.allocUnsafe(e.length); return e.copy(t), t }; class l {constructor (e, t = 0) { this.buffer = e, this.offset = t, o(i.tuple(i.Buffer, i.UInt32), [e, t]) } static withCapacity (e) { return new l(r.alloc(e)) }writeUInt8 (e) { this.offset = this.buffer.writeUInt8(e, this.offset) }writeInt32 (e) { this.offset = this.buffer.writeInt32LE(e, this.offset) }writeUInt32 (e) { this.offset = this.buffer.writeUInt32LE(e, this.offset) }writeUInt64 (e) { this.offset = u(this.buffer, e, this.offset) }writeVarInt (e) { a.encode(e, this.buffer, this.offset), this.offset += a.encode.bytes }writeSlice (e) { if (this.buffer.length < this.offset + e.length) throw new Error('Cannot write slice out of bounds'); this.offset += e.copy(this.buffer, this.offset) }writeVarSlice (e) { this.writeVarInt(e.length), this.writeSlice(e) }writeVector (e) { this.writeVarInt(e.length), e.forEach(e => this.writeVarSlice(e)) }end () { if (this.buffer.length === this.offset) return this.buffer; throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`) }}t.BufferWriter = l; t.BufferReader = class {constructor (e, t = 0) { this.buffer = e, this.offset = t, o(i.tuple(i.Buffer, i.UInt32), [e, t]) }readUInt8 () { const e = this.buffer.readUInt8(this.offset); return this.offset++, e }readInt32 () { const e = this.buffer.readInt32LE(this.offset); return this.offset += 4, e }readUInt32 () { const e = this.buffer.readUInt32LE(this.offset); return this.offset += 4, e }readUInt64 () { const e = c(this.buffer, this.offset); return this.offset += 8, e }readVarInt () { const e = a.decode(this.buffer, this.offset); return this.offset += a.decode.bytes, e }readSlice (e) { if (this.buffer.length < this.offset + e) throw new Error('Cannot read slice out of bounds'); const t = this.buffer.slice(this.offset, this.offset + e); return this.offset += e, t }readVarSlice () { return this.readSlice(this.readVarInt()) }readVector () { const e = this.readVarInt(); const t = []; for (let n = 0; n < e; n++)t.push(this.readVarSlice()); return t }} }, 5525: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.taggedHash = t.hash256 = t.hash160 = t.sha256 = t.sha1 = t.ripemd160 = void 0; const i = n(3482); function o (e) { try { return i('rmd160').update(e).digest() } catch (t) { return i('ripemd160').update(e).digest() } } function a (e) { return i('sha256').update(e).digest() }t.ripemd160 = o, t.sha1 = function (e) { return i('sha1').update(e).digest() }, t.sha256 = a, t.hash160 = function (e) { return o(a(e)) }, t.hash256 = function (e) { return a(a(e)) }; const s = Object.fromEntries(['BIP0340/challenge', 'BIP0340/aux', 'BIP0340/nonce', 'TapLeaf', 'TapBranch', 'TapSighash', 'TapTweak', 'KeyAgg list', 'KeyAgg coefficient'].map(e => { const t = a(r.from(e)); return [e, r.concat([t, t])] })); t.taggedHash = function (e, t) { return a(r.concat([s[e], t])) } }, 7656: (e, t, n) => { 'use strict'; t.Lk = void 0; const r = n(5488); t.Lk = r; n(5525); n(4378); n(3348); n(3357); const i = n(7949); const o = n(9930); const a = n(7334); const s = n(2737) }, 5381: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.fastMerkleRoot = void 0, t.fastMerkleRoot = function (e, t) { if (!Array.isArray(e)) throw TypeError('Expected values Array'); if (typeof t !== 'function') throw TypeError('Expected digest Function'); let n = e.length; const i = e.concat(); for (;n > 1;) { let e = 0; for (let o = 0; o < n; o += 2, ++e) { const a = i[o]; const s = o + 1 === n ? a : i[o + 1]; const c = r.concat([a, s]); i[e] = t(c) }n = e } return i[0] } }, 4378: (e, t) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.testnet = t.regtest = t.bitcoin = void 0, t.bitcoin = { messagePrefix: 'Bitcoin Signed Message:\n', bech32: 'bc', bip32: { public: 76067358, private: 76066276 }, pubKeyHash: 0, scriptHash: 5, wif: 128 }, t.regtest = { messagePrefix: 'Bitcoin Signed Message:\n', bech32: 'bcrt', bip32: { public: 70617039, private: 70615956 }, pubKeyHash: 111, scriptHash: 196, wif: 239 }, t.testnet = { messagePrefix: 'Bitcoin Signed Message:\n', bech32: 'tb', bip32: { public: 70617039, private: 70615956 }, pubKeyHash: 111, scriptHash: 196, wif: 239 } }, 7334: (e, t) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.REVERSE_OPS = t.OPS = void 0; const n = { OP_FALSE: 0, OP_0: 0, OP_PUSHDATA1: 76, OP_PUSHDATA2: 77, OP_PUSHDATA4: 78, OP_1NEGATE: 79, OP_RESERVED: 80, OP_TRUE: 81, OP_1: 81, OP_2: 82, OP_3: 83, OP_4: 84, OP_5: 85, OP_6: 86, OP_7: 87, OP_8: 88, OP_9: 89, OP_10: 90, OP_11: 91, OP_12: 92, OP_13: 93, OP_14: 94, OP_15: 95, OP_16: 96, OP_NOP: 97, OP_VER: 98, OP_IF: 99, OP_NOTIF: 100, OP_VERIF: 101, OP_VERNOTIF: 102, OP_ELSE: 103, OP_ENDIF: 104, OP_VERIFY: 105, OP_RETURN: 106, OP_TOALTSTACK: 107, OP_FROMALTSTACK: 108, OP_2DROP: 109, OP_2DUP: 110, OP_3DUP: 111, OP_2OVER: 112, OP_2ROT: 113, OP_2SWAP: 114, OP_IFDUP: 115, OP_DEPTH: 116, OP_DROP: 117, OP_DUP: 118, OP_NIP: 119, OP_OVER: 120, OP_PICK: 121, OP_ROLL: 122, OP_ROT: 123, OP_SWAP: 124, OP_TUCK: 125, OP_CAT: 126, OP_SUBSTR: 127, OP_LEFT: 128, OP_RIGHT: 129, OP_SIZE: 130, OP_INVERT: 131, OP_AND: 132, OP_OR: 133, OP_XOR: 134, OP_EQUAL: 135, OP_EQUALVERIFY: 136, OP_RESERVED1: 137, OP_RESERVED2: 138, OP_1ADD: 139, OP_1SUB: 140, OP_2MUL: 141, OP_2DIV: 142, OP_NEGATE: 143, OP_ABS: 144, OP_NOT: 145, OP_0NOTEQUAL: 146, OP_ADD: 147, OP_SUB: 148, OP_MUL: 149, OP_DIV: 150, OP_MOD: 151, OP_LSHIFT: 152, OP_RSHIFT: 153, OP_BOOLAND: 154, OP_BOOLOR: 155, OP_NUMEQUAL: 156, OP_NUMEQUALVERIFY: 157, OP_NUMNOTEQUAL: 158, OP_LESSTHAN: 159, OP_GREATERTHAN: 160, OP_LESSTHANOREQUAL: 161, OP_GREATERTHANOREQUAL: 162, OP_MIN: 163, OP_MAX: 164, OP_WITHIN: 165, OP_RIPEMD160: 166, OP_SHA1: 167, OP_SHA256: 168, OP_HASH160: 169, OP_HASH256: 170, OP_CODESEPARATOR: 171, OP_CHECKSIG: 172, OP_CHECKSIGVERIFY: 173, OP_CHECKMULTISIG: 174, OP_CHECKMULTISIGVERIFY: 175, OP_NOP1: 176, OP_NOP2: 177, OP_CHECKLOCKTIMEVERIFY: 177, OP_NOP3: 178, OP_CHECKSEQUENCEVERIFY: 178, OP_NOP4: 179, OP_NOP5: 180, OP_NOP6: 181, OP_NOP7: 182, OP_NOP8: 183, OP_NOP9: 184, OP_NOP10: 185, OP_PUBKEYHASH: 253, OP_PUBKEY: 254, OP_INVALIDOPCODE: 255 }; t.OPS = n; const r = {}; t.REVERSE_OPS = r; for (const e of Object.keys(n)) { r[n[e]] = e } }, 6648: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.p2data = void 0; const r = n(4378); const i = n(3357); const o = n(1838); const a = n(2691); const s = i.OPS; t.p2data = function (e, t) { if (!e.data && !e.output) throw new TypeError('Not enough data'); t = Object.assign({ validate: !0 }, t || {}), (0, o.typeforce)({ network: o.typeforce.maybe(o.typeforce.Object), output: o.typeforce.maybe(o.typeforce.Buffer), data: o.typeforce.maybe(o.typeforce.arrayOf(o.typeforce.Buffer)) }, e); const n = { name: 'embed', network: e.network || r.bitcoin }; if (a.prop(n, 'output', () => { if (e.data) return i.compile([s.OP_RETURN].concat(e.data)) }), a.prop(n, 'data', () => { if (e.output) return i.decompile(e.output).slice(1) }), t.validate && e.output) { const t = i.decompile(e.output); if (t[0] !== s.OP_RETURN) throw new TypeError('Output is invalid'); if (!t.slice(1).every(o.typeforce.Buffer)) throw new TypeError('Output is invalid'); if (e.data && !(function (e, t) { return e.length === t.length && e.every((e, n) => e.equals(t[n])) }(e.data, n.data))) throw new TypeError('Data mismatch') } return Object.assign(n, e) } }, 3348: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.p2wsh = t.p2wpkh = t.p2sh = t.p2pkh = t.p2pk = t.p2ms = t.embed = void 0; const r = n(6648); Object.defineProperty(t, 'embed', { enumerable: !0, get: function () { return r.p2data } }); const i = n(8793); Object.defineProperty(t, 'p2ms', { enumerable: !0, get: function () { return i.p2ms } }); const o = n(7759); Object.defineProperty(t, 'p2pk', { enumerable: !0, get: function () { return o.p2pk } }); const a = n(4483); Object.defineProperty(t, 'p2pkh', { enumerable: !0, get: function () { return a.p2pkh } }); const s = n(1160); Object.defineProperty(t, 'p2sh', { enumerable: !0, get: function () { return s.p2sh } }); const c = n(8810); Object.defineProperty(t, 'p2wpkh', { enumerable: !0, get: function () { return c.p2wpkh } }); const u = n(6924); Object.defineProperty(t, 'p2wsh', { enumerable: !0, get: function () { return u.p2wsh } }) }, 2691: (e, t) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.value = t.prop = void 0, t.prop = function (e, t, n) { Object.defineProperty(e, t, { configurable: !0, enumerable: !0, get () { const e = n.call(this); return this[t] = e, e }, set (e) { Object.defineProperty(this, t, { configurable: !0, enumerable: !0, value: e, writable: !0 }) } }) }, t.value = function (e) { let t; return () => (void 0 !== t || (t = e()), t) } }, 8793: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.p2ms = void 0; const r = n(4378); const i = n(3357); const o = n(1838); const a = n(2691); const s = i.OPS; const c = s.OP_RESERVED; function u (e, t) { return e.length === t.length && e.every((e, n) => e.equals(t[n])) }t.p2ms = function (e, t) { if (!(e.input || e.output || e.pubkeys && void 0 !== e.m || e.signatures)) throw new TypeError('Not enough data'); function n (e) { return i.isCanonicalScriptSignature(e) || void 0 !== (t.allowIncomplete && e === s.OP_0) }t = Object.assign({ validate: !0 }, t || {}), (0, o.typeforce)({ network: o.typeforce.maybe(o.typeforce.Object), m: o.typeforce.maybe(o.typeforce.Number), n: o.typeforce.maybe(o.typeforce.Number), output: o.typeforce.maybe(o.typeforce.Buffer), pubkeys: o.typeforce.maybe(o.typeforce.arrayOf(o.isPoint)), signatures: o.typeforce.maybe(o.typeforce.arrayOf(n)), input: o.typeforce.maybe(o.typeforce.Buffer) }, e); const l = { network: e.network || r.bitcoin }; let d = []; let f = !1; function h (e) { f || (f = !0, d = i.decompile(e), l.m = d[0] - c, l.n = d[d.length - 2] - c, l.pubkeys = d.slice(1, -2)) } if (a.prop(l, 'output', () => { if (e.m && l.n && e.pubkeys) return i.compile([].concat(c + e.m, e.pubkeys, c + l.n, s.OP_CHECKMULTISIG)) }), a.prop(l, 'm', () => { if (l.output) return h(l.output), l.m }), a.prop(l, 'n', () => { if (l.pubkeys) return l.pubkeys.length }), a.prop(l, 'pubkeys', () => { if (e.output) return h(e.output), l.pubkeys }), a.prop(l, 'signatures', () => { if (e.input) return i.decompile(e.input).slice(1) }), a.prop(l, 'input', () => { if (e.signatures) return i.compile([s.OP_0].concat(e.signatures)) }), a.prop(l, 'witness', () => { if (l.input) return [] }), a.prop(l, 'name', () => { if (l.m && l.n) return `p2ms(${l.m} of ${l.n})` }), t.validate) { if (e.output) { if (h(e.output), !o.typeforce.Number(d[0])) throw new TypeError('Output is invalid'); if (!o.typeforce.Number(d[d.length - 2])) throw new TypeError('Output is invalid'); if (d[d.length - 1] !== s.OP_CHECKMULTISIG) throw new TypeError('Output is invalid'); if (l.m <= 0 || l.n > 16 || l.m > l.n || l.n !== d.length - 3) throw new TypeError('Output is invalid'); if (!l.pubkeys.every(e => (0, o.isPoint)(e))) throw new TypeError('Output is invalid'); if (void 0 !== e.m && e.m !== l.m) throw new TypeError('m mismatch'); if (void 0 !== e.n && e.n !== l.n) throw new TypeError('n mismatch'); if (e.pubkeys && !u(e.pubkeys, l.pubkeys)) throw new TypeError('Pubkeys mismatch') } if (e.pubkeys) { if (void 0 !== e.n && e.n !== e.pubkeys.length) throw new TypeError('Pubkey count mismatch'); if (l.n = e.pubkeys.length, l.n < l.m) throw new TypeError('Pubkey count cannot be less than m') } if (e.signatures) { if (e.signatures.length < l.m) throw new TypeError('Not enough signatures provided'); if (e.signatures.length > l.m) throw new TypeError('Too many signatures provided') } if (e.input) { if (e.input[0] !== s.OP_0) throw new TypeError('Input is invalid'); if (l.signatures.length === 0 || !l.signatures.every(n)) throw new TypeError('Input has invalid signature(s)'); if (e.signatures && !u(e.signatures, l.signatures)) throw new TypeError('Signature mismatch'); if (void 0 !== e.m && e.m !== e.signatures.length) throw new TypeError('Signature count mismatch') } } return Object.assign(l, e) } }, 7759: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.p2pk = void 0; const r = n(4378); const i = n(3357); const o = n(1838); const a = n(2691); const s = i.OPS; t.p2pk = function (e, t) { if (!(e.input || e.output || e.pubkey || e.input || e.signature)) throw new TypeError('Not enough data'); t = Object.assign({ validate: !0 }, t || {}), (0, o.typeforce)({ network: o.typeforce.maybe(o.typeforce.Object), output: o.typeforce.maybe(o.typeforce.Buffer), pubkey: o.typeforce.maybe(o.isPoint), signature: o.typeforce.maybe(i.isCanonicalScriptSignature), input: o.typeforce.maybe(o.typeforce.Buffer) }, e); const n = a.value(() => i.decompile(e.input)); const c = { name: 'p2pk', network: e.network || r.bitcoin }; if (a.prop(c, 'output', () => { if (e.pubkey) return i.compile([e.pubkey, s.OP_CHECKSIG]) }), a.prop(c, 'pubkey', () => { if (e.output) return e.output.slice(1, -1) }), a.prop(c, 'signature', () => { if (e.input) return n()[0] }), a.prop(c, 'input', () => { if (e.signature) return i.compile([e.signature]) }), a.prop(c, 'witness', () => { if (c.input) return [] }), t.validate) { if (e.output) { if (e.output[e.output.length - 1] !== s.OP_CHECKSIG) throw new TypeError('Output is invalid'); if (!(0, o.isPoint)(c.pubkey)) throw new TypeError('Output pubkey is invalid'); if (e.pubkey && !e.pubkey.equals(c.pubkey)) throw new TypeError('Pubkey mismatch') } if (e.signature && e.input && !e.input.equals(c.input)) throw new TypeError('Signature mismatch'); if (e.input) { if (n().length !== 1) throw new TypeError('Input is invalid'); if (!i.isCanonicalScriptSignature(c.signature)) throw new TypeError('Input has invalid signature') } } return Object.assign(c, e) } }, 4483: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.p2pkh = void 0; const i = n(5525); const o = n(4378); const a = n(3357); const s = n(1838); const c = n(2691); const u = n(8334); const l = a.OPS; t.p2pkh = function (e, t) { if (!(e.address || e.hash || e.output || e.pubkey || e.input)) throw new TypeError('Not enough data'); t = Object.assign({ validate: !0 }, t || {}), (0, s.typeforce)({ network: s.typeforce.maybe(s.typeforce.Object), address: s.typeforce.maybe(s.typeforce.String), hash: s.typeforce.maybe(s.typeforce.BufferN(20)), output: s.typeforce.maybe(s.typeforce.BufferN(25)), pubkey: s.typeforce.maybe(s.isPoint), signature: s.typeforce.maybe(a.isCanonicalScriptSignature), input: s.typeforce.maybe(s.typeforce.Buffer) }, e); const n = c.value(() => { const t = u.decode(e.address); return { version: t.readUInt8(0), hash: t.slice(1) } }); const d = c.value(() => a.decompile(e.input)); const f = e.network || o.bitcoin; const h = { name: 'p2pkh', network: f }; if (c.prop(h, 'address', () => { if (!h.hash) return; const e = r.allocUnsafe(21); return e.writeUInt8(f.pubKeyHash, 0), h.hash.copy(e, 1), u.encode(e) }), c.prop(h, 'hash', () => e.output ? e.output.slice(3, 23) : e.address ? n().hash : e.pubkey || h.pubkey ? i.hash160(e.pubkey || h.pubkey) : void 0), c.prop(h, 'output', () => { if (h.hash) return a.compile([l.OP_DUP, l.OP_HASH160, h.hash, l.OP_EQUALVERIFY, l.OP_CHECKSIG]) }), c.prop(h, 'pubkey', () => { if (e.input) return d()[1] }), c.prop(h, 'signature', () => { if (e.input) return d()[0] }), c.prop(h, 'input', () => { if (e.pubkey && e.signature) return a.compile([e.signature, e.pubkey]) }), c.prop(h, 'witness', () => { if (h.input) return [] }), t.validate) { let t = r.from([]); if (e.address) { if (n().version !== f.pubKeyHash) throw new TypeError('Invalid version or Network mismatch'); if (n().hash.length !== 20) throw new TypeError('Invalid address'); t = n().hash } if (e.hash) { if (t.length > 0 && !t.equals(e.hash)) throw new TypeError('Hash mismatch'); t = e.hash } if (e.output) { if (e.output.length !== 25 || e.output[0] !== l.OP_DUP || e.output[1] !== l.OP_HASH160 || e.output[2] !== 20 || e.output[23] !== l.OP_EQUALVERIFY || e.output[24] !== l.OP_CHECKSIG) throw new TypeError('Output is invalid'); const n = e.output.slice(3, 23); if (t.length > 0 && !t.equals(n)) throw new TypeError('Hash mismatch'); t = n } if (e.pubkey) { const n = i.hash160(e.pubkey); if (t.length > 0 && !t.equals(n)) throw new TypeError('Hash mismatch'); t = n } if (e.input) { const n = d(); if (n.length !== 2) throw new TypeError('Input is invalid'); if (!a.isCanonicalScriptSignature(n[0])) throw new TypeError('Input has invalid signature'); if (!(0, s.isPoint)(n[1])) throw new TypeError('Input has invalid pubkey'); if (e.signature && !e.signature.equals(n[0])) throw new TypeError('Signature mismatch'); if (e.pubkey && !e.pubkey.equals(n[1])) throw new TypeError('Pubkey mismatch'); const r = i.hash160(n[1]); if (t.length > 0 && !t.equals(r)) throw new TypeError('Hash mismatch') } } return Object.assign(h, e) } }, 1160: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.p2sh = void 0; const i = n(5525); const o = n(4378); const a = n(3357); const s = n(1838); const c = n(2691); const u = n(8334); const l = a.OPS; t.p2sh = function (e, t) { if (!(e.address || e.hash || e.output || e.redeem || e.input)) throw new TypeError('Not enough data'); t = Object.assign({ validate: !0 }, t || {}), (0, s.typeforce)({ network: s.typeforce.maybe(s.typeforce.Object), address: s.typeforce.maybe(s.typeforce.String), hash: s.typeforce.maybe(s.typeforce.BufferN(20)), output: s.typeforce.maybe(s.typeforce.BufferN(23)), redeem: s.typeforce.maybe({ network: s.typeforce.maybe(s.typeforce.Object), output: s.typeforce.maybe(s.typeforce.Buffer), input: s.typeforce.maybe(s.typeforce.Buffer), witness: s.typeforce.maybe(s.typeforce.arrayOf(s.typeforce.Buffer)) }), input: s.typeforce.maybe(s.typeforce.Buffer), witness: s.typeforce.maybe(s.typeforce.arrayOf(s.typeforce.Buffer)) }, e); let n = e.network; n || (n = e.redeem && e.redeem.network || o.bitcoin); const d = { network: n }; const f = c.value(() => { const t = u.decode(e.address); return { version: t.readUInt8(0), hash: t.slice(1) } }); const h = c.value(() => a.decompile(e.input)); const p = c.value(() => { const t = h(); return { network: n, output: t[t.length - 1], input: a.compile(t.slice(0, -1)), witness: e.witness || [] } }); if (c.prop(d, 'address', () => { if (!d.hash) return; const e = r.allocUnsafe(21); return e.writeUInt8(d.network.scriptHash, 0), d.hash.copy(e, 1), u.encode(e) }), c.prop(d, 'hash', () => e.output ? e.output.slice(2, 22) : e.address ? f().hash : d.redeem && d.redeem.output ? i.hash160(d.redeem.output) : void 0), c.prop(d, 'output', () => { if (d.hash) return a.compile([l.OP_HASH160, d.hash, l.OP_EQUAL]) }), c.prop(d, 'redeem', () => { if (e.input) return p() }), c.prop(d, 'input', () => { if (e.redeem && e.redeem.input && e.redeem.output) return a.compile([].concat(a.decompile(e.redeem.input), e.redeem.output)) }), c.prop(d, 'witness', () => d.redeem && d.redeem.witness ? d.redeem.witness : d.input ? [] : void 0), c.prop(d, 'name', () => { const e = ['p2sh']; return void 0 !== d.redeem && void 0 !== d.redeem.name && e.push(d.redeem.name), e.join('-') }), t.validate) { let t = r.from([]); if (e.address) { if (f().version !== n.scriptHash) throw new TypeError('Invalid version or Network mismatch'); if (f().hash.length !== 20) throw new TypeError('Invalid address'); t = f().hash } if (e.hash) { if (t.length > 0 && !t.equals(e.hash)) throw new TypeError('Hash mismatch'); t = e.hash } if (e.output) { if (e.output.length !== 23 || e.output[0] !== l.OP_HASH160 || e.output[1] !== 20 || e.output[22] !== l.OP_EQUAL) throw new TypeError('Output is invalid'); const n = e.output.slice(2, 22); if (t.length > 0 && !t.equals(n)) throw new TypeError('Hash mismatch'); t = n } const o = e => { if (e.output) { const n = a.decompile(e.output); if (!n || n.length < 1) throw new TypeError('Redeem.output too short'); const r = i.hash160(e.output); if (t.length > 0 && !t.equals(r)) throw new TypeError('Hash mismatch'); t = r } if (e.input) { const t = e.input.length > 0; const n = e.witness && e.witness.length > 0; if (!t && !n) throw new TypeError('Empty input'); if (t && n) throw new TypeError('Input and witness provided'); if (t) { const t = a.decompile(e.input); if (!a.isPushOnly(t)) throw new TypeError('Non push-only scriptSig') } } }; if (e.input) { const e = h(); if (!e || e.length < 1) throw new TypeError('Input too short'); if (!r.isBuffer(p().output)) throw new TypeError('Input is invalid'); o(p()) } if (e.redeem) { if (e.redeem.network && e.redeem.network !== n) throw new TypeError('Network mismatch'); if (e.input) { const t = p(); if (e.redeem.output && !e.redeem.output.equals(t.output)) throw new TypeError('Redeem.output mismatch'); if (e.redeem.input && !e.redeem.input.equals(t.input)) throw new TypeError('Redeem.input mismatch') }o(e.redeem) } if (e.witness && e.redeem && e.redeem.witness && !(function (e, t) { return e.length === t.length && e.every((e, n) => e.equals(t[n])) }(e.redeem.witness, e.witness))) throw new TypeError('Witness and redeem.witness mismatch') } return Object.assign(d, e) } }, 8810: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.p2wpkh = void 0; const i = n(5525); const o = n(4378); const a = n(3357); const s = n(1838); const c = n(2691); const u = n(7715); const l = a.OPS; const d = r.alloc(0); t.p2wpkh = function (e, t) { if (!(e.address || e.hash || e.output || e.pubkey || e.witness)) throw new TypeError('Not enough data'); t = Object.assign({ validate: !0 }, t || {}), (0, s.typeforce)({ address: s.typeforce.maybe(s.typeforce.String), hash: s.typeforce.maybe(s.typeforce.BufferN(20)), input: s.typeforce.maybe(s.typeforce.BufferN(0)), network: s.typeforce.maybe(s.typeforce.Object), output: s.typeforce.maybe(s.typeforce.BufferN(22)), pubkey: s.typeforce.maybe(s.isPoint), signature: s.typeforce.maybe(a.isCanonicalScriptSignature), witness: s.typeforce.maybe(s.typeforce.arrayOf(s.typeforce.Buffer)) }, e); const n = c.value(() => { const t = u.bech32.decode(e.address); const n = t.words.shift(); const i = u.bech32.fromWords(t.words); return { version: n, prefix: t.prefix, data: r.from(i) } }); const f = e.network || o.bitcoin; const h = { name: 'p2wpkh', network: f }; if (c.prop(h, 'address', () => { if (!h.hash) return; const e = u.bech32.toWords(h.hash); return e.unshift(0), u.bech32.encode(f.bech32, e) }), c.prop(h, 'hash', () => e.output ? e.output.slice(2, 22) : e.address ? n().data : e.pubkey || h.pubkey ? i.hash160(e.pubkey || h.pubkey) : void 0), c.prop(h, 'output', () => { if (h.hash) return a.compile([l.OP_0, h.hash]) }), c.prop(h, 'pubkey', () => e.pubkey ? e.pubkey : e.witness ? e.witness[1] : void 0), c.prop(h, 'signature', () => { if (e.witness) return e.witness[0] }), c.prop(h, 'input', () => { if (h.witness) return d }), c.prop(h, 'witness', () => { if (e.pubkey && e.signature) return [e.signature, e.pubkey] }), t.validate) { let t = r.from([]); if (e.address) { if (f && f.bech32 !== n().prefix) throw new TypeError('Invalid prefix or Network mismatch'); if (n().version !== 0) throw new TypeError('Invalid address version'); if (n().data.length !== 20) throw new TypeError('Invalid address data'); t = n().data } if (e.hash) { if (t.length > 0 && !t.equals(e.hash)) throw new TypeError('Hash mismatch'); t = e.hash } if (e.output) { if (e.output.length !== 22 || e.output[0] !== l.OP_0 || e.output[1] !== 20) throw new TypeError('Output is invalid'); if (t.length > 0 && !t.equals(e.output.slice(2))) throw new TypeError('Hash mismatch'); t = e.output.slice(2) } if (e.pubkey) { const n = i.hash160(e.pubkey); if (t.length > 0 && !t.equals(n)) throw new TypeError('Hash mismatch'); if (t = n, !(0, s.isPoint)(e.pubkey) || e.pubkey.length !== 33) throw new TypeError('Invalid pubkey for p2wpkh') } if (e.witness) { if (e.witness.length !== 2) throw new TypeError('Witness is invalid'); if (!a.isCanonicalScriptSignature(e.witness[0])) throw new TypeError('Witness has invalid signature'); if (!(0, s.isPoint)(e.witness[1]) || e.witness[1].length !== 33) throw new TypeError('Witness has invalid pubkey'); if (e.signature && !e.signature.equals(e.witness[0])) throw new TypeError('Signature mismatch'); if (e.pubkey && !e.pubkey.equals(e.witness[1])) throw new TypeError('Pubkey mismatch'); const n = i.hash160(e.witness[1]); if (t.length > 0 && !t.equals(n)) throw new TypeError('Hash mismatch') } } return Object.assign(h, e) } }, 6924: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.p2wsh = void 0; const i = n(5525); const o = n(4378); const a = n(3357); const s = n(1838); const c = n(2691); const u = n(7715); const l = a.OPS; const d = r.alloc(0); function f (e) { return !(!r.isBuffer(e) || e.length !== 65 || e[0] !== 4 || !(0, s.isPoint)(e)) }t.p2wsh = function (e, t) { if (!(e.address || e.hash || e.output || e.redeem || e.witness)) throw new TypeError('Not enough data'); t = Object.assign({ validate: !0 }, t || {}), (0, s.typeforce)({ network: s.typeforce.maybe(s.typeforce.Object), address: s.typeforce.maybe(s.typeforce.String), hash: s.typeforce.maybe(s.typeforce.BufferN(32)), output: s.typeforce.maybe(s.typeforce.BufferN(34)), redeem: s.typeforce.maybe({ input: s.typeforce.maybe(s.typeforce.Buffer), network: s.typeforce.maybe(s.typeforce.Object), output: s.typeforce.maybe(s.typeforce.Buffer), witness: s.typeforce.maybe(s.typeforce.arrayOf(s.typeforce.Buffer)) }), input: s.typeforce.maybe(s.typeforce.BufferN(0)), witness: s.typeforce.maybe(s.typeforce.arrayOf(s.typeforce.Buffer)) }, e); const n = c.value(() => { const t = u.bech32.decode(e.address); const n = t.words.shift(); const i = u.bech32.fromWords(t.words); return { version: n, prefix: t.prefix, data: r.from(i) } }); const h = c.value(() => a.decompile(e.redeem.input)); let p = e.network; p || (p = e.redeem && e.redeem.network || o.bitcoin); const g = { network: p }; if (c.prop(g, 'address', () => { if (!g.hash) return; const e = u.bech32.toWords(g.hash); return e.unshift(0), u.bech32.encode(p.bech32, e) }), c.prop(g, 'hash', () => e.output ? e.output.slice(2) : e.address ? n().data : g.redeem && g.redeem.output ? i.sha256(g.redeem.output) : void 0), c.prop(g, 'output', () => { if (g.hash) return a.compile([l.OP_0, g.hash]) }), c.prop(g, 'redeem', () => { if (e.witness) return { output: e.witness[e.witness.length - 1], input: d, witness: e.witness.slice(0, -1) } }), c.prop(g, 'input', () => { if (g.witness) return d }), c.prop(g, 'witness', () => { if (e.redeem && e.redeem.input && e.redeem.input.length > 0 && e.redeem.output && e.redeem.output.length > 0) { const t = a.toStack(h()); return g.redeem = Object.assign({ witness: t }, e.redeem), g.redeem.input = d, [].concat(t, e.redeem.output) } if (e.redeem && e.redeem.output && e.redeem.witness) return [].concat(e.redeem.witness, e.redeem.output) }), c.prop(g, 'name', () => { const e = ['p2wsh']; return void 0 !== g.redeem && void 0 !== g.redeem.name && e.push(g.redeem.name), e.join('-') }), t.validate) { let t = r.from([]); if (e.address) { if (n().prefix !== p.bech32) throw new TypeError('Invalid prefix or Network mismatch'); if (n().version !== 0) throw new TypeError('Invalid address version'); if (n().data.length !== 32) throw new TypeError('Invalid address data'); t = n().data } if (e.hash) { if (t.length > 0 && !t.equals(e.hash)) throw new TypeError('Hash mismatch'); t = e.hash } if (e.output) { if (e.output.length !== 34 || e.output[0] !== l.OP_0 || e.output[1] !== 32) throw new TypeError('Output is invalid'); const n = e.output.slice(2); if (t.length > 0 && !t.equals(n)) throw new TypeError('Hash mismatch'); t = n } if (e.redeem) { if (e.redeem.network && e.redeem.network !== p) throw new TypeError('Network mismatch'); if (e.redeem.input && e.redeem.input.length > 0 && e.redeem.witness && e.redeem.witness.length > 0) throw new TypeError('Ambiguous witness source'); if (e.redeem.output) { if (a.decompile(e.redeem.output).length === 0) throw new TypeError('Redeem.output is invalid'); const n = i.sha256(e.redeem.output); if (t.length > 0 && !t.equals(n)) throw new TypeError('Hash mismatch'); t = n } if (e.redeem.input && !a.isPushOnly(h())) throw new TypeError('Non push-only scriptSig'); if (e.witness && e.redeem.witness && !(function (e, t) { return e.length === t.length && e.every((e, n) => e.equals(t[n])) }(e.witness, e.redeem.witness))) throw new TypeError('Witness and redeem.witness mismatch'); if (e.redeem.input && h().some(f) || e.redeem.output && (a.decompile(e.redeem.output) || []).some(f)) throw new TypeError('redeem.input or redeem.output contains uncompressed pubkey') } if (e.witness && e.witness.length > 0) { const t = e.witness[e.witness.length - 1]; if (e.redeem && e.redeem.output && !e.redeem.output.equals(t)) throw new TypeError('Witness and redeem.output mismatch'); if (e.witness.some(f) || (a.decompile(t) || []).some(f)) throw new TypeError('Witness contains uncompressed pubkey') } } return Object.assign(g, e) } }, 9930: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.Psbt = void 0; const i = n(5011); const o = n(3493); const a = n(1532); const s = n(5488); const c = n(9357); const u = n(5525); const l = n(4378); const d = n(3348); const f = n(3357); const h = n(2737); const p = { network: l.bitcoin, maximumFeeRate: 5e3 }; class g {constructor (e = {}, t = new i.Psbt(new y())) { this.data = t, this.opts = Object.assign({}, p, e), this.__CACHE = { __NON_WITNESS_UTXO_TX_CACHE: [], __NON_WITNESS_UTXO_BUF_CACHE: [], __TX_IN_CACHE: {}, __TX: this.data.globalMap.unsignedTx.tx, __UNSAFE_SIGN_NONSEGWIT: !1 }, this.data.inputs.length === 0 && this.setVersion(2); const n = (e, t, n, r) => Object.defineProperty(e, t, { enumerable: n, writable: r }); n(this, '__CACHE', !1, !0), n(this, 'opts', !1, !0) } static fromBase64 (e, t = {}) { const n = r.from(e, 'base64'); return this.fromBuffer(n, t) } static fromHex (e, t = {}) { const n = r.from(e, 'hex'); return this.fromBuffer(n, t) } static fromBuffer (e, t = {}) { const n = i.Psbt.fromBuffer(e, m); const r = new g(t, n); let o, a; return o = r.__CACHE.__TX, a = r.__CACHE, o.ins.forEach(e => { P(a, e) }), r } get inputCount () { return this.data.inputs.length } get version () { return this.__CACHE.__TX.version } set version (e) { this.setVersion(e) } get locktime () { return this.__CACHE.__TX.locktime } set locktime (e) { this.setLocktime(e) } get txInputs () { return this.__CACHE.__TX.ins.map(e => ({ hash: (0, c.cloneBuffer)(e.hash), index: e.index, sequence: e.sequence })) } get txOutputs () { return this.__CACHE.__TX.outs.map(e => { let t; try { t = (0, s.fromOutputScript)(e.script, this.opts.network) } catch (e) {} return { script: (0, c.cloneBuffer)(e.script), value: e.value, address: t } }) }combine (...e) { return this.data.combine(...e.map(e => e.data)), this }clone () { const e = g.fromBuffer(this.data.toBuffer()); return e.opts = JSON.parse(JSON.stringify(this.opts)), e }setMaximumFeeRate (e) { N(e), this.opts.maximumFeeRate = e }setVersion (e) { N(e), T(this.data.inputs, 'setVersion'); const t = this.__CACHE; return t.__TX.version = e, t.__EXTRACTED_TX = void 0, this }setLocktime (e) { N(e), T(this.data.inputs, 'setLocktime'); const t = this.__CACHE; return t.__TX.locktime = e, t.__EXTRACTED_TX = void 0, this }setInputSequence (e, t) { N(t), T(this.data.inputs, 'setInputSequence'); const n = this.__CACHE; if (n.__TX.ins.length <= e) throw new Error('Input index too high'); return n.__TX.ins[e].sequence = t, n.__EXTRACTED_TX = void 0, this }addInputs (e) { return e.forEach(e => this.addInput(e)), this }addInput (e) { if (arguments.length > 1 || !e || void 0 === e.hash || void 0 === e.index) throw new Error('Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]'); T(this.data.inputs, 'addInput'), e.witnessScript && Y(e.witnessScript); const t = this.__CACHE; this.data.addInput(e); P(t, t.__TX.ins[t.__TX.ins.length - 1]); const n = this.data.inputs.length - 1; const r = this.data.inputs[n]; return r.nonWitnessUtxo && q(this.__CACHE, r, n), t.__FEE = void 0, t.__FEE_RATE = void 0, t.__EXTRACTED_TX = void 0, this }addOutputs (e) { return e.forEach(e => this.addOutput(e)), this }addOutput (e) { if (arguments.length > 1 || !e || void 0 === e.value || void 0 === e.address && void 0 === e.script) throw new Error('Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]'); T(this.data.inputs, 'addOutput'); const { address: t } = e; if (typeof t === 'string') { const { network: n } = this.opts; const r = (0, s.toOutputScript)(t, n); e = Object.assign(e, { script: r }) } const n = this.__CACHE; return this.data.addOutput(e), n.__FEE = void 0, n.__FEE_RATE = void 0, n.__EXTRACTED_TX = void 0, this }extractTransaction (e) { if (!this.data.inputs.every(w)) throw new Error('Not finalized'); const t = this.__CACHE; if (e || (function (e, t, n) { const r = t.__FEE_RATE || e.getFeeRate(); const i = t.__EXTRACTED_TX.virtualSize(); const o = r * i; if (r >= n.maximumFeeRate) throw new Error(`Warning: You are paying around ${(o / 1e8).toFixed(8)} in fees, which is ${r} satoshi per byte for a transaction with a VSize of ${i} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`) }(this, t, this.opts)), t.__EXTRACTED_TX) return t.__EXTRACTED_TX; const n = t.__TX.clone(); return K(this.data.inputs, n, t, !0), n }getFeeRate () { return j('__FEE_RATE', 'fee rate', this.data.inputs, this.__CACHE) }getFee () { return j('__FEE', 'fee', this.data.inputs, this.__CACHE) }finalizeAllInputs () { return (0, a.checkForInput)(this.data.inputs, 0), X(this.data.inputs.length).forEach(e => this.finalizeInput(e)), this }finalizeInput (e, t = D) { const n = (0, a.checkForInput)(this.data.inputs, e); const { script: r, isP2SH: i, isP2WSH: o, isSegwit: s } = (function (e, t, n) { const r = n.__TX; const i = { script: null, isSegwit: !1, isP2SH: !1, isP2WSH: !1 }; if (i.isP2SH = !!t.redeemScript, i.isP2WSH = !!t.witnessScript, t.witnessScript)i.script = t.witnessScript; else if (t.redeemScript)i.script = t.redeemScript; else if (t.nonWitnessUtxo) { const o = V(n, t, e); const a = r.ins[e].index; i.script = o.outs[a].script } else t.witnessUtxo && (i.script = t.witnessUtxo.script); (t.witnessScript || A(i.script)) && (i.isSegwit = !0); return i }(e, n, this.__CACHE)); if (!r) throw new Error(`No script found for input #${e}`); !(function (e) { if (!e.sighashType || !e.partialSig) return; const { partialSig: t, sighashType: n } = e; t.forEach(e => { const { hashType: t } = f.signature.decode(e.signature); if (n !== t) throw new Error('Signature sighash does not match input sighash type') }) }(n)); const { finalScriptSig: c, finalScriptWitness: u } = t(e, n, r, s, i, o); if (c && this.data.updateInput(e, { finalScriptSig: c }), u && this.data.updateInput(e, { finalScriptWitness: u }), !c && !u) throw new Error(`Unknown error finalizing input #${e}`); return this.data.clearFinalizedInput(e), this }getInputType (e) { const t = (0, a.checkForInput)(this.data.inputs, e); const n = G(W(e, t, this.__CACHE), e, 'input', t.redeemScript || (function (e) { if (!e) return; const t = f.decompile(e); if (!t) return; const n = t[t.length - 1]; if (!r.isBuffer(n) || $(n) || (i = n, f.isCanonicalScriptSignature(i))) return; let i; if (!f.decompile(n)) return; return n }(t.finalScriptSig)), t.witnessScript || (function (e) { if (!e) return; const t = F(e); const n = t[t.length - 1]; if ($(n)) return; if (!f.decompile(n)) return; return n }(t.finalScriptWitness))); return (n.type === 'raw' ? '' : n.type + '-') + J(n.meaningfulScript) }inputHasPubkey (e, t) { return (function (e, t, n, r) { const i = W(n, t, r); const { meaningfulScript: o } = G(i, n, 'input', t.redeemScript, t.witnessScript); return Z(e, o) }(t, (0, a.checkForInput)(this.data.inputs, e), e, this.__CACHE)) }inputHasHDKey (e, t) { const n = (0, a.checkForInput)(this.data.inputs, e); const r = I(t); return !!n.bip32Derivation && n.bip32Derivation.some(r) }outputHasPubkey (e, t) { return (function (e, t, n, r) { const i = r.__TX.outs[n].script; const { meaningfulScript: o } = G(i, n, 'output', t.redeemScript, t.witnessScript); return Z(e, o) }(t, (0, a.checkForOutput)(this.data.outputs, e), e, this.__CACHE)) }outputHasHDKey (e, t) { const n = (0, a.checkForOutput)(this.data.outputs, e); const r = I(t); return !!n.bip32Derivation && n.bip32Derivation.some(r) }validateSignaturesOfAllInputs (e) { (0, a.checkForInput)(this.data.inputs, 0); return X(this.data.inputs.length).map(t => this.validateSignaturesOfInput(t, e)).reduce((e, t) => !0 === t && e, !0) }validateSignaturesOfInput (e, t, n) { const r = this.data.inputs[e]; const i = (r || {}).partialSig; if (!r || !i || i.length < 1) throw new Error('No signatures to validate'); if (typeof t !== 'function') throw new Error('Need validator function to validate signatures'); const o = n ? i.filter(e => e.pubkey.equals(n)) : i; if (o.length < 1) throw new Error('No signatures for this pubkey'); const a = []; let s, c, u; for (const n of o) { const i = f.signature.decode(n.signature); const { hash: o, script: l } = u !== i.hashType ? M(e, Object.assign({}, r, { sighashType: i.hashType }), this.__CACHE, !0) : { hash: s, script: c }; u = i.hashType, s = o, c = l, R(n.pubkey, l, 'verify'), a.push(t(n.pubkey, o, i.signature)) } return a.every(e => !0 === e) }signAllInputsHD (e, t = [h.Transaction.SIGHASH_ALL]) { if (!e || !e.publicKey || !e.fingerprint) throw new Error('Need HDSigner to sign input'); const n = []; for (const r of X(this.data.inputs.length)) try { this.signInputHD(r, e, t), n.push(!0) } catch (e) { n.push(!1) } if (n.every(e => !1 === e)) throw new Error('No inputs were signed'); return this }signAllInputsHDAsync (e, t = [h.Transaction.SIGHASH_ALL]) { return new Promise((n, r) => { if (!e || !e.publicKey || !e.fingerprint) return r(new Error('Need HDSigner to sign input')); const i = []; const o = []; for (const n of X(this.data.inputs.length))o.push(this.signInputHDAsync(n, e, t).then(() => { i.push(!0) }, () => { i.push(!1) })); return Promise.all(o).then(() => { if (i.every(e => !1 === e)) return r(new Error('No inputs were signed')); n() }) }) }signInputHD (e, t, n = [h.Transaction.SIGHASH_ALL]) { if (!t || !t.publicKey || !t.fingerprint) throw new Error('Need HDSigner to sign input'); return z(e, this.data.inputs, t).forEach(t => this.signInput(e, t, n)), this }signInputHDAsync (e, t, n = [h.Transaction.SIGHASH_ALL]) { return new Promise((r, i) => { if (!t || !t.publicKey || !t.fingerprint) return i(new Error('Need HDSigner to sign input')); const o = z(e, this.data.inputs, t).map(t => this.signInputAsync(e, t, n)); return Promise.all(o).then(() => { r() }).catch(i) }) }signAllInputs (e, t = [h.Transaction.SIGHASH_ALL]) { if (!e || !e.publicKey) throw new Error('Need Signer to sign input'); const n = []; for (const r of X(this.data.inputs.length)) try { this.signInput(r, e, t), n.push(!0) } catch (e) { n.push(!1) } if (n.every(e => !1 === e)) throw new Error('No inputs were signed'); return this }signAllInputsAsync (e, t = [h.Transaction.SIGHASH_ALL]) { return new Promise((n, r) => { if (!e || !e.publicKey) return r(new Error('Need Signer to sign input')); const i = []; const o = []; for (const [n] of this.data.inputs.entries())o.push(this.signInputAsync(n, e, t).then(() => { i.push(!0) }, () => { i.push(!1) })); return Promise.all(o).then(() => { if (i.every(e => !1 === e)) return r(new Error('No inputs were signed')); n() }) }) }signInput (e, t, n = [h.Transaction.SIGHASH_ALL]) { if (!t || !t.publicKey) throw new Error('Need Signer to sign input'); const { hash: r, sighashType: i } = U(this.data.inputs, e, t.publicKey, this.__CACHE, n); const o = [{ pubkey: t.publicKey, signature: f.signature.encode(t.sign(r), i) }]; return this.data.updateInput(e, { partialSig: o }), this }signInputAsync (e, t, n = [h.Transaction.SIGHASH_ALL]) { return Promise.resolve().then(() => { if (!t || !t.publicKey) throw new Error('Need Signer to sign input'); const { hash: r, sighashType: i } = U(this.data.inputs, e, t.publicKey, this.__CACHE, n); return Promise.resolve(t.sign(r)).then(n => { const r = [{ pubkey: t.publicKey, signature: f.signature.encode(n, i) }]; this.data.updateInput(e, { partialSig: r }) }) }) }toBuffer () { return b(this.__CACHE), this.data.toBuffer() }toHex () { return b(this.__CACHE), this.data.toHex() }toBase64 () { return b(this.__CACHE), this.data.toBase64() }updateGlobal (e) { return this.data.updateGlobal(e), this }updateInput (e, t) { return t.witnessScript && Y(t.witnessScript), this.data.updateInput(e, t), t.nonWitnessUtxo && q(this.__CACHE, this.data.inputs[e], e), this }updateOutput (e, t) { return this.data.updateOutput(e, t), this }addUnknownKeyValToGlobal (e) { return this.data.addUnknownKeyValToGlobal(e), this }addUnknownKeyValToInput (e, t) { return this.data.addUnknownKeyValToInput(e, t), this }addUnknownKeyValToOutput (e, t) { return this.data.addUnknownKeyValToOutput(e, t), this }clearFinalizedInput (e) { return this.data.clearFinalizedInput(e), this }}t.Psbt = g; const m = e => new y(e); class y {constructor (e = r.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) { this.tx = h.Transaction.fromBuffer(e), (function (e) { if (!e.ins.every(e => e.script && e.script.length === 0 && e.witness && e.witness.length === 0)) throw new Error('Format Error: Transaction ScriptSigs are not empty') }(this.tx)), Object.defineProperty(this, 'tx', { enumerable: !1, writable: !0 }) }getInputOutputCounts () { return { inputCount: this.tx.ins.length, outputCount: this.tx.outs.length } }addInput (e) { if (void 0 === e.hash || void 0 === e.index || !r.isBuffer(e.hash) && typeof e.hash !== 'string' || typeof e.index !== 'number') throw new Error('Error adding input.'); const t = typeof e.hash === 'string' ? (0, c.reverseBuffer)(r.from(e.hash, 'hex')) : e.hash; this.tx.addInput(t, e.index, e.sequence) }addOutput (e) { if (void 0 === e.script || void 0 === e.value || !r.isBuffer(e.script) || typeof e.value !== 'number') throw new Error('Error adding output.'); this.tx.addOutput(e.script, e.value) }toBuffer () { return this.tx.toBuffer() }} function b (e) { if (!1 !== e.__UNSAFE_SIGN_NONSEGWIT) throw new Error('Not BIP174 compliant, can not export') } function v (e, t, n) { if (!t) return !1; let r; if (r = n ? n.map(e => { const n = (function (e) { if (e.length === 65) { const t = 1 & e[64]; const n = e.slice(0, 33); return n[0] = 2 | t, n } return e.slice() }(e)); return t.find(e => e.pubkey.equals(n)) }).filter(e => !!e) : t, r.length > e) throw new Error('Too many signatures'); return r.length === e } function w (e) { return !!e.finalScriptSig || !!e.finalScriptWitness } function _ (e) { return t => { try { return e({ output: t }), !0 } catch (e) { return !1 } } } const E = _(d.p2ms); const k = _(d.p2pk); const S = _(d.p2pkh); const A = _(d.p2wpkh); const O = _(d.p2wsh); const x = _(d.p2sh); function I (e) { return t => !!t.masterFingerprint.equals(e.fingerprint) && !!e.derivePath(t.path).publicKey.equals(t.pubkey) } function N (e) { if (typeof e !== 'number' || e !== Math.floor(e) || e > 4294967295 || e < 0) throw new Error('Invalid 32 bit integer') } function T (e, t) { e.forEach(e => { let n = !1; let i = []; if ((e.partialSig || []).length === 0) { if (!e.finalScriptSig && !e.finalScriptWitness) return; i = (function (e) { const t = e.finalScriptSig && f.decompile(e.finalScriptSig) || []; const n = e.finalScriptWitness && f.decompile(e.finalScriptWitness) || []; return t.concat(n).filter(e => r.isBuffer(e) && f.isCanonicalScriptSignature(e)).map(e => ({ signature: e })) }(e)) } else i = e.partialSig; if (i.forEach(e => { const { hashType: r } = f.signature.decode(e.signature); const i = []; r & h.Transaction.SIGHASH_ANYONECANPAY && i.push('addInput'); switch (31 & r) { case h.Transaction.SIGHASH_ALL:break; case h.Transaction.SIGHASH_SINGLE:case h.Transaction.SIGHASH_NONE:i.push('addOutput'), i.push('setInputSequence') }i.indexOf(t) === -1 && (n = !0) }), n) throw new Error('Can not modify transaction, signatures exist.') }) } function R (e, t, n) { if (!Z(e, t)) throw new Error(`Can not ${n} for this input with the key ${e.toString('hex')}`) } function P (e, t) { const n = (0, c.reverseBuffer)(r.from(t.hash)).toString('hex') + ':' + t.index; if (e.__TX_IN_CACHE[n]) throw new Error('Duplicate input detected.'); e.__TX_IN_CACHE[n] = 1 } function C (e, t) { return (n, r, i, o) => { const a = e({ redeem: { output: i } }).output; if (!r.equals(a)) throw new Error(`${t} for ${o} #${n} doesn't match the scriptPubKey in the prevout`) } } const B = C(d.p2sh, 'Redeem script'); const L = C(d.p2wsh, 'Witness script'); function j (e, t, n, r) { if (!n.every(w)) throw new Error(`PSBT must be finalized to calculate ${t}`); if (e === '__FEE_RATE' && r.__FEE_RATE) return r.__FEE_RATE; if (e === '__FEE' && r.__FEE) return r.__FEE; let i; let o = !0; return r.__EXTRACTED_TX ? (i = r.__EXTRACTED_TX, o = !1) : i = r.__TX.clone(), K(n, i, r, o), e === '__FEE_RATE' ? r.__FEE_RATE : e === '__FEE' ? r.__FEE : void 0 } function D (e, t, n, r, i, o) { const a = J(n); if (!(function (e, t, n) { switch (n) { case 'pubkey':case 'pubkeyhash':case 'witnesspubkeyhash':return v(1, e.partialSig); case 'multisig':const n = d.p2ms({ output: t }); return v(n.m, e.partialSig, n.pubkeys); default:return !1 } }(t, n, a))) throw new Error(`Can not finalize input #${e}`); return (function (e, t, n, r, i, o) { let a, s; const c = (function (e, t, n) { let r; switch (t) { case 'multisig':const t = (function (e, t) { const n = d.p2ms({ output: e }); return n.pubkeys.map(e => (t.filter(t => t.pubkey.equals(e))[0] || {}).signature).filter(e => !!e) }(e, n)); r = d.p2ms({ output: e, signatures: t }); break; case 'pubkey':r = d.p2pk({ output: e, signature: n[0].signature }); break; case 'pubkeyhash':r = d.p2pkh({ output: e, pubkey: n[0].pubkey, signature: n[0].signature }); break; case 'witnesspubkeyhash':r = d.p2wpkh({ output: e, pubkey: n[0].pubkey, signature: n[0].signature }) } return r }(e, t, n)); const u = o ? d.p2wsh({ redeem: c }) : null; const l = i ? d.p2sh({ redeem: u || c }) : null; r ? (s = H(u ? u.witness : c.witness), l && (a = l.input)) : a = l ? l.input : c.input; return { finalScriptSig: a, finalScriptWitness: s } }(n, a, t.partialSig, r, i, o)) } function U (e, t, n, r, i) { const o = (0, a.checkForInput)(e, t); const { hash: s, sighashType: c, script: u } = M(t, o, r, !1, i); return R(n, u, 'sign'), { hash: s, sighashType: c } } function M (e, t, n, r, i) { const o = n.__TX; const a = t.sighashType || h.Transaction.SIGHASH_ALL; if (i && i.indexOf(a) < 0) { const e = (function (e) { let t = e & h.Transaction.SIGHASH_ANYONECANPAY ? 'SIGHASH_ANYONECANPAY | ' : ''; switch (31 & e) { case h.Transaction.SIGHASH_ALL:t += 'SIGHASH_ALL'; break; case h.Transaction.SIGHASH_SINGLE:t += 'SIGHASH_SINGLE'; break; case h.Transaction.SIGHASH_NONE:t += 'SIGHASH_NONE' } return t }(a)); throw new Error(`Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${e}`) } let s, c; if (t.nonWitnessUtxo) { const r = V(n, t, e); const i = o.ins[e].hash; const a = r.getHash(); if (!i.equals(a)) throw new Error(`Non-witness UTXO hash for input #${e} doesn't match the hash specified in the prevout`); const s = o.ins[e].index; c = r.outs[s] } else { if (!t.witnessUtxo) throw new Error('Need a Utxo input item for signing'); c = t.witnessUtxo } const { meaningfulScript: u, type: l } = G(c.script, e, 'input', t.redeemScript, t.witnessScript); if (['p2sh-p2wsh', 'p2wsh'].indexOf(l) >= 0)s = o.hashForWitnessV0(e, u, c.value, a); else if (A(u)) { const t = d.p2pkh({ hash: u.slice(2) }).output; s = o.hashForWitnessV0(e, t, c.value, a) } else { if (void 0 === t.nonWitnessUtxo && !1 === n.__UNSAFE_SIGN_NONSEGWIT) throw new Error(`Input #${e} has witnessUtxo but non-segwit script: ${u.toString('hex')}`); r || !1 === n.__UNSAFE_SIGN_NONSEGWIT || console.warn("Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecesor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************"), s = o.hashForSignature(e, u, a) } return { script: u, sighashType: a, hash: s } } function z (e, t, n) { const r = (0, a.checkForInput)(t, e); if (!r.bip32Derivation || r.bip32Derivation.length === 0) throw new Error('Need bip32Derivation to sign with HD'); const i = r.bip32Derivation.map(e => e.masterFingerprint.equals(n.fingerprint) ? e : void 0).filter(e => !!e); if (i.length === 0) throw new Error('Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint'); return i.map(e => { const t = n.derivePath(e.path); if (!e.pubkey.equals(t.publicKey)) throw new Error('pubkey did not match bip32Derivation'); return t }) } function F (e) { let t = 0; function n () { const n = o.decode(e, t); return t += o.decode.bytes, n } function r () { return r = n(), t += r, e.slice(t - r, t); let r } return (function () { const e = n(); const t = []; for (let n = 0; n < e; n++)t.push(r()); return t }()) } function H (e) { let t = r.allocUnsafe(0); function n (e) { const n = t.length; const i = o.encodingLength(e); t = r.concat([t, r.allocUnsafe(i)]), o.encode(e, t, n) } function i (e) { n(e.length), (function (e) { t = r.concat([t, r.from(e)]) }(e)) } let a; return n((a = e).length), a.forEach(i), t } function q (e, t, n) { e.__NON_WITNESS_UTXO_BUF_CACHE[n] = t.nonWitnessUtxo; const r = h.Transaction.fromBuffer(t.nonWitnessUtxo); e.__NON_WITNESS_UTXO_TX_CACHE[n] = r; const i = e; const o = n; delete t.nonWitnessUtxo, Object.defineProperty(t, 'nonWitnessUtxo', { enumerable: !0, get () { const e = i.__NON_WITNESS_UTXO_BUF_CACHE[o]; const t = i.__NON_WITNESS_UTXO_TX_CACHE[o]; if (void 0 !== e) return e; { const e = t.toBuffer(); return i.__NON_WITNESS_UTXO_BUF_CACHE[o] = e, e } }, set (e) { i.__NON_WITNESS_UTXO_BUF_CACHE[o] = e } }) } function K (e, t, n, r) { let i = 0; e.forEach((e, o) => { if (r && e.finalScriptSig && (t.ins[o].script = e.finalScriptSig), r && e.finalScriptWitness && (t.ins[o].witness = F(e.finalScriptWitness)), e.witnessUtxo)i += e.witnessUtxo.value; else if (e.nonWitnessUtxo) { const r = V(n, e, o); const a = t.ins[o].index; const s = r.outs[a]; i += s.value } }); const o = t.outs.reduce((e, t) => e + t.value, 0); const a = i - o; if (a < 0) throw new Error('Outputs are spending more than Inputs'); const s = t.virtualSize(); n.__FEE = a, n.__EXTRACTED_TX = t, n.__FEE_RATE = Math.floor(a / s) } function V (e, t, n) { const r = e.__NON_WITNESS_UTXO_TX_CACHE; return r[n] || q(e, t, n), r[n] } function W (e, t, n) { if (void 0 !== t.witnessUtxo) return t.witnessUtxo.script; if (void 0 !== t.nonWitnessUtxo) { return V(n, t, e).outs[n.__TX.ins[e].index].script } throw new Error("Can't find pubkey in input without Utxo data") } function $ (e) { return e.length === 33 && f.isCanonicalPubKey(e) } function G (e, t, n, r, i) { const o = x(e); const a = o && r && O(r); const s = O(e); if (o && void 0 === r) throw new Error('scriptPubkey is P2SH but redeemScript missing'); if ((s || a) && void 0 === i) throw new Error('scriptPubkey or redeemScript is P2WSH but witnessScript missing'); let c; return a ? (c = i, B(t, e, r, n), L(t, r, i, n), Y(c)) : s ? (c = i, L(t, e, i, n), Y(c)) : o ? (c = r, B(t, e, r, n)) : c = e, { meaningfulScript: c, type: a ? 'p2sh-p2wsh' : o ? 'p2sh' : s ? 'p2wsh' : 'raw' } } function Y (e) { if (A(e) || x(e)) throw new Error('P2WPKH or P2SH can not be contained within P2WSH') } function Z (e, t) { const n = (0, u.hash160)(e); const r = f.decompile(t); if (r === null) throw new Error('Unknown script error'); return r.some(t => typeof t !== 'number' && (t.equals(e) || t.equals(n))) } function J (e) { return A(e) ? 'witnesspubkeyhash' : S(e) ? 'pubkeyhash' : E(e) ? 'multisig' : k(e) ? 'pubkey' : 'nonstandard' } function X (e) { return [...Array(e).keys()] } }, 9937: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.decode = t.encode = t.encodingLength = void 0; const r = n(7334); function i (e) { return e < r.OPS.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5 }t.encodingLength = i, t.encode = function (e, t, n) { const o = i(t); return o === 1 ? e.writeUInt8(t, n) : o === 2 ? (e.writeUInt8(r.OPS.OP_PUSHDATA1, n), e.writeUInt8(t, n + 1)) : o === 3 ? (e.writeUInt8(r.OPS.OP_PUSHDATA2, n), e.writeUInt16LE(t, n + 1)) : (e.writeUInt8(r.OPS.OP_PUSHDATA4, n), e.writeUInt32LE(t, n + 1)), o }, t.decode = function (e, t) { const n = e.readUInt8(t); let i, o; if (n < r.OPS.OP_PUSHDATA1)i = n, o = 1; else if (n === r.OPS.OP_PUSHDATA1) { if (t + 2 > e.length) return null; i = e.readUInt8(t + 1), o = 2 } else if (n === r.OPS.OP_PUSHDATA2) { if (t + 3 > e.length) return null; i = e.readUInt16LE(t + 1), o = 3 } else { if (t + 5 > e.length) return null; if (n !== r.OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode'); i = e.readUInt32LE(t + 1), o = 5 } return { opcode: n, number: i, size: o } } }, 3357: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.signature = t.number = t.isCanonicalScriptSignature = t.isDefinedHashType = t.isCanonicalPubKey = t.toStack = t.fromASM = t.toASM = t.decompile = t.compile = t.isPushOnly = t.OPS = void 0; const i = n(7617); const o = n(7334); Object.defineProperty(t, 'OPS', { enumerable: !0, get: function () { return o.OPS } }); const a = n(9937); const s = n(5815); const c = n(4362); const u = n(1838); const { typeforce: l } = u; const d = o.OPS.OP_RESERVED; function f (e) { return u.Buffer(e) || (function (e) { return u.Number(e) && (e === o.OPS.OP_0 || e >= o.OPS.OP_1 && e <= o.OPS.OP_16 || e === o.OPS.OP_1NEGATE) }(e)) } function h (e) { return u.Array(e) && e.every(f) } function p (e) { return e.length === 0 ? o.OPS.OP_0 : e.length === 1 ? e[0] >= 1 && e[0] <= 16 ? d + e[0] : e[0] === 129 ? o.OPS.OP_1NEGATE : void 0 : void 0 } function g (e) { return r.isBuffer(e) } function m (e) { return r.isBuffer(e) } function y (e) { if (g(e)) return e; l(u.Array, e); const t = e.reduce((e, t) => m(t) ? t.length === 1 && void 0 !== p(t) ? e + 1 : e + a.encodingLength(t.length) + t.length : e + 1, 0); const n = r.allocUnsafe(t); let i = 0; if (e.forEach(e => { if (m(e)) { const t = p(e); if (void 0 !== t) return n.writeUInt8(t, i), void (i += 1); i += a.encode(n, e.length, i), e.copy(n, i), i += e.length } else n.writeUInt8(e, i), i += 1 }), i !== n.length) throw new Error('Could not decode chunks'); return n } function b (e) { if (t = e, u.Array(t)) return e; let t; l(u.Buffer, e); const n = []; let r = 0; for (;r < e.length;) { const t = e[r]; if (t > o.OPS.OP_0 && t <= o.OPS.OP_PUSHDATA4) { const t = a.decode(e, r); if (t === null) return null; if (r += t.size, r + t.number > e.length) return null; const i = e.slice(r, r + t.number); r += t.number; const o = p(i); void 0 !== o ? n.push(o) : n.push(i) } else n.push(t), r += 1 } return n } function v (e) { const t = -129 & e; return t > 0 && t < 4 }t.isPushOnly = h, t.compile = y, t.decompile = b, t.toASM = function (e) { return g(e) && (e = b(e)), e.map(e => { if (m(e)) { const t = p(e); if (void 0 === t) return e.toString('hex'); e = t } return o.REVERSE_OPS[e] }).join(' ') }, t.fromASM = function (e) { return l(u.String, e), y(e.split(' ').map(e => void 0 !== o.OPS[e] ? o.OPS[e] : (l(u.Hex, e), r.from(e, 'hex')))) }, t.toStack = function (e) { return e = b(e), l(h, e), e.map(e => m(e) ? e : e === o.OPS.OP_0 ? r.allocUnsafe(0) : s.encode(e - d)) }, t.isCanonicalPubKey = function (e) { return u.isPoint(e) }, t.isDefinedHashType = v, t.isCanonicalScriptSignature = function (e) { return !!r.isBuffer(e) && (!!v(e[e.length - 1]) && i.check(e.slice(0, -1))) }, t.number = s, t.signature = c }, 5815: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.encode = t.decode = void 0, t.decode = function (e, t, n) { t = t || 4, n = void 0 === n || n; const r = e.length; if (r === 0) return 0; if (r > t) throw new TypeError('Script number overflow'); if (n && (127 & e[r - 1]) == 0 && (r <= 1 || (128 & e[r - 2]) == 0)) throw new Error('Non-minimally encoded script number'); if (r === 5) { const t = e.readUInt32LE(0); const n = e.readUInt8(4); return 128 & n ? -(4294967296 * (-129 & n) + t) : 4294967296 * n + t } let i = 0; for (let t = 0; t < r; ++t)i |= e[t] << 8 * t; return 128 & e[r - 1] ? -(i & ~(128 << 8 * (r - 1))) : i }, t.encode = function (e) { let t = Math.abs(e); const n = (i = t) > 2147483647 ? 5 : i > 8388607 ? 4 : i > 32767 ? 3 : i > 127 ? 2 : i > 0 ? 1 : 0; let i; const o = r.allocUnsafe(n); const a = e < 0; for (let e = 0; e < n; ++e)o.writeUInt8(255 & t, e), t >>= 8; return 128 & o[n - 1] ? o.writeUInt8(a ? 128 : 0, n - 1) : a && (o[n - 1] |= 128), o } }, 4362: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.encode = t.decode = void 0; const i = n(7617); const o = n(1838); const { typeforce: a } = o; const s = r.alloc(1, 0); function c (e) { let t = 0; for (;e[t] === 0;)++t; return t === e.length ? s : 128 & (e = e.slice(t))[0] ? r.concat([s, e], 1 + e.length) : e } function u (e) { e[0] === 0 && (e = e.slice(1)); const t = r.alloc(32, 0); const n = Math.max(0, 32 - e.length); return e.copy(t, n), t }t.decode = function (e) { const t = e.readUInt8(e.length - 1); const n = -129 & t; if (n <= 0 || n >= 4) throw new Error('Invalid hashType ' + t); const o = i.decode(e.slice(0, -1)); const a = u(o.r); const s = u(o.s); return { signature: r.concat([a, s], 64), hashType: t } }, t.encode = function (e, t) { a({ signature: o.BufferN(64), hashType: o.UInt8 }, { signature: e, hashType: t }); const n = -129 & t; if (n <= 0 || n >= 4) throw new Error('Invalid hashType ' + t); const s = r.allocUnsafe(1); s.writeUInt8(t, 0); const u = c(e.slice(0, 32)); const l = c(e.slice(32, 64)); return r.concat([i.encode(u, l), s]) } }, 2737: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; Object.defineProperty(t, '__esModule', { value: !0 }), t.Transaction = void 0; const i = n(9357); const o = n(5525); const a = n(3357); const s = n(3357); const c = n(1838); const { typeforce: u } = c; function l (e) { const t = e.length; return i.varuint.encodingLength(t) + t } const d = r.allocUnsafe(0); const f = []; const h = r.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex'); const p = r.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'); const g = r.from('ffffffffffffffff', 'hex'); const m = { script: d, valueBuffer: g }; class y {constructor () { this.version = 1, this.locktime = 0, this.ins = [], this.outs = [] } static fromBuffer (e, t) { const n = new i.BufferReader(e); const r = new y(); r.version = n.readInt32(); const o = n.readUInt8(); const a = n.readUInt8(); let s = !1; o === y.ADVANCED_TRANSACTION_MARKER && a === y.ADVANCED_TRANSACTION_FLAG ? s = !0 : n.offset -= 2; const c = n.readVarInt(); for (let e = 0; e < c; ++e)r.ins.push({ hash: n.readSlice(32), index: n.readUInt32(), script: n.readVarSlice(), sequence: n.readUInt32(), witness: f }); const u = n.readVarInt(); for (let e = 0; e < u; ++e)r.outs.push({ value: n.readUInt64(), script: n.readVarSlice() }); if (s) { for (let e = 0; e < c; ++e)r.ins[e].witness = n.readVector(); if (!r.hasWitnesses()) throw new Error('Transaction has superfluous witness data') } if (r.locktime = n.readUInt32(), t) return r; if (n.offset !== e.length) throw new Error('Transaction has unexpected data'); return r } static fromHex (e) { return y.fromBuffer(r.from(e, 'hex'), !1) } static isCoinbaseHash (e) { u(c.Hash256bit, e); for (let t = 0; t < 32; ++t) if (e[t] !== 0) return !1; return !0 }isCoinbase () { return this.ins.length === 1 && y.isCoinbaseHash(this.ins[0].hash) }addInput (e, t, n, r) { return u(c.tuple(c.Hash256bit, c.UInt32, c.maybe(c.UInt32), c.maybe(c.Buffer)), arguments), c.Null(n) && (n = y.DEFAULT_SEQUENCE), this.ins.push({ hash: e, index: t, script: r || d, sequence: n, witness: f }) - 1 }addOutput (e, t) { return u(c.tuple(c.Buffer, c.Satoshi), arguments), this.outs.push({ script: e, value: t }) - 1 }hasWitnesses () { return this.ins.some(e => e.witness.length !== 0) }weight () { return 3 * this.byteLength(!1) + this.byteLength(!0) }virtualSize () { return Math.ceil(this.weight() / 4) }byteLength (e = !0) { const t = e && this.hasWitnesses(); return (t ? 10 : 8) + i.varuint.encodingLength(this.ins.length) + i.varuint.encodingLength(this.outs.length) + this.ins.reduce((e, t) => e + 40 + l(t.script), 0) + this.outs.reduce((e, t) => e + 8 + l(t.script), 0) + (t ? this.ins.reduce((e, t) => e + (function (e) { const t = e.length; return i.varuint.encodingLength(t) + e.reduce((e, t) => e + l(t), 0) }(t.witness)), 0) : 0) }clone () { const e = new y(); return e.version = this.version, e.locktime = this.locktime, e.ins = this.ins.map(e => ({ hash: e.hash, index: e.index, script: e.script, sequence: e.sequence, witness: e.witness })), e.outs = this.outs.map(e => ({ script: e.script, value: e.value })), e }hashForSignature (e, t, n) { if (u(c.tuple(c.UInt32, c.Buffer, c.Number), arguments), e >= this.ins.length) return p; const i = a.compile(a.decompile(t).filter(e => e !== s.OPS.OP_CODESEPARATOR)); const l = this.clone(); if ((31 & n) === y.SIGHASH_NONE)l.outs = [], l.ins.forEach((t, n) => { n !== e && (t.sequence = 0) }); else if ((31 & n) === y.SIGHASH_SINGLE) { if (e >= this.outs.length) return p; l.outs.length = e + 1; for (let t = 0; t < e; t++)l.outs[t] = m; l.ins.forEach((t, n) => { n !== e && (t.sequence = 0) }) }n & y.SIGHASH_ANYONECANPAY ? (l.ins = [l.ins[e]], l.ins[0].script = i) : (l.ins.forEach(e => { e.script = d }), l.ins[e].script = i); const f = r.allocUnsafe(l.byteLength(!1) + 4); return f.writeInt32LE(n, f.length - 4), l.__toBuffer(f, 0, !1), o.hash256(f) }hashForWitnessV1 (e, t, n, a, s, f) { if (u(c.tuple(c.UInt32, u.arrayOf(c.Buffer), u.arrayOf(c.Satoshi), c.UInt32), arguments), n.length !== this.ins.length || t.length !== this.ins.length) throw new Error('Must supply prevout script and value for all inputs'); const h = a === y.SIGHASH_DEFAULT ? y.SIGHASH_ALL : a & y.SIGHASH_OUTPUT_MASK; const p = (a & y.SIGHASH_INPUT_MASK) === y.SIGHASH_ANYONECANPAY; const g = h === y.SIGHASH_NONE; const m = h === y.SIGHASH_SINGLE; let b = d; let v = d; let w = d; let _ = d; let E = d; if (!p) { let e = i.BufferWriter.withCapacity(36 * this.ins.length); this.ins.forEach(t => { e.writeSlice(t.hash), e.writeUInt32(t.index) }), b = o.sha256(e.end()), e = i.BufferWriter.withCapacity(8 * this.ins.length), n.forEach(t => e.writeUInt64(t)), v = o.sha256(e.end()), e = i.BufferWriter.withCapacity(t.map(l).reduce((e, t) => e + t)), t.forEach(t => e.writeVarSlice(t)), w = o.sha256(e.end()), e = i.BufferWriter.withCapacity(4 * this.ins.length), this.ins.forEach(t => e.writeUInt32(t.sequence)), _ = o.sha256(e.end()) } if (g || m) { if (m && e < this.outs.length) { const t = this.outs[e]; const n = i.BufferWriter.withCapacity(8 + l(t.script)); n.writeUInt64(t.value), n.writeVarSlice(t.script), E = o.sha256(n.end()) } } else { const e = this.outs.map(e => 8 + l(e.script)).reduce((e, t) => e + t); const t = i.BufferWriter.withCapacity(e); this.outs.forEach(e => { t.writeUInt64(e.value), t.writeVarSlice(e.script) }), E = o.sha256(t.end()) } const k = (s ? 2 : 0) + (f ? 1 : 0); const S = 174 - (p ? 49 : 0) - (g ? 32 : 0) + (f ? 32 : 0) + (s ? 37 : 0); const A = i.BufferWriter.withCapacity(S); if (A.writeUInt8(a), A.writeInt32(this.version), A.writeUInt32(this.locktime), A.writeSlice(b), A.writeSlice(v), A.writeSlice(w), A.writeSlice(_), g || m || A.writeSlice(E), A.writeUInt8(k), p) { const r = this.ins[e]; A.writeSlice(r.hash), A.writeUInt32(r.index), A.writeUInt64(n[e]), A.writeVarSlice(t[e]), A.writeUInt32(r.sequence) } else A.writeUInt32(e); if (f) { const e = i.BufferWriter.withCapacity(l(f)); e.writeVarSlice(f), A.writeSlice(o.sha256(e.end())) } return m && A.writeSlice(E), s && (A.writeSlice(s), A.writeUInt8(0), A.writeUInt32(4294967295)), o.taggedHash('TapSighash', r.concat([r.of(0), A.end()])) }hashForWitnessV0 (e, t, n, a) { u(c.tuple(c.UInt32, c.Buffer, c.Satoshi, c.UInt32), arguments); let s; let d = r.from([]); let f = h; let p = h; let g = h; if (a & y.SIGHASH_ANYONECANPAY || (d = r.allocUnsafe(36 * this.ins.length), s = new i.BufferWriter(d, 0), this.ins.forEach(e => { s.writeSlice(e.hash), s.writeUInt32(e.index) }), p = o.hash256(d)), a & y.SIGHASH_ANYONECANPAY || (31 & a) === y.SIGHASH_SINGLE || (31 & a) === y.SIGHASH_NONE || (d = r.allocUnsafe(4 * this.ins.length), s = new i.BufferWriter(d, 0), this.ins.forEach(e => { s.writeUInt32(e.sequence) }), g = o.hash256(d)), (31 & a) !== y.SIGHASH_SINGLE && (31 & a) !== y.SIGHASH_NONE) { const e = this.outs.reduce((e, t) => e + 8 + l(t.script), 0); d = r.allocUnsafe(e), s = new i.BufferWriter(d, 0), this.outs.forEach(e => { s.writeUInt64(e.value), s.writeVarSlice(e.script) }), f = o.hash256(d) } else if ((31 & a) === y.SIGHASH_SINGLE && e < this.outs.length) { const t = this.outs[e]; d = r.allocUnsafe(8 + l(t.script)), s = new i.BufferWriter(d, 0), s.writeUInt64(t.value), s.writeVarSlice(t.script), f = o.hash256(d) }d = r.allocUnsafe(156 + l(t)), s = new i.BufferWriter(d, 0); const m = this.ins[e]; return s.writeInt32(this.version), s.writeSlice(p), s.writeSlice(g), s.writeSlice(m.hash), s.writeUInt32(m.index), s.writeVarSlice(t), s.writeUInt64(n), s.writeUInt32(m.sequence), s.writeSlice(f), s.writeUInt32(this.locktime), s.writeUInt32(a), o.hash256(d) }getHash (e) { return e && this.isCoinbase() ? r.alloc(32, 0) : o.hash256(this.__toBuffer(void 0, void 0, e)) }getId () { return (0, i.reverseBuffer)(this.getHash(!1)).toString('hex') }toBuffer (e, t) { return this.__toBuffer(e, t, !0) }toHex () { return this.toBuffer(void 0, void 0).toString('hex') }setInputScript (e, t) { u(c.tuple(c.Number, c.Buffer), arguments), this.ins[e].script = t }setWitness (e, t) { u(c.tuple(c.Number, [c.Buffer]), arguments), this.ins[e].witness = t }__toBuffer (e, t, n = !1) { e || (e = r.allocUnsafe(this.byteLength(n))); const o = new i.BufferWriter(e, t || 0); o.writeInt32(this.version); const a = n && this.hasWitnesses(); return a && (o.writeUInt8(y.ADVANCED_TRANSACTION_MARKER), o.writeUInt8(y.ADVANCED_TRANSACTION_FLAG)), o.writeVarInt(this.ins.length), this.ins.forEach(e => { o.writeSlice(e.hash), o.writeUInt32(e.index), o.writeVarSlice(e.script), o.writeUInt32(e.sequence) }), o.writeVarInt(this.outs.length), this.outs.forEach(e => { void 0 !== e.value ? o.writeUInt64(e.value) : o.writeSlice(e.valueBuffer), o.writeVarSlice(e.script) }), a && this.ins.forEach(e => { o.writeVector(e.witness) }), o.writeUInt32(this.locktime), void 0 !== t ? e.slice(t, o.offset) : e }}t.Transaction = y, y.DEFAULT_SEQUENCE = 4294967295, y.SIGHASH_DEFAULT = 0, y.SIGHASH_ALL = 1, y.SIGHASH_NONE = 2, y.SIGHASH_SINGLE = 3, y.SIGHASH_ANYONECANPAY = 128, y.SIGHASH_OUTPUT_MASK = 3, y.SIGHASH_INPUT_MASK = 128, y.ADVANCED_TRANSACTION_MARKER = 0, y.ADVANCED_TRANSACTION_FLAG = 1 }, 1838: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.oneOf = t.Null = t.BufferN = t.Function = t.UInt32 = t.UInt8 = t.tuple = t.maybe = t.Hex = t.Buffer = t.String = t.Boolean = t.Array = t.Number = t.Hash256bit = t.Hash160bit = t.Buffer256bit = t.Network = t.ECPoint = t.Satoshi = t.Signer = t.BIP32Path = t.UInt31 = t.isPoint = t.typeforce = void 0; const r = n(8764); t.typeforce = n(2401); const i = r.Buffer.alloc(32, 0); const o = r.Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex'); t.isPoint = function (e) { if (!r.Buffer.isBuffer(e)) return !1; if (e.length < 33) return !1; const t = e[0]; const n = e.slice(1, 33); if (n.compare(i) === 0) return !1; if (n.compare(o) >= 0) return !1; if ((t === 2 || t === 3) && e.length === 33) return !0; const a = e.slice(33); return a.compare(i) !== 0 && (!(a.compare(o) >= 0) && (t === 4 && e.length === 65)) }; const a = Math.pow(2, 31) - 1; function s (e) { return t.typeforce.String(e) && !!e.match(/^(m\/)?(\d+'?\/)*\d+'?$/) }t.UInt31 = function (e) { return t.typeforce.UInt32(e) && e <= a }, t.BIP32Path = s, s.toJSON = () => 'BIP32 derivation path', t.Signer = function (e) { return (t.typeforce.Buffer(e.publicKey) || typeof e.getPublicKey === 'function') && typeof e.sign === 'function' }; t.Satoshi = function (e) { return t.typeforce.UInt53(e) && e <= 21e14 }, t.ECPoint = t.typeforce.quacksLike('Point'), t.Network = t.typeforce.compile({ messagePrefix: t.typeforce.oneOf(t.typeforce.Buffer, t.typeforce.String), bip32: { public: t.typeforce.UInt32, private: t.typeforce.UInt32 }, pubKeyHash: t.typeforce.UInt8, scriptHash: t.typeforce.UInt8, wif: t.typeforce.UInt8 }), t.Buffer256bit = t.typeforce.BufferN(32), t.Hash160bit = t.typeforce.BufferN(20), t.Hash256bit = t.typeforce.BufferN(32), t.Number = t.typeforce.Number, t.Array = t.typeforce.Array, t.Boolean = t.typeforce.Boolean, t.String = t.typeforce.String, t.Buffer = t.typeforce.Buffer, t.Hex = t.typeforce.Hex, t.maybe = t.typeforce.maybe, t.tuple = t.typeforce.tuple, t.UInt8 = t.typeforce.UInt8, t.UInt32 = t.typeforce.UInt32, t.Function = t.typeforce.Function, t.BufferN = t.typeforce.BufferN, t.Null = t.typeforce.Null, t.oneOf = t.typeforce.oneOf }, 3550: function (e, t, n) { !(function (e, t) { 'use strict'; function r (e, t) { if (!e) throw new Error(t || 'Assertion failed') } function i (e, t) { e.super_ = t; const n = function () {}; n.prototype = t.prototype, e.prototype = new n(), e.prototype.constructor = e } function o (e, t, n) { if (o.isBN(e)) return e; this.negative = 0, this.words = null, this.length = 0, this.red = null, e !== null && (t !== 'le' && t !== 'be' || (n = t, t = 10), this._init(e || 0, t || 10, n || 'be')) } let a; typeof e === 'object' ? e.exports = o : t.BN = o, o.BN = o, o.wordSize = 26; try { a = typeof window !== 'undefined' && void 0 !== window.Buffer ? window.Buffer : n(6601).Buffer } catch (e) {} function s (e, t) { const n = e.charCodeAt(t); return n >= 65 && n <= 70 ? n - 55 : n >= 97 && n <= 102 ? n - 87 : n - 48 & 15 } function c (e, t, n) { let r = s(e, n); return n - 1 >= t && (r |= s(e, n - 1) << 4), r } function u (e, t, n, r) { for (var i = 0, o = Math.min(e.length, n), a = t; a < o; a++) { const s = e.charCodeAt(a) - 48; i *= r, i += s >= 49 ? s - 49 + 10 : s >= 17 ? s - 17 + 10 : s } return i }o.isBN = function (e) { return e instanceof o || e !== null && typeof e === 'object' && e.constructor.wordSize === o.wordSize && Array.isArray(e.words) }, o.max = function (e, t) { return e.cmp(t) > 0 ? e : t }, o.min = function (e, t) { return e.cmp(t) < 0 ? e : t }, o.prototype._init = function (e, t, n) { if (typeof e === 'number') return this._initNumber(e, t, n); if (typeof e === 'object') return this._initArray(e, t, n); t === 'hex' && (t = 16), r(t === (0 | t) && t >= 2 && t <= 36); let i = 0; (e = e.toString().replace(/\s+/g, ''))[0] === '-' && (i++, this.negative = 1), i < e.length && (t === 16 ? this._parseHex(e, i, n) : (this._parseBase(e, t, i), n === 'le' && this._initArray(this.toArray(), t, n))) }, o.prototype._initNumber = function (e, t, n) { e < 0 && (this.negative = 1, e = -e), e < 67108864 ? (this.words = [67108863 & e], this.length = 1) : e < 4503599627370496 ? (this.words = [67108863 & e, e / 67108864 & 67108863], this.length = 2) : (r(e < 9007199254740992), this.words = [67108863 & e, e / 67108864 & 67108863, 1], this.length = 3), n === 'le' && this._initArray(this.toArray(), t, n) }, o.prototype._initArray = function (e, t, n) { if (r(typeof e.length === 'number'), e.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(e.length / 3), this.words = new Array(this.length); for (var i = 0; i < this.length; i++) this.words[i] = 0; let o; let a; let s = 0; if (n === 'be') for (i = e.length - 1, o = 0; i >= 0; i -= 3)a = e[i] | e[i - 1] << 8 | e[i - 2] << 16, this.words[o] |= a << s & 67108863, this.words[o + 1] = a >>> 26 - s & 67108863, (s += 24) >= 26 && (s -= 26, o++); else if (n === 'le') for (i = 0, o = 0; i < e.length; i += 3)a = e[i] | e[i + 1] << 8 | e[i + 2] << 16, this.words[o] |= a << s & 67108863, this.words[o + 1] = a >>> 26 - s & 67108863, (s += 24) >= 26 && (s -= 26, o++); return this.strip() }, o.prototype._parseHex = function (e, t, n) { this.length = Math.ceil((e.length - t) / 6), this.words = new Array(this.length); for (var r = 0; r < this.length; r++) this.words[r] = 0; let i; let o = 0; let a = 0; if (n === 'be') for (r = e.length - 1; r >= t; r -= 2)i = c(e, t, r) << o, this.words[a] |= 67108863 & i, o >= 18 ? (o -= 18, a += 1, this.words[a] |= i >>> 26) : o += 8; else for (r = (e.length - t) % 2 == 0 ? t + 1 : t; r < e.length; r += 2)i = c(e, t, r) << o, this.words[a] |= 67108863 & i, o >= 18 ? (o -= 18, a += 1, this.words[a] |= i >>> 26) : o += 8; this.strip() }, o.prototype._parseBase = function (e, t, n) { this.words = [0], this.length = 1; for (var r = 0, i = 1; i <= 67108863; i *= t)r++; r--, i = i / t | 0; for (var o = e.length - n, a = o % r, s = Math.min(o, o - a) + n, c = 0, l = n; l < s; l += r)c = u(e, l, l + r, t), this.imuln(i), this.words[0] + c < 67108864 ? this.words[0] += c : this._iaddn(c); if (a !== 0) { let d = 1; for (c = u(e, l, e.length, t), l = 0; l < a; l++)d *= t; this.imuln(d), this.words[0] + c < 67108864 ? this.words[0] += c : this._iaddn(c) } this.strip() }, o.prototype.copy = function (e) { e.words = new Array(this.length); for (let t = 0; t < this.length; t++)e.words[t] = this.words[t]; e.length = this.length, e.negative = this.negative, e.red = this.red }, o.prototype.clone = function () { const e = new o(null); return this.copy(e), e }, o.prototype._expand = function (e) { for (;this.length < e;) this.words[this.length++] = 0; return this }, o.prototype.strip = function () { for (;this.length > 1 && this.words[this.length - 1] === 0;) this.length--; return this._normSign() }, o.prototype._normSign = function () { return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this }, o.prototype.inspect = function () { return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>' }; const l = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000']; const d = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]; const f = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; function h (e, t, n) { n.negative = t.negative ^ e.negative; let r = e.length + t.length | 0; n.length = r, r = r - 1 | 0; let i = 0 | e.words[0]; let o = 0 | t.words[0]; let a = i * o; const s = 67108863 & a; let c = a / 67108864 | 0; n.words[0] = s; for (var u = 1; u < r; u++) { for (var l = c >>> 26, d = 67108863 & c, f = Math.min(u, t.length - 1), h = Math.max(0, u - e.length + 1); h <= f; h++) { const p = u - h | 0; l += (a = (i = 0 | e.words[p]) * (o = 0 | t.words[h]) + d) / 67108864 | 0, d = 67108863 & a }n.words[u] = 0 | d, c = 0 | l } return c !== 0 ? n.words[u] = 0 | c : n.length--, n.strip() }o.prototype.toString = function (e, t) { let n; if (t = 0 | t || 1, (e = e || 10) === 16 || e === 'hex') { n = ''; for (var i = 0, o = 0, a = 0; a < this.length; a++) { const s = this.words[a]; const c = (16777215 & (s << i | o)).toString(16); n = (o = s >>> 24 - i & 16777215) !== 0 || a !== this.length - 1 ? l[6 - c.length] + c + n : c + n, (i += 2) >= 26 && (i -= 26, a--) } for (o !== 0 && (n = o.toString(16) + n); n.length % t != 0;)n = '0' + n; return this.negative !== 0 && (n = '-' + n), n } if (e === (0 | e) && e >= 2 && e <= 36) { const u = d[e]; const h = f[e]; n = ''; let p = this.clone(); for (p.negative = 0; !p.isZero();) { const g = p.modn(h).toString(e); n = (p = p.idivn(h)).isZero() ? g + n : l[u - g.length] + g + n } for (this.isZero() && (n = '0' + n); n.length % t != 0;)n = '0' + n; return this.negative !== 0 && (n = '-' + n), n }r(!1, 'Base should be between 2 and 36') }, o.prototype.toNumber = function () { let e = this.words[0]; return this.length === 2 ? e += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? e += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r(!1, 'Number can only safely store up to 53 bits'), this.negative !== 0 ? -e : e }, o.prototype.toJSON = function () { return this.toString(16) }, o.prototype.toBuffer = function (e, t) { return r(void 0 !== a), this.toArrayLike(a, e, t) }, o.prototype.toArray = function (e, t) { return this.toArrayLike(Array, e, t) }, o.prototype.toArrayLike = function (e, t, n) { const i = this.byteLength(); const o = n || Math.max(1, i); r(i <= o, 'byte array longer than desired length'), r(o > 0, 'Requested array length <= 0'), this.strip(); let a; let s; const c = t === 'le'; const u = new e(o); const l = this.clone(); if (c) { for (s = 0; !l.isZero(); s++)a = l.andln(255), l.iushrn(8), u[s] = a; for (;s < o; s++)u[s] = 0 } else { for (s = 0; s < o - i; s++)u[s] = 0; for (s = 0; !l.isZero(); s++)a = l.andln(255), l.iushrn(8), u[o - s - 1] = a } return u }, Math.clz32 ? o.prototype._countBits = function (e) { return 32 - Math.clz32(e) } : o.prototype._countBits = function (e) { let t = e; let n = 0; return t >= 4096 && (n += 13, t >>>= 13), t >= 64 && (n += 7, t >>>= 7), t >= 8 && (n += 4, t >>>= 4), t >= 2 && (n += 2, t >>>= 2), n + t }, o.prototype._zeroBits = function (e) { if (e === 0) return 26; let t = e; let n = 0; return (8191 & t) == 0 && (n += 13, t >>>= 13), (127 & t) == 0 && (n += 7, t >>>= 7), (15 & t) == 0 && (n += 4, t >>>= 4), (3 & t) == 0 && (n += 2, t >>>= 2), (1 & t) == 0 && n++, n }, o.prototype.bitLength = function () { const e = this.words[this.length - 1]; const t = this._countBits(e); return 26 * (this.length - 1) + t }, o.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var e = 0, t = 0; t < this.length; t++) { const n = this._zeroBits(this.words[t]); if (e += n, n !== 26) break } return e }, o.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, o.prototype.toTwos = function (e) { return this.negative !== 0 ? this.abs().inotn(e).iaddn(1) : this.clone() }, o.prototype.fromTwos = function (e) { return this.testn(e - 1) ? this.notn(e).iaddn(1).ineg() : this.clone() }, o.prototype.isNeg = function () { return this.negative !== 0 }, o.prototype.neg = function () { return this.clone().ineg() }, o.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, o.prototype.iuor = function (e) { for (;this.length < e.length;) this.words[this.length++] = 0; for (let t = 0; t < e.length; t++) this.words[t] = this.words[t] | e.words[t]; return this.strip() }, o.prototype.ior = function (e) { return r((this.negative | e.negative) == 0), this.iuor(e) }, o.prototype.or = function (e) { return this.length > e.length ? this.clone().ior(e) : e.clone().ior(this) }, o.prototype.uor = function (e) { return this.length > e.length ? this.clone().iuor(e) : e.clone().iuor(this) }, o.prototype.iuand = function (e) { let t; t = this.length > e.length ? e : this; for (let n = 0; n < t.length; n++) this.words[n] = this.words[n] & e.words[n]; return this.length = t.length, this.strip() }, o.prototype.iand = function (e) { return r((this.negative | e.negative) == 0), this.iuand(e) }, o.prototype.and = function (e) { return this.length > e.length ? this.clone().iand(e) : e.clone().iand(this) }, o.prototype.uand = function (e) { return this.length > e.length ? this.clone().iuand(e) : e.clone().iuand(this) }, o.prototype.iuxor = function (e) { let t, n; this.length > e.length ? (t = this, n = e) : (t = e, n = this); for (var r = 0; r < n.length; r++) this.words[r] = t.words[r] ^ n.words[r]; if (this !== t) for (;r < t.length; r++) this.words[r] = t.words[r]; return this.length = t.length, this.strip() }, o.prototype.ixor = function (e) { return r((this.negative | e.negative) == 0), this.iuxor(e) }, o.prototype.xor = function (e) { return this.length > e.length ? this.clone().ixor(e) : e.clone().ixor(this) }, o.prototype.uxor = function (e) { return this.length > e.length ? this.clone().iuxor(e) : e.clone().iuxor(this) }, o.prototype.inotn = function (e) { r(typeof e === 'number' && e >= 0); let t = 0 | Math.ceil(e / 26); const n = e % 26; this._expand(t), n > 0 && t--; for (var i = 0; i < t; i++) this.words[i] = 67108863 & ~this.words[i]; return n > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - n), this.strip() }, o.prototype.notn = function (e) { return this.clone().inotn(e) }, o.prototype.setn = function (e, t) { r(typeof e === 'number' && e >= 0); const n = e / 26 | 0; const i = e % 26; return this._expand(n + 1), this.words[n] = t ? this.words[n] | 1 << i : this.words[n] & ~(1 << i), this.strip() }, o.prototype.iadd = function (e) { let t, n, r; if (this.negative !== 0 && e.negative === 0) return this.negative = 0, t = this.isub(e), this.negative ^= 1, this._normSign(); if (this.negative === 0 && e.negative !== 0) return e.negative = 0, t = this.isub(e), e.negative = 1, t._normSign(); this.length > e.length ? (n = this, r = e) : (n = e, r = this); for (var i = 0, o = 0; o < r.length; o++)t = (0 | n.words[o]) + (0 | r.words[o]) + i, this.words[o] = 67108863 & t, i = t >>> 26; for (;i !== 0 && o < n.length; o++)t = (0 | n.words[o]) + i, this.words[o] = 67108863 & t, i = t >>> 26; if (this.length = n.length, i !== 0) this.words[this.length] = i, this.length++; else if (n !== this) for (;o < n.length; o++) this.words[o] = n.words[o]; return this }, o.prototype.add = function (e) { let t; return e.negative !== 0 && this.negative === 0 ? (e.negative = 0, t = this.sub(e), e.negative ^= 1, t) : e.negative === 0 && this.negative !== 0 ? (this.negative = 0, t = e.sub(this), this.negative = 1, t) : this.length > e.length ? this.clone().iadd(e) : e.clone().iadd(this) }, o.prototype.isub = function (e) { if (e.negative !== 0) { e.negative = 0; var t = this.iadd(e); return e.negative = 1, t._normSign() } if (this.negative !== 0) return this.negative = 0, this.iadd(e), this.negative = 1, this._normSign(); let n; let r; const i = this.cmp(e); if (i === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this; i > 0 ? (n = this, r = e) : (n = e, r = this); for (var o = 0, a = 0; a < r.length; a++)o = (t = (0 | n.words[a]) - (0 | r.words[a]) + o) >> 26, this.words[a] = 67108863 & t; for (;o !== 0 && a < n.length; a++)o = (t = (0 | n.words[a]) + o) >> 26, this.words[a] = 67108863 & t; if (o === 0 && a < n.length && n !== this) for (;a < n.length; a++) this.words[a] = n.words[a]; return this.length = Math.max(this.length, a), n !== this && (this.negative = 1), this.strip() }, o.prototype.sub = function (e) { return this.clone().isub(e) }; let p = function (e, t, n) { let r; let i; let o; const a = e.words; const s = t.words; const c = n.words; let u = 0; const l = 0 | a[0]; const d = 8191 & l; const f = l >>> 13; const h = 0 | a[1]; const p = 8191 & h; const g = h >>> 13; const m = 0 | a[2]; const y = 8191 & m; const b = m >>> 13; const v = 0 | a[3]; const w = 8191 & v; const _ = v >>> 13; const E = 0 | a[4]; const k = 8191 & E; const S = E >>> 13; const A = 0 | a[5]; const O = 8191 & A; const x = A >>> 13; const I = 0 | a[6]; const N = 8191 & I; const T = I >>> 13; const R = 0 | a[7]; const P = 8191 & R; const C = R >>> 13; const B = 0 | a[8]; const L = 8191 & B; const j = B >>> 13; const D = 0 | a[9]; const U = 8191 & D; const M = D >>> 13; const z = 0 | s[0]; const F = 8191 & z; const H = z >>> 13; const q = 0 | s[1]; const K = 8191 & q; const V = q >>> 13; const W = 0 | s[2]; const $ = 8191 & W; const G = W >>> 13; const Y = 0 | s[3]; const Z = 8191 & Y; const J = Y >>> 13; const X = 0 | s[4]; const Q = 8191 & X; const ee = X >>> 13; const te = 0 | s[5]; const ne = 8191 & te; const re = te >>> 13; const ie = 0 | s[6]; const oe = 8191 & ie; const ae = ie >>> 13; const se = 0 | s[7]; const ce = 8191 & se; const ue = se >>> 13; const le = 0 | s[8]; const de = 8191 & le; const fe = le >>> 13; const he = 0 | s[9]; const pe = 8191 & he; const ge = he >>> 13; n.negative = e.negative ^ t.negative, n.length = 19; let me = (u + (r = Math.imul(d, F)) | 0) + ((8191 & (i = (i = Math.imul(d, H)) + Math.imul(f, F) | 0)) << 13) | 0; u = ((o = Math.imul(f, H)) + (i >>> 13) | 0) + (me >>> 26) | 0, me &= 67108863, r = Math.imul(p, F), i = (i = Math.imul(p, H)) + Math.imul(g, F) | 0, o = Math.imul(g, H); let ye = (u + (r = r + Math.imul(d, K) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, V) | 0) + Math.imul(f, K) | 0)) << 13) | 0; u = ((o = o + Math.imul(f, V) | 0) + (i >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, r = Math.imul(y, F), i = (i = Math.imul(y, H)) + Math.imul(b, F) | 0, o = Math.imul(b, H), r = r + Math.imul(p, K) | 0, i = (i = i + Math.imul(p, V) | 0) + Math.imul(g, K) | 0, o = o + Math.imul(g, V) | 0; let be = (u + (r = r + Math.imul(d, $) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, G) | 0) + Math.imul(f, $) | 0)) << 13) | 0; u = ((o = o + Math.imul(f, G) | 0) + (i >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, r = Math.imul(w, F), i = (i = Math.imul(w, H)) + Math.imul(_, F) | 0, o = Math.imul(_, H), r = r + Math.imul(y, K) | 0, i = (i = i + Math.imul(y, V) | 0) + Math.imul(b, K) | 0, o = o + Math.imul(b, V) | 0, r = r + Math.imul(p, $) | 0, i = (i = i + Math.imul(p, G) | 0) + Math.imul(g, $) | 0, o = o + Math.imul(g, G) | 0; let ve = (u + (r = r + Math.imul(d, Z) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, J) | 0) + Math.imul(f, Z) | 0)) << 13) | 0; u = ((o = o + Math.imul(f, J) | 0) + (i >>> 13) | 0) + (ve >>> 26) | 0, ve &= 67108863, r = Math.imul(k, F), i = (i = Math.imul(k, H)) + Math.imul(S, F) | 0, o = Math.imul(S, H), r = r + Math.imul(w, K) | 0, i = (i = i + Math.imul(w, V) | 0) + Math.imul(_, K) | 0, o = o + Math.imul(_, V) | 0, r = r + Math.imul(y, $) | 0, i = (i = i + Math.imul(y, G) | 0) + Math.imul(b, $) | 0, o = o + Math.imul(b, G) | 0, r = r + Math.imul(p, Z) | 0, i = (i = i + Math.imul(p, J) | 0) + Math.imul(g, Z) | 0, o = o + Math.imul(g, J) | 0; let we = (u + (r = r + Math.imul(d, Q) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, ee) | 0) + Math.imul(f, Q) | 0)) << 13) | 0; u = ((o = o + Math.imul(f, ee) | 0) + (i >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, r = Math.imul(O, F), i = (i = Math.imul(O, H)) + Math.imul(x, F) | 0, o = Math.imul(x, H), r = r + Math.imul(k, K) | 0, i = (i = i + Math.imul(k, V) | 0) + Math.imul(S, K) | 0, o = o + Math.imul(S, V) | 0, r = r + Math.imul(w, $) | 0, i = (i = i + Math.imul(w, G) | 0) + Math.imul(_, $) | 0, o = o + Math.imul(_, G) | 0, r = r + Math.imul(y, Z) | 0, i = (i = i + Math.imul(y, J) | 0) + Math.imul(b, Z) | 0, o = o + Math.imul(b, J) | 0, r = r + Math.imul(p, Q) | 0, i = (i = i + Math.imul(p, ee) | 0) + Math.imul(g, Q) | 0, o = o + Math.imul(g, ee) | 0; let _e = (u + (r = r + Math.imul(d, ne) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, re) | 0) + Math.imul(f, ne) | 0)) << 13) | 0; u = ((o = o + Math.imul(f, re) | 0) + (i >>> 13) | 0) + (_e >>> 26) | 0, _e &= 67108863, r = Math.imul(N, F), i = (i = Math.imul(N, H)) + Math.imul(T, F) | 0, o = Math.imul(T, H), r = r + Math.imul(O, K) | 0, i = (i = i + Math.imul(O, V) | 0) + Math.imul(x, K) | 0, o = o + Math.imul(x, V) | 0, r = r + Math.imul(k, $) | 0, i = (i = i + Math.imul(k, G) | 0) + Math.imul(S, $) | 0, o = o + Math.imul(S, G) | 0, r = r + Math.imul(w, Z) | 0, i = (i = i + Math.imul(w, J) | 0) + Math.imul(_, Z) | 0, o = o + Math.imul(_, J) | 0, r = r + Math.imul(y, Q) | 0, i = (i = i + Math.imul(y, ee) | 0) + Math.imul(b, Q) | 0, o = o + Math.imul(b, ee) | 0, r = r + Math.imul(p, ne) | 0, i = (i = i + Math.imul(p, re) | 0) + Math.imul(g, ne) | 0, o = o + Math.imul(g, re) | 0; let Ee = (u + (r = r + Math.imul(d, oe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, ae) | 0) + Math.imul(f, oe) | 0)) << 13) | 0; u = ((o = o + Math.imul(f, ae) | 0) + (i >>> 13) | 0) + (Ee >>> 26) | 0, Ee &= 67108863, r = Math.imul(P, F), i = (i = Math.imul(P, H)) + Math.imul(C, F) | 0, o = Math.imul(C, H), r = r + Math.imul(N, K) | 0, i = (i = i + Math.imul(N, V) | 0) + Math.imul(T, K) | 0, o = o + Math.imul(T, V) | 0, r = r + Math.imul(O, $) | 0, i = (i = i + Math.imul(O, G) | 0) + Math.imul(x, $) | 0, o = o + Math.imul(x, G) | 0, r = r + Math.imul(k, Z) | 0, i = (i = i + Math.imul(k, J) | 0) + Math.imul(S, Z) | 0, o = o + Math.imul(S, J) | 0, r = r + Math.imul(w, Q) | 0, i = (i = i + Math.imul(w, ee) | 0) + Math.imul(_, Q) | 0, o = o + Math.imul(_, ee) | 0, r = r + Math.imul(y, ne) | 0, i = (i = i + Math.imul(y, re) | 0) + Math.imul(b, ne) | 0, o = o + Math.imul(b, re) | 0, r = r + Math.imul(p, oe) | 0, i = (i = i + Math.imul(p, ae) | 0) + Math.imul(g, oe) | 0, o = o + Math.imul(g, ae) | 0; let ke = (u + (r = r + Math.imul(d, ce) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, ue) | 0) + Math.imul(f, ce) | 0)) << 13) | 0; u = ((o = o + Math.imul(f, ue) | 0) + (i >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, r = Math.imul(L, F), i = (i = Math.imul(L, H)) + Math.imul(j, F) | 0, o = Math.imul(j, H), r = r + Math.imul(P, K) | 0, i = (i = i + Math.imul(P, V) | 0) + Math.imul(C, K) | 0, o = o + Math.imul(C, V) | 0, r = r + Math.imul(N, $) | 0, i = (i = i + Math.imul(N, G) | 0) + Math.imul(T, $) | 0, o = o + Math.imul(T, G) | 0, r = r + Math.imul(O, Z) | 0, i = (i = i + Math.imul(O, J) | 0) + Math.imul(x, Z) | 0, o = o + Math.imul(x, J) | 0, r = r + Math.imul(k, Q) | 0, i = (i = i + Math.imul(k, ee) | 0) + Math.imul(S, Q) | 0, o = o + Math.imul(S, ee) | 0, r = r + Math.imul(w, ne) | 0, i = (i = i + Math.imul(w, re) | 0) + Math.imul(_, ne) | 0, o = o + Math.imul(_, re) | 0, r = r + Math.imul(y, oe) | 0, i = (i = i + Math.imul(y, ae) | 0) + Math.imul(b, oe) | 0, o = o + Math.imul(b, ae) | 0, r = r + Math.imul(p, ce) | 0, i = (i = i + Math.imul(p, ue) | 0) + Math.imul(g, ce) | 0, o = o + Math.imul(g, ue) | 0; let Se = (u + (r = r + Math.imul(d, de) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, fe) | 0) + Math.imul(f, de) | 0)) << 13) | 0; u = ((o = o + Math.imul(f, fe) | 0) + (i >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, r = Math.imul(U, F), i = (i = Math.imul(U, H)) + Math.imul(M, F) | 0, o = Math.imul(M, H), r = r + Math.imul(L, K) | 0, i = (i = i + Math.imul(L, V) | 0) + Math.imul(j, K) | 0, o = o + Math.imul(j, V) | 0, r = r + Math.imul(P, $) | 0, i = (i = i + Math.imul(P, G) | 0) + Math.imul(C, $) | 0, o = o + Math.imul(C, G) | 0, r = r + Math.imul(N, Z) | 0, i = (i = i + Math.imul(N, J) | 0) + Math.imul(T, Z) | 0, o = o + Math.imul(T, J) | 0, r = r + Math.imul(O, Q) | 0, i = (i = i + Math.imul(O, ee) | 0) + Math.imul(x, Q) | 0, o = o + Math.imul(x, ee) | 0, r = r + Math.imul(k, ne) | 0, i = (i = i + Math.imul(k, re) | 0) + Math.imul(S, ne) | 0, o = o + Math.imul(S, re) | 0, r = r + Math.imul(w, oe) | 0, i = (i = i + Math.imul(w, ae) | 0) + Math.imul(_, oe) | 0, o = o + Math.imul(_, ae) | 0, r = r + Math.imul(y, ce) | 0, i = (i = i + Math.imul(y, ue) | 0) + Math.imul(b, ce) | 0, o = o + Math.imul(b, ue) | 0, r = r + Math.imul(p, de) | 0, i = (i = i + Math.imul(p, fe) | 0) + Math.imul(g, de) | 0, o = o + Math.imul(g, fe) | 0; let Ae = (u + (r = r + Math.imul(d, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, ge) | 0) + Math.imul(f, pe) | 0)) << 13) | 0; u = ((o = o + Math.imul(f, ge) | 0) + (i >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, r = Math.imul(U, K), i = (i = Math.imul(U, V)) + Math.imul(M, K) | 0, o = Math.imul(M, V), r = r + Math.imul(L, $) | 0, i = (i = i + Math.imul(L, G) | 0) + Math.imul(j, $) | 0, o = o + Math.imul(j, G) | 0, r = r + Math.imul(P, Z) | 0, i = (i = i + Math.imul(P, J) | 0) + Math.imul(C, Z) | 0, o = o + Math.imul(C, J) | 0, r = r + Math.imul(N, Q) | 0, i = (i = i + Math.imul(N, ee) | 0) + Math.imul(T, Q) | 0, o = o + Math.imul(T, ee) | 0, r = r + Math.imul(O, ne) | 0, i = (i = i + Math.imul(O, re) | 0) + Math.imul(x, ne) | 0, o = o + Math.imul(x, re) | 0, r = r + Math.imul(k, oe) | 0, i = (i = i + Math.imul(k, ae) | 0) + Math.imul(S, oe) | 0, o = o + Math.imul(S, ae) | 0, r = r + Math.imul(w, ce) | 0, i = (i = i + Math.imul(w, ue) | 0) + Math.imul(_, ce) | 0, o = o + Math.imul(_, ue) | 0, r = r + Math.imul(y, de) | 0, i = (i = i + Math.imul(y, fe) | 0) + Math.imul(b, de) | 0, o = o + Math.imul(b, fe) | 0; let Oe = (u + (r = r + Math.imul(p, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(p, ge) | 0) + Math.imul(g, pe) | 0)) << 13) | 0; u = ((o = o + Math.imul(g, ge) | 0) + (i >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, r = Math.imul(U, $), i = (i = Math.imul(U, G)) + Math.imul(M, $) | 0, o = Math.imul(M, G), r = r + Math.imul(L, Z) | 0, i = (i = i + Math.imul(L, J) | 0) + Math.imul(j, Z) | 0, o = o + Math.imul(j, J) | 0, r = r + Math.imul(P, Q) | 0, i = (i = i + Math.imul(P, ee) | 0) + Math.imul(C, Q) | 0, o = o + Math.imul(C, ee) | 0, r = r + Math.imul(N, ne) | 0, i = (i = i + Math.imul(N, re) | 0) + Math.imul(T, ne) | 0, o = o + Math.imul(T, re) | 0, r = r + Math.imul(O, oe) | 0, i = (i = i + Math.imul(O, ae) | 0) + Math.imul(x, oe) | 0, o = o + Math.imul(x, ae) | 0, r = r + Math.imul(k, ce) | 0, i = (i = i + Math.imul(k, ue) | 0) + Math.imul(S, ce) | 0, o = o + Math.imul(S, ue) | 0, r = r + Math.imul(w, de) | 0, i = (i = i + Math.imul(w, fe) | 0) + Math.imul(_, de) | 0, o = o + Math.imul(_, fe) | 0; let xe = (u + (r = r + Math.imul(y, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(y, ge) | 0) + Math.imul(b, pe) | 0)) << 13) | 0; u = ((o = o + Math.imul(b, ge) | 0) + (i >>> 13) | 0) + (xe >>> 26) | 0, xe &= 67108863, r = Math.imul(U, Z), i = (i = Math.imul(U, J)) + Math.imul(M, Z) | 0, o = Math.imul(M, J), r = r + Math.imul(L, Q) | 0, i = (i = i + Math.imul(L, ee) | 0) + Math.imul(j, Q) | 0, o = o + Math.imul(j, ee) | 0, r = r + Math.imul(P, ne) | 0, i = (i = i + Math.imul(P, re) | 0) + Math.imul(C, ne) | 0, o = o + Math.imul(C, re) | 0, r = r + Math.imul(N, oe) | 0, i = (i = i + Math.imul(N, ae) | 0) + Math.imul(T, oe) | 0, o = o + Math.imul(T, ae) | 0, r = r + Math.imul(O, ce) | 0, i = (i = i + Math.imul(O, ue) | 0) + Math.imul(x, ce) | 0, o = o + Math.imul(x, ue) | 0, r = r + Math.imul(k, de) | 0, i = (i = i + Math.imul(k, fe) | 0) + Math.imul(S, de) | 0, o = o + Math.imul(S, fe) | 0; let Ie = (u + (r = r + Math.imul(w, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(w, ge) | 0) + Math.imul(_, pe) | 0)) << 13) | 0; u = ((o = o + Math.imul(_, ge) | 0) + (i >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, r = Math.imul(U, Q), i = (i = Math.imul(U, ee)) + Math.imul(M, Q) | 0, o = Math.imul(M, ee), r = r + Math.imul(L, ne) | 0, i = (i = i + Math.imul(L, re) | 0) + Math.imul(j, ne) | 0, o = o + Math.imul(j, re) | 0, r = r + Math.imul(P, oe) | 0, i = (i = i + Math.imul(P, ae) | 0) + Math.imul(C, oe) | 0, o = o + Math.imul(C, ae) | 0, r = r + Math.imul(N, ce) | 0, i = (i = i + Math.imul(N, ue) | 0) + Math.imul(T, ce) | 0, o = o + Math.imul(T, ue) | 0, r = r + Math.imul(O, de) | 0, i = (i = i + Math.imul(O, fe) | 0) + Math.imul(x, de) | 0, o = o + Math.imul(x, fe) | 0; let Ne = (u + (r = r + Math.imul(k, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(k, ge) | 0) + Math.imul(S, pe) | 0)) << 13) | 0; u = ((o = o + Math.imul(S, ge) | 0) + (i >>> 13) | 0) + (Ne >>> 26) | 0, Ne &= 67108863, r = Math.imul(U, ne), i = (i = Math.imul(U, re)) + Math.imul(M, ne) | 0, o = Math.imul(M, re), r = r + Math.imul(L, oe) | 0, i = (i = i + Math.imul(L, ae) | 0) + Math.imul(j, oe) | 0, o = o + Math.imul(j, ae) | 0, r = r + Math.imul(P, ce) | 0, i = (i = i + Math.imul(P, ue) | 0) + Math.imul(C, ce) | 0, o = o + Math.imul(C, ue) | 0, r = r + Math.imul(N, de) | 0, i = (i = i + Math.imul(N, fe) | 0) + Math.imul(T, de) | 0, o = o + Math.imul(T, fe) | 0; let Te = (u + (r = r + Math.imul(O, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(O, ge) | 0) + Math.imul(x, pe) | 0)) << 13) | 0; u = ((o = o + Math.imul(x, ge) | 0) + (i >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, r = Math.imul(U, oe), i = (i = Math.imul(U, ae)) + Math.imul(M, oe) | 0, o = Math.imul(M, ae), r = r + Math.imul(L, ce) | 0, i = (i = i + Math.imul(L, ue) | 0) + Math.imul(j, ce) | 0, o = o + Math.imul(j, ue) | 0, r = r + Math.imul(P, de) | 0, i = (i = i + Math.imul(P, fe) | 0) + Math.imul(C, de) | 0, o = o + Math.imul(C, fe) | 0; let Re = (u + (r = r + Math.imul(N, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(N, ge) | 0) + Math.imul(T, pe) | 0)) << 13) | 0; u = ((o = o + Math.imul(T, ge) | 0) + (i >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, r = Math.imul(U, ce), i = (i = Math.imul(U, ue)) + Math.imul(M, ce) | 0, o = Math.imul(M, ue), r = r + Math.imul(L, de) | 0, i = (i = i + Math.imul(L, fe) | 0) + Math.imul(j, de) | 0, o = o + Math.imul(j, fe) | 0; let Pe = (u + (r = r + Math.imul(P, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(P, ge) | 0) + Math.imul(C, pe) | 0)) << 13) | 0; u = ((o = o + Math.imul(C, ge) | 0) + (i >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, r = Math.imul(U, de), i = (i = Math.imul(U, fe)) + Math.imul(M, de) | 0, o = Math.imul(M, fe); let Ce = (u + (r = r + Math.imul(L, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(L, ge) | 0) + Math.imul(j, pe) | 0)) << 13) | 0; u = ((o = o + Math.imul(j, ge) | 0) + (i >>> 13) | 0) + (Ce >>> 26) | 0, Ce &= 67108863; let Be = (u + (r = Math.imul(U, pe)) | 0) + ((8191 & (i = (i = Math.imul(U, ge)) + Math.imul(M, pe) | 0)) << 13) | 0; return u = ((o = Math.imul(M, ge)) + (i >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, c[0] = me, c[1] = ye, c[2] = be, c[3] = ve, c[4] = we, c[5] = _e, c[6] = Ee, c[7] = ke, c[8] = Se, c[9] = Ae, c[10] = Oe, c[11] = xe, c[12] = Ie, c[13] = Ne, c[14] = Te, c[15] = Re, c[16] = Pe, c[17] = Ce, c[18] = Be, u !== 0 && (c[19] = u, n.length++), n }; function g (e, t, n) { return (new m()).mulp(e, t, n) } function m (e, t) { this.x = e, this.y = t }Math.imul || (p = h), o.prototype.mulTo = function (e, t) { let n; const r = this.length + e.length; return n = this.length === 10 && e.length === 10 ? p(this, e, t) : r < 63 ? h(this, e, t) : r < 1024 ? (function (e, t, n) { n.negative = t.negative ^ e.negative, n.length = e.length + t.length; for (var r = 0, i = 0, o = 0; o < n.length - 1; o++) { let a = i; i = 0; for (var s = 67108863 & r, c = Math.min(o, t.length - 1), u = Math.max(0, o - e.length + 1); u <= c; u++) { const l = o - u; const d = (0 | e.words[l]) * (0 | t.words[u]); let f = 67108863 & d; s = 67108863 & (f = f + s | 0), i += (a = (a = a + (d / 67108864 | 0) | 0) + (f >>> 26) | 0) >>> 26, a &= 67108863 }n.words[o] = s, r = a, a = i } return r !== 0 ? n.words[o] = r : n.length--, n.strip() }(this, e, t)) : g(this, e, t), n }, m.prototype.makeRBT = function (e) { for (var t = new Array(e), n = o.prototype._countBits(e) - 1, r = 0; r < e; r++)t[r] = this.revBin(r, n, e); return t }, m.prototype.revBin = function (e, t, n) { if (e === 0 || e === n - 1) return e; for (var r = 0, i = 0; i < t; i++)r |= (1 & e) << t - i - 1, e >>= 1; return r }, m.prototype.permute = function (e, t, n, r, i, o) { for (let a = 0; a < o; a++)r[a] = t[e[a]], i[a] = n[e[a]] }, m.prototype.transform = function (e, t, n, r, i, o) { this.permute(o, e, t, n, r, i); for (let a = 1; a < i; a <<= 1) for (let s = a << 1, c = Math.cos(2 * Math.PI / s), u = Math.sin(2 * Math.PI / s), l = 0; l < i; l += s) for (let d = c, f = u, h = 0; h < a; h++) { const p = n[l + h]; const g = r[l + h]; let m = n[l + h + a]; let y = r[l + h + a]; let b = d * m - f * y; y = d * y + f * m, m = b, n[l + h] = p + m, r[l + h] = g + y, n[l + h + a] = p - m, r[l + h + a] = g - y, h !== s && (b = c * d - u * f, f = c * f + u * d, d = b) } }, m.prototype.guessLen13b = function (e, t) { let n = 1 | Math.max(t, e); const r = 1 & n; let i = 0; for (n = n / 2 | 0; n; n >>>= 1)i++; return 1 << i + 1 + r }, m.prototype.conjugate = function (e, t, n) { if (!(n <= 1)) for (let r = 0; r < n / 2; r++) { let i = e[r]; e[r] = e[n - r - 1], e[n - r - 1] = i, i = t[r], t[r] = -t[n - r - 1], t[n - r - 1] = -i } }, m.prototype.normalize13b = function (e, t) { for (let n = 0, r = 0; r < t / 2; r++) { const i = 8192 * Math.round(e[2 * r + 1] / t) + Math.round(e[2 * r] / t) + n; e[r] = 67108863 & i, n = i < 67108864 ? 0 : i / 67108864 | 0 } return e }, m.prototype.convert13b = function (e, t, n, i) { for (var o = 0, a = 0; a < t; a++)o += 0 | e[a], n[2 * a] = 8191 & o, o >>>= 13, n[2 * a + 1] = 8191 & o, o >>>= 13; for (a = 2 * t; a < i; ++a)n[a] = 0; r(o === 0), r((-8192 & o) == 0) }, m.prototype.stub = function (e) { for (var t = new Array(e), n = 0; n < e; n++)t[n] = 0; return t }, m.prototype.mulp = function (e, t, n) { const r = 2 * this.guessLen13b(e.length, t.length); const i = this.makeRBT(r); const o = this.stub(r); const a = new Array(r); const s = new Array(r); const c = new Array(r); const u = new Array(r); const l = new Array(r); const d = new Array(r); const f = n.words; f.length = r, this.convert13b(e.words, e.length, a, r), this.convert13b(t.words, t.length, u, r), this.transform(a, o, s, c, r, i), this.transform(u, o, l, d, r, i); for (let h = 0; h < r; h++) { const p = s[h] * l[h] - c[h] * d[h]; c[h] = s[h] * d[h] + c[h] * l[h], s[h] = p } return this.conjugate(s, c, r), this.transform(s, c, f, o, r, i), this.conjugate(f, o, r), this.normalize13b(f, r), n.negative = e.negative ^ t.negative, n.length = e.length + t.length, n.strip() }, o.prototype.mul = function (e) { const t = new o(null); return t.words = new Array(this.length + e.length), this.mulTo(e, t) }, o.prototype.mulf = function (e) { const t = new o(null); return t.words = new Array(this.length + e.length), g(this, e, t) }, o.prototype.imul = function (e) { return this.clone().mulTo(e, this) }, o.prototype.imuln = function (e) { r(typeof e === 'number'), r(e < 67108864); for (var t = 0, n = 0; n < this.length; n++) { const i = (0 | this.words[n]) * e; const o = (67108863 & i) + (67108863 & t); t >>= 26, t += i / 67108864 | 0, t += o >>> 26, this.words[n] = 67108863 & o } return t !== 0 && (this.words[n] = t, this.length++), this }, o.prototype.muln = function (e) { return this.clone().imuln(e) }, o.prototype.sqr = function () { return this.mul(this) }, o.prototype.isqr = function () { return this.imul(this.clone()) }, o.prototype.pow = function (e) { const t = (function (e) { for (var t = new Array(e.bitLength()), n = 0; n < t.length; n++) { const r = n / 26 | 0; const i = n % 26; t[n] = (e.words[r] & 1 << i) >>> i } return t }(e)); if (t.length === 0) return new o(1); for (var n = this, r = 0; r < t.length && t[r] === 0; r++, n = n.sqr());if (++r < t.length) for (let i = n.sqr(); r < t.length; r++, i = i.sqr())t[r] !== 0 && (n = n.mul(i)); return n }, o.prototype.iushln = function (e) { r(typeof e === 'number' && e >= 0); let t; const n = e % 26; const i = (e - n) / 26; const o = 67108863 >>> 26 - n << 26 - n; if (n !== 0) { let a = 0; for (t = 0; t < this.length; t++) { const s = this.words[t] & o; const c = (0 | this.words[t]) - s << n; this.words[t] = c | a, a = s >>> 26 - n }a && (this.words[t] = a, this.length++) } if (i !== 0) { for (t = this.length - 1; t >= 0; t--) this.words[t + i] = this.words[t]; for (t = 0; t < i; t++) this.words[t] = 0; this.length += i } return this.strip() }, o.prototype.ishln = function (e) { return r(this.negative === 0), this.iushln(e) }, o.prototype.iushrn = function (e, t, n) { let i; r(typeof e === 'number' && e >= 0), i = t ? (t - t % 26) / 26 : 0; const o = e % 26; const a = Math.min((e - o) / 26, this.length); const s = 67108863 ^ 67108863 >>> o << o; const c = n; if (i -= a, i = Math.max(0, i), c) { for (var u = 0; u < a; u++)c.words[u] = this.words[u]; c.length = a } if (a === 0);else if (this.length > a) for (this.length -= a, u = 0; u < this.length; u++) this.words[u] = this.words[u + a]; else this.words[0] = 0, this.length = 1; let l = 0; for (u = this.length - 1; u >= 0 && (l !== 0 || u >= i); u--) { const d = 0 | this.words[u]; this.words[u] = l << 26 - o | d >>> o, l = d & s } return c && l !== 0 && (c.words[c.length++] = l), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip() }, o.prototype.ishrn = function (e, t, n) { return r(this.negative === 0), this.iushrn(e, t, n) }, o.prototype.shln = function (e) { return this.clone().ishln(e) }, o.prototype.ushln = function (e) { return this.clone().iushln(e) }, o.prototype.shrn = function (e) { return this.clone().ishrn(e) }, o.prototype.ushrn = function (e) { return this.clone().iushrn(e) }, o.prototype.testn = function (e) { r(typeof e === 'number' && e >= 0); const t = e % 26; const n = (e - t) / 26; const i = 1 << t; return !(this.length <= n) && !!(this.words[n] & i) }, o.prototype.imaskn = function (e) { r(typeof e === 'number' && e >= 0); const t = e % 26; let n = (e - t) / 26; if (r(this.negative === 0, 'imaskn works only with positive numbers'), this.length <= n) return this; if (t !== 0 && n++, this.length = Math.min(n, this.length), t !== 0) { const i = 67108863 ^ 67108863 >>> t << t; this.words[this.length - 1] &= i } return this.strip() }, o.prototype.maskn = function (e) { return this.clone().imaskn(e) }, o.prototype.iaddn = function (e) { return r(typeof e === 'number'), r(e < 67108864), e < 0 ? this.isubn(-e) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < e ? (this.words[0] = e - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(e), this.negative = 1, this) : this._iaddn(e) }, o.prototype._iaddn = function (e) { this.words[0] += e; for (var t = 0; t < this.length && this.words[t] >= 67108864; t++) this.words[t] -= 67108864, t === this.length - 1 ? this.words[t + 1] = 1 : this.words[t + 1]++; return this.length = Math.max(this.length, t + 1), this }, o.prototype.isubn = function (e) { if (r(typeof e === 'number'), r(e < 67108864), e < 0) return this.iaddn(-e); if (this.negative !== 0) return this.negative = 0, this.iaddn(e), this.negative = 1, this; if (this.words[0] -= e, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (let t = 0; t < this.length && this.words[t] < 0; t++) this.words[t] += 67108864, this.words[t + 1] -= 1; return this.strip() }, o.prototype.addn = function (e) { return this.clone().iaddn(e) }, o.prototype.subn = function (e) { return this.clone().isubn(e) }, o.prototype.iabs = function () { return this.negative = 0, this }, o.prototype.abs = function () { return this.clone().iabs() }, o.prototype._ishlnsubmul = function (e, t, n) { let i; let o; const a = e.length + n; this._expand(a); let s = 0; for (i = 0; i < e.length; i++) { o = (0 | this.words[i + n]) + s; const c = (0 | e.words[i]) * t; s = ((o -= 67108863 & c) >> 26) - (c / 67108864 | 0), this.words[i + n] = 67108863 & o } for (;i < this.length - n; i++)s = (o = (0 | this.words[i + n]) + s) >> 26, this.words[i + n] = 67108863 & o; if (s === 0) return this.strip(); for (r(s === -1), s = 0, i = 0; i < this.length; i++)s = (o = -(0 | this.words[i]) + s) >> 26, this.words[i] = 67108863 & o; return this.negative = 1, this.strip() }, o.prototype._wordDiv = function (e, t) { let n = (this.length, e.length); let r = this.clone(); let i = e; let a = 0 | i.words[i.length - 1]; (n = 26 - this._countBits(a)) !== 0 && (i = i.ushln(n), r.iushln(n), a = 0 | i.words[i.length - 1]); let s; const c = r.length - i.length; if (t !== 'mod') { (s = new o(null)).length = c + 1, s.words = new Array(s.length); for (let u = 0; u < s.length; u++)s.words[u] = 0 } const l = r.clone()._ishlnsubmul(i, 1, c); l.negative === 0 && (r = l, s && (s.words[c] = 1)); for (let d = c - 1; d >= 0; d--) { let f = 67108864 * (0 | r.words[i.length + d]) + (0 | r.words[i.length + d - 1]); for (f = Math.min(f / a | 0, 67108863), r._ishlnsubmul(i, f, d); r.negative !== 0;)f--, r.negative = 0, r._ishlnsubmul(i, 1, d), r.isZero() || (r.negative ^= 1); s && (s.words[d] = f) } return s && s.strip(), r.strip(), t !== 'div' && n !== 0 && r.iushrn(n), { div: s || null, mod: r } }, o.prototype.divmod = function (e, t, n) { return r(!e.isZero()), this.isZero() ? { div: new o(0), mod: new o(0) } : this.negative !== 0 && e.negative === 0 ? (s = this.neg().divmod(e, t), t !== 'mod' && (i = s.div.neg()), t !== 'div' && (a = s.mod.neg(), n && a.negative !== 0 && a.iadd(e)), { div: i, mod: a }) : this.negative === 0 && e.negative !== 0 ? (s = this.divmod(e.neg(), t), t !== 'mod' && (i = s.div.neg()), { div: i, mod: s.mod }) : (this.negative & e.negative) != 0 ? (s = this.neg().divmod(e.neg(), t), t !== 'div' && (a = s.mod.neg(), n && a.negative !== 0 && a.isub(e)), { div: s.div, mod: a }) : e.length > this.length || this.cmp(e) < 0 ? { div: new o(0), mod: this } : e.length === 1 ? t === 'div' ? { div: this.divn(e.words[0]), mod: null } : t === 'mod' ? { div: null, mod: new o(this.modn(e.words[0])) } : { div: this.divn(e.words[0]), mod: new o(this.modn(e.words[0])) } : this._wordDiv(e, t); let i, a, s }, o.prototype.div = function (e) { return this.divmod(e, 'div', !1).div }, o.prototype.mod = function (e) { return this.divmod(e, 'mod', !1).mod }, o.prototype.umod = function (e) { return this.divmod(e, 'mod', !0).mod }, o.prototype.divRound = function (e) { const t = this.divmod(e); if (t.mod.isZero()) return t.div; const n = t.div.negative !== 0 ? t.mod.isub(e) : t.mod; const r = e.ushrn(1); const i = e.andln(1); const o = n.cmp(r); return o < 0 || i === 1 && o === 0 ? t.div : t.div.negative !== 0 ? t.div.isubn(1) : t.div.iaddn(1) }, o.prototype.modn = function (e) { r(e <= 67108863); for (var t = (1 << 26) % e, n = 0, i = this.length - 1; i >= 0; i--)n = (t * n + (0 | this.words[i])) % e; return n }, o.prototype.idivn = function (e) { r(e <= 67108863); for (let t = 0, n = this.length - 1; n >= 0; n--) { const i = (0 | this.words[n]) + 67108864 * t; this.words[n] = i / e | 0, t = i % e } return this.strip() }, o.prototype.divn = function (e) { return this.clone().idivn(e) }, o.prototype.egcd = function (e) { r(e.negative === 0), r(!e.isZero()); let t = this; const n = e.clone(); t = t.negative !== 0 ? t.umod(e) : t.clone(); for (var i = new o(1), a = new o(0), s = new o(0), c = new o(1), u = 0; t.isEven() && n.isEven();)t.iushrn(1), n.iushrn(1), ++u; for (let l = n.clone(), d = t.clone(); !t.isZero();) { for (var f = 0, h = 1; (t.words[0] & h) == 0 && f < 26; ++f, h <<= 1);if (f > 0) for (t.iushrn(f); f-- > 0;)(i.isOdd() || a.isOdd()) && (i.iadd(l), a.isub(d)), i.iushrn(1), a.iushrn(1); for (var p = 0, g = 1; (n.words[0] & g) == 0 && p < 26; ++p, g <<= 1);if (p > 0) for (n.iushrn(p); p-- > 0;)(s.isOdd() || c.isOdd()) && (s.iadd(l), c.isub(d)), s.iushrn(1), c.iushrn(1); t.cmp(n) >= 0 ? (t.isub(n), i.isub(s), a.isub(c)) : (n.isub(t), s.isub(i), c.isub(a)) } return { a: s, b: c, gcd: n.iushln(u) } }, o.prototype._invmp = function (e) { r(e.negative === 0), r(!e.isZero()); let t = this; const n = e.clone(); t = t.negative !== 0 ? t.umod(e) : t.clone(); for (var i, a = new o(1), s = new o(0), c = n.clone(); t.cmpn(1) > 0 && n.cmpn(1) > 0;) { for (var u = 0, l = 1; (t.words[0] & l) == 0 && u < 26; ++u, l <<= 1);if (u > 0) for (t.iushrn(u); u-- > 0;)a.isOdd() && a.iadd(c), a.iushrn(1); for (var d = 0, f = 1; (n.words[0] & f) == 0 && d < 26; ++d, f <<= 1);if (d > 0) for (n.iushrn(d); d-- > 0;)s.isOdd() && s.iadd(c), s.iushrn(1); t.cmp(n) >= 0 ? (t.isub(n), a.isub(s)) : (n.isub(t), s.isub(a)) } return (i = t.cmpn(1) === 0 ? a : s).cmpn(0) < 0 && i.iadd(e), i }, o.prototype.gcd = function (e) { if (this.isZero()) return e.abs(); if (e.isZero()) return this.abs(); let t = this.clone(); let n = e.clone(); t.negative = 0, n.negative = 0; for (var r = 0; t.isEven() && n.isEven(); r++)t.iushrn(1), n.iushrn(1); for (;;) { for (;t.isEven();)t.iushrn(1); for (;n.isEven();)n.iushrn(1); const i = t.cmp(n); if (i < 0) { const o = t; t = n, n = o } else if (i === 0 || n.cmpn(1) === 0) break; t.isub(n) } return n.iushln(r) }, o.prototype.invm = function (e) { return this.egcd(e).a.umod(e) }, o.prototype.isEven = function () { return (1 & this.words[0]) == 0 }, o.prototype.isOdd = function () { return (1 & this.words[0]) == 1 }, o.prototype.andln = function (e) { return this.words[0] & e }, o.prototype.bincn = function (e) { r(typeof e === 'number'); const t = e % 26; const n = (e - t) / 26; const i = 1 << t; if (this.length <= n) return this._expand(n + 1), this.words[n] |= i, this; for (var o = i, a = n; o !== 0 && a < this.length; a++) { let s = 0 | this.words[a]; o = (s += o) >>> 26, s &= 67108863, this.words[a] = s } return o !== 0 && (this.words[a] = o, this.length++), this }, o.prototype.isZero = function () { return this.length === 1 && this.words[0] === 0 }, o.prototype.cmpn = function (e) { let t; const n = e < 0; if (this.negative !== 0 && !n) return -1; if (this.negative === 0 && n) return 1; if (this.strip(), this.length > 1)t = 1; else { n && (e = -e), r(e <= 67108863, 'Number is too big'); const i = 0 | this.words[0]; t = i === e ? 0 : i < e ? -1 : 1 } return this.negative !== 0 ? 0 | -t : t }, o.prototype.cmp = function (e) { if (this.negative !== 0 && e.negative === 0) return -1; if (this.negative === 0 && e.negative !== 0) return 1; const t = this.ucmp(e); return this.negative !== 0 ? 0 | -t : t }, o.prototype.ucmp = function (e) { if (this.length > e.length) return 1; if (this.length < e.length) return -1; for (var t = 0, n = this.length - 1; n >= 0; n--) { const r = 0 | this.words[n]; const i = 0 | e.words[n]; if (r !== i) { r < i ? t = -1 : r > i && (t = 1); break } } return t }, o.prototype.gtn = function (e) { return this.cmpn(e) === 1 }, o.prototype.gt = function (e) { return this.cmp(e) === 1 }, o.prototype.gten = function (e) { return this.cmpn(e) >= 0 }, o.prototype.gte = function (e) { return this.cmp(e) >= 0 }, o.prototype.ltn = function (e) { return this.cmpn(e) === -1 }, o.prototype.lt = function (e) { return this.cmp(e) === -1 }, o.prototype.lten = function (e) { return this.cmpn(e) <= 0 }, o.prototype.lte = function (e) { return this.cmp(e) <= 0 }, o.prototype.eqn = function (e) { return this.cmpn(e) === 0 }, o.prototype.eq = function (e) { return this.cmp(e) === 0 }, o.red = function (e) { return new k(e) }, o.prototype.toRed = function (e) { return r(!this.red, 'Already a number in reduction context'), r(this.negative === 0, 'red works only with positives'), e.convertTo(this)._forceRed(e) }, o.prototype.fromRed = function () { return r(this.red, 'fromRed works only with numbers in reduction context'), this.red.convertFrom(this) }, o.prototype._forceRed = function (e) { return this.red = e, this }, o.prototype.forceRed = function (e) { return r(!this.red, 'Already a number in reduction context'), this._forceRed(e) }, o.prototype.redAdd = function (e) { return r(this.red, 'redAdd works only with red numbers'), this.red.add(this, e) }, o.prototype.redIAdd = function (e) { return r(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, e) }, o.prototype.redSub = function (e) { return r(this.red, 'redSub works only with red numbers'), this.red.sub(this, e) }, o.prototype.redISub = function (e) { return r(this.red, 'redISub works only with red numbers'), this.red.isub(this, e) }, o.prototype.redShl = function (e) { return r(this.red, 'redShl works only with red numbers'), this.red.shl(this, e) }, o.prototype.redMul = function (e) { return r(this.red, 'redMul works only with red numbers'), this.red._verify2(this, e), this.red.mul(this, e) }, o.prototype.redIMul = function (e) { return r(this.red, 'redMul works only with red numbers'), this.red._verify2(this, e), this.red.imul(this, e) }, o.prototype.redSqr = function () { return r(this.red, 'redSqr works only with red numbers'), this.red._verify1(this), this.red.sqr(this) }, o.prototype.redISqr = function () { return r(this.red, 'redISqr works only with red numbers'), this.red._verify1(this), this.red.isqr(this) }, o.prototype.redSqrt = function () { return r(this.red, 'redSqrt works only with red numbers'), this.red._verify1(this), this.red.sqrt(this) }, o.prototype.redInvm = function () { return r(this.red, 'redInvm works only with red numbers'), this.red._verify1(this), this.red.invm(this) }, o.prototype.redNeg = function () { return r(this.red, 'redNeg works only with red numbers'), this.red._verify1(this), this.red.neg(this) }, o.prototype.redPow = function (e) { return r(this.red && !e.red, 'redPow(normalNum)'), this.red._verify1(this), this.red.pow(this, e) }; const y = { k256: null, p224: null, p192: null, p25519: null }; function b (e, t) { this.name = e, this.p = new o(t, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } function v () { b.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f') } function w () { b.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001') } function _ () { b.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff') } function E () { b.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed') } function k (e) { if (typeof e === 'string') { const t = o._prime(e); this.m = t.p, this.prime = t } else r(e.gtn(1), 'modulus must be greater than 1'), this.m = e, this.prime = null } function S (e) { k.call(this, e), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) }b.prototype._tmp = function () { const e = new o(null); return e.words = new Array(Math.ceil(this.n / 13)), e }, b.prototype.ireduce = function (e) { let t; let n = e; do { this.split(n, this.tmp), t = (n = (n = this.imulK(n)).iadd(this.tmp)).bitLength() } while (t > this.n); const r = t < this.n ? -1 : n.ucmp(this.p); return r === 0 ? (n.words[0] = 0, n.length = 1) : r > 0 ? n.isub(this.p) : void 0 !== n.strip ? n.strip() : n._strip(), n }, b.prototype.split = function (e, t) { e.iushrn(this.n, 0, t) }, b.prototype.imulK = function (e) { return e.imul(this.k) }, i(v, b), v.prototype.split = function (e, t) { for (var n = 4194303, r = Math.min(e.length, 9), i = 0; i < r; i++)t.words[i] = e.words[i]; if (t.length = r, e.length <= 9) return e.words[0] = 0, void (e.length = 1); let o = e.words[9]; for (t.words[t.length++] = o & n, i = 10; i < e.length; i++) { const a = 0 | e.words[i]; e.words[i - 10] = (a & n) << 4 | o >>> 22, o = a }o >>>= 22, e.words[i - 10] = o, o === 0 && e.length > 10 ? e.length -= 10 : e.length -= 9 }, v.prototype.imulK = function (e) { e.words[e.length] = 0, e.words[e.length + 1] = 0, e.length += 2; for (let t = 0, n = 0; n < e.length; n++) { const r = 0 | e.words[n]; t += 977 * r, e.words[n] = 67108863 & t, t = 64 * r + (t / 67108864 | 0) } return e.words[e.length - 1] === 0 && (e.length--, e.words[e.length - 1] === 0 && e.length--), e }, i(w, b), i(_, b), i(E, b), E.prototype.imulK = function (e) { for (var t = 0, n = 0; n < e.length; n++) { let r = 19 * (0 | e.words[n]) + t; const i = 67108863 & r; r >>>= 26, e.words[n] = i, t = r } return t !== 0 && (e.words[e.length++] = t), e }, o._prime = function (e) { if (y[e]) return y[e]; let t; if (e === 'k256')t = new v(); else if (e === 'p224')t = new w(); else if (e === 'p192')t = new _(); else { if (e !== 'p25519') throw new Error('Unknown prime ' + e); t = new E() } return y[e] = t, t }, k.prototype._verify1 = function (e) { r(e.negative === 0, 'red works only with positives'), r(e.red, 'red works only with red numbers') }, k.prototype._verify2 = function (e, t) { r((e.negative | t.negative) == 0, 'red works only with positives'), r(e.red && e.red === t.red, 'red works only with red numbers') }, k.prototype.imod = function (e) { return this.prime ? this.prime.ireduce(e)._forceRed(this) : e.umod(this.m)._forceRed(this) }, k.prototype.neg = function (e) { return e.isZero() ? e.clone() : this.m.sub(e)._forceRed(this) }, k.prototype.add = function (e, t) { this._verify2(e, t); const n = e.add(t); return n.cmp(this.m) >= 0 && n.isub(this.m), n._forceRed(this) }, k.prototype.iadd = function (e, t) { this._verify2(e, t); const n = e.iadd(t); return n.cmp(this.m) >= 0 && n.isub(this.m), n }, k.prototype.sub = function (e, t) { this._verify2(e, t); const n = e.sub(t); return n.cmpn(0) < 0 && n.iadd(this.m), n._forceRed(this) }, k.prototype.isub = function (e, t) { this._verify2(e, t); const n = e.isub(t); return n.cmpn(0) < 0 && n.iadd(this.m), n }, k.prototype.shl = function (e, t) { return this._verify1(e), this.imod(e.ushln(t)) }, k.prototype.imul = function (e, t) { return this._verify2(e, t), this.imod(e.imul(t)) }, k.prototype.mul = function (e, t) { return this._verify2(e, t), this.imod(e.mul(t)) }, k.prototype.isqr = function (e) { return this.imul(e, e.clone()) }, k.prototype.sqr = function (e) { return this.mul(e, e) }, k.prototype.sqrt = function (e) { if (e.isZero()) return e.clone(); const t = this.m.andln(3); if (r(t % 2 == 1), t === 3) { const n = this.m.add(new o(1)).iushrn(2); return this.pow(e, n) } for (var i = this.m.subn(1), a = 0; !i.isZero() && i.andln(1) === 0;)a++, i.iushrn(1); r(!i.isZero()); const s = new o(1).toRed(this); const c = s.redNeg(); const u = this.m.subn(1).iushrn(1); let l = this.m.bitLength(); for (l = new o(2 * l * l).toRed(this); this.pow(l, u).cmp(c) !== 0;)l.redIAdd(c); for (var d = this.pow(l, i), f = this.pow(e, i.addn(1).iushrn(1)), h = this.pow(e, i), p = a; h.cmp(s) !== 0;) { for (var g = h, m = 0; g.cmp(s) !== 0; m++)g = g.redSqr(); r(m < p); const y = this.pow(d, new o(1).iushln(p - m - 1)); f = f.redMul(y), d = y.redSqr(), h = h.redMul(d), p = m } return f }, k.prototype.invm = function (e) { const t = e._invmp(this.m); return t.negative !== 0 ? (t.negative = 0, this.imod(t).redNeg()) : this.imod(t) }, k.prototype.pow = function (e, t) { if (t.isZero()) return new o(1).toRed(this); if (t.cmpn(1) === 0) return e.clone(); const n = new Array(16); n[0] = new o(1).toRed(this), n[1] = e; for (var r = 2; r < n.length; r++)n[r] = this.mul(n[r - 1], e); let i = n[0]; let a = 0; let s = 0; let c = t.bitLength() % 26; for (c === 0 && (c = 26), r = t.length - 1; r >= 0; r--) { for (let u = t.words[r], l = c - 1; l >= 0; l--) { const d = u >> l & 1; i !== n[0] && (i = this.sqr(i)), d !== 0 || a !== 0 ? (a <<= 1, a |= d, (++s === 4 || r === 0 && l === 0) && (i = this.mul(i, n[a]), s = 0, a = 0)) : s = 0 }c = 26 } return i }, k.prototype.convertTo = function (e) { const t = e.umod(this.m); return t === e ? t.clone() : t }, k.prototype.convertFrom = function (e) { const t = e.clone(); return t.red = null, t }, o.mont = function (e) { return new S(e) }, i(S, k), S.prototype.convertTo = function (e) { return this.imod(e.ushln(this.shift)) }, S.prototype.convertFrom = function (e) { const t = this.imod(e.mul(this.rinv)); return t.red = null, t }, S.prototype.imul = function (e, t) { if (e.isZero() || t.isZero()) return e.words[0] = 0, e.length = 1, e; const n = e.imul(t); const r = n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m); const i = n.isub(r).iushrn(this.shift); let o = i; return i.cmp(this.m) >= 0 ? o = i.isub(this.m) : i.cmpn(0) < 0 && (o = i.iadd(this.m)), o._forceRed(this) }, S.prototype.mul = function (e, t) { if (e.isZero() || t.isZero()) return new o(0)._forceRed(this); const n = e.mul(t); const r = n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m); const i = n.isub(r).iushrn(this.shift); let a = i; return i.cmp(this.m) >= 0 ? a = i.isub(this.m) : i.cmpn(0) < 0 && (a = i.iadd(this.m)), a._forceRed(this) }, S.prototype.invm = function (e) { return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this) } }(e = n.nmd(e), this)) }, 6683: e => { 'use strict'; for (var t = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l', n = {}, r = 0; r < 32; r++) { const i = t.charAt(r); if (void 0 !== n[i]) throw new TypeError(i + ' is ambiguous'); n[i] = r } function o (e) { const t = e >> 25; return (33554431 & e) << 5 ^ 996825010 & -(t >> 0 & 1) ^ 642813549 & -(t >> 1 & 1) ^ 513874426 & -(t >> 2 & 1) ^ 1027748829 & -(t >> 3 & 1) ^ 705979059 & -(t >> 4 & 1) } function a (e) { for (var t = 1, n = 0; n < e.length; ++n) { const r = e.charCodeAt(n); if (r < 33 || r > 126) return 'Invalid prefix (' + e + ')'; t = o(t) ^ r >> 5 } for (t = o(t), n = 0; n < e.length; ++n) { const i = e.charCodeAt(n); t = o(t) ^ 31 & i } return t } function s (e, t) { if (t = t || 90, e.length < 8) return e + ' too short'; if (e.length > t) return 'Exceeds length limit'; const r = e.toLowerCase(); const i = e.toUpperCase(); if (e !== r && e !== i) return 'Mixed-case string ' + e; const s = (e = r).lastIndexOf('1'); if (s === -1) return 'No separator character for ' + e; if (s === 0) return 'Missing prefix for ' + e; const c = e.slice(0, s); const u = e.slice(s + 1); if (u.length < 6) return 'Data too short'; let l = a(c); if (typeof l === 'string') return l; for (var d = [], f = 0; f < u.length; ++f) { const h = u.charAt(f); const p = n[h]; if (void 0 === p) return 'Unknown character ' + h; l = o(l) ^ p, f + 6 >= u.length || d.push(p) } return l !== 1 ? 'Invalid checksum for ' + e : { prefix: c, words: d } } function c (e, t, n, r) { for (var i = 0, o = 0, a = (1 << n) - 1, s = [], c = 0; c < e.length; ++c) for (i = i << t | e[c], o += t; o >= n;)o -= n, s.push(i >> o & a); if (r)o > 0 && s.push(i << n - o & a); else { if (o >= t) return 'Excess padding'; if (i << n - o & a) return 'Non-zero padding' } return s }e.exports = { decodeUnsafe: function () { const e = s.apply(null, arguments); if (typeof e === 'object') return e }, decode: function (e) { const t = s.apply(null, arguments); if (typeof t === 'object') return t; throw new Error(t) }, encode: function (e, n, r) { if (r = r || 90, e.length + 7 + n.length > r) throw new TypeError('Exceeds length limit'); let i = a(e = e.toLowerCase()); if (typeof i === 'string') throw new Error(i); for (var s = e + '1', c = 0; c < n.length; ++c) { const u = n[c]; if (u >> 5 != 0) throw new Error('Non 5-bit word'); i = o(i) ^ u, s += t.charAt(u) } for (c = 0; c < 6; ++c)i = o(i); for (i ^= 1, c = 0; c < 6; ++c) { s += t.charAt(i >> 5 * (5 - c) & 31) } return s }, toWordsUnsafe: function (e) { const t = c(e, 8, 5, !0); if (Array.isArray(t)) return t }, toWords: function (e) { const t = c(e, 8, 5, !0); if (Array.isArray(t)) return t; throw new Error(t) }, fromWordsUnsafe: function (e) { const t = c(e, 5, 8, !1); if (Array.isArray(t)) return t }, fromWords: function (e) { const t = c(e, 5, 8, !1); if (Array.isArray(t)) return t; throw new Error(t) } } }, 8805: (e, t, n) => { 'use strict'; const r = n(3482); const i = n(6683); const o = n(7221); const a = n(9509).Buffer; const s = n(3550); const c = n(7656).Lk; const u = n(361); const l = { bech32: 'bc', pubKeyHash: 0, scriptHash: 5, validWitnessVersions: [0, 1] }; const d = { bech32: 'tb', pubKeyHash: 111, scriptHash: 196, validWitnessVersions: [0, 1] }; const f = { bech32: 'bcrt', pubKeyHash: 111, scriptHash: 196, validWitnessVersions: [0, 1] }; const h = { bech32: 'sb', pubKeyHash: 63, scriptHash: 123, validWitnessVersions: [0, 1] }; const p = { word_length: 4, var_onion_optin: { required: !1, supported: !0 }, payment_secret: { required: !1, supported: !0 } }; const g = ['option_data_loss_protect', 'initial_routing_sync', 'option_upfront_shutdown_script', 'gossip_queries', 'var_onion_optin', 'gossip_queries_ex', 'option_static_remotekey', 'payment_secret', 'basic_mpp', 'option_support_large_channel']; const m = { m: new s(1e3, 10), u: new s(1e6, 10), n: new s(1e9, 10), p: new s(1e12, 10) }; const y = new s('2100000000000000000', 10); const b = new s(1e11, 10); const v = new s(1e8, 10); const w = new s(1e5, 10); const _ = new s(100, 10); const E = new s(10, 10); const k = { payment_hash: 1, payment_secret: 16, description: 13, payee_node_key: 19, purpose_commit_hash: 23, expire_time: 6, min_final_cltv_expiry: 24, fallback_address: 9, routing_info: 3, feature_bits: 5 }; const S = {}; for (let e = 0, t = Object.keys(k); e < t.length; e++) { const n = t[e]; const r = k[t[e]].toString(); S[r] = n } const A = { payment_hash: L, payment_secret: L, description: function (e) { const t = (function (e) { return a.from(e, 'utf8') }(e)); return i.toWords(t) }, payee_node_key: L, purpose_commit_hash: function (e) { let t; if (void 0 === e || !(typeof e === 'string' || e instanceof String)) throw new Error('purpose or purpose commit must be a string or hex string'); t = e.match(/^([a-zA-Z0-9]{2})*$/) ? a.from(e, 'hex') : R(a.from(e, 'utf8')); return i.toWords(t) }, expire_time: T, min_final_cltv_expiry: T, fallback_address: function (e, t) { return [e.code].concat(L(e.addressHash)) }, routing_info: function (e) { let t = a.from([]); return e.forEach(e => { t = a.concat([t, B(e.pubkey)]), t = a.concat([t, B(e.short_channel_id)]), t = a.concat([t, a.from([0, 0, 0].concat(T(e.fee_base_msat, 8)).slice(-4))]), t = a.concat([t, a.from([0, 0, 0].concat(T(e.fee_proportional_millionths, 8)).slice(-4))]), t = a.concat([t, a.from([0].concat(T(e.cltv_expiry_delta, 8)).slice(-2))]) }), L(t) }, feature_bits: function (e) { let t = e.word_length; let n = []; g.forEach(t => { n.push(!!(e[t] || {}).required), n.push(!!(e[t] || {}).supported) }); for (;!1 === n[n.length - 1];)n.pop(); for (;n.length % 5 != 0;)n.push(!1); if (e.extra_bits && Array.isArray(e.extra_bits.bits) && e.extra_bits.bits.length > 0) { for (;n.length < e.extra_bits.start_bit;)n.push(!1); n = n.concat(e.extra_bits.bits) } if (void 0 !== t && n.length / 5 > t) throw new Error('word_length is too small to contain all featureBits'); void 0 === t && (t = Math.ceil(n.length / 5)); return new Array(t).fill(0).map((e, t) => n[5 * t + 4] << 4 | n[5 * t + 3] << 3 | n[5 * t + 2] << 2 | n[5 * t + 1] << 1 | n[5 * t] << 0).reverse() } }; const O = { 1: e => C(e, !0).toString('hex'), 16: e => C(e, !0).toString('hex'), 13: e => C(e, !0).toString('utf8'), 19: e => C(e, !0).toString('hex'), 23: e => C(e, !0).toString('hex'), 6: N, 24: N, 9: function (e, t) { const n = e[0]; const r = C(e = e.slice(1), !0); let i = null; switch (n) { case 17:i = c.toBase58Check(r, t.pubKeyHash); break; case 18:i = c.toBase58Check(r, t.scriptHash); break; case 0:case 1:i = c.toBech32(r, n, t.bech32) } return { code: n, address: i, addressHash: r.toString('hex') } }, 3: function (e) { const t = []; let n; let r; let i; let o; let a; let s = C(e, !0); for (;s.length > 0;)n = s.slice(0, 33).toString('hex'), r = s.slice(33, 41).toString('hex'), i = parseInt(s.slice(41, 45).toString('hex'), 16), o = parseInt(s.slice(45, 49).toString('hex'), 16), a = parseInt(s.slice(49, 51).toString('hex'), 16), s = s.slice(51), t.push({ pubkey: n, short_channel_id: r, fee_base_msat: i, fee_proportional_millionths: o, cltv_expiry_delta: a }); return t }, 5: function (e) { const t = e.slice().reverse().map(e => [!!(1 & e), !!(2 & e), !!(4 & e), !!(8 & e), !!(16 & e)]).reduce((e, t) => e.concat(t), []); for (;t.length < 2 * g.length;)t.push(!1); const n = { word_length: e.length }; if (g.forEach((e, r) => { n[e] = { required: t[2 * r], supported: t[2 * r + 1] } }), t.length > 2 * g.length) { const e = t.slice(2 * g.length); n.extra_bits = { start_bit: 2 * g.length, bits: e, has_required: e.reduce((e, t, n) => n % 2 != 0 ? e || !1 : e || t, !1) } } else n.extra_bits = { start_bit: 2 * g.length, bits: [], has_required: !1 }; return n } }; const x = 'unknownTag'; function I (e) { return t => ({ tagCode: parseInt(e), words: i.encode('unknown', t, Number.MAX_SAFE_INTEGER) }) } function N (e) { return e.reverse().reduce((e, t, n) => e + t * Math.pow(32, n), 0) } function T (e, t) { const n = []; if (void 0 === t && (t = 5), (e = Math.floor(e)) === 0) return [0]; for (;e > 0;)n.push(e & Math.pow(2, t) - 1), e = Math.floor(e / Math.pow(2, t)); return n.reverse() } function R (e) { return r('sha256').update(e).digest() } function P (e, t, n) { let r = 0; let i = 0; const o = (1 << n) - 1; const a = []; for (let s = 0; s < e.length; ++s) for (r = r << t | e[s], i += t; i >= n;)i -= n, a.push(r >> i & o); return i > 0 && a.push(r << n - i & o), a } function C (e, t) { let n = a.from(P(e, 5, 8)); return t && 5 * e.length % 8 != 0 && (n = n.slice(0, -1)), n } function B (e) { return void 0 !== e && (typeof e === 'string' || e instanceof String) && e.match(/^([a-zA-Z0-9]{2})*$/) ? a.from(e, 'hex') : e } function L (e) { const t = B(e); return i.toWords(t) } function j (e, t) { const n = e.filter(e => e.tagName === t); return n.length > 0 ? n[0].data : null } function D (e, t) { return j(e, t) !== null } function U (e, t) { const n = {}; if (Object.keys(e).sort().forEach(t => { n[t] = e[t] }), !0 === t) { const e = '__tagsObject_cache'; Object.defineProperty(n, 'tagsObject', { get () { return this[e] || Object.defineProperty(this, e, { value: q(this.tags) }), this[e] } }) } return n } function M (e) { if (!e.toString().match(/^\d+$/)) throw new Error('satoshis must be an integer'); return z(new s(e, 10).mul(new s(1e3, 10))) } function z (e) { if (!e.toString().match(/^\d+$/)) throw new Error('millisatoshis must be an integer'); const t = new s(e, 10); const n = t.toString(10); const r = n.length; let i, o; return r > 11 && /0{11}$/.test(n) ? (i = '', o = t.div(b).toString(10)) : r > 8 && /0{8}$/.test(n) ? (i = 'm', o = t.div(v).toString(10)) : r > 5 && /0{5}$/.test(n) ? (i = 'u', o = t.div(w).toString(10)) : r > 2 && /0{2}$/.test(n) ? (i = 'n', o = t.div(_).toString(10)) : (i = 'p', o = t.mul(E).toString(10)), o + i } function F (e, t) { const n = H(e, !1); if (!n.mod(new s(1e3, 10)).eq(new s(0, 10))) throw new Error('Amount is outside of valid range'); const r = n.div(new s(1e3, 10)); return t ? r.toString() : r } function H (e, t) { let n, r; if (e.slice(-1).match(/^[munp]$/))n = e.slice(-1), r = e.slice(0, -1); else { if (e.slice(-1).match(/^[^munp0-9]$/)) throw new Error('Not a valid multiplier for the amount'); r = e } if (!r.match(/^\d+$/)) throw new Error('Not a valid human readable amount'); const i = new s(r, 10); const o = n ? i.mul(b).div(m[n]) : i.mul(b); if (n === 'p' && !i.mod(new s(10, 10)).eq(new s(0, 10)) || o.gt(y)) throw new Error('Amount is outside of valid range'); return t ? o.toString() : o } function q (e) { const t = {}; return e.forEach(e => { e.tagName === x ? (t.unknownTags || (t.unknownTags = []), t.unknownTags.push(e.data)) : t[e.tagName] = e.data }), t }e.exports = { encode: function (e, t) { const n = u(e); void 0 === t && (t = !0); const r = !(void 0 === n.signature || void 0 === n.recoveryFlag); let d, f, h, g, m, y; if (void 0 !== n.network || r) { if (void 0 === n.network && r) throw new Error('Need network for proper payment request reconstruction'); if (!n.network.bech32 || void 0 === n.network.pubKeyHash || void 0 === n.network.scriptHash || !Array.isArray(n.network.validWitnessVersions)) throw new Error('Invalid network'); d = n.network } else n.network = l, d = l; if (void 0 !== n.timestamp || r) { if (void 0 === n.timestamp && r) throw new Error('Need timestamp for proper payment request reconstruction') } else n.timestamp = Math.floor((new Date()).getTime() / 1e3); if (void 0 === n.tags) throw new Error('Payment Requests need tags array'); if (!D(n.tags, S[1])) throw new Error('Lightning Payment Request needs a payment hash'); if (D(n.tags, S[16])) if (D(n.tags, S[5])) { const e = j(n.tags, S[5]); if (!e.payment_secret || !e.payment_secret.supported && !e.payment_secret.required) throw new Error('Payment request requires feature bits with at least payment secret support flagged if payment secret is included') } else { if (!t) throw new Error('Payment request requires feature bits with at least payment secret support flagged if payment secret is included'); n.tags.push({ tagName: S[5], data: p }) } if (!D(n.tags, S[13]) && !D(n.tags, S[23])) { if (!t) throw new Error('Payment request requires description or purpose commit hash'); n.tags.push({ tagName: S[13], data: '' }) } if (D(n.tags, S[13]) && a.from(j(n.tags, S[13]), 'utf8').length > 639) throw new Error('Description is too long: Max length 639 bytes'); if (D(n.tags, S[6]) || r || !t || n.tags.push({ tagName: S[6], data: 3600 }), D(n.tags, S[24]) || r || !t || n.tags.push({ tagName: S[24], data: 9 }), D(n.tags, S[19]) && (h = B(j(n.tags, S[19]))), n.payeeNodeKey && (f = B(n.payeeNodeKey)), f && h && !h.equals(f)) throw new Error('payeeNodeKey and tag payee node key do not match'); if (f = f || h, f && (n.payeeNodeKey = f.toString('hex')), D(n.tags, S[9])) { const e = j(n.tags, S[9]); if (y = e.address, m = e.addressHash, g = e.code, void 0 === m || void 0 === g) { let t, n; try { t = c.fromBech32(y), m = t.data, g = t.version } catch (e) { try { n = c.fromBase58Check(y), n.version === d.pubKeyHash ? g = 17 : n.version === d.scriptHash && (g = 18), m = n.hash } catch (e) { throw new Error('Fallback address type is unknown') } } if (t && !(t.version in d.validWitnessVersions)) throw new Error('Fallback address witness version is unknown'); if (t && t.prefix !== d.bech32) throw new Error('Fallback address network type does not match payment request network type'); if (n && n.version !== d.pubKeyHash && n.version !== d.scriptHash) throw new Error('Fallback address version (base58) is unknown or the network type is incorrect'); e.addressHash = m.toString('hex'), e.code = g } } if (D(n.tags, S[3])) { j(n.tags, S[3]).forEach(e => { if (void 0 === e.pubkey || void 0 === e.short_channel_id || void 0 === e.fee_base_msat || void 0 === e.fee_proportional_millionths || void 0 === e.cltv_expiry_delta) throw new Error('Routing info is incomplete'); if (!o.publicKeyVerify(B(e.pubkey))) throw new Error('Routing info pubkey is not a valid pubkey'); const t = B(e.short_channel_id); if (!(t instanceof a) || t.length !== 8) throw new Error('Routing info short channel id must be 8 bytes'); if (typeof e.fee_base_msat !== 'number' || Math.floor(e.fee_base_msat) !== e.fee_base_msat) throw new Error('Routing info fee base msat is not an integer'); if (typeof e.fee_proportional_millionths !== 'number' || Math.floor(e.fee_proportional_millionths) !== e.fee_proportional_millionths) throw new Error('Routing info fee proportional millionths is not an integer'); if (typeof e.cltv_expiry_delta !== 'number' || Math.floor(e.cltv_expiry_delta) !== e.cltv_expiry_delta) throw new Error('Routing info cltv expiry delta is not an integer') }) } let b; let v = 'ln'; if (v += d.bech32, n.millisatoshis && n.satoshis) { b = z(new s(n.millisatoshis, 10)); if (M(new s(n.satoshis, 10)) !== b) throw new Error('satoshis and millisatoshis do not match') } else b = n.millisatoshis ? z(new s(n.millisatoshis, 10)) : n.satoshis ? M(new s(n.satoshis, 10)) : ''; v += b; const w = T(n.timestamp); for (;w.length < 7;)w.unshift(0); const _ = n.tags; let E = []; _.forEach(e => { const t = Object.keys(A); if (r && t.push(x), t.indexOf(e.tagName) === -1) throw new Error('Unknown tag key: ' + e.tagName); let n; if (e.tagName !== x) { E.push(k[e.tagName]); n = (0, A[e.tagName])(e.data) } else { const t = (function (e) { return e.words = i.decode(e.words, Number.MAX_SAFE_INTEGER).words, e }(e.data)); E.push(t.tagCode), n = t.words }E = E.concat([0].concat(T(n.length)).slice(-2)), E = E.concat(n) }); let O = w.concat(E); const I = R(a.concat([a.from(v, 'utf8'), a.from(P(O, 5, 8))])); let N; if (r) { if (!f) throw new Error('Reconstruction with signature and recoveryID requires payeeNodeKey to verify correctness of input data.'); { const e = a.from(o.ecdsaRecover(a.from(n.signature, 'hex'), n.recoveryFlag, I, !0)); if (f && !f.equals(e)) throw new Error('Signature, message, and recoveryID did not produce the same pubkey as payeeNodeKey'); N = L(n.signature + '0' + n.recoveryFlag) } } return N && (O = O.concat(N)), D(n.tags, S[6]) && (n.timeExpireDate = n.timestamp + j(n.tags, S[6]), n.timeExpireDateString = new Date(1e3 * n.timeExpireDate).toISOString()), n.timestampString = new Date(1e3 * n.timestamp).toISOString(), n.complete = !!N, n.paymentRequest = n.complete ? i.encode(v, O, Number.MAX_SAFE_INTEGER) : '', n.prefix = v, n.wordsTemp = i.encode('temp', O, Number.MAX_SAFE_INTEGER), U(n) }, decode: function (e, t) { if (typeof e !== 'string') throw new Error('Lightning Payment Request must be string'); if (e.slice(0, 2).toLowerCase() !== 'ln') throw new Error('Not a proper lightning payment request'); const n = i.decode(e, Number.MAX_SAFE_INTEGER); e = e.toLowerCase(); const r = n.prefix; let s = n.words; const c = s.slice(-104); const u = s.slice(0, -104); s = s.slice(0, -104); let p = C(c, !0); const g = p.slice(-1)[0]; if (p = p.slice(0, -1), !(g in [0, 1, 2, 3]) || p.length !== 64) throw new Error('Signature is missing or incorrect'); let m = r.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/); if (m && !m[2] && (m = r.match(/^ln(\S+)$/)), !m) throw new Error('Not a proper lightning payment request'); const y = m[1]; let b; if (t) { if (void 0 === t.bech32 || void 0 === t.pubKeyHash || void 0 === t.scriptHash || !Array.isArray(t.validWitnessVersions)) throw new Error('Invalid network'); b = t } else switch (y) { case l.bech32:b = l; break; case d.bech32:b = d; break; case f.bech32:b = f; break; case h.bech32:b = h } if (!b || b.bech32 !== y) throw new Error('Unknown coin bech32 prefix'); const v = m[2]; let w, _, E; if (v) { const e = m[3]; try { w = parseInt(F(v + e, !0)) } catch (e) { w = null, E = !0 }_ = H(v + e, !0) } else w = null, _ = null; const k = N(s.slice(0, 7)); const A = new Date(1e3 * k).toISOString(); s = s.slice(7); const T = []; let B, L, M, z, q, K; for (;s.length > 0;) { const e = s[0].toString(); B = S[e] || x, L = O[e] || I(e), s = s.slice(1), M = N(s.slice(0, 2)), s = s.slice(2), z = s.slice(0, M), s = s.slice(M), T.push({ tagName: B, data: L(z, b) }) }D(T, S[6]) && (q = k + j(T, S[6]), K = new Date(1e3 * q).toISOString()); const V = R(a.concat([a.from(r, 'utf8'), a.from(P(u, 5, 8))])); const W = a.from(o.ecdsaRecover(p, g, V, !0)); if (D(T, S[19]) && j(T, S[19]) !== W.toString('hex')) throw new Error('Lightning Payment Request signature pubkey does not match payee pubkey'); let $ = { paymentRequest: e, complete: !0, prefix: r, wordsTemp: i.encode('temp', u.concat(c), Number.MAX_SAFE_INTEGER), network: b, satoshis: w, millisatoshis: _, timestamp: k, timestampString: A, payeeNodeKey: W.toString('hex'), signature: p.toString('hex'), recoveryFlag: g, tags: T }; return E && delete $.satoshis, q && ($ = Object.assign($, { timeExpireDate: q, timeExpireDateString: K })), U($, !0) }, sign: function (e, t) { const n = u(e); const r = B(t); if (n.complete && n.paymentRequest) return n; if (void 0 === r || r.length !== 32 || !o.privateKeyVerify(r)) throw new Error('privateKey must be a 32 byte Buffer and valid private key'); let s, c; if (D(n.tags, S[19]) && (c = B(j(n.tags, S[19]))), n.payeeNodeKey && (s = B(n.payeeNodeKey)), s && c && !c.equals(s)) throw new Error('payee node key tag and payeeNodeKey attribute must match'); s = c || s; const l = a.from(o.publicKeyCreate(r)); if (s && !l.equals(s)) throw new Error('The private key given is not the private key of the node public key given'); const d = i.decode(n.wordsTemp, Number.MAX_SAFE_INTEGER).words; const f = R(a.concat([a.from(n.prefix, 'utf8'), C(d)])); const h = o.ecdsaSign(f, r); h.signature = a.from(h.signature); const p = L(h.signature.toString('hex') + '0' + h.recid); return n.payeeNodeKey = l.toString('hex'), n.signature = h.signature.toString('hex'), n.recoveryFlag = h.recid, n.wordsTemp = i.encode('temp', d.concat(p), Number.MAX_SAFE_INTEGER), n.complete = !0, n.paymentRequest = i.encode(n.prefix, d.concat(p), Number.MAX_SAFE_INTEGER), U(n) }, satToHrp: M, millisatToHrp: z, hrpToSat: F, hrpToMillisat: H } }, 9931: (e, t, n) => { let r; function i (e) { this.rand = e } if (e.exports = function (e) { return r || (r = new i(null)), r.generate(e) }, e.exports.Rand = i, i.prototype.generate = function (e) { return this._rand(e) }, i.prototype._rand = function (e) { if (this.rand.getBytes) return this.rand.getBytes(e); for (var t = new Uint8Array(e), n = 0; n < t.length; n++)t[n] = this.rand.getByte(); return t }, typeof self === 'object')self.crypto && self.crypto.getRandomValues ? i.prototype._rand = function (e) { const t = new Uint8Array(e); return self.crypto.getRandomValues(t), t } : self.msCrypto && self.msCrypto.getRandomValues ? i.prototype._rand = function (e) { const t = new Uint8Array(e); return self.msCrypto.getRandomValues(t), t } : typeof window === 'object' && (i.prototype._rand = function () { throw new Error('Not implemented yet') }); else try { const o = n(9214); if (typeof o.randomBytes !== 'function') throw new Error('Not supported'); i.prototype._rand = function (e) { return o.randomBytes(e) } } catch (e) {} }, 7191: (e, t, n) => { const r = n(8162); e.exports = r('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz') }, 3310: (e, t, n) => { 'use strict'; const r = n(7191); const i = n(9509).Buffer; e.exports = function (e) { function t (t) { const n = t.slice(0, -4); const r = t.slice(-4); const i = e(n); if (!(r[0] ^ i[0] | r[1] ^ i[1] | r[2] ^ i[2] | r[3] ^ i[3])) return n } return { encode: function (t) { const n = e(t); return r.encode(i.concat([t, n], t.length + 4)) }, decode: function (e) { const n = t(r.decode(e)); if (!n) throw new Error('Invalid checksum'); return n }, decodeUnsafe: function (e) { const n = r.decodeUnsafe(e); if (n) return t(n) } } } }, 8334: (e, t, n) => { 'use strict'; const r = n(3482); const i = n(3310); e.exports = i(function (e) { const t = r('sha256').update(e).digest(); return r('sha256').update(t).digest() }) }, 8764: (e, t, n) => { 'use strict'; const r = n(9742); const i = n(645); const o = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : null; t.Buffer = c, t.SlowBuffer = function (e) { +e != e && (e = 0); return c.alloc(+e) }, t.INSPECT_MAX_BYTES = 50; const a = 2147483647; function s (e) { if (e > a) throw new RangeError('The value "' + e + '" is invalid for option "size"'); const t = new Uint8Array(e); return Object.setPrototypeOf(t, c.prototype), t } function c (e, t, n) { if (typeof e === 'number') { if (typeof t === 'string') throw new TypeError('The "string" argument must be of type string. Received type number'); return d(e) } return u(e, t, n) } function u (e, t, n) { if (typeof e === 'string') return (function (e, t) { typeof t === 'string' && t !== '' || (t = 'utf8'); if (!c.isEncoding(t)) throw new TypeError('Unknown encoding: ' + t); const n = 0 | g(e, t); let r = s(n); const i = r.write(e, t); i !== n && (r = r.slice(0, i)); return r }(e, t)); if (ArrayBuffer.isView(e)) return (function (e) { if (Y(e, Uint8Array)) { const t = new Uint8Array(e); return h(t.buffer, t.byteOffset, t.byteLength) } return f(e) }(e)); if (e == null) throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof e); if (Y(e, ArrayBuffer) || e && Y(e.buffer, ArrayBuffer)) return h(e, t, n); if (typeof SharedArrayBuffer !== 'undefined' && (Y(e, SharedArrayBuffer) || e && Y(e.buffer, SharedArrayBuffer))) return h(e, t, n); if (typeof e === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number'); const r = e.valueOf && e.valueOf(); if (r != null && r !== e) return c.from(r, t, n); const i = (function (e) { if (c.isBuffer(e)) { const t = 0 | p(e.length); const n = s(t); return n.length === 0 || e.copy(n, 0, 0, t), n } if (void 0 !== e.length) return typeof e.length !== 'number' || Z(e.length) ? s(0) : f(e); if (e.type === 'Buffer' && Array.isArray(e.data)) return f(e.data) }(e)); if (i) return i; if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === 'function') return c.from(e[Symbol.toPrimitive]('string'), t, n); throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof e) } function l (e) { if (typeof e !== 'number') throw new TypeError('"size" argument must be of type number'); if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"') } function d (e) { return l(e), s(e < 0 ? 0 : 0 | p(e)) } function f (e) { const t = e.length < 0 ? 0 : 0 | p(e.length); const n = s(t); for (let r = 0; r < t; r += 1)n[r] = 255 & e[r]; return n } function h (e, t, n) { if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds'); if (e.byteLength < t + (n || 0)) throw new RangeError('"length" is outside of buffer bounds'); let r; return r = void 0 === t && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, t) : new Uint8Array(e, t, n), Object.setPrototypeOf(r, c.prototype), r } function p (e) { if (e >= a) throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' + a.toString(16) + ' bytes'); return 0 | e } function g (e, t) { if (c.isBuffer(e)) return e.length; if (ArrayBuffer.isView(e) || Y(e, ArrayBuffer)) return e.byteLength; if (typeof e !== 'string') throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e); const n = e.length; const r = arguments.length > 2 && !0 === arguments[2]; if (!r && n === 0) return 0; let i = !1; for (;;) switch (t) { case 'ascii':case 'latin1':case 'binary':return n; case 'utf8':case 'utf-8':return W(e).length; case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':return 2 * n; case 'hex':return n >>> 1; case 'base64':return $(e).length; default:if (i) return r ? -1 : W(e).length; t = ('' + t).toLowerCase(), i = !0 } } function m (e, t, n) { let r = !1; if ((void 0 === t || t < 0) && (t = 0), t > this.length) return ''; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return ''; if ((n >>>= 0) <= (t >>>= 0)) return ''; for (e || (e = 'utf8'); ;) switch (e) { case 'hex':return T(this, t, n); case 'utf8':case 'utf-8':return O(this, t, n); case 'ascii':return I(this, t, n); case 'latin1':case 'binary':return N(this, t, n); case 'base64':return A(this, t, n); case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':return R(this, t, n); default:if (r) throw new TypeError('Unknown encoding: ' + e); e = (e + '').toLowerCase(), r = !0 } } function y (e, t, n) { const r = e[t]; e[t] = e[n], e[n] = r } function b (e, t, n, r, i) { if (e.length === 0) return -1; if (typeof n === 'string' ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), Z(n = +n) && (n = i ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) { if (i) return -1; n = e.length - 1 } else if (n < 0) { if (!i) return -1; n = 0 } if (typeof t === 'string' && (t = c.from(t, r)), c.isBuffer(t)) return t.length === 0 ? -1 : v(e, t, n, r, i); if (typeof t === 'number') return t &= 255, typeof Uint8Array.prototype.indexOf === 'function' ? i ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : v(e, [t], n, r, i); throw new TypeError('val must be string, number or Buffer') } function v (e, t, n, r, i) { let o; let a = 1; let s = e.length; let c = t.length; if (void 0 !== r && ((r = String(r).toLowerCase()) === 'ucs2' || r === 'ucs-2' || r === 'utf16le' || r === 'utf-16le')) { if (e.length < 2 || t.length < 2) return -1; a = 2, s /= 2, c /= 2, n /= 2 } function u (e, t) { return a === 1 ? e[t] : e.readUInt16BE(t * a) } if (i) { let r = -1; for (o = n; o < s; o++) if (u(e, o) === u(t, r === -1 ? 0 : o - r)) { if (r === -1 && (r = o), o - r + 1 === c) return r * a } else r !== -1 && (o -= o - r), r = -1 } else for (n + c > s && (n = s - c), o = n; o >= 0; o--) { let n = !0; for (let r = 0; r < c; r++) if (u(e, o + r) !== u(t, r)) { n = !1; break } if (n) return o } return -1 } function w (e, t, n, r) { n = Number(n) || 0; const i = e.length - n; r ? (r = Number(r)) > i && (r = i) : r = i; const o = t.length; let a; for (r > o / 2 && (r = o / 2), a = 0; a < r; ++a) { const r = parseInt(t.substr(2 * a, 2), 16); if (Z(r)) return a; e[n + a] = r } return a } function _ (e, t, n, r) { return G(W(t, e.length - n), e, n, r) } function E (e, t, n, r) { return G((function (e) { const t = []; for (let n = 0; n < e.length; ++n)t.push(255 & e.charCodeAt(n)); return t }(t)), e, n, r) } function k (e, t, n, r) { return G($(t), e, n, r) } function S (e, t, n, r) { return G((function (e, t) { let n, r, i; const o = []; for (let a = 0; a < e.length && !((t -= 2) < 0); ++a)n = e.charCodeAt(a), r = n >> 8, i = n % 256, o.push(i), o.push(r); return o }(t, e.length - n)), e, n, r) } function A (e, t, n) { return t === 0 && n === e.length ? r.fromByteArray(e) : r.fromByteArray(e.slice(t, n)) } function O (e, t, n) { n = Math.min(e.length, n); const r = []; let i = t; for (;i < n;) { const t = e[i]; let o = null; let a = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1; if (i + a <= n) { let n, r, s, c; switch (a) { case 1:t < 128 && (o = t); break; case 2:n = e[i + 1], (192 & n) == 128 && (c = (31 & t) << 6 | 63 & n, c > 127 && (o = c)); break; case 3:n = e[i + 1], r = e[i + 2], (192 & n) == 128 && (192 & r) == 128 && (c = (15 & t) << 12 | (63 & n) << 6 | 63 & r, c > 2047 && (c < 55296 || c > 57343) && (o = c)); break; case 4:n = e[i + 1], r = e[i + 2], s = e[i + 3], (192 & n) == 128 && (192 & r) == 128 && (192 & s) == 128 && (c = (15 & t) << 18 | (63 & n) << 12 | (63 & r) << 6 | 63 & s, c > 65535 && c < 1114112 && (o = c)) } }o === null ? (o = 65533, a = 1) : o > 65535 && (o -= 65536, r.push(o >>> 10 & 1023 | 55296), o = 56320 | 1023 & o), r.push(o), i += a } return (function (e) { const t = e.length; if (t <= x) return String.fromCharCode.apply(String, e); let n = ''; let r = 0; for (;r < t;)n += String.fromCharCode.apply(String, e.slice(r, r += x)); return n }(r)) }t.kMaxLength = a, c.TYPED_ARRAY_SUPPORT = (function () { try { const e = new Uint8Array(1); const t = { foo: function () { return 42 } }; return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42 } catch (e) { return !1 } }()), c.TYPED_ARRAY_SUPPORT || typeof console === 'undefined' || typeof console.error !== 'function' || console.error('This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'), Object.defineProperty(c.prototype, 'parent', { enumerable: !0, get: function () { if (c.isBuffer(this)) return this.buffer } }), Object.defineProperty(c.prototype, 'offset', { enumerable: !0, get: function () { if (c.isBuffer(this)) return this.byteOffset } }), c.poolSize = 8192, c.from = function (e, t, n) { return u(e, t, n) }, Object.setPrototypeOf(c.prototype, Uint8Array.prototype), Object.setPrototypeOf(c, Uint8Array), c.alloc = function (e, t, n) { return (function (e, t, n) { return l(e), e <= 0 ? s(e) : void 0 !== t ? typeof n === 'string' ? s(e).fill(t, n) : s(e).fill(t) : s(e) }(e, t, n)) }, c.allocUnsafe = function (e) { return d(e) }, c.allocUnsafeSlow = function (e) { return d(e) }, c.isBuffer = function (e) { return e != null && !0 === e._isBuffer && e !== c.prototype }, c.compare = function (e, t) { if (Y(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)), Y(t, Uint8Array) && (t = c.from(t, t.offset, t.byteLength)), !c.isBuffer(e) || !c.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (e === t) return 0; let n = e.length; let r = t.length; for (let i = 0, o = Math.min(n, r); i < o; ++i) if (e[i] !== t[i]) { n = e[i], r = t[i]; break } return n < r ? -1 : r < n ? 1 : 0 }, c.isEncoding = function (e) { switch (String(e).toLowerCase()) { case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'latin1':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':return !0; default:return !1 } }, c.concat = function (e, t) { if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers'); if (e.length === 0) return c.alloc(0); let n; if (void 0 === t) for (t = 0, n = 0; n < e.length; ++n)t += e[n].length; const r = c.allocUnsafe(t); let i = 0; for (n = 0; n < e.length; ++n) { let t = e[n]; if (Y(t, Uint8Array))i + t.length > r.length ? (c.isBuffer(t) || (t = c.from(t)), t.copy(r, i)) : Uint8Array.prototype.set.call(r, t, i); else { if (!c.isBuffer(t)) throw new TypeError('"list" argument must be an Array of Buffers'); t.copy(r, i) }i += t.length } return r }, c.byteLength = g, c.prototype._isBuffer = !0, c.prototype.swap16 = function () { const e = this.length; if (e % 2 != 0) throw new RangeError('Buffer size must be a multiple of 16-bits'); for (let t = 0; t < e; t += 2)y(this, t, t + 1); return this }, c.prototype.swap32 = function () { const e = this.length; if (e % 4 != 0) throw new RangeError('Buffer size must be a multiple of 32-bits'); for (let t = 0; t < e; t += 4)y(this, t, t + 3), y(this, t + 1, t + 2); return this }, c.prototype.swap64 = function () { const e = this.length; if (e % 8 != 0) throw new RangeError('Buffer size must be a multiple of 64-bits'); for (let t = 0; t < e; t += 8)y(this, t, t + 7), y(this, t + 1, t + 6), y(this, t + 2, t + 5), y(this, t + 3, t + 4); return this }, c.prototype.toString = function () { const e = this.length; return e === 0 ? '' : arguments.length === 0 ? O(this, 0, e) : m.apply(this, arguments) }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function (e) { if (!c.isBuffer(e)) throw new TypeError('Argument must be a Buffer'); return this === e || c.compare(this, e) === 0 }, c.prototype.inspect = function () { let e = ''; const n = t.INSPECT_MAX_BYTES; return e = this.toString('hex', 0, n).replace(/(.{2})/g, '$1 ').trim(), this.length > n && (e += ' ... '), '<Buffer ' + e + '>' }, o && (c.prototype[o] = c.prototype.inspect), c.prototype.compare = function (e, t, n, r, i) { if (Y(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)), !c.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e); if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), t < 0 || n > e.length || r < 0 || i > this.length) throw new RangeError('out of range index'); if (r >= i && t >= n) return 0; if (r >= i) return -1; if (t >= n) return 1; if (this === e) return 0; let o = (i >>>= 0) - (r >>>= 0); let a = (n >>>= 0) - (t >>>= 0); const s = Math.min(o, a); const u = this.slice(r, i); const l = e.slice(t, n); for (let e = 0; e < s; ++e) if (u[e] !== l[e]) { o = u[e], a = l[e]; break } return o < a ? -1 : a < o ? 1 : 0 }, c.prototype.includes = function (e, t, n) { return this.indexOf(e, t, n) !== -1 }, c.prototype.indexOf = function (e, t, n) { return b(this, e, t, n, !0) }, c.prototype.lastIndexOf = function (e, t, n) { return b(this, e, t, n, !1) }, c.prototype.write = function (e, t, n, r) { if (void 0 === t)r = 'utf8', n = this.length, t = 0; else if (void 0 === n && typeof t === 'string')r = t, n = this.length, t = 0; else { if (!isFinite(t)) throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported'); t >>>= 0, isFinite(n) ? (n >>>= 0, void 0 === r && (r = 'utf8')) : (r = n, n = void 0) } const i = this.length - t; if ((void 0 === n || n > i) && (n = i), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError('Attempt to write outside buffer bounds'); r || (r = 'utf8'); let o = !1; for (;;) switch (r) { case 'hex':return w(this, e, t, n); case 'utf8':case 'utf-8':return _(this, e, t, n); case 'ascii':case 'latin1':case 'binary':return E(this, e, t, n); case 'base64':return k(this, e, t, n); case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':return S(this, e, t, n); default:if (o) throw new TypeError('Unknown encoding: ' + r); r = ('' + r).toLowerCase(), o = !0 } }, c.prototype.toJSON = function () { return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) } }; const x = 4096; function I (e, t, n) { let r = ''; n = Math.min(e.length, n); for (let i = t; i < n; ++i)r += String.fromCharCode(127 & e[i]); return r } function N (e, t, n) { let r = ''; n = Math.min(e.length, n); for (let i = t; i < n; ++i)r += String.fromCharCode(e[i]); return r } function T (e, t, n) { const r = e.length; (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r); let i = ''; for (let r = t; r < n; ++r)i += J[e[r]]; return i } function R (e, t, n) { const r = e.slice(t, n); let i = ''; for (let e = 0; e < r.length - 1; e += 2)i += String.fromCharCode(r[e] + 256 * r[e + 1]); return i } function P (e, t, n) { if (e % 1 != 0 || e < 0) throw new RangeError('offset is not uint'); if (e + t > n) throw new RangeError('Trying to access beyond buffer length') } function C (e, t, n, r, i, o) { if (!c.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (t > i || t < o) throw new RangeError('"value" argument is out of bounds'); if (n + r > e.length) throw new RangeError('Index out of range') } function B (e, t, n, r, i) { H(t, r, i, e, n, 7); let o = Number(t & BigInt(4294967295)); e[n++] = o, o >>= 8, e[n++] = o, o >>= 8, e[n++] = o, o >>= 8, e[n++] = o; let a = Number(t >> BigInt(32) & BigInt(4294967295)); return e[n++] = a, a >>= 8, e[n++] = a, a >>= 8, e[n++] = a, a >>= 8, e[n++] = a, n } function L (e, t, n, r, i) { H(t, r, i, e, n, 7); let o = Number(t & BigInt(4294967295)); e[n + 7] = o, o >>= 8, e[n + 6] = o, o >>= 8, e[n + 5] = o, o >>= 8, e[n + 4] = o; let a = Number(t >> BigInt(32) & BigInt(4294967295)); return e[n + 3] = a, a >>= 8, e[n + 2] = a, a >>= 8, e[n + 1] = a, a >>= 8, e[n] = a, n + 8 } function j (e, t, n, r, i, o) { if (n + r > e.length) throw new RangeError('Index out of range'); if (n < 0) throw new RangeError('Index out of range') } function D (e, t, n, r, o) { return t = +t, n >>>= 0, o || j(e, 0, n, 4), i.write(e, t, n, r, 23, 4), n + 4 } function U (e, t, n, r, o) { return t = +t, n >>>= 0, o || j(e, 0, n, 8), i.write(e, t, n, r, 52, 8), n + 8 }c.prototype.slice = function (e, t) { const n = this.length; (e = ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), (t = void 0 === t ? n : ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e); const r = this.subarray(e, t); return Object.setPrototypeOf(r, c.prototype), r }, c.prototype.readUintLE = c.prototype.readUIntLE = function (e, t, n) { e >>>= 0, t >>>= 0, n || P(e, t, this.length); let r = this[e]; let i = 1; let o = 0; for (;++o < t && (i *= 256);)r += this[e + o] * i; return r }, c.prototype.readUintBE = c.prototype.readUIntBE = function (e, t, n) { e >>>= 0, t >>>= 0, n || P(e, t, this.length); let r = this[e + --t]; let i = 1; for (;t > 0 && (i *= 256);)r += this[e + --t] * i; return r }, c.prototype.readUint8 = c.prototype.readUInt8 = function (e, t) { return e >>>= 0, t || P(e, 1, this.length), this[e] }, c.prototype.readUint16LE = c.prototype.readUInt16LE = function (e, t) { return e >>>= 0, t || P(e, 2, this.length), this[e] | this[e + 1] << 8 }, c.prototype.readUint16BE = c.prototype.readUInt16BE = function (e, t) { return e >>>= 0, t || P(e, 2, this.length), this[e] << 8 | this[e + 1] }, c.prototype.readUint32LE = c.prototype.readUInt32LE = function (e, t) { return e >>>= 0, t || P(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3] }, c.prototype.readUint32BE = c.prototype.readUInt32BE = function (e, t) { return e >>>= 0, t || P(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]) }, c.prototype.readBigUInt64LE = X(function (e) { q(e >>>= 0, 'offset'); const t = this[e]; const n = this[e + 7]; void 0 !== t && void 0 !== n || K(e, this.length - 8); const r = t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24; const i = this[++e] + 256 * this[++e] + 65536 * this[++e] + n * 2 ** 24; return BigInt(r) + (BigInt(i) << BigInt(32)) }), c.prototype.readBigUInt64BE = X(function (e) { q(e >>>= 0, 'offset'); const t = this[e]; const n = this[e + 7]; void 0 !== t && void 0 !== n || K(e, this.length - 8); const r = t * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + this[++e]; const i = this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + n; return (BigInt(r) << BigInt(32)) + BigInt(i) }), c.prototype.readIntLE = function (e, t, n) { e >>>= 0, t >>>= 0, n || P(e, t, this.length); let r = this[e]; let i = 1; let o = 0; for (;++o < t && (i *= 256);)r += this[e + o] * i; return i *= 128, r >= i && (r -= Math.pow(2, 8 * t)), r }, c.prototype.readIntBE = function (e, t, n) { e >>>= 0, t >>>= 0, n || P(e, t, this.length); let r = t; let i = 1; let o = this[e + --r]; for (;r > 0 && (i *= 256);)o += this[e + --r] * i; return i *= 128, o >= i && (o -= Math.pow(2, 8 * t)), o }, c.prototype.readInt8 = function (e, t) { return e >>>= 0, t || P(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e] }, c.prototype.readInt16LE = function (e, t) { e >>>= 0, t || P(e, 2, this.length); const n = this[e] | this[e + 1] << 8; return 32768 & n ? 4294901760 | n : n }, c.prototype.readInt16BE = function (e, t) { e >>>= 0, t || P(e, 2, this.length); const n = this[e + 1] | this[e] << 8; return 32768 & n ? 4294901760 | n : n }, c.prototype.readInt32LE = function (e, t) { return e >>>= 0, t || P(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24 }, c.prototype.readInt32BE = function (e, t) { return e >>>= 0, t || P(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3] }, c.prototype.readBigInt64LE = X(function (e) { q(e >>>= 0, 'offset'); const t = this[e]; const n = this[e + 7]; void 0 !== t && void 0 !== n || K(e, this.length - 8); const r = this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (n << 24); return (BigInt(r) << BigInt(32)) + BigInt(t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24) }), c.prototype.readBigInt64BE = X(function (e) { q(e >>>= 0, 'offset'); const t = this[e]; const n = this[e + 7]; void 0 !== t && void 0 !== n || K(e, this.length - 8); const r = (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e]; return (BigInt(r) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + n) }), c.prototype.readFloatLE = function (e, t) { return e >>>= 0, t || P(e, 4, this.length), i.read(this, e, !0, 23, 4) }, c.prototype.readFloatBE = function (e, t) { return e >>>= 0, t || P(e, 4, this.length), i.read(this, e, !1, 23, 4) }, c.prototype.readDoubleLE = function (e, t) { return e >>>= 0, t || P(e, 8, this.length), i.read(this, e, !0, 52, 8) }, c.prototype.readDoubleBE = function (e, t) { return e >>>= 0, t || P(e, 8, this.length), i.read(this, e, !1, 52, 8) }, c.prototype.writeUintLE = c.prototype.writeUIntLE = function (e, t, n, r) { if (e = +e, t >>>= 0, n >>>= 0, !r) { C(this, e, t, n, Math.pow(2, 8 * n) - 1, 0) } let i = 1; let o = 0; for (this[t] = 255 & e; ++o < n && (i *= 256);) this[t + o] = e / i & 255; return t + n }, c.prototype.writeUintBE = c.prototype.writeUIntBE = function (e, t, n, r) { if (e = +e, t >>>= 0, n >>>= 0, !r) { C(this, e, t, n, Math.pow(2, 8 * n) - 1, 0) } let i = n - 1; let o = 1; for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) this[t + i] = e / o & 255; return t + n }, c.prototype.writeUint8 = c.prototype.writeUInt8 = function (e, t, n) { return e = +e, t >>>= 0, n || C(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1 }, c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function (e, t, n) { return e = +e, t >>>= 0, n || C(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2 }, c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function (e, t, n) { return e = +e, t >>>= 0, n || C(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2 }, c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function (e, t, n) { return e = +e, t >>>= 0, n || C(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4 }, c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function (e, t, n) { return e = +e, t >>>= 0, n || C(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4 }, c.prototype.writeBigUInt64LE = X(function (e, t = 0) { return B(this, e, t, BigInt(0), BigInt('0xffffffffffffffff')) }), c.prototype.writeBigUInt64BE = X(function (e, t = 0) { return L(this, e, t, BigInt(0), BigInt('0xffffffffffffffff')) }), c.prototype.writeIntLE = function (e, t, n, r) { if (e = +e, t >>>= 0, !r) { const r = Math.pow(2, 8 * n - 1); C(this, e, t, n, r - 1, -r) } let i = 0; let o = 1; let a = 0; for (this[t] = 255 & e; ++i < n && (o *= 256);)e < 0 && a === 0 && this[t + i - 1] !== 0 && (a = 1), this[t + i] = (e / o >> 0) - a & 255; return t + n }, c.prototype.writeIntBE = function (e, t, n, r) { if (e = +e, t >>>= 0, !r) { const r = Math.pow(2, 8 * n - 1); C(this, e, t, n, r - 1, -r) } let i = n - 1; let o = 1; let a = 0; for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);)e < 0 && a === 0 && this[t + i + 1] !== 0 && (a = 1), this[t + i] = (e / o >> 0) - a & 255; return t + n }, c.prototype.writeInt8 = function (e, t, n) { return e = +e, t >>>= 0, n || C(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1 }, c.prototype.writeInt16LE = function (e, t, n) { return e = +e, t >>>= 0, n || C(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2 }, c.prototype.writeInt16BE = function (e, t, n) { return e = +e, t >>>= 0, n || C(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2 }, c.prototype.writeInt32LE = function (e, t, n) { return e = +e, t >>>= 0, n || C(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4 }, c.prototype.writeInt32BE = function (e, t, n) { return e = +e, t >>>= 0, n || C(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4 }, c.prototype.writeBigInt64LE = X(function (e, t = 0) { return B(this, e, t, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff')) }), c.prototype.writeBigInt64BE = X(function (e, t = 0) { return L(this, e, t, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff')) }), c.prototype.writeFloatLE = function (e, t, n) { return D(this, e, t, !0, n) }, c.prototype.writeFloatBE = function (e, t, n) { return D(this, e, t, !1, n) }, c.prototype.writeDoubleLE = function (e, t, n) { return U(this, e, t, !0, n) }, c.prototype.writeDoubleBE = function (e, t, n) { return U(this, e, t, !1, n) }, c.prototype.copy = function (e, t, n, r) { if (!c.isBuffer(e)) throw new TypeError('argument should be a Buffer'); if (n || (n = 0), r || r === 0 || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n) return 0; if (e.length === 0 || this.length === 0) return 0; if (t < 0) throw new RangeError('targetStart out of bounds'); if (n < 0 || n >= this.length) throw new RangeError('Index out of range'); if (r < 0) throw new RangeError('sourceEnd out of bounds'); r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n); const i = r - n; return this === e && typeof Uint8Array.prototype.copyWithin === 'function' ? this.copyWithin(t, n, r) : Uint8Array.prototype.set.call(e, this.subarray(n, r), t), i }, c.prototype.fill = function (e, t, n, r) { if (typeof e === 'string') { if (typeof t === 'string' ? (r = t, t = 0, n = this.length) : typeof n === 'string' && (r = n, n = this.length), void 0 !== r && typeof r !== 'string') throw new TypeError('encoding must be a string'); if (typeof r === 'string' && !c.isEncoding(r)) throw new TypeError('Unknown encoding: ' + r); if (e.length === 1) { const t = e.charCodeAt(0); (r === 'utf8' && t < 128 || r === 'latin1') && (e = t) } } else typeof e === 'number' ? e &= 255 : typeof e === 'boolean' && (e = Number(e)); if (t < 0 || this.length < t || this.length < n) throw new RangeError('Out of range index'); if (n <= t) return this; let i; if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), typeof e === 'number') for (i = t; i < n; ++i) this[i] = e; else { const o = c.isBuffer(e) ? e : c.from(e, r); const a = o.length; if (a === 0) throw new TypeError('The value "' + e + '" is invalid for argument "value"'); for (i = 0; i < n - t; ++i) this[i + t] = o[i % a] } return this }; const M = {}; function z (e, t, n) { M[e] = class extends n {constructor () { super(), Object.defineProperty(this, 'message', { value: t.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${e}]`, this.stack, delete this.name } get code () { return e } set code (e) { Object.defineProperty(this, 'code', { configurable: !0, enumerable: !0, value: e, writable: !0 }) }toString () { return `${this.name} [${e}]: ${this.message}` }} } function F (e) { let t = ''; let n = e.length; const r = e[0] === '-' ? 1 : 0; for (;n >= r + 4; n -= 3)t = `_${e.slice(n - 3, n)}${t}`; return `${e.slice(0, n)}${t}` } function H (e, t, n, r, i, o) { if (e > n || e < t) { const r = typeof t === 'bigint' ? 'n' : ''; let i; throw i = o > 3 ? t === 0 || t === BigInt(0) ? `>= 0${r} and < 2${r} ** ${8 * (o + 1)}${r}` : `>= -(2${r} ** ${8 * (o + 1) - 1}${r}) and < 2 ** ${8 * (o + 1) - 1}${r}` : `>= ${t}${r} and <= ${n}${r}`, new M.ERR_OUT_OF_RANGE('value', i, e) }!(function (e, t, n) { q(t, 'offset'), void 0 !== e[t] && void 0 !== e[t + n] || K(t, e.length - (n + 1)) }(r, i, o)) } function q (e, t) { if (typeof e !== 'number') throw new M.ERR_INVALID_ARG_TYPE(t, 'number', e) } function K (e, t, n) { if (Math.floor(e) !== e) throw q(e, n), new M.ERR_OUT_OF_RANGE(n || 'offset', 'an integer', e); if (t < 0) throw new M.ERR_BUFFER_OUT_OF_BOUNDS(); throw new M.ERR_OUT_OF_RANGE(n || 'offset', `>= ${n ? 1 : 0} and <= ${t}`, e) }z('ERR_BUFFER_OUT_OF_BOUNDS', function (e) { return e ? `${e} is outside of buffer bounds` : 'Attempt to access memory outside buffer bounds' }, RangeError), z('ERR_INVALID_ARG_TYPE', function (e, t) { return `The "${e}" argument must be of type number. Received type ${typeof t}` }, TypeError), z('ERR_OUT_OF_RANGE', function (e, t, n) { let r = `The value of "${e}" is out of range.`; let i = n; return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? i = F(String(n)) : typeof n === 'bigint' && (i = String(n), (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (i = F(i)), i += 'n'), r += ` It must be ${t}. Received ${i}`, r }, RangeError); const V = /[^+/0-9A-Za-z-_]/g; function W (e, t) { let n; t = t || 1 / 0; const r = e.length; let i = null; const o = []; for (let a = 0; a < r; ++a) { if (n = e.charCodeAt(a), n > 55295 && n < 57344) { if (!i) { if (n > 56319) { (t -= 3) > -1 && o.push(239, 191, 189); continue } if (a + 1 === r) { (t -= 3) > -1 && o.push(239, 191, 189); continue }i = n; continue } if (n < 56320) { (t -= 3) > -1 && o.push(239, 191, 189), i = n; continue }n = 65536 + (i - 55296 << 10 | n - 56320) } else i && (t -= 3) > -1 && o.push(239, 191, 189); if (i = null, n < 128) { if ((t -= 1) < 0) break; o.push(n) } else if (n < 2048) { if ((t -= 2) < 0) break; o.push(n >> 6 | 192, 63 & n | 128) } else if (n < 65536) { if ((t -= 3) < 0) break; o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128) } else { if (!(n < 1114112)) throw new Error('Invalid code point'); if ((t -= 4) < 0) break; o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128) } } return o } function $ (e) { return r.toByteArray(function (e) { if ((e = (e = e.split('=')[0]).trim().replace(V, '')).length < 2) return ''; for (;e.length % 4 != 0;)e += '='; return e }(e)) } function G (e, t, n, r) { let i; for (i = 0; i < r && !(i + n >= t.length || i >= e.length); ++i)t[i + n] = e[i]; return i } function Y (e, t) { return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name } function Z (e) { return e != e } const J = (function () { const e = '0123456789abcdef'; const t = new Array(256); for (let n = 0; n < 16; ++n) { const r = 16 * n; for (let i = 0; i < 16; ++i)t[r + i] = e[n] + e[i] } return t }()); function X (e) { return typeof BigInt === 'undefined' ? Q : e } function Q () { throw new Error('BigInt not supported') } }, 1027: (e, t, n) => { const r = n(9509).Buffer; const i = n(2830).Transform; const o = n(2553).s; function a (e) { i.call(this), this.hashMode = typeof e === 'string', this.hashMode ? this[e] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null }n(5717)(a, i), a.prototype.update = function (e, t, n) { typeof e === 'string' && (e = r.from(e, t)); let i = this._update(e); return this.hashMode ? this : (n && (i = this._toString(i, n)), i) }, a.prototype.setAutoPadding = function () {}, a.prototype.getAuthTag = function () { throw new Error('trying to get auth tag in unsupported state') }, a.prototype.setAuthTag = function () { throw new Error('trying to set auth tag in unsupported state') }, a.prototype.setAAD = function () { throw new Error('trying to set aad in unsupported state') }, a.prototype._transform = function (e, t, n) { let r; try { this.hashMode ? this._update(e) : this.push(this._update(e)) } catch (e) { r = e } finally { n(r) } }, a.prototype._flush = function (e) { let t; try { this.push(this.__final()) } catch (e) { t = e }e(t) }, a.prototype._finalOrDigest = function (e) { let t = this.__final() || r.alloc(0); return e && (t = this._toString(t, e, !0)), t }, a.prototype._toString = function (e, t, n) { if (this._decoder || (this._decoder = new o(t), this._encoding = t), this._encoding !== t) throw new Error("can't switch encodings"); let r = this._decoder.write(e); return n && (r += this._decoder.end()), r }, e.exports = a }, 3482: (e, t, n) => { 'use strict'; const r = n(5717); const i = n(2318); const o = n(9785); const a = n(9072); const s = n(1027); function c (e) { s.call(this, 'digest'), this._hash = e }r(c, s), c.prototype._update = function (e) { this._hash.update(e) }, c.prototype._final = function () { return this._hash.digest() }, e.exports = function (e) { return (e = e.toLowerCase()) === 'md5' ? new i() : e === 'rmd160' || e === 'ripemd160' ? new o() : new c(a(e)) } }, 452: function (e, t, n) { let r; e.exports = (r = n(8249), n(8269), n(8214), n(888), n(5109), (function () { const e = r; const t = e.lib.BlockCipher; const n = e.algo; const i = []; const o = []; const a = []; const s = []; const c = []; const u = []; const l = []; const d = []; const f = []; const h = []; !(function () { for (var e = [], t = 0; t < 256; t++)e[t] = t < 128 ? t << 1 : t << 1 ^ 283; let n = 0; let r = 0; for (t = 0; t < 256; t++) { let p = r ^ r << 1 ^ r << 2 ^ r << 3 ^ r << 4; p = p >>> 8 ^ 255 & p ^ 99, i[n] = p, o[p] = n; const g = e[n]; const m = e[g]; const y = e[m]; let b = 257 * e[p] ^ 16843008 * p; a[n] = b << 24 | b >>> 8, s[n] = b << 16 | b >>> 16, c[n] = b << 8 | b >>> 24, u[n] = b, b = 16843009 * y ^ 65537 * m ^ 257 * g ^ 16843008 * n, l[p] = b << 24 | b >>> 8, d[p] = b << 16 | b >>> 16, f[p] = b << 8 | b >>> 24, h[p] = b, n ? (n = g ^ e[e[e[y ^ g]]], r ^= e[e[r]]) : n = r = 1 } }()); const p = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]; const g = n.AES = t.extend({ _doReset: function () { if (!this._nRounds || this._keyPriorReset !== this._key) { for (var e = this._keyPriorReset = this._key, t = e.words, n = e.sigBytes / 4, r = 4 * ((this._nRounds = n + 6) + 1), o = this._keySchedule = [], a = 0; a < r; a++)a < n ? o[a] = t[a] : (u = o[a - 1], a % n ? n > 6 && a % n == 4 && (u = i[u >>> 24] << 24 | i[u >>> 16 & 255] << 16 | i[u >>> 8 & 255] << 8 | i[255 & u]) : (u = i[(u = u << 8 | u >>> 24) >>> 24] << 24 | i[u >>> 16 & 255] << 16 | i[u >>> 8 & 255] << 8 | i[255 & u], u ^= p[a / n | 0] << 24), o[a] = o[a - n] ^ u); for (let s = this._invKeySchedule = [], c = 0; c < r; c++) { if (a = r - c, c % 4) var u = o[a]; else u = o[a - 4]; s[c] = c < 4 || a <= 4 ? u : l[i[u >>> 24]] ^ d[i[u >>> 16 & 255]] ^ f[i[u >>> 8 & 255]] ^ h[i[255 & u]] } } }, encryptBlock: function (e, t) { this._doCryptBlock(e, t, this._keySchedule, a, s, c, u, i) }, decryptBlock: function (e, t) { let n = e[t + 1]; e[t + 1] = e[t + 3], e[t + 3] = n, this._doCryptBlock(e, t, this._invKeySchedule, l, d, f, h, o), n = e[t + 1], e[t + 1] = e[t + 3], e[t + 3] = n }, _doCryptBlock: function (e, t, n, r, i, o, a, s) { for (var c = this._nRounds, u = e[t] ^ n[0], l = e[t + 1] ^ n[1], d = e[t + 2] ^ n[2], f = e[t + 3] ^ n[3], h = 4, p = 1; p < c; p++) { var g = r[u >>> 24] ^ i[l >>> 16 & 255] ^ o[d >>> 8 & 255] ^ a[255 & f] ^ n[h++]; var m = r[l >>> 24] ^ i[d >>> 16 & 255] ^ o[f >>> 8 & 255] ^ a[255 & u] ^ n[h++]; var y = r[d >>> 24] ^ i[f >>> 16 & 255] ^ o[u >>> 8 & 255] ^ a[255 & l] ^ n[h++]; var b = r[f >>> 24] ^ i[u >>> 16 & 255] ^ o[l >>> 8 & 255] ^ a[255 & d] ^ n[h++]; u = g, l = m, d = y, f = b }g = (s[u >>> 24] << 24 | s[l >>> 16 & 255] << 16 | s[d >>> 8 & 255] << 8 | s[255 & f]) ^ n[h++], m = (s[l >>> 24] << 24 | s[d >>> 16 & 255] << 16 | s[f >>> 8 & 255] << 8 | s[255 & u]) ^ n[h++], y = (s[d >>> 24] << 24 | s[f >>> 16 & 255] << 16 | s[u >>> 8 & 255] << 8 | s[255 & l]) ^ n[h++], b = (s[f >>> 24] << 24 | s[u >>> 16 & 255] << 16 | s[l >>> 8 & 255] << 8 | s[255 & d]) ^ n[h++], e[t] = g, e[t + 1] = m, e[t + 2] = y, e[t + 3] = b }, keySize: 8 }); e.AES = t._createHelper(g) }()), r.AES) }, 5109: function (e, t, n) { let r; e.exports = (r = n(8249), n(888), void (r.lib.Cipher || (function (e) { const t = r; const n = t.lib; const i = n.Base; const o = n.WordArray; const a = n.BufferedBlockAlgorithm; const s = t.enc; const c = (s.Utf8, s.Base64); const u = t.algo.EvpKDF; const l = n.Cipher = a.extend({ cfg: i.extend(), createEncryptor: function (e, t) { return this.create(this._ENC_XFORM_MODE, e, t) }, createDecryptor: function (e, t) { return this.create(this._DEC_XFORM_MODE, e, t) }, init: function (e, t, n) { this.cfg = this.cfg.extend(n), this._xformMode = e, this._key = t, this.reset() }, reset: function () { a.reset.call(this), this._doReset() }, process: function (e) { return this._append(e), this._process() }, finalize: function (e) { return e && this._append(e), this._doFinalize() }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: (function () { function e (e) { return typeof e === 'string' ? v : y } return function (t) { return { encrypt: function (n, r, i) { return e(r).encrypt(t, n, r, i) }, decrypt: function (n, r, i) { return e(r).decrypt(t, n, r, i) } } } }()) }); const d = (n.StreamCipher = l.extend({ _doFinalize: function () { return this._process(!0) }, blockSize: 1 }), t.mode = {}); const f = n.BlockCipherMode = i.extend({ createEncryptor: function (e, t) { return this.Encryptor.create(e, t) }, createDecryptor: function (e, t) { return this.Decryptor.create(e, t) }, init: function (e, t) { this._cipher = e, this._iv = t } }); const h = d.CBC = (function () { const t = f.extend(); function n (t, n, r) { let i; const o = this._iv; o ? (i = o, this._iv = e) : i = this._prevBlock; for (let a = 0; a < r; a++)t[n + a] ^= i[a] } return t.Encryptor = t.extend({ processBlock: function (e, t) { const r = this._cipher; const i = r.blockSize; n.call(this, e, t, i), r.encryptBlock(e, t), this._prevBlock = e.slice(t, t + i) } }), t.Decryptor = t.extend({ processBlock: function (e, t) { const r = this._cipher; const i = r.blockSize; const o = e.slice(t, t + i); r.decryptBlock(e, t), n.call(this, e, t, i), this._prevBlock = o } }), t }()); const p = (t.pad = {}).Pkcs7 = { pad: function (e, t) { for (var n = 4 * t, r = n - e.sigBytes % n, i = r << 24 | r << 16 | r << 8 | r, a = [], s = 0; s < r; s += 4)a.push(i); const c = o.create(a, r); e.concat(c) }, unpad: function (e) { const t = 255 & e.words[e.sigBytes - 1 >>> 2]; e.sigBytes -= t } }; const g = (n.BlockCipher = l.extend({ cfg: l.cfg.extend({ mode: h, padding: p }), reset: function () { let e; l.reset.call(this); const t = this.cfg; const n = t.iv; const r = t.mode; this._xformMode == this._ENC_XFORM_MODE ? e = r.createEncryptor : (e = r.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == e ? this._mode.init(this, n && n.words) : (this._mode = e.call(r, this, n && n.words), this._mode.__creator = e) }, _doProcessBlock: function (e, t) { this._mode.processBlock(e, t) }, _doFinalize: function () { let e; const t = this.cfg.padding; return this._xformMode == this._ENC_XFORM_MODE ? (t.pad(this._data, this.blockSize), e = this._process(!0)) : (e = this._process(!0), t.unpad(e)), e }, blockSize: 4 }), n.CipherParams = i.extend({ init: function (e) { this.mixIn(e) }, toString: function (e) { return (e || this.formatter).stringify(this) } })); const m = (t.format = {}).OpenSSL = { stringify: function (e) { const t = e.ciphertext; const n = e.salt; return (n ? o.create([1398893684, 1701076831]).concat(n).concat(t) : t).toString(c) }, parse: function (e) { let t; const n = c.parse(e); const r = n.words; return r[0] == 1398893684 && r[1] == 1701076831 && (t = o.create(r.slice(2, 4)), r.splice(0, 4), n.sigBytes -= 16), g.create({ ciphertext: n, salt: t }) } }; var y = n.SerializableCipher = i.extend({ cfg: i.extend({ format: m }), encrypt: function (e, t, n, r) { r = this.cfg.extend(r); const i = e.createEncryptor(n, r); const o = i.finalize(t); const a = i.cfg; return g.create({ ciphertext: o, key: n, iv: a.iv, algorithm: e, mode: a.mode, padding: a.padding, blockSize: e.blockSize, formatter: r.format }) }, decrypt: function (e, t, n, r) { return r = this.cfg.extend(r), t = this._parse(t, r.format), e.createDecryptor(n, r).finalize(t.ciphertext) }, _parse: function (e, t) { return typeof e === 'string' ? t.parse(e, this) : e } }); const b = (t.kdf = {}).OpenSSL = { execute: function (e, t, n, r) { r || (r = o.random(8)); const i = u.create({ keySize: t + n }).compute(e, r); const a = o.create(i.words.slice(t), 4 * n); return i.sigBytes = 4 * t, g.create({ key: i, iv: a, salt: r }) } }; var v = n.PasswordBasedCipher = y.extend({ cfg: y.cfg.extend({ kdf: b }), encrypt: function (e, t, n, r) { const i = (r = this.cfg.extend(r)).kdf.execute(n, e.keySize, e.ivSize); r.iv = i.iv; const o = y.encrypt.call(this, e, t, i.key, r); return o.mixIn(i), o }, decrypt: function (e, t, n, r) { r = this.cfg.extend(r), t = this._parse(t, r.format); const i = r.kdf.execute(n, e.keySize, e.ivSize, t.salt); return r.iv = i.iv, y.decrypt.call(this, e, t, i.key, r) } }) }()))) }, 8249: function (e, t, n) { let r; e.exports = (r = r || (function (e, t) { let r; if (typeof window !== 'undefined' && window.crypto && (r = window.crypto), typeof self !== 'undefined' && self.crypto && (r = self.crypto), typeof globalThis !== 'undefined' && globalThis.crypto && (r = globalThis.crypto), !r && typeof window !== 'undefined' && window.msCrypto && (r = window.msCrypto), !r && void 0 !== n.g && n.g.crypto && (r = n.g.crypto), !r) try { r = n(2480) } catch (e) {} const i = function () { if (r) { if (typeof r.getRandomValues === 'function') try { return r.getRandomValues(new Uint32Array(1))[0] } catch (e) {} if (typeof r.randomBytes === 'function') try { return r.randomBytes(4).readInt32LE() } catch (e) {} } throw new Error('Native crypto module could not be used to get secure random number.') }; const o = Object.create || (function () { function e () {} return function (t) { let n; return e.prototype = t, n = new e(), e.prototype = null, n } }()); const a = {}; const s = a.lib = {}; const c = s.Base = { extend: function (e) { const t = o(this); return e && t.mixIn(e), t.hasOwnProperty('init') && this.init !== t.init || (t.init = function () { t.$super.init.apply(this, arguments) }), t.init.prototype = t, t.$super = this, t }, create: function () { const e = this.extend(); return e.init.apply(e, arguments), e }, init: function () {}, mixIn: function (e) { for (const t in e)e.hasOwnProperty(t) && (this[t] = e[t]); e.hasOwnProperty('toString') && (this.toString = e.toString) }, clone: function () { return this.init.prototype.extend(this) } }; var u = s.WordArray = c.extend({ init: function (e, n) { e = this.words = e || [], this.sigBytes = n != t ? n : 4 * e.length }, toString: function (e) { return (e || d).stringify(this) }, concat: function (e) { const t = this.words; const n = e.words; const r = this.sigBytes; const i = e.sigBytes; if (this.clamp(), r % 4) for (let o = 0; o < i; o++) { const a = n[o >>> 2] >>> 24 - o % 4 * 8 & 255; t[r + o >>> 2] |= a << 24 - (r + o) % 4 * 8 } else for (let s = 0; s < i; s += 4)t[r + s >>> 2] = n[s >>> 2]; return this.sigBytes += i, this }, clamp: function () { const t = this.words; const n = this.sigBytes; t[n >>> 2] &= 4294967295 << 32 - n % 4 * 8, t.length = e.ceil(n / 4) }, clone: function () { const e = c.clone.call(this); return e.words = this.words.slice(0), e }, random: function (e) { for (var t = [], n = 0; n < e; n += 4)t.push(i()); return new u.init(t, e) } }); const l = a.enc = {}; var d = l.Hex = { stringify: function (e) { for (var t = e.words, n = e.sigBytes, r = [], i = 0; i < n; i++) { const o = t[i >>> 2] >>> 24 - i % 4 * 8 & 255; r.push((o >>> 4).toString(16)), r.push((15 & o).toString(16)) } return r.join('') }, parse: function (e) { for (var t = e.length, n = [], r = 0; r < t; r += 2)n[r >>> 3] |= parseInt(e.substr(r, 2), 16) << 24 - r % 8 * 4; return new u.init(n, t / 2) } }; const f = l.Latin1 = { stringify: function (e) { for (var t = e.words, n = e.sigBytes, r = [], i = 0; i < n; i++) { const o = t[i >>> 2] >>> 24 - i % 4 * 8 & 255; r.push(String.fromCharCode(o)) } return r.join('') }, parse: function (e) { for (var t = e.length, n = [], r = 0; r < t; r++)n[r >>> 2] |= (255 & e.charCodeAt(r)) << 24 - r % 4 * 8; return new u.init(n, t) } }; const h = l.Utf8 = { stringify: function (e) { try { return decodeURIComponent(escape(f.stringify(e))) } catch (e) { throw new Error('Malformed UTF-8 data') } }, parse: function (e) { return f.parse(unescape(encodeURIComponent(e))) } }; const p = s.BufferedBlockAlgorithm = c.extend({ reset: function () { this._data = new u.init(), this._nDataBytes = 0 }, _append: function (e) { typeof e === 'string' && (e = h.parse(e)), this._data.concat(e), this._nDataBytes += e.sigBytes }, _process: function (t) { let n; const r = this._data; const i = r.words; const o = r.sigBytes; const a = this.blockSize; let s = o / (4 * a); const c = (s = t ? e.ceil(s) : e.max((0 | s) - this._minBufferSize, 0)) * a; const l = e.min(4 * c, o); if (c) { for (let d = 0; d < c; d += a) this._doProcessBlock(i, d); n = i.splice(0, c), r.sigBytes -= l } return new u.init(n, l) }, clone: function () { const e = c.clone.call(this); return e._data = this._data.clone(), e }, _minBufferSize: 0 }); var g = (s.Hasher = p.extend({ cfg: c.extend(), init: function (e) { this.cfg = this.cfg.extend(e), this.reset() }, reset: function () { p.reset.call(this), this._doReset() }, update: function (e) { return this._append(e), this._process(), this }, finalize: function (e) { return e && this._append(e), this._doFinalize() }, blockSize: 16, _createHelper: function (e) { return function (t, n) { return new e.init(n).finalize(t) } }, _createHmacHelper: function (e) { return function (t, n) { return new g.HMAC.init(e, n).finalize(t) } } }), a.algo = {}); return a }(Math)), r) }, 8269: function (e, t, n) { let r; e.exports = (r = n(8249), (function () { const e = r; const t = e.lib.WordArray; function n (e, n, r) { for (var i = [], o = 0, a = 0; a < n; a++) if (a % 4) { const s = r[e.charCodeAt(a - 1)] << a % 4 * 2 | r[e.charCodeAt(a)] >>> 6 - a % 4 * 2; i[o >>> 2] |= s << 24 - o % 4 * 8, o++ } return t.create(i, o) }e.enc.Base64 = { stringify: function (e) { const t = e.words; const n = e.sigBytes; const r = this._map; e.clamp(); for (var i = [], o = 0; o < n; o += 3) for (let a = (t[o >>> 2] >>> 24 - o % 4 * 8 & 255) << 16 | (t[o + 1 >>> 2] >>> 24 - (o + 1) % 4 * 8 & 255) << 8 | t[o + 2 >>> 2] >>> 24 - (o + 2) % 4 * 8 & 255, s = 0; s < 4 && o + 0.75 * s < n; s++)i.push(r.charAt(a >>> 6 * (3 - s) & 63)); const c = r.charAt(64); if (c) for (;i.length % 4;)i.push(c); return i.join('') }, parse: function (e) { let t = e.length; const r = this._map; let i = this._reverseMap; if (!i) { i = this._reverseMap = []; for (let o = 0; o < r.length; o++)i[r.charCodeAt(o)] = o } const a = r.charAt(64); if (a) { const s = e.indexOf(a); s !== -1 && (t = s) } return n(e, t, i) }, _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' } }()), r.enc.Base64) }, 3786: function (e, t, n) { let r; e.exports = (r = n(8249), (function () { const e = r; const t = e.lib.WordArray; function n (e, n, r) { for (var i = [], o = 0, a = 0; a < n; a++) if (a % 4) { const s = r[e.charCodeAt(a - 1)] << a % 4 * 2 | r[e.charCodeAt(a)] >>> 6 - a % 4 * 2; i[o >>> 2] |= s << 24 - o % 4 * 8, o++ } return t.create(i, o) }e.enc.Base64url = { stringify: function (e, t = !0) { const n = e.words; const r = e.sigBytes; const i = t ? this._safe_map : this._map; e.clamp(); for (var o = [], a = 0; a < r; a += 3) for (let s = (n[a >>> 2] >>> 24 - a % 4 * 8 & 255) << 16 | (n[a + 1 >>> 2] >>> 24 - (a + 1) % 4 * 8 & 255) << 8 | n[a + 2 >>> 2] >>> 24 - (a + 2) % 4 * 8 & 255, c = 0; c < 4 && a + 0.75 * c < r; c++)o.push(i.charAt(s >>> 6 * (3 - c) & 63)); const u = i.charAt(64); if (u) for (;o.length % 4;)o.push(u); return o.join('') }, parse: function (e, t = !0) { let r = e.length; const i = t ? this._safe_map : this._map; let o = this._reverseMap; if (!o) { o = this._reverseMap = []; for (let a = 0; a < i.length; a++)o[i.charCodeAt(a)] = a } const s = i.charAt(64); if (s) { const c = e.indexOf(s); c !== -1 && (r = c) } return n(e, r, o) }, _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=', _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_' } }()), r.enc.Base64url) }, 3465: function (e, t, n) { let r; e.exports = (r = n(8249), r.enc.Hex) }, 298: function (e, t, n) { let r; e.exports = (r = n(8249), (function () { const e = r; const t = e.lib.WordArray; const n = e.enc; function i (e) { return e << 8 & 4278255360 | e >>> 8 & 16711935 }n.Utf16 = n.Utf16BE = { stringify: function (e) { for (var t = e.words, n = e.sigBytes, r = [], i = 0; i < n; i += 2) { const o = t[i >>> 2] >>> 16 - i % 4 * 8 & 65535; r.push(String.fromCharCode(o)) } return r.join('') }, parse: function (e) { for (var n = e.length, r = [], i = 0; i < n; i++)r[i >>> 1] |= e.charCodeAt(i) << 16 - i % 2 * 16; return t.create(r, 2 * n) } }, n.Utf16LE = { stringify: function (e) { for (var t = e.words, n = e.sigBytes, r = [], o = 0; o < n; o += 2) { const a = i(t[o >>> 2] >>> 16 - o % 4 * 8 & 65535); r.push(String.fromCharCode(a)) } return r.join('') }, parse: function (e) { for (var n = e.length, r = [], o = 0; o < n; o++)r[o >>> 1] |= i(e.charCodeAt(o) << 16 - o % 2 * 16); return t.create(r, 2 * n) } } }()), r.enc.Utf16) }, 5743: function (e, t, n) { let r; e.exports = (r = n(8249), r.enc.Utf8) }, 888: function (e, t, n) { let r, i, o, a, s, c, u, l; e.exports = (l = n(8249), n(2783), n(9824), i = (r = l).lib, o = i.Base, a = i.WordArray, s = r.algo, c = s.MD5, u = s.EvpKDF = o.extend({ cfg: o.extend({ keySize: 4, hasher: c, iterations: 1 }), init: function (e) { this.cfg = this.cfg.extend(e) }, compute: function (e, t) { for (var n, r = this.cfg, i = r.hasher.create(), o = a.create(), s = o.words, c = r.keySize, u = r.iterations; s.length < c;) { n && i.update(n), n = i.update(e).finalize(t), i.reset(); for (let l = 1; l < u; l++)n = i.finalize(n), i.reset(); o.concat(n) } return o.sigBytes = 4 * c, o } }), r.EvpKDF = function (e, t, n) { return u.create(n).compute(e, t) }, l.EvpKDF) }, 2209: function (e, t, n) { let r, i, o, a; e.exports = (a = n(8249), n(5109), i = (r = a).lib.CipherParams, o = r.enc.Hex, r.format.Hex = { stringify: function (e) { return e.ciphertext.toString(o) }, parse: function (e) { const t = o.parse(e); return i.create({ ciphertext: t }) } }, a.format.Hex) }, 8010: function (e, t, n) { let r; e.exports = (r = n(8249), n(2153), n(9824), r.HmacSHA256) }, 9824: function (e, t, n) { let r, i, o, a; e.exports = (r = n(8249), o = (i = r).lib.Base, a = i.enc.Utf8, void (i.algo.HMAC = o.extend({ init: function (e, t) { e = this._hasher = new e.init(), typeof t === 'string' && (t = a.parse(t)); const n = e.blockSize; const r = 4 * n; t.sigBytes > r && (t = e.finalize(t)), t.clamp(); for (var i = this._oKey = t.clone(), o = this._iKey = t.clone(), s = i.words, c = o.words, u = 0; u < n; u++)s[u] ^= 1549556828, c[u] ^= 909522486; i.sigBytes = o.sigBytes = r, this.reset() }, reset: function () { const e = this._hasher; e.reset(), e.update(this._iKey) }, update: function (e) { return this._hasher.update(e), this }, finalize: function (e) { const t = this._hasher; const n = t.finalize(e); return t.reset(), t.finalize(this._oKey.clone().concat(n)) } }))) }, 1354: function (e, t, n) { let r; e.exports = (r = n(8249), n(4938), n(4433), n(298), n(8269), n(3786), n(8214), n(2783), n(2153), n(7792), n(34), n(7460), n(3327), n(706), n(9824), n(2112), n(888), n(5109), n(8568), n(4242), n(9968), n(7660), n(1148), n(3615), n(2807), n(1077), n(6475), n(6991), n(2209), n(452), n(4253), n(1857), n(4454), n(3974), r) }, 4433: function (e, t, n) { let r; e.exports = (r = n(8249), (function () { if (typeof ArrayBuffer === 'function') { const e = r.lib.WordArray; const t = e.init; const n = e.init = function (e) { if (e instanceof ArrayBuffer && (e = new Uint8Array(e)), (e instanceof Int8Array || typeof Uint8ClampedArray !== 'undefined' && e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array || e instanceof Float64Array) && (e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength)), e instanceof Uint8Array) { for (var n = e.byteLength, r = [], i = 0; i < n; i++)r[i >>> 2] |= e[i] << 24 - i % 4 * 8; t.call(this, r, n) } else t.apply(this, arguments) }; n.prototype = e } }()), r.lib.WordArray) }, 8214: function (e, t, n) { let r; e.exports = (r = n(8249), (function (e) { const t = r; const n = t.lib; const i = n.WordArray; const o = n.Hasher; const a = t.algo; const s = []; !(function () { for (let t = 0; t < 64; t++)s[t] = 4294967296 * e.abs(e.sin(t + 1)) | 0 }()); const c = a.MD5 = o.extend({ _doReset: function () { this._hash = new i.init([1732584193, 4023233417, 2562383102, 271733878]) }, _doProcessBlock: function (e, t) { for (let n = 0; n < 16; n++) { const r = t + n; const i = e[r]; e[r] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8) } const o = this._hash.words; const a = e[t + 0]; const c = e[t + 1]; const h = e[t + 2]; const p = e[t + 3]; const g = e[t + 4]; const m = e[t + 5]; const y = e[t + 6]; const b = e[t + 7]; const v = e[t + 8]; const w = e[t + 9]; const _ = e[t + 10]; const E = e[t + 11]; const k = e[t + 12]; const S = e[t + 13]; const A = e[t + 14]; const O = e[t + 15]; let x = o[0]; let I = o[1]; let N = o[2]; let T = o[3]; x = u(x, I, N, T, a, 7, s[0]), T = u(T, x, I, N, c, 12, s[1]), N = u(N, T, x, I, h, 17, s[2]), I = u(I, N, T, x, p, 22, s[3]), x = u(x, I, N, T, g, 7, s[4]), T = u(T, x, I, N, m, 12, s[5]), N = u(N, T, x, I, y, 17, s[6]), I = u(I, N, T, x, b, 22, s[7]), x = u(x, I, N, T, v, 7, s[8]), T = u(T, x, I, N, w, 12, s[9]), N = u(N, T, x, I, _, 17, s[10]), I = u(I, N, T, x, E, 22, s[11]), x = u(x, I, N, T, k, 7, s[12]), T = u(T, x, I, N, S, 12, s[13]), N = u(N, T, x, I, A, 17, s[14]), x = l(x, I = u(I, N, T, x, O, 22, s[15]), N, T, c, 5, s[16]), T = l(T, x, I, N, y, 9, s[17]), N = l(N, T, x, I, E, 14, s[18]), I = l(I, N, T, x, a, 20, s[19]), x = l(x, I, N, T, m, 5, s[20]), T = l(T, x, I, N, _, 9, s[21]), N = l(N, T, x, I, O, 14, s[22]), I = l(I, N, T, x, g, 20, s[23]), x = l(x, I, N, T, w, 5, s[24]), T = l(T, x, I, N, A, 9, s[25]), N = l(N, T, x, I, p, 14, s[26]), I = l(I, N, T, x, v, 20, s[27]), x = l(x, I, N, T, S, 5, s[28]), T = l(T, x, I, N, h, 9, s[29]), N = l(N, T, x, I, b, 14, s[30]), x = d(x, I = l(I, N, T, x, k, 20, s[31]), N, T, m, 4, s[32]), T = d(T, x, I, N, v, 11, s[33]), N = d(N, T, x, I, E, 16, s[34]), I = d(I, N, T, x, A, 23, s[35]), x = d(x, I, N, T, c, 4, s[36]), T = d(T, x, I, N, g, 11, s[37]), N = d(N, T, x, I, b, 16, s[38]), I = d(I, N, T, x, _, 23, s[39]), x = d(x, I, N, T, S, 4, s[40]), T = d(T, x, I, N, a, 11, s[41]), N = d(N, T, x, I, p, 16, s[42]), I = d(I, N, T, x, y, 23, s[43]), x = d(x, I, N, T, w, 4, s[44]), T = d(T, x, I, N, k, 11, s[45]), N = d(N, T, x, I, O, 16, s[46]), x = f(x, I = d(I, N, T, x, h, 23, s[47]), N, T, a, 6, s[48]), T = f(T, x, I, N, b, 10, s[49]), N = f(N, T, x, I, A, 15, s[50]), I = f(I, N, T, x, m, 21, s[51]), x = f(x, I, N, T, k, 6, s[52]), T = f(T, x, I, N, p, 10, s[53]), N = f(N, T, x, I, _, 15, s[54]), I = f(I, N, T, x, c, 21, s[55]), x = f(x, I, N, T, v, 6, s[56]), T = f(T, x, I, N, O, 10, s[57]), N = f(N, T, x, I, y, 15, s[58]), I = f(I, N, T, x, S, 21, s[59]), x = f(x, I, N, T, g, 6, s[60]), T = f(T, x, I, N, E, 10, s[61]), N = f(N, T, x, I, h, 15, s[62]), I = f(I, N, T, x, w, 21, s[63]), o[0] = o[0] + x | 0, o[1] = o[1] + I | 0, o[2] = o[2] + N | 0, o[3] = o[3] + T | 0 }, _doFinalize: function () { const t = this._data; const n = t.words; const r = 8 * this._nDataBytes; const i = 8 * t.sigBytes; n[i >>> 5] |= 128 << 24 - i % 32; const o = e.floor(r / 4294967296); const a = r; n[15 + (i + 64 >>> 9 << 4)] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8), n[14 + (i + 64 >>> 9 << 4)] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8), t.sigBytes = 4 * (n.length + 1), this._process(); for (var s = this._hash, c = s.words, u = 0; u < 4; u++) { const l = c[u]; c[u] = 16711935 & (l << 8 | l >>> 24) | 4278255360 & (l << 24 | l >>> 8) } return s }, clone: function () { const e = o.clone.call(this); return e._hash = this._hash.clone(), e } }); function u (e, t, n, r, i, o, a) { const s = e + (t & n | ~t & r) + i + a; return (s << o | s >>> 32 - o) + t } function l (e, t, n, r, i, o, a) { const s = e + (t & r | n & ~r) + i + a; return (s << o | s >>> 32 - o) + t } function d (e, t, n, r, i, o, a) { const s = e + (t ^ n ^ r) + i + a; return (s << o | s >>> 32 - o) + t } function f (e, t, n, r, i, o, a) { const s = e + (n ^ (t | ~r)) + i + a; return (s << o | s >>> 32 - o) + t }t.MD5 = o._createHelper(c), t.HmacMD5 = o._createHmacHelper(c) }(Math)), r.MD5) }, 8568: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.mode.CFB = (function () { const e = r.lib.BlockCipherMode.extend(); function t (e, t, n, r) { let i; const o = this._iv; o ? (i = o.slice(0), this._iv = void 0) : i = this._prevBlock, r.encryptBlock(i, 0); for (let a = 0; a < n; a++)e[t + a] ^= i[a] } return e.Encryptor = e.extend({ processBlock: function (e, n) { const r = this._cipher; const i = r.blockSize; t.call(this, e, n, i, r), this._prevBlock = e.slice(n, n + i) } }), e.Decryptor = e.extend({ processBlock: function (e, n) { const r = this._cipher; const i = r.blockSize; const o = e.slice(n, n + i); t.call(this, e, n, i, r), this._prevBlock = o } }), e }()), r.mode.CFB) }, 9968: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.mode.CTRGladman = (function () { const e = r.lib.BlockCipherMode.extend(); function t (e) { if ((e >> 24 & 255) == 255) { let t = e >> 16 & 255; let n = e >> 8 & 255; let r = 255 & e; t === 255 ? (t = 0, n === 255 ? (n = 0, r === 255 ? r = 0 : ++r) : ++n) : ++t, e = 0, e += t << 16, e += n << 8, e += r } else e += 1 << 24; return e } function n (e) { return (e[0] = t(e[0])) === 0 && (e[1] = t(e[1])), e } const i = e.Encryptor = e.extend({ processBlock: function (e, t) { const r = this._cipher; const i = r.blockSize; const o = this._iv; let a = this._counter; o && (a = this._counter = o.slice(0), this._iv = void 0), n(a); const s = a.slice(0); r.encryptBlock(s, 0); for (let c = 0; c < i; c++)e[t + c] ^= s[c] } }); return e.Decryptor = i, e }()), r.mode.CTRGladman) }, 4242: function (e, t, n) { let r, i, o; e.exports = (o = n(8249), n(5109), o.mode.CTR = (r = o.lib.BlockCipherMode.extend(), i = r.Encryptor = r.extend({ processBlock: function (e, t) { const n = this._cipher; const r = n.blockSize; const i = this._iv; let o = this._counter; i && (o = this._counter = i.slice(0), this._iv = void 0); const a = o.slice(0); n.encryptBlock(a, 0), o[r - 1] = o[r - 1] + 1 | 0; for (let s = 0; s < r; s++)e[t + s] ^= a[s] } }), r.Decryptor = i, r), o.mode.CTR) }, 1148: function (e, t, n) { let r, i; e.exports = (i = n(8249), n(5109), i.mode.ECB = ((r = i.lib.BlockCipherMode.extend()).Encryptor = r.extend({ processBlock: function (e, t) { this._cipher.encryptBlock(e, t) } }), r.Decryptor = r.extend({ processBlock: function (e, t) { this._cipher.decryptBlock(e, t) } }), r), i.mode.ECB) }, 7660: function (e, t, n) { let r, i, o; e.exports = (o = n(8249), n(5109), o.mode.OFB = (r = o.lib.BlockCipherMode.extend(), i = r.Encryptor = r.extend({ processBlock: function (e, t) { const n = this._cipher; const r = n.blockSize; const i = this._iv; let o = this._keystream; i && (o = this._keystream = i.slice(0), this._iv = void 0), n.encryptBlock(o, 0); for (let a = 0; a < r; a++)e[t + a] ^= o[a] } }), r.Decryptor = i, r), o.mode.OFB) }, 3615: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.pad.AnsiX923 = { pad: function (e, t) { const n = e.sigBytes; const r = 4 * t; const i = r - n % r; const o = n + i - 1; e.clamp(), e.words[o >>> 2] |= i << 24 - o % 4 * 8, e.sigBytes += i }, unpad: function (e) { const t = 255 & e.words[e.sigBytes - 1 >>> 2]; e.sigBytes -= t } }, r.pad.Ansix923) }, 2807: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.pad.Iso10126 = { pad: function (e, t) { const n = 4 * t; const i = n - e.sigBytes % n; e.concat(r.lib.WordArray.random(i - 1)).concat(r.lib.WordArray.create([i << 24], 1)) }, unpad: function (e) { const t = 255 & e.words[e.sigBytes - 1 >>> 2]; e.sigBytes -= t } }, r.pad.Iso10126) }, 1077: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.pad.Iso97971 = { pad: function (e, t) { e.concat(r.lib.WordArray.create([2147483648], 1)), r.pad.ZeroPadding.pad(e, t) }, unpad: function (e) { r.pad.ZeroPadding.unpad(e), e.sigBytes-- } }, r.pad.Iso97971) }, 6991: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.pad.NoPadding = { pad: function () {}, unpad: function () {} }, r.pad.NoPadding) }, 6475: function (e, t, n) { let r; e.exports = (r = n(8249), n(5109), r.pad.ZeroPadding = { pad: function (e, t) { const n = 4 * t; e.clamp(), e.sigBytes += n - (e.sigBytes % n || n) }, unpad: function (e) { const t = e.words; let n = e.sigBytes - 1; for (n = e.sigBytes - 1; n >= 0; n--) if (t[n >>> 2] >>> 24 - n % 4 * 8 & 255) { e.sigBytes = n + 1; break } } }, r.pad.ZeroPadding) }, 2112: function (e, t, n) { let r, i, o, a, s, c, u, l, d; e.exports = (d = n(8249), n(2783), n(9824), i = (r = d).lib, o = i.Base, a = i.WordArray, s = r.algo, c = s.SHA1, u = s.HMAC, l = s.PBKDF2 = o.extend({ cfg: o.extend({ keySize: 4, hasher: c, iterations: 1 }), init: function (e) { this.cfg = this.cfg.extend(e) }, compute: function (e, t) { for (var n = this.cfg, r = u.create(n.hasher, e), i = a.create(), o = a.create([1]), s = i.words, c = o.words, l = n.keySize, d = n.iterations; s.length < l;) { const f = r.update(t).finalize(o); r.reset(); for (let h = f.words, p = h.length, g = f, m = 1; m < d; m++) { g = r.finalize(g), r.reset(); for (let y = g.words, b = 0; b < p; b++)h[b] ^= y[b] }i.concat(f), c[0]++ } return i.sigBytes = 4 * l, i } }), r.PBKDF2 = function (e, t, n) { return l.create(n).compute(e, t) }, d.PBKDF2) }, 3974: function (e, t, n) { let r; e.exports = (r = n(8249), n(8269), n(8214), n(888), n(5109), (function () { const e = r; const t = e.lib.StreamCipher; const n = e.algo; const i = []; const o = []; const a = []; const s = n.RabbitLegacy = t.extend({ _doReset: function () { const e = this._key.words; const t = this.cfg.iv; const n = this._X = [e[0], e[3] << 16 | e[2] >>> 16, e[1], e[0] << 16 | e[3] >>> 16, e[2], e[1] << 16 | e[0] >>> 16, e[3], e[2] << 16 | e[1] >>> 16]; const r = this._C = [e[2] << 16 | e[2] >>> 16, 4294901760 & e[0] | 65535 & e[1], e[3] << 16 | e[3] >>> 16, 4294901760 & e[1] | 65535 & e[2], e[0] << 16 | e[0] >>> 16, 4294901760 & e[2] | 65535 & e[3], e[1] << 16 | e[1] >>> 16, 4294901760 & e[3] | 65535 & e[0]]; this._b = 0; for (var i = 0; i < 4; i++)c.call(this); for (i = 0; i < 8; i++)r[i] ^= n[i + 4 & 7]; if (t) { const o = t.words; const a = o[0]; const s = o[1]; const u = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8); const l = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8); const d = u >>> 16 | 4294901760 & l; const f = l << 16 | 65535 & u; for (r[0] ^= u, r[1] ^= d, r[2] ^= l, r[3] ^= f, r[4] ^= u, r[5] ^= d, r[6] ^= l, r[7] ^= f, i = 0; i < 4; i++)c.call(this) } }, _doProcessBlock: function (e, t) { const n = this._X; c.call(this), i[0] = n[0] ^ n[5] >>> 16 ^ n[3] << 16, i[1] = n[2] ^ n[7] >>> 16 ^ n[5] << 16, i[2] = n[4] ^ n[1] >>> 16 ^ n[7] << 16, i[3] = n[6] ^ n[3] >>> 16 ^ n[1] << 16; for (let r = 0; r < 4; r++)i[r] = 16711935 & (i[r] << 8 | i[r] >>> 24) | 4278255360 & (i[r] << 24 | i[r] >>> 8), e[t + r] ^= i[r] }, blockSize: 4, ivSize: 2 }); function c () { for (var e = this._X, t = this._C, n = 0; n < 8; n++)o[n] = t[n]; for (t[0] = t[0] + 1295307597 + this._b | 0, t[1] = t[1] + 3545052371 + (t[0] >>> 0 < o[0] >>> 0 ? 1 : 0) | 0, t[2] = t[2] + 886263092 + (t[1] >>> 0 < o[1] >>> 0 ? 1 : 0) | 0, t[3] = t[3] + 1295307597 + (t[2] >>> 0 < o[2] >>> 0 ? 1 : 0) | 0, t[4] = t[4] + 3545052371 + (t[3] >>> 0 < o[3] >>> 0 ? 1 : 0) | 0, t[5] = t[5] + 886263092 + (t[4] >>> 0 < o[4] >>> 0 ? 1 : 0) | 0, t[6] = t[6] + 1295307597 + (t[5] >>> 0 < o[5] >>> 0 ? 1 : 0) | 0, t[7] = t[7] + 3545052371 + (t[6] >>> 0 < o[6] >>> 0 ? 1 : 0) | 0, this._b = t[7] >>> 0 < o[7] >>> 0 ? 1 : 0, n = 0; n < 8; n++) { const r = e[n] + t[n]; const i = 65535 & r; const s = r >>> 16; const c = ((i * i >>> 17) + i * s >>> 15) + s * s; const u = ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0); a[n] = c ^ u }e[0] = a[0] + (a[7] << 16 | a[7] >>> 16) + (a[6] << 16 | a[6] >>> 16) | 0, e[1] = a[1] + (a[0] << 8 | a[0] >>> 24) + a[7] | 0, e[2] = a[2] + (a[1] << 16 | a[1] >>> 16) + (a[0] << 16 | a[0] >>> 16) | 0, e[3] = a[3] + (a[2] << 8 | a[2] >>> 24) + a[1] | 0, e[4] = a[4] + (a[3] << 16 | a[3] >>> 16) + (a[2] << 16 | a[2] >>> 16) | 0, e[5] = a[5] + (a[4] << 8 | a[4] >>> 24) + a[3] | 0, e[6] = a[6] + (a[5] << 16 | a[5] >>> 16) + (a[4] << 16 | a[4] >>> 16) | 0, e[7] = a[7] + (a[6] << 8 | a[6] >>> 24) + a[5] | 0 }e.RabbitLegacy = t._createHelper(s) }()), r.RabbitLegacy) }, 4454: function (e, t, n) { let r; e.exports = (r = n(8249), n(8269), n(8214), n(888), n(5109), (function () { const e = r; const t = e.lib.StreamCipher; const n = e.algo; const i = []; const o = []; const a = []; const s = n.Rabbit = t.extend({ _doReset: function () { for (var e = this._key.words, t = this.cfg.iv, n = 0; n < 4; n++)e[n] = 16711935 & (e[n] << 8 | e[n] >>> 24) | 4278255360 & (e[n] << 24 | e[n] >>> 8); const r = this._X = [e[0], e[3] << 16 | e[2] >>> 16, e[1], e[0] << 16 | e[3] >>> 16, e[2], e[1] << 16 | e[0] >>> 16, e[3], e[2] << 16 | e[1] >>> 16]; const i = this._C = [e[2] << 16 | e[2] >>> 16, 4294901760 & e[0] | 65535 & e[1], e[3] << 16 | e[3] >>> 16, 4294901760 & e[1] | 65535 & e[2], e[0] << 16 | e[0] >>> 16, 4294901760 & e[2] | 65535 & e[3], e[1] << 16 | e[1] >>> 16, 4294901760 & e[3] | 65535 & e[0]]; for (this._b = 0, n = 0; n < 4; n++)c.call(this); for (n = 0; n < 8; n++)i[n] ^= r[n + 4 & 7]; if (t) { const o = t.words; const a = o[0]; const s = o[1]; const u = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8); const l = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8); const d = u >>> 16 | 4294901760 & l; const f = l << 16 | 65535 & u; for (i[0] ^= u, i[1] ^= d, i[2] ^= l, i[3] ^= f, i[4] ^= u, i[5] ^= d, i[6] ^= l, i[7] ^= f, n = 0; n < 4; n++)c.call(this) } }, _doProcessBlock: function (e, t) { const n = this._X; c.call(this), i[0] = n[0] ^ n[5] >>> 16 ^ n[3] << 16, i[1] = n[2] ^ n[7] >>> 16 ^ n[5] << 16, i[2] = n[4] ^ n[1] >>> 16 ^ n[7] << 16, i[3] = n[6] ^ n[3] >>> 16 ^ n[1] << 16; for (let r = 0; r < 4; r++)i[r] = 16711935 & (i[r] << 8 | i[r] >>> 24) | 4278255360 & (i[r] << 24 | i[r] >>> 8), e[t + r] ^= i[r] }, blockSize: 4, ivSize: 2 }); function c () { for (var e = this._X, t = this._C, n = 0; n < 8; n++)o[n] = t[n]; for (t[0] = t[0] + 1295307597 + this._b | 0, t[1] = t[1] + 3545052371 + (t[0] >>> 0 < o[0] >>> 0 ? 1 : 0) | 0, t[2] = t[2] + 886263092 + (t[1] >>> 0 < o[1] >>> 0 ? 1 : 0) | 0, t[3] = t[3] + 1295307597 + (t[2] >>> 0 < o[2] >>> 0 ? 1 : 0) | 0, t[4] = t[4] + 3545052371 + (t[3] >>> 0 < o[3] >>> 0 ? 1 : 0) | 0, t[5] = t[5] + 886263092 + (t[4] >>> 0 < o[4] >>> 0 ? 1 : 0) | 0, t[6] = t[6] + 1295307597 + (t[5] >>> 0 < o[5] >>> 0 ? 1 : 0) | 0, t[7] = t[7] + 3545052371 + (t[6] >>> 0 < o[6] >>> 0 ? 1 : 0) | 0, this._b = t[7] >>> 0 < o[7] >>> 0 ? 1 : 0, n = 0; n < 8; n++) { const r = e[n] + t[n]; const i = 65535 & r; const s = r >>> 16; const c = ((i * i >>> 17) + i * s >>> 15) + s * s; const u = ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0); a[n] = c ^ u }e[0] = a[0] + (a[7] << 16 | a[7] >>> 16) + (a[6] << 16 | a[6] >>> 16) | 0, e[1] = a[1] + (a[0] << 8 | a[0] >>> 24) + a[7] | 0, e[2] = a[2] + (a[1] << 16 | a[1] >>> 16) + (a[0] << 16 | a[0] >>> 16) | 0, e[3] = a[3] + (a[2] << 8 | a[2] >>> 24) + a[1] | 0, e[4] = a[4] + (a[3] << 16 | a[3] >>> 16) + (a[2] << 16 | a[2] >>> 16) | 0, e[5] = a[5] + (a[4] << 8 | a[4] >>> 24) + a[3] | 0, e[6] = a[6] + (a[5] << 16 | a[5] >>> 16) + (a[4] << 16 | a[4] >>> 16) | 0, e[7] = a[7] + (a[6] << 8 | a[6] >>> 24) + a[5] | 0 }e.Rabbit = t._createHelper(s) }()), r.Rabbit) }, 1857: function (e, t, n) { let r; e.exports = (r = n(8249), n(8269), n(8214), n(888), n(5109), (function () { const e = r; const t = e.lib.StreamCipher; const n = e.algo; const i = n.RC4 = t.extend({ _doReset: function () { for (var e = this._key, t = e.words, n = e.sigBytes, r = this._S = [], i = 0; i < 256; i++)r[i] = i; i = 0; for (let o = 0; i < 256; i++) { const a = i % n; const s = t[a >>> 2] >>> 24 - a % 4 * 8 & 255; o = (o + r[i] + s) % 256; const c = r[i]; r[i] = r[o], r[o] = c } this._i = this._j = 0 }, _doProcessBlock: function (e, t) { e[t] ^= o.call(this) }, keySize: 8, ivSize: 0 }); function o () { for (var e = this._S, t = this._i, n = this._j, r = 0, i = 0; i < 4; i++) { n = (n + e[t = (t + 1) % 256]) % 256; const o = e[t]; e[t] = e[n], e[n] = o, r |= e[(e[t] + e[n]) % 256] << 24 - 8 * i } return this._i = t, this._j = n, r }e.RC4 = t._createHelper(i); const a = n.RC4Drop = i.extend({ cfg: i.cfg.extend({ drop: 192 }), _doReset: function () { i._doReset.call(this); for (let e = this.cfg.drop; e > 0; e--)o.call(this) } }); e.RC4Drop = t._createHelper(a) }()), r.RC4) }, 706: function (e, t, n) { let r; e.exports = (r = n(8249), (function (e) { const t = r; const n = t.lib; const i = n.WordArray; const o = n.Hasher; const a = t.algo; const s = i.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]); const c = i.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]); const u = i.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]); const l = i.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]); const d = i.create([0, 1518500249, 1859775393, 2400959708, 2840853838]); const f = i.create([1352829926, 1548603684, 1836072691, 2053994217, 0]); const h = a.RIPEMD160 = o.extend({ _doReset: function () { this._hash = i.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (e, t) { for (var n = 0; n < 16; n++) { const r = t + n; const i = e[r]; e[r] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8) } let o; let a; let h; let w; let _; let E; let k; let S; let A; let O; let x; const I = this._hash.words; const N = d.words; const T = f.words; const R = s.words; const P = c.words; const C = u.words; const B = l.words; for (E = o = I[0], k = a = I[1], S = h = I[2], A = w = I[3], O = _ = I[4], n = 0; n < 80; n += 1)x = o + e[t + R[n]] | 0, x += n < 16 ? p(a, h, w) + N[0] : n < 32 ? g(a, h, w) + N[1] : n < 48 ? m(a, h, w) + N[2] : n < 64 ? y(a, h, w) + N[3] : b(a, h, w) + N[4], x = (x = v(x |= 0, C[n])) + _ | 0, o = _, _ = w, w = v(h, 10), h = a, a = x, x = E + e[t + P[n]] | 0, x += n < 16 ? b(k, S, A) + T[0] : n < 32 ? y(k, S, A) + T[1] : n < 48 ? m(k, S, A) + T[2] : n < 64 ? g(k, S, A) + T[3] : p(k, S, A) + T[4], x = (x = v(x |= 0, B[n])) + O | 0, E = O, O = A, A = v(S, 10), S = k, k = x; x = I[1] + h + A | 0, I[1] = I[2] + w + O | 0, I[2] = I[3] + _ + E | 0, I[3] = I[4] + o + k | 0, I[4] = I[0] + a + S | 0, I[0] = x }, _doFinalize: function () { const e = this._data; const t = e.words; const n = 8 * this._nDataBytes; const r = 8 * e.sigBytes; t[r >>> 5] |= 128 << 24 - r % 32, t[14 + (r + 64 >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8), e.sigBytes = 4 * (t.length + 1), this._process(); for (var i = this._hash, o = i.words, a = 0; a < 5; a++) { const s = o[a]; o[a] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8) } return i }, clone: function () { const e = o.clone.call(this); return e._hash = this._hash.clone(), e } }); function p (e, t, n) { return e ^ t ^ n } function g (e, t, n) { return e & t | ~e & n } function m (e, t, n) { return (e | ~t) ^ n } function y (e, t, n) { return e & n | t & ~n } function b (e, t, n) { return e ^ (t | ~n) } function v (e, t) { return e << t | e >>> 32 - t }t.RIPEMD160 = o._createHelper(h), t.HmacRIPEMD160 = o._createHmacHelper(h) }(Math)), r.RIPEMD160) }, 2783: function (e, t, n) { let r, i, o, a, s, c, u, l; e.exports = (l = n(8249), i = (r = l).lib, o = i.WordArray, a = i.Hasher, s = r.algo, c = [], u = s.SHA1 = a.extend({ _doReset: function () { this._hash = new o.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (e, t) { for (var n = this._hash.words, r = n[0], i = n[1], o = n[2], a = n[3], s = n[4], u = 0; u < 80; u++) { if (u < 16)c[u] = 0 | e[t + u]; else { const l = c[u - 3] ^ c[u - 8] ^ c[u - 14] ^ c[u - 16]; c[u] = l << 1 | l >>> 31 } let d = (r << 5 | r >>> 27) + s + c[u]; d += u < 20 ? 1518500249 + (i & o | ~i & a) : u < 40 ? 1859775393 + (i ^ o ^ a) : u < 60 ? (i & o | i & a | o & a) - 1894007588 : (i ^ o ^ a) - 899497514, s = a, a = o, o = i << 30 | i >>> 2, i = r, r = d }n[0] = n[0] + r | 0, n[1] = n[1] + i | 0, n[2] = n[2] + o | 0, n[3] = n[3] + a | 0, n[4] = n[4] + s | 0 }, _doFinalize: function () { const e = this._data; const t = e.words; const n = 8 * this._nDataBytes; const r = 8 * e.sigBytes; return t[r >>> 5] |= 128 << 24 - r % 32, t[14 + (r + 64 >>> 9 << 4)] = Math.floor(n / 4294967296), t[15 + (r + 64 >>> 9 << 4)] = n, e.sigBytes = 4 * t.length, this._process(), this._hash }, clone: function () { const e = a.clone.call(this); return e._hash = this._hash.clone(), e } }), r.SHA1 = a._createHelper(u), r.HmacSHA1 = a._createHmacHelper(u), l.SHA1) }, 7792: function (e, t, n) { let r, i, o, a, s, c; e.exports = (c = n(8249), n(2153), i = (r = c).lib.WordArray, o = r.algo, a = o.SHA256, s = o.SHA224 = a.extend({ _doReset: function () { this._hash = new i.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]) }, _doFinalize: function () { const e = a._doFinalize.call(this); return e.sigBytes -= 4, e } }), r.SHA224 = a._createHelper(s), r.HmacSHA224 = a._createHmacHelper(s), c.SHA224) }, 2153: function (e, t, n) { let r; e.exports = (r = n(8249), (function (e) { const t = r; const n = t.lib; const i = n.WordArray; const o = n.Hasher; const a = t.algo; const s = []; const c = []; !(function () { function t (t) { for (let n = e.sqrt(t), r = 2; r <= n; r++) if (!(t % r)) return !1; return !0 } function n (e) { return 4294967296 * (e - (0 | e)) | 0 } for (let r = 2, i = 0; i < 64;)t(r) && (i < 8 && (s[i] = n(e.pow(r, 0.5))), c[i] = n(e.pow(r, 1 / 3)), i++), r++ }()); const u = []; const l = a.SHA256 = o.extend({ _doReset: function () { this._hash = new i.init(s.slice(0)) }, _doProcessBlock: function (e, t) { for (var n = this._hash.words, r = n[0], i = n[1], o = n[2], a = n[3], s = n[4], l = n[5], d = n[6], f = n[7], h = 0; h < 64; h++) { if (h < 16)u[h] = 0 | e[t + h]; else { const p = u[h - 15]; const g = (p << 25 | p >>> 7) ^ (p << 14 | p >>> 18) ^ p >>> 3; const m = u[h - 2]; const y = (m << 15 | m >>> 17) ^ (m << 13 | m >>> 19) ^ m >>> 10; u[h] = g + u[h - 7] + y + u[h - 16] } const b = r & i ^ r & o ^ i & o; const v = (r << 30 | r >>> 2) ^ (r << 19 | r >>> 13) ^ (r << 10 | r >>> 22); const w = f + ((s << 26 | s >>> 6) ^ (s << 21 | s >>> 11) ^ (s << 7 | s >>> 25)) + (s & l ^ ~s & d) + c[h] + u[h]; f = d, d = l, l = s, s = a + w | 0, a = o, o = i, i = r, r = w + (v + b) | 0 }n[0] = n[0] + r | 0, n[1] = n[1] + i | 0, n[2] = n[2] + o | 0, n[3] = n[3] + a | 0, n[4] = n[4] + s | 0, n[5] = n[5] + l | 0, n[6] = n[6] + d | 0, n[7] = n[7] + f | 0 }, _doFinalize: function () { const t = this._data; const n = t.words; const r = 8 * this._nDataBytes; const i = 8 * t.sigBytes; return n[i >>> 5] |= 128 << 24 - i % 32, n[14 + (i + 64 >>> 9 << 4)] = e.floor(r / 4294967296), n[15 + (i + 64 >>> 9 << 4)] = r, t.sigBytes = 4 * n.length, this._process(), this._hash }, clone: function () { const e = o.clone.call(this); return e._hash = this._hash.clone(), e } }); t.SHA256 = o._createHelper(l), t.HmacSHA256 = o._createHmacHelper(l) }(Math)), r.SHA256) }, 3327: function (e, t, n) { let r; e.exports = (r = n(8249), n(4938), (function (e) { const t = r; const n = t.lib; const i = n.WordArray; const o = n.Hasher; const a = t.x64.Word; const s = t.algo; const c = []; const u = []; const l = []; !(function () { for (var e = 1, t = 0, n = 0; n < 24; n++) { c[e + 5 * t] = (n + 1) * (n + 2) / 2 % 64; const r = (2 * e + 3 * t) % 5; e = t % 5, t = r } for (e = 0; e < 5; e++) for (t = 0; t < 5; t++)u[e + 5 * t] = t + (2 * e + 3 * t) % 5 * 5; for (let i = 1, o = 0; o < 24; o++) { for (var s = 0, d = 0, f = 0; f < 7; f++) { if (1 & i) { const h = (1 << f) - 1; h < 32 ? d ^= 1 << h : s ^= 1 << h - 32 }128 & i ? i = i << 1 ^ 113 : i <<= 1 }l[o] = a.create(s, d) } }()); const d = []; !(function () { for (let e = 0; e < 25; e++)d[e] = a.create() }()); const f = s.SHA3 = o.extend({ cfg: o.cfg.extend({ outputLength: 512 }), _doReset: function () { for (let e = this._state = [], t = 0; t < 25; t++)e[t] = new a.init(); this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32 }, _doProcessBlock: function (e, t) { for (var n = this._state, r = this.blockSize / 2, i = 0; i < r; i++) { let o = e[t + 2 * i]; let a = e[t + 2 * i + 1]; o = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8), a = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8), (I = n[i]).high ^= a, I.low ^= o } for (let s = 0; s < 24; s++) { for (var f = 0; f < 5; f++) { for (var h = 0, p = 0, g = 0; g < 5; g++)h ^= (I = n[f + 5 * g]).high, p ^= I.low; const m = d[f]; m.high = h, m.low = p } for (f = 0; f < 5; f++) { const y = d[(f + 4) % 5]; const b = d[(f + 1) % 5]; const v = b.high; const w = b.low; for (h = y.high ^ (v << 1 | w >>> 31), p = y.low ^ (w << 1 | v >>> 31), g = 0; g < 5; g++)(I = n[f + 5 * g]).high ^= h, I.low ^= p } for (var _ = 1; _ < 25; _++) { const E = (I = n[_]).high; const k = I.low; const S = c[_]; S < 32 ? (h = E << S | k >>> 32 - S, p = k << S | E >>> 32 - S) : (h = k << S - 32 | E >>> 64 - S, p = E << S - 32 | k >>> 64 - S); const A = d[u[_]]; A.high = h, A.low = p } const O = d[0]; const x = n[0]; for (O.high = x.high, O.low = x.low, f = 0; f < 5; f++) for (g = 0; g < 5; g++) { var I = n[_ = f + 5 * g]; const N = d[_]; const T = d[(f + 1) % 5 + 5 * g]; const R = d[(f + 2) % 5 + 5 * g]; I.high = N.high ^ ~T.high & R.high, I.low = N.low ^ ~T.low & R.low }I = n[0]; const P = l[s]; I.high ^= P.high, I.low ^= P.low } }, _doFinalize: function () { const t = this._data; const n = t.words; const r = (this._nDataBytes, 8 * t.sigBytes); const o = 32 * this.blockSize; n[r >>> 5] |= 1 << 24 - r % 32, n[(e.ceil((r + 1) / o) * o >>> 5) - 1] |= 128, t.sigBytes = 4 * n.length, this._process(); for (var a = this._state, s = this.cfg.outputLength / 8, c = s / 8, u = [], l = 0; l < c; l++) { const d = a[l]; let f = d.high; let h = d.low; f = 16711935 & (f << 8 | f >>> 24) | 4278255360 & (f << 24 | f >>> 8), h = 16711935 & (h << 8 | h >>> 24) | 4278255360 & (h << 24 | h >>> 8), u.push(h), u.push(f) } return new i.init(u, s) }, clone: function () { for (var e = o.clone.call(this), t = e._state = this._state.slice(0), n = 0; n < 25; n++)t[n] = t[n].clone(); return e } }); t.SHA3 = o._createHelper(f), t.HmacSHA3 = o._createHmacHelper(f) }(Math)), r.SHA3) }, 7460: function (e, t, n) { let r, i, o, a, s, c, u, l; e.exports = (l = n(8249), n(4938), n(34), i = (r = l).x64, o = i.Word, a = i.WordArray, s = r.algo, c = s.SHA512, u = s.SHA384 = c.extend({ _doReset: function () { this._hash = new a.init([new o.init(3418070365, 3238371032), new o.init(1654270250, 914150663), new o.init(2438529370, 812702999), new o.init(355462360, 4144912697), new o.init(1731405415, 4290775857), new o.init(2394180231, 1750603025), new o.init(3675008525, 1694076839), new o.init(1203062813, 3204075428)]) }, _doFinalize: function () { const e = c._doFinalize.call(this); return e.sigBytes -= 16, e } }), r.SHA384 = c._createHelper(u), r.HmacSHA384 = c._createHmacHelper(u), l.SHA384) }, 34: function (e, t, n) { let r; e.exports = (r = n(8249), n(4938), (function () { const e = r; const t = e.lib.Hasher; const n = e.x64; const i = n.Word; const o = n.WordArray; const a = e.algo; function s () { return i.create.apply(i, arguments) } const c = [s(1116352408, 3609767458), s(1899447441, 602891725), s(3049323471, 3964484399), s(3921009573, 2173295548), s(961987163, 4081628472), s(1508970993, 3053834265), s(2453635748, 2937671579), s(2870763221, 3664609560), s(3624381080, 2734883394), s(310598401, 1164996542), s(607225278, 1323610764), s(1426881987, 3590304994), s(1925078388, 4068182383), s(2162078206, 991336113), s(2614888103, 633803317), s(3248222580, 3479774868), s(3835390401, 2666613458), s(4022224774, 944711139), s(264347078, 2341262773), s(604807628, 2007800933), s(770255983, 1495990901), s(1249150122, 1856431235), s(1555081692, 3175218132), s(1996064986, 2198950837), s(2554220882, 3999719339), s(2821834349, 766784016), s(2952996808, 2566594879), s(3210313671, 3203337956), s(3336571891, 1034457026), s(3584528711, 2466948901), s(113926993, 3758326383), s(338241895, 168717936), s(666307205, 1188179964), s(773529912, 1546045734), s(1294757372, 1522805485), s(1396182291, 2643833823), s(1695183700, 2343527390), s(1986661051, 1014477480), s(2177026350, 1206759142), s(2456956037, 344077627), s(2730485921, 1290863460), s(2820302411, 3158454273), s(3259730800, 3505952657), s(3345764771, 106217008), s(3516065817, 3606008344), s(3600352804, 1432725776), s(4094571909, 1467031594), s(275423344, 851169720), s(430227734, 3100823752), s(506948616, 1363258195), s(659060556, 3750685593), s(883997877, 3785050280), s(958139571, 3318307427), s(1322822218, 3812723403), s(1537002063, 2003034995), s(1747873779, 3602036899), s(1955562222, 1575990012), s(2024104815, 1125592928), s(2227730452, 2716904306), s(2361852424, 442776044), s(2428436474, 593698344), s(2756734187, 3733110249), s(3204031479, 2999351573), s(3329325298, 3815920427), s(3391569614, 3928383900), s(3515267271, 566280711), s(3940187606, 3454069534), s(4118630271, 4000239992), s(116418474, 1914138554), s(174292421, 2731055270), s(289380356, 3203993006), s(460393269, 320620315), s(685471733, 587496836), s(852142971, 1086792851), s(1017036298, 365543100), s(1126000580, 2618297676), s(1288033470, 3409855158), s(1501505948, 4234509866), s(1607167915, 987167468), s(1816402316, 1246189591)]; const u = []; !(function () { for (let e = 0; e < 80; e++)u[e] = s() }()); const l = a.SHA512 = t.extend({ _doReset: function () { this._hash = new o.init([new i.init(1779033703, 4089235720), new i.init(3144134277, 2227873595), new i.init(1013904242, 4271175723), new i.init(2773480762, 1595750129), new i.init(1359893119, 2917565137), new i.init(2600822924, 725511199), new i.init(528734635, 4215389547), new i.init(1541459225, 327033209)]) }, _doProcessBlock: function (e, t) { for (var n = this._hash.words, r = n[0], i = n[1], o = n[2], a = n[3], s = n[4], l = n[5], d = n[6], f = n[7], h = r.high, p = r.low, g = i.high, m = i.low, y = o.high, b = o.low, v = a.high, w = a.low, _ = s.high, E = s.low, k = l.high, S = l.low, A = d.high, O = d.low, x = f.high, I = f.low, N = h, T = p, R = g, P = m, C = y, B = b, L = v, j = w, D = _, U = E, M = k, z = S, F = A, H = O, q = x, K = I, V = 0; V < 80; V++) { var W; var $; const G = u[V]; if (V < 16)$ = G.high = 0 | e[t + 2 * V], W = G.low = 0 | e[t + 2 * V + 1]; else { const Y = u[V - 15]; const Z = Y.high; const J = Y.low; const X = (Z >>> 1 | J << 31) ^ (Z >>> 8 | J << 24) ^ Z >>> 7; const Q = (J >>> 1 | Z << 31) ^ (J >>> 8 | Z << 24) ^ (J >>> 7 | Z << 25); const ee = u[V - 2]; const te = ee.high; const ne = ee.low; const re = (te >>> 19 | ne << 13) ^ (te << 3 | ne >>> 29) ^ te >>> 6; const ie = (ne >>> 19 | te << 13) ^ (ne << 3 | te >>> 29) ^ (ne >>> 6 | te << 26); const oe = u[V - 7]; const ae = oe.high; const se = oe.low; const ce = u[V - 16]; const ue = ce.high; const le = ce.low; $ = ($ = ($ = X + ae + ((W = Q + se) >>> 0 < Q >>> 0 ? 1 : 0)) + re + ((W += ie) >>> 0 < ie >>> 0 ? 1 : 0)) + ue + ((W += le) >>> 0 < le >>> 0 ? 1 : 0), G.high = $, G.low = W } var de; const fe = D & M ^ ~D & F; const he = U & z ^ ~U & H; const pe = N & R ^ N & C ^ R & C; const ge = T & P ^ T & B ^ P & B; const me = (N >>> 28 | T << 4) ^ (N << 30 | T >>> 2) ^ (N << 25 | T >>> 7); const ye = (T >>> 28 | N << 4) ^ (T << 30 | N >>> 2) ^ (T << 25 | N >>> 7); const be = (D >>> 14 | U << 18) ^ (D >>> 18 | U << 14) ^ (D << 23 | U >>> 9); const ve = (U >>> 14 | D << 18) ^ (U >>> 18 | D << 14) ^ (U << 23 | D >>> 9); const we = c[V]; const _e = we.high; const Ee = we.low; let ke = q + be + ((de = K + ve) >>> 0 < K >>> 0 ? 1 : 0); const Se = ye + ge; q = F, K = H, F = M, H = z, M = D, z = U, D = L + (ke = (ke = (ke = ke + fe + ((de += he) >>> 0 < he >>> 0 ? 1 : 0)) + _e + ((de += Ee) >>> 0 < Ee >>> 0 ? 1 : 0)) + $ + ((de += W) >>> 0 < W >>> 0 ? 1 : 0)) + ((U = j + de | 0) >>> 0 < j >>> 0 ? 1 : 0) | 0, L = C, j = B, C = R, B = P, R = N, P = T, N = ke + (me + pe + (Se >>> 0 < ye >>> 0 ? 1 : 0)) + ((T = de + Se | 0) >>> 0 < de >>> 0 ? 1 : 0) | 0 }p = r.low = p + T, r.high = h + N + (p >>> 0 < T >>> 0 ? 1 : 0), m = i.low = m + P, i.high = g + R + (m >>> 0 < P >>> 0 ? 1 : 0), b = o.low = b + B, o.high = y + C + (b >>> 0 < B >>> 0 ? 1 : 0), w = a.low = w + j, a.high = v + L + (w >>> 0 < j >>> 0 ? 1 : 0), E = s.low = E + U, s.high = _ + D + (E >>> 0 < U >>> 0 ? 1 : 0), S = l.low = S + z, l.high = k + M + (S >>> 0 < z >>> 0 ? 1 : 0), O = d.low = O + H, d.high = A + F + (O >>> 0 < H >>> 0 ? 1 : 0), I = f.low = I + K, f.high = x + q + (I >>> 0 < K >>> 0 ? 1 : 0) }, _doFinalize: function () { const e = this._data; const t = e.words; const n = 8 * this._nDataBytes; const r = 8 * e.sigBytes; return t[r >>> 5] |= 128 << 24 - r % 32, t[30 + (r + 128 >>> 10 << 5)] = Math.floor(n / 4294967296), t[31 + (r + 128 >>> 10 << 5)] = n, e.sigBytes = 4 * t.length, this._process(), this._hash.toX32() }, clone: function () { const e = t.clone.call(this); return e._hash = this._hash.clone(), e }, blockSize: 32 }); e.SHA512 = t._createHelper(l), e.HmacSHA512 = t._createHmacHelper(l) }()), r.SHA512) }, 4253: function (e, t, n) { let r; e.exports = (r = n(8249), n(8269), n(8214), n(888), n(5109), (function () { const e = r; const t = e.lib; const n = t.WordArray; const i = t.BlockCipher; const o = e.algo; const a = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]; const s = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]; const c = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28]; const u = [{ 0: 8421888, 268435456: 32768, 536870912: 8421378, 805306368: 2, 1073741824: 512, 1342177280: 8421890, 1610612736: 8389122, 1879048192: 8388608, 2147483648: 514, 2415919104: 8389120, 2684354560: 33280, 2952790016: 8421376, 3221225472: 32770, 3489660928: 8388610, 3758096384: 0, 4026531840: 33282, 134217728: 0, 402653184: 8421890, 671088640: 33282, 939524096: 32768, 1207959552: 8421888, 1476395008: 512, 1744830464: 8421378, 2013265920: 2, 2281701376: 8389120, 2550136832: 33280, 2818572288: 8421376, 3087007744: 8389122, 3355443200: 8388610, 3623878656: 32770, 3892314112: 514, 4160749568: 8388608, 1: 32768, 268435457: 2, 536870913: 8421888, 805306369: 8388608, 1073741825: 8421378, 1342177281: 33280, 1610612737: 512, 1879048193: 8389122, 2147483649: 8421890, 2415919105: 8421376, 2684354561: 8388610, 2952790017: 33282, 3221225473: 514, 3489660929: 8389120, 3758096385: 32770, 4026531841: 0, 134217729: 8421890, 402653185: 8421376, 671088641: 8388608, 939524097: 512, 1207959553: 32768, 1476395009: 8388610, 1744830465: 2, 2013265921: 33282, 2281701377: 32770, 2550136833: 8389122, 2818572289: 514, 3087007745: 8421888, 3355443201: 8389120, 3623878657: 0, 3892314113: 33280, 4160749569: 8421378 }, { 0: 1074282512, 16777216: 16384, 33554432: 524288, 50331648: 1074266128, 67108864: 1073741840, 83886080: 1074282496, 100663296: 1073758208, 117440512: 16, 134217728: 540672, 150994944: 1073758224, 167772160: 1073741824, 184549376: 540688, 201326592: 524304, 218103808: 0, 234881024: 16400, 251658240: 1074266112, 8388608: 1073758208, 25165824: 540688, 41943040: 16, 58720256: 1073758224, 75497472: 1074282512, 92274688: 1073741824, 109051904: 524288, 125829120: 1074266128, 142606336: 524304, 159383552: 0, 176160768: 16384, 192937984: 1074266112, 209715200: 1073741840, 226492416: 540672, 243269632: 1074282496, 260046848: 16400, 268435456: 0, 285212672: 1074266128, 301989888: 1073758224, 318767104: 1074282496, 335544320: 1074266112, 352321536: 16, 369098752: 540688, 385875968: 16384, 402653184: 16400, 419430400: 524288, 436207616: 524304, 452984832: 1073741840, 469762048: 540672, 486539264: 1073758208, 503316480: 1073741824, 520093696: 1074282512, 276824064: 540688, 293601280: 524288, 310378496: 1074266112, 327155712: 16384, 343932928: 1073758208, 360710144: 1074282512, 377487360: 16, 394264576: 1073741824, 411041792: 1074282496, 427819008: 1073741840, 444596224: 1073758224, 461373440: 524304, 478150656: 0, 494927872: 16400, 511705088: 1074266128, 528482304: 540672 }, { 0: 260, 1048576: 0, 2097152: 67109120, 3145728: 65796, 4194304: 65540, 5242880: 67108868, 6291456: 67174660, 7340032: 67174400, 8388608: 67108864, 9437184: 67174656, 10485760: 65792, 11534336: 67174404, 12582912: 67109124, 13631488: 65536, 14680064: 4, 15728640: 256, 524288: 67174656, 1572864: 67174404, 2621440: 0, 3670016: 67109120, 4718592: 67108868, 5767168: 65536, 6815744: 65540, 7864320: 260, 8912896: 4, 9961472: 256, 11010048: 67174400, 12058624: 65796, 13107200: 65792, 14155776: 67109124, 15204352: 67174660, 16252928: 67108864, 16777216: 67174656, 17825792: 65540, 18874368: 65536, 19922944: 67109120, 20971520: 256, 22020096: 67174660, 23068672: 67108868, 24117248: 0, 25165824: 67109124, 26214400: 67108864, 27262976: 4, 28311552: 65792, 29360128: 67174400, 30408704: 260, 31457280: 65796, 32505856: 67174404, 17301504: 67108864, 18350080: 260, 19398656: 67174656, 20447232: 0, 21495808: 65540, 22544384: 67109120, 23592960: 256, 24641536: 67174404, 25690112: 65536, 26738688: 67174660, 27787264: 65796, 28835840: 67108868, 29884416: 67109124, 30932992: 67174400, 31981568: 4, 33030144: 65792 }, { 0: 2151682048, 65536: 2147487808, 131072: 4198464, 196608: 2151677952, 262144: 0, 327680: 4198400, 393216: 2147483712, 458752: 4194368, 524288: 2147483648, 589824: 4194304, 655360: 64, 720896: 2147487744, 786432: 2151678016, 851968: 4160, 917504: 4096, 983040: 2151682112, 32768: 2147487808, 98304: 64, 163840: 2151678016, 229376: 2147487744, 294912: 4198400, 360448: 2151682112, 425984: 0, 491520: 2151677952, 557056: 4096, 622592: 2151682048, 688128: 4194304, 753664: 4160, 819200: 2147483648, 884736: 4194368, 950272: 4198464, 1015808: 2147483712, 1048576: 4194368, 1114112: 4198400, 1179648: 2147483712, 1245184: 0, 1310720: 4160, 1376256: 2151678016, 1441792: 2151682048, 1507328: 2147487808, 1572864: 2151682112, 1638400: 2147483648, 1703936: 2151677952, 1769472: 4198464, 1835008: 2147487744, 1900544: 4194304, 1966080: 64, 2031616: 4096, 1081344: 2151677952, 1146880: 2151682112, 1212416: 0, 1277952: 4198400, 1343488: 4194368, 1409024: 2147483648, 1474560: 2147487808, 1540096: 64, 1605632: 2147483712, 1671168: 4096, 1736704: 2147487744, 1802240: 2151678016, 1867776: 4160, 1933312: 2151682048, 1998848: 4194304, 2064384: 4198464 }, { 0: 128, 4096: 17039360, 8192: 262144, 12288: 536870912, 16384: 537133184, 20480: 16777344, 24576: 553648256, 28672: 262272, 32768: 16777216, 36864: 537133056, 40960: 536871040, 45056: 553910400, 49152: 553910272, 53248: 0, 57344: 17039488, 61440: 553648128, 2048: 17039488, 6144: 553648256, 10240: 128, 14336: 17039360, 18432: 262144, 22528: 537133184, 26624: 553910272, 30720: 536870912, 34816: 537133056, 38912: 0, 43008: 553910400, 47104: 16777344, 51200: 536871040, 55296: 553648128, 59392: 16777216, 63488: 262272, 65536: 262144, 69632: 128, 73728: 536870912, 77824: 553648256, 81920: 16777344, 86016: 553910272, 90112: 537133184, 94208: 16777216, 98304: 553910400, 102400: 553648128, 106496: 17039360, 110592: 537133056, 114688: 262272, 118784: 536871040, 122880: 0, 126976: 17039488, 67584: 553648256, 71680: 16777216, 75776: 17039360, 79872: 537133184, 83968: 536870912, 88064: 17039488, 92160: 128, 96256: 553910272, 100352: 262272, 104448: 553910400, 108544: 0, 112640: 553648128, 116736: 16777344, 120832: 262144, 124928: 537133056, 129024: 536871040 }, { 0: 268435464, 256: 8192, 512: 270532608, 768: 270540808, 1024: 268443648, 1280: 2097152, 1536: 2097160, 1792: 268435456, 2048: 0, 2304: 268443656, 2560: 2105344, 2816: 8, 3072: 270532616, 3328: 2105352, 3584: 8200, 3840: 270540800, 128: 270532608, 384: 270540808, 640: 8, 896: 2097152, 1152: 2105352, 1408: 268435464, 1664: 268443648, 1920: 8200, 2176: 2097160, 2432: 8192, 2688: 268443656, 2944: 270532616, 3200: 0, 3456: 270540800, 3712: 2105344, 3968: 268435456, 4096: 268443648, 4352: 270532616, 4608: 270540808, 4864: 8200, 5120: 2097152, 5376: 268435456, 5632: 268435464, 5888: 2105344, 6144: 2105352, 6400: 0, 6656: 8, 6912: 270532608, 7168: 8192, 7424: 268443656, 7680: 270540800, 7936: 2097160, 4224: 8, 4480: 2105344, 4736: 2097152, 4992: 268435464, 5248: 268443648, 5504: 8200, 5760: 270540808, 6016: 270532608, 6272: 270540800, 6528: 270532616, 6784: 8192, 7040: 2105352, 7296: 2097160, 7552: 0, 7808: 268435456, 8064: 268443656 }, { 0: 1048576, 16: 33555457, 32: 1024, 48: 1049601, 64: 34604033, 80: 0, 96: 1, 112: 34603009, 128: 33555456, 144: 1048577, 160: 33554433, 176: 34604032, 192: 34603008, 208: 1025, 224: 1049600, 240: 33554432, 8: 34603009, 24: 0, 40: 33555457, 56: 34604032, 72: 1048576, 88: 33554433, 104: 33554432, 120: 1025, 136: 1049601, 152: 33555456, 168: 34603008, 184: 1048577, 200: 1024, 216: 34604033, 232: 1, 248: 1049600, 256: 33554432, 272: 1048576, 288: 33555457, 304: 34603009, 320: 1048577, 336: 33555456, 352: 34604032, 368: 1049601, 384: 1025, 400: 34604033, 416: 1049600, 432: 1, 448: 0, 464: 34603008, 480: 33554433, 496: 1024, 264: 1049600, 280: 33555457, 296: 34603009, 312: 1, 328: 33554432, 344: 1048576, 360: 1025, 376: 34604032, 392: 33554433, 408: 34603008, 424: 0, 440: 34604033, 456: 1049601, 472: 1024, 488: 33555456, 504: 1048577 }, { 0: 134219808, 1: 131072, 2: 134217728, 3: 32, 4: 131104, 5: 134350880, 6: 134350848, 7: 2048, 8: 134348800, 9: 134219776, 10: 133120, 11: 134348832, 12: 2080, 13: 0, 14: 134217760, 15: 133152, 2147483648: 2048, 2147483649: 134350880, 2147483650: 134219808, 2147483651: 134217728, 2147483652: 134348800, 2147483653: 133120, 2147483654: 133152, 2147483655: 32, 2147483656: 134217760, 2147483657: 2080, 2147483658: 131104, 2147483659: 134350848, 2147483660: 0, 2147483661: 134348832, 2147483662: 134219776, 2147483663: 131072, 16: 133152, 17: 134350848, 18: 32, 19: 2048, 20: 134219776, 21: 134217760, 22: 134348832, 23: 131072, 24: 0, 25: 131104, 26: 134348800, 27: 134219808, 28: 134350880, 29: 133120, 30: 2080, 31: 134217728, 2147483664: 131072, 2147483665: 2048, 2147483666: 134348832, 2147483667: 133152, 2147483668: 32, 2147483669: 134348800, 2147483670: 134217728, 2147483671: 134219808, 2147483672: 134350880, 2147483673: 134217760, 2147483674: 134219776, 2147483675: 0, 2147483676: 133120, 2147483677: 2080, 2147483678: 131104, 2147483679: 134350848 }]; const l = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679]; const d = o.DES = i.extend({ _doReset: function () { for (var e = this._key.words, t = [], n = 0; n < 56; n++) { const r = a[n] - 1; t[n] = e[r >>> 5] >>> 31 - r % 32 & 1 } for (var i = this._subKeys = [], o = 0; o < 16; o++) { const u = i[o] = []; const l = c[o]; for (n = 0; n < 24; n++)u[n / 6 | 0] |= t[(s[n] - 1 + l) % 28] << 31 - n % 6, u[4 + (n / 6 | 0)] |= t[28 + (s[n + 24] - 1 + l) % 28] << 31 - n % 6; for (u[0] = u[0] << 1 | u[0] >>> 31, n = 1; n < 7; n++)u[n] = u[n] >>> 4 * (n - 1) + 3; u[7] = u[7] << 5 | u[7] >>> 27 } const d = this._invSubKeys = []; for (n = 0; n < 16; n++)d[n] = i[15 - n] }, encryptBlock: function (e, t) { this._doCryptBlock(e, t, this._subKeys) }, decryptBlock: function (e, t) { this._doCryptBlock(e, t, this._invSubKeys) }, _doCryptBlock: function (e, t, n) { this._lBlock = e[t], this._rBlock = e[t + 1], f.call(this, 4, 252645135), f.call(this, 16, 65535), h.call(this, 2, 858993459), h.call(this, 8, 16711935), f.call(this, 1, 1431655765); for (let r = 0; r < 16; r++) { for (var i = n[r], o = this._lBlock, a = this._rBlock, s = 0, c = 0; c < 8; c++)s |= u[c][((a ^ i[c]) & l[c]) >>> 0]; this._lBlock = a, this._rBlock = o ^ s } const d = this._lBlock; this._lBlock = this._rBlock, this._rBlock = d, f.call(this, 1, 1431655765), h.call(this, 8, 16711935), h.call(this, 2, 858993459), f.call(this, 16, 65535), f.call(this, 4, 252645135), e[t] = this._lBlock, e[t + 1] = this._rBlock }, keySize: 2, ivSize: 2, blockSize: 2 }); function f (e, t) { const n = (this._lBlock >>> e ^ this._rBlock) & t; this._rBlock ^= n, this._lBlock ^= n << e } function h (e, t) { const n = (this._rBlock >>> e ^ this._lBlock) & t; this._lBlock ^= n, this._rBlock ^= n << e }e.DES = i._createHelper(d); const p = o.TripleDES = i.extend({ _doReset: function () { const e = this._key.words; if (e.length !== 2 && e.length !== 4 && e.length < 6) throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.'); const t = e.slice(0, 2); const r = e.length < 4 ? e.slice(0, 2) : e.slice(2, 4); const i = e.length < 6 ? e.slice(0, 2) : e.slice(4, 6); this._des1 = d.createEncryptor(n.create(t)), this._des2 = d.createEncryptor(n.create(r)), this._des3 = d.createEncryptor(n.create(i)) }, encryptBlock: function (e, t) { this._des1.encryptBlock(e, t), this._des2.decryptBlock(e, t), this._des3.encryptBlock(e, t) }, decryptBlock: function (e, t) { this._des3.decryptBlock(e, t), this._des2.encryptBlock(e, t), this._des1.decryptBlock(e, t) }, keySize: 6, ivSize: 2, blockSize: 2 }); e.TripleDES = i._createHelper(p) }()), r.TripleDES) }, 4938: function (e, t, n) { let r; e.exports = (r = n(8249), (function (e) { const t = r; const n = t.lib; const i = n.Base; const o = n.WordArray; const a = t.x64 = {}; a.Word = i.extend({ init: function (e, t) { this.high = e, this.low = t } }), a.WordArray = i.extend({ init: function (t, n) { t = this.words = t || [], this.sigBytes = n != e ? n : 8 * t.length }, toX32: function () { for (var e = this.words, t = e.length, n = [], r = 0; r < t; r++) { const i = e[r]; n.push(i.high), n.push(i.low) } return o.create(n, this.sigBytes) }, clone: function () { for (var e = i.clone.call(this), t = e.words = this.words.slice(0), n = t.length, r = 0; r < n; r++)t[r] = t[r].clone(); return e } }) }()), r) }, 7484: function (e) { e.exports = (function () { 'use strict'; const e = 1e3; const t = 6e4; const n = 36e5; const r = 'millisecond'; const i = 'second'; const o = 'minute'; const a = 'hour'; const s = 'day'; const c = 'week'; const u = 'month'; const l = 'quarter'; const d = 'year'; const f = 'date'; const h = 'Invalid Date'; const p = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/; const g = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g; const m = { name: 'en', weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'), months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'), ordinal: function (e) { const t = ['th', 'st', 'nd', 'rd']; const n = e % 100; return '[' + e + (t[(n - 20) % 10] || t[n] || t[0]) + ']' } }; const y = function (e, t, n) { const r = String(e); return !r || r.length >= t ? e : '' + Array(t + 1 - r.length).join(n) + e }; const b = { s: y, z: function (e) { const t = -e.utcOffset(); const n = Math.abs(t); const r = Math.floor(n / 60); const i = n % 60; return (t <= 0 ? '+' : '-') + y(r, 2, '0') + ':' + y(i, 2, '0') }, m: function e (t, n) { if (t.date() < n.date()) return -e(n, t); const r = 12 * (n.year() - t.year()) + (n.month() - t.month()); const i = t.clone().add(r, u); const o = n - i < 0; const a = t.clone().add(r + (o ? -1 : 1), u); return +(-(r + (n - i) / (o ? i - a : a - i)) || 0) }, a: function (e) { return e < 0 ? Math.ceil(e) || 0 : Math.floor(e) }, p: function (e) { return { M: u, y: d, w: c, d: s, D: f, h: a, m: o, s: i, ms: r, Q: l }[e] || String(e || '').toLowerCase().replace(/s$/, '') }, u: function (e) { return void 0 === e } }; let v = 'en'; const w = {}; w[v] = m; const _ = function (e) { return e instanceof A }; const E = function e (t, n, r) { let i; if (!t) return v; if (typeof t === 'string') { const o = t.toLowerCase(); w[o] && (i = o), n && (w[o] = n, i = o); const a = t.split('-'); if (!i && a.length > 1) return e(a[0]) } else { const s = t.name; w[s] = t, i = s } return !r && i && (v = i), i || !r && v }; const k = function (e, t) { if (_(e)) return e.clone(); const n = typeof t === 'object' ? t : {}; return n.date = e, n.args = arguments, new A(n) }; const S = b; S.l = E, S.i = _, S.w = function (e, t) { return k(e, { locale: t.$L, utc: t.$u, x: t.$x, $offset: t.$offset }) }; var A = (function () { function m (e) { this.$L = E(e.locale, null, !0), this.parse(e) } const y = m.prototype; return y.parse = function (e) { this.$d = (function (e) { const t = e.date; const n = e.utc; if (t === null) return new Date(NaN); if (S.u(t)) return new Date(); if (t instanceof Date) return new Date(t); if (typeof t === 'string' && !/Z$/i.test(t)) { const r = t.match(p); if (r) { const i = r[2] - 1 || 0; const o = (r[7] || '0').substring(0, 3); return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, o)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, o) } } return new Date(t) }(e)), this.$x = e.x || {}, this.init() }, y.init = function () { const e = this.$d; this.$y = e.getFullYear(), this.$M = e.getMonth(), this.$D = e.getDate(), this.$W = e.getDay(), this.$H = e.getHours(), this.$m = e.getMinutes(), this.$s = e.getSeconds(), this.$ms = e.getMilliseconds() }, y.$utils = function () { return S }, y.isValid = function () { return !(this.$d.toString() === h) }, y.isSame = function (e, t) { const n = k(e); return this.startOf(t) <= n && n <= this.endOf(t) }, y.isAfter = function (e, t) { return k(e) < this.startOf(t) }, y.isBefore = function (e, t) { return this.endOf(t) < k(e) }, y.$g = function (e, t, n) { return S.u(e) ? this[t] : this.set(n, e) }, y.unix = function () { return Math.floor(this.valueOf() / 1e3) }, y.valueOf = function () { return this.$d.getTime() }, y.startOf = function (e, t) { const n = this; const r = !!S.u(t) || t; const l = S.p(e); const h = function (e, t) { const i = S.w(n.$u ? Date.UTC(n.$y, t, e) : new Date(n.$y, t, e), n); return r ? i : i.endOf(s) }; const p = function (e, t) { return S.w(n.toDate()[e].apply(n.toDate('s'), (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)), n) }; const g = this.$W; const m = this.$M; const y = this.$D; const b = 'set' + (this.$u ? 'UTC' : ''); switch (l) { case d:return r ? h(1, 0) : h(31, 11); case u:return r ? h(1, m) : h(0, m + 1); case c:var v = this.$locale().weekStart || 0; var w = (g < v ? g + 7 : g) - v; return h(r ? y - w : y + (6 - w), m); case s:case f:return p(b + 'Hours', 0); case a:return p(b + 'Minutes', 1); case o:return p(b + 'Seconds', 2); case i:return p(b + 'Milliseconds', 3); default:return this.clone() } }, y.endOf = function (e) { return this.startOf(e, !1) }, y.$set = function (e, t) { let n; const c = S.p(e); const l = 'set' + (this.$u ? 'UTC' : ''); const h = (n = {}, n[s] = l + 'Date', n[f] = l + 'Date', n[u] = l + 'Month', n[d] = l + 'FullYear', n[a] = l + 'Hours', n[o] = l + 'Minutes', n[i] = l + 'Seconds', n[r] = l + 'Milliseconds', n)[c]; const p = c === s ? this.$D + (t - this.$W) : t; if (c === u || c === d) { const g = this.clone().set(f, 1); g.$d[h](p), g.init(), this.$d = g.set(f, Math.min(this.$D, g.daysInMonth())).$d } else h && this.$d[h](p); return this.init(), this }, y.set = function (e, t) { return this.clone().$set(e, t) }, y.get = function (e) { return this[S.p(e)]() }, y.add = function (r, l) { let f; const h = this; r = Number(r); const p = S.p(l); const g = function (e) { const t = k(h); return S.w(t.date(t.date() + Math.round(e * r)), h) }; if (p === u) return this.set(u, this.$M + r); if (p === d) return this.set(d, this.$y + r); if (p === s) return g(1); if (p === c) return g(7); const m = (f = {}, f[o] = t, f[a] = n, f[i] = e, f)[p] || 1; const y = this.$d.getTime() + r * m; return S.w(y, this) }, y.subtract = function (e, t) { return this.add(-1 * e, t) }, y.format = function (e) { const t = this; const n = this.$locale(); if (!this.isValid()) return n.invalidDate || h; const r = e || 'YYYY-MM-DDTHH:mm:ssZ'; const i = S.z(this); const o = this.$H; const a = this.$m; const s = this.$M; const c = n.weekdays; const u = n.months; const l = n.meridiem; const d = function (e, n, i, o) { return e && (e[n] || e(t, r)) || i[n].slice(0, o) }; const f = function (e) { return S.s(o % 12 || 12, e, '0') }; const p = l || function (e, t, n) { const r = e < 12 ? 'AM' : 'PM'; return n ? r.toLowerCase() : r }; return r.replace(g, function (e, r) { return r || (function (e) { switch (e) { case 'YY':return String(t.$y).slice(-2); case 'YYYY':return S.s(t.$y, 4, '0'); case 'M':return s + 1; case 'MM':return S.s(s + 1, 2, '0'); case 'MMM':return d(n.monthsShort, s, u, 3); case 'MMMM':return d(u, s); case 'D':return t.$D; case 'DD':return S.s(t.$D, 2, '0'); case 'd':return String(t.$W); case 'dd':return d(n.weekdaysMin, t.$W, c, 2); case 'ddd':return d(n.weekdaysShort, t.$W, c, 3); case 'dddd':return c[t.$W]; case 'H':return String(o); case 'HH':return S.s(o, 2, '0'); case 'h':return f(1); case 'hh':return f(2); case 'a':return p(o, a, !0); case 'A':return p(o, a, !1); case 'm':return String(a); case 'mm':return S.s(a, 2, '0'); case 's':return String(t.$s); case 'ss':return S.s(t.$s, 2, '0'); case 'SSS':return S.s(t.$ms, 3, '0'); case 'Z':return i } return null }(e)) || i.replace(':', '') }) }, y.utcOffset = function () { return 15 * -Math.round(this.$d.getTimezoneOffset() / 15) }, y.diff = function (r, f, h) { let p; const g = this; const m = S.p(f); const y = k(r); const b = (y.utcOffset() - this.utcOffset()) * t; const v = this - y; const w = function () { return S.m(g, y) }; switch (m) { case d:p = w() / 12; break; case u:p = w(); break; case l:p = w() / 3; break; case c:p = (v - b) / 6048e5; break; case s:p = (v - b) / 864e5; break; case a:p = v / n; break; case o:p = v / t; break; case i:p = v / e; break; default:p = v } return h ? p : S.a(p) }, y.daysInMonth = function () { return this.endOf(u).$D }, y.$locale = function () { return w[this.$L] }, y.locale = function (e, t) { if (!e) return this.$L; const n = this.clone(); const r = E(e, t, !0); return r && (n.$L = r), n }, y.clone = function () { return S.w(this.$d, this) }, y.toDate = function () { return new Date(this.valueOf()) }, y.toJSON = function () { return this.isValid() ? this.toISOString() : null }, y.toISOString = function () { return this.$d.toISOString() }, y.toString = function () { return this.$d.toUTCString() }, m }()); const O = A.prototype; return k.prototype = O, [['$ms', r], ['$s', i], ['$m', o], ['$H', a], ['$W', s], ['$M', u], ['$y', d], ['$D', f]].forEach(function (e) { O[e[1]] = function (t) { return this.$g(t, e[0], e[1]) } }), k.extend = function (e, t) { return e.$i || (e(t, A, k), e.$i = !0), k }, k.locale = E, k.isDayjs = _, k.unix = function (e) { return k(1e3 * e) }, k.en = w[v], k.Ls = w, k.p = {}, k }()) }, 8507: function (e, t, n) { e.exports = (function (e) { 'use strict'; function t (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e } } const n = t(e); function r (e) { return e > 1 && e < 5 && ~~(e / 10) != 1 } function i (e, t, n, i) { const o = e + ' '; switch (n) { case 's':return t || i ? 'pr sekund' : 'pr sekundami'; case 'm':return t ? 'minuta' : i ? 'minutu' : 'minutou'; case 'mm':return t || i ? o + (r(e) ? 'minuty' : 'minut') : o + 'minutami'; case 'h':return t ? 'hodina' : i ? 'hodinu' : 'hodinou'; case 'hh':return t || i ? o + (r(e) ? 'hodiny' : 'hodin') : o + 'hodinami'; case 'd':return t || i ? 'den' : 'dnem'; case 'dd':return t || i ? o + (r(e) ? 'dny' : 'dn') : o + 'dny'; case 'M':return t || i ? 'msc' : 'mscem'; case 'MM':return t || i ? o + (r(e) ? 'msce' : 'msc') : o + 'msci'; case 'y':return t || i ? 'rok' : 'rokem'; case 'yy':return t || i ? o + (r(e) ? 'roky' : 'let') : o + 'lety' } } const o = { name: 'cs', weekdays: 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'), weekdaysShort: 'ne_po_t_st_t_p_so'.split('_'), weekdaysMin: 'ne_po_t_st_t_p_so'.split('_'), months: 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'), monthsShort: 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_'), weekStart: 1, yearStart: 4, ordinal: function (e) { return e + '.' }, formats: { LT: 'H:mm', LTS: 'H:mm:ss', L: 'DD.MM.YYYY', LL: 'D. MMMM YYYY', LLL: 'D. MMMM YYYY H:mm', LLLL: 'dddd D. MMMM YYYY H:mm', l: 'D. M. YYYY' }, relativeTime: { future: 'za %s', past: 'ped %s', s: i, m: i, mm: i, h: i, hh: i, d: i, dd: i, M: i, MM: i, y: i, yy: i } }; return n.default.locale(o, null, !0), o }(n(7484))) }, 7427: function (e, t, n) { e.exports = (function (e) { 'use strict'; function t (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e } } const n = t(e); const r = { name: 'da', weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'), weekdaysShort: 'sn._man._tirs._ons._tors._fre._lr.'.split('_'), weekdaysMin: 's._ma._ti._on._to._fr._l.'.split('_'), months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'), monthsShort: 'jan._feb._mar._apr._maj_juni_juli_aug._sept._okt._nov._dec.'.split('_'), weekStart: 1, ordinal: function (e) { return e + '.' }, formats: { LT: 'HH:mm', LTS: 'HH:mm:ss', L: 'DD.MM.YYYY', LL: 'D. MMMM YYYY', LLL: 'D. MMMM YYYY HH:mm', LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm' }, relativeTime: { future: 'om %s', past: '%s siden', s: 'f sekunder', m: 'et minut', mm: '%d minutter', h: 'en time', hh: '%d timer', d: 'en dag', dd: '%d dage', M: 'en mned', MM: '%d mneder', y: 'et r', yy: '%d r' } }; return n.default.locale(r, null, !0), r }(n(7484))) }, 7763: function (e, t, n) { e.exports = (function (e) { 'use strict'; function t (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e } } const n = t(e); const r = { name: 'es', monthsShort: 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'), weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'), weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'), weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'), months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'), weekStart: 1, formats: { LT: 'H:mm', LTS: 'H:mm:ss', L: 'DD/MM/YYYY', LL: 'D [de] MMMM [de] YYYY', LLL: 'D [de] MMMM [de] YYYY H:mm', LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm' }, relativeTime: { future: 'en %s', past: 'hace %s', s: 'unos segundos', m: 'un minuto', mm: '%d minutos', h: 'una hora', hh: '%d horas', d: 'un da', dd: '%d das', M: 'un mes', MM: '%d meses', y: 'un ao', yy: '%d aos' }, ordinal: function (e) { return e + '' } }; return n.default.locale(r, null, !0), r }(n(7484))) }, 7822: function (e, t, n) { e.exports = (function (e) { 'use strict'; function t (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e } } const n = t(e); function r (e, t, n, r) { const i = { s: 'muutama sekunti', m: 'minuutti', mm: '%d minuuttia', h: 'tunti', hh: '%d tuntia', d: 'piv', dd: '%d piv', M: 'kuukausi', MM: '%d kuukautta', y: 'vuosi', yy: '%d vuotta', numbers: 'nolla_yksi_kaksi_kolme_nelj_viisi_kuusi_seitsemn_kahdeksan_yhdeksn'.split('_') }; const o = { s: 'muutaman sekunnin', m: 'minuutin', mm: '%d minuutin', h: 'tunnin', hh: '%d tunnin', d: 'pivn', dd: '%d pivn', M: 'kuukauden', MM: '%d kuukauden', y: 'vuoden', yy: '%d vuoden', numbers: 'nollan_yhden_kahden_kolmen_neljn_viiden_kuuden_seitsemn_kahdeksan_yhdeksn'.split('_') }; const a = r && !t ? o : i; const s = a[n]; return e < 10 ? s.replace('%d', a.numbers[e]) : s.replace('%d', e) } const i = { name: 'fi', weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'), weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'), weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'), months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'), monthsShort: 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'), ordinal: function (e) { return e + '.' }, weekStart: 1, yearStart: 4, relativeTime: { future: '%s pst', past: '%s sitten', s: r, m: r, mm: r, h: r, hh: r, d: r, dd: r, M: r, MM: r, y: r, yy: r }, formats: { LT: 'HH.mm', LTS: 'HH.mm.ss', L: 'DD.MM.YYYY', LL: 'D. MMMM[ta] YYYY', LLL: 'D. MMMM[ta] YYYY, [klo] HH.mm', LLLL: 'dddd, D. MMMM[ta] YYYY, [klo] HH.mm', l: 'D.M.YYYY', ll: 'D. MMM YYYY', lll: 'D. MMM YYYY, [klo] HH.mm', llll: 'ddd, D. MMM YYYY, [klo] HH.mm' } }; return n.default.locale(i, null, !0), i }(n(7484))) }, 6023: function (e, t, n) { e.exports = (function (e) { 'use strict'; function t (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e } } const n = t(e); const r = { name: 'fr', weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'), weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'), weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'), months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'), monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'), weekStart: 1, yearStart: 4, formats: { LT: 'HH:mm', LTS: 'HH:mm:ss', L: 'DD/MM/YYYY', LL: 'D MMMM YYYY', LLL: 'D MMMM YYYY HH:mm', LLLL: 'dddd D MMMM YYYY HH:mm' }, relativeTime: { future: 'dans %s', past: 'il y a %s', s: 'quelques secondes', m: 'une minute', mm: '%d minutes', h: 'une heure', hh: '%d heures', d: 'un jour', dd: '%d jours', M: 'un mois', MM: '%d mois', y: 'un an', yy: '%d ans' }, ordinal: function (e) { return e + (e === 1 ? 'er' : '') } }; return n.default.locale(r, null, !0), r }(n(7484))) }, 5551: function (e, t, n) { e.exports = (function (e) { 'use strict'; function t (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e } } const n = t(e); const r = { name: 'it', weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'), weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'), weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'), months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'), weekStart: 1, monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'), formats: { LT: 'HH:mm', LTS: 'HH:mm:ss', L: 'DD/MM/YYYY', LL: 'D MMMM YYYY', LLL: 'D MMMM YYYY HH:mm', LLLL: 'dddd D MMMM YYYY HH:mm' }, relativeTime: { future: 'tra %s', past: '%s fa', s: 'qualche secondo', m: 'un minuto', mm: '%d minuti', h: "un' ora", hh: '%d ore', d: 'un giorno', dd: '%d giorni', M: 'un mese', MM: '%d mesi', y: 'un anno', yy: '%d anni' }, ordinal: function (e) { return e + '' } }; return n.default.locale(r, null, !0), r }(n(7484))) }, 5473: function (e, t, n) { e.exports = (function (e) { 'use strict'; function t (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e } } const n = t(e); const r = { name: 'mr', weekdays: '______'.split('_'), months: '___________'.split('_'), weekdaysShort: '______'.split('_'), monthsShort: '._._._._._._._._._._._.'.split('_'), weekdaysMin: '______'.split('_'), ordinal: function (e) { return e }, formats: { LT: 'A h:mm ', LTS: 'A h:mm:ss ', L: 'DD/MM/YYYY', LL: 'D MMMM YYYY', LLL: 'D MMMM YYYY, A h:mm ', LLLL: 'dddd, D MMMM YYYY, A h:mm ' } }; return n.default.locale(r, null, !0), r }(n(7484))) }, 1987: function (e, t, n) { e.exports = (function (e) { 'use strict'; function t (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e } } const n = t(e); function r (e) { return e % 10 < 5 && e % 10 > 1 && ~~(e / 10) % 10 != 1 } function i (e, t, n) { const i = e + ' '; switch (n) { case 'm':return t ? 'minuta' : 'minut'; case 'mm':return i + (r(e) ? 'minuty' : 'minut'); case 'h':return t ? 'godzina' : 'godzin'; case 'hh':return i + (r(e) ? 'godziny' : 'godzin'); case 'MM':return i + (r(e) ? 'miesice' : 'miesicy'); case 'yy':return i + (r(e) ? 'lata' : 'lat') } } const o = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_'); const a = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'); const s = /D MMMM/; const c = function (e, t) { return s.test(t) ? o[e.month()] : a[e.month()] }; c.s = a, c.f = o; const u = { name: 'pl', weekdays: 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'), weekdaysShort: 'ndz_pon_wt_r_czw_pt_sob'.split('_'), weekdaysMin: 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'), months: c, monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'), ordinal: function (e) { return e + '.' }, weekStart: 1, yearStart: 4, relativeTime: { future: 'za %s', past: '%s temu', s: 'kilka sekund', m: i, mm: i, h: i, hh: i, d: '1 dzie', dd: '%d dni', M: 'miesic', MM: i, y: 'rok', yy: i }, formats: { LT: 'HH:mm', LTS: 'HH:mm:ss', L: 'DD.MM.YYYY', LL: 'D MMMM YYYY', LLL: 'D MMMM YYYY HH:mm', LLLL: 'dddd, D MMMM YYYY HH:mm' } }; return n.default.locale(u, null, !0), u }(n(7484))) }, 7548: function (e, t, n) { e.exports = (function (e) { 'use strict'; function t (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e } } const n = t(e); const r = { name: 'pt-br', weekdays: 'domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado'.split('_'), weekdaysShort: 'dom_seg_ter_qua_qui_sex_sb'.split('_'), weekdaysMin: 'Do_2_3_4_5_6_S'.split('_'), months: 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'), monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'), ordinal: function (e) { return e + '' }, formats: { LT: 'HH:mm', LTS: 'HH:mm:ss', L: 'DD/MM/YYYY', LL: 'D [de] MMMM [de] YYYY', LLL: 'D [de] MMMM [de] YYYY [s] HH:mm', LLLL: 'dddd, D [de] MMMM [de] YYYY [s] HH:mm' }, relativeTime: { future: 'em %s', past: 'h %s', s: 'poucos segundos', m: 'um minuto', mm: '%d minutos', h: 'uma hora', hh: '%d horas', d: 'um dia', dd: '%d dias', M: 'um ms', MM: '%d meses', y: 'um ano', yy: '%d anos' } }; return n.default.locale(r, null, !0), r }(n(7484))) }, 1876: function (e, t, n) { e.exports = (function (e) { 'use strict'; function t (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e } } const n = t(e); const r = { name: 'sv', weekdays: 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'), weekdaysShort: 'sn_mn_tis_ons_tor_fre_lr'.split('_'), weekdaysMin: 's_m_ti_on_to_fr_l'.split('_'), months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'), monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'), weekStart: 1, yearStart: 4, ordinal: function (e) { const t = e % 10; return '[' + e + (t === 1 || t === 2 ? 'a' : 'e') + ']' }, formats: { LT: 'HH:mm', LTS: 'HH:mm:ss', L: 'YYYY-MM-DD', LL: 'D MMMM YYYY', LLL: 'D MMMM YYYY [kl.] HH:mm', LLLL: 'dddd D MMMM YYYY [kl.] HH:mm', lll: 'D MMM YYYY HH:mm', llll: 'ddd D MMM YYYY HH:mm' }, relativeTime: { future: 'om %s', past: 'fr %s sedan', s: 'ngra sekunder', m: 'en minut', mm: '%d minuter', h: 'en timme', hh: '%d timmar', d: 'en dag', dd: '%d dagar', M: 'en mnad', MM: '%d mnader', y: 'ett r', yy: '%d r' } }; return n.default.locale(r, null, !0), r }(n(7484))) }, 3852: function (e, t, n) { e.exports = (function (e) { 'use strict'; function t (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e } } const n = t(e); const r = { name: 'zh-cn', weekdays: '______'.split('_'), weekdaysShort: '______'.split('_'), weekdaysMin: '______'.split('_'), months: '___________'.split('_'), monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'), ordinal: function (e, t) { return t === 'W' ? e + '' : e + '' }, weekStart: 1, yearStart: 4, formats: { LT: 'HH:mm', LTS: 'HH:mm:ss', L: 'YYYY/MM/DD', LL: 'YYYYMD', LLL: 'YYYYMDAhmm', LLLL: 'YYYYMDddddAhmm', l: 'YYYY/M/D', ll: 'YYYYMD', lll: 'YYYYMD HH:mm', llll: 'YYYYMDdddd HH:mm' }, relativeTime: { future: '%s', past: '%s', s: '', m: '1 ', mm: '%d ', h: '1 ', hh: '%d ', d: '1 ', dd: '%d ', M: '1 ', MM: '%d ', y: '1 ', yy: '%d ' }, meridiem: function (e, t) { const n = 100 * e + t; return n < 600 ? '' : n < 900 ? '' : n < 1100 ? '' : n < 1300 ? '' : n < 1800 ? '' : '' } }; return n.default.locale(r, null, !0), r }(n(7484))) }, 6121: function (e) { e.exports = (function () { 'use strict'; return function (e, t) { t.prototype.isSameOrBefore = function (e, t) { return this.isSame(e, t) || this.isBefore(e, t) } } }()) }, 6266: (e, t, n) => { 'use strict'; const r = t; r.version = n(8597).i8, r.utils = n(953), r.rand = n(9931), r.curve = n(8254), r.curves = n(5427), r.ec = n(7954), r.eddsa = n(5980) }, 4918: (e, t, n) => { 'use strict'; const r = n(3550); const i = n(953); const o = i.getNAF; const a = i.getJSF; const s = i.assert; function c (e, t) { this.type = e, this.p = new r(t.p, 16), this.red = t.prime ? r.red(t.prime) : r.mont(this.p), this.zero = new r(0).toRed(this.red), this.one = new r(1).toRed(this.red), this.two = new r(2).toRed(this.red), this.n = t.n && new r(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0; const n = this.n && this.p.div(this.n); !n || n.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red)) } function u (e, t) { this.curve = e, this.type = t, this.precomputed = null }e.exports = c, c.prototype.point = function () { throw new Error('Not implemented') }, c.prototype.validate = function () { throw new Error('Not implemented') }, c.prototype._fixedNafMul = function (e, t) { s(e.precomputed); const n = e._getDoubles(); const r = o(t, 1, this._bitLength); let i = (1 << n.step + 1) - (n.step % 2 == 0 ? 2 : 1); i /= 3; let a; let c; const u = []; for (a = 0; a < r.length; a += n.step) { c = 0; for (let l = a + n.step - 1; l >= a; l--)c = (c << 1) + r[l]; u.push(c) } for (var d = this.jpoint(null, null, null), f = this.jpoint(null, null, null), h = i; h > 0; h--) { for (a = 0; a < u.length; a++)(c = u[a]) === h ? f = f.mixedAdd(n.points[a]) : c === -h && (f = f.mixedAdd(n.points[a].neg())); d = d.add(f) } return d.toP() }, c.prototype._wnafMul = function (e, t) { let n = 4; const r = e._getNAFPoints(n); n = r.wnd; for (var i = r.points, a = o(t, n, this._bitLength), c = this.jpoint(null, null, null), u = a.length - 1; u >= 0; u--) { for (var l = 0; u >= 0 && a[u] === 0; u--)l++; if (u >= 0 && l++, c = c.dblp(l), u < 0) break; const d = a[u]; s(d !== 0), c = e.type === 'affine' ? d > 0 ? c.mixedAdd(i[d - 1 >> 1]) : c.mixedAdd(i[-d - 1 >> 1].neg()) : d > 0 ? c.add(i[d - 1 >> 1]) : c.add(i[-d - 1 >> 1].neg()) } return e.type === 'affine' ? c.toP() : c }, c.prototype._wnafMulAdd = function (e, t, n, r, i) { let s; let c; let u; const l = this._wnafT1; const d = this._wnafT2; const f = this._wnafT3; let h = 0; for (s = 0; s < r; s++) { const p = (u = t[s])._getNAFPoints(e); l[s] = p.wnd, d[s] = p.points } for (s = r - 1; s >= 1; s -= 2) { const g = s - 1; const m = s; if (l[g] === 1 && l[m] === 1) { const y = [t[g], null, null, t[m]]; t[g].y.cmp(t[m].y) === 0 ? (y[1] = t[g].add(t[m]), y[2] = t[g].toJ().mixedAdd(t[m].neg())) : t[g].y.cmp(t[m].y.redNeg()) === 0 ? (y[1] = t[g].toJ().mixedAdd(t[m]), y[2] = t[g].add(t[m].neg())) : (y[1] = t[g].toJ().mixedAdd(t[m]), y[2] = t[g].toJ().mixedAdd(t[m].neg())); const b = [-3, -1, -5, -7, 0, 7, 5, 1, 3]; const v = a(n[g], n[m]); for (h = Math.max(v[0].length, h), f[g] = new Array(h), f[m] = new Array(h), c = 0; c < h; c++) { const w = 0 | v[0][c]; const _ = 0 | v[1][c]; f[g][c] = b[3 * (w + 1) + (_ + 1)], f[m][c] = 0, d[g] = y } } else f[g] = o(n[g], l[g], this._bitLength), f[m] = o(n[m], l[m], this._bitLength), h = Math.max(f[g].length, h), h = Math.max(f[m].length, h) } let E = this.jpoint(null, null, null); const k = this._wnafT4; for (s = h; s >= 0; s--) { for (var S = 0; s >= 0;) { let A = !0; for (c = 0; c < r; c++)k[c] = 0 | f[c][s], k[c] !== 0 && (A = !1); if (!A) break; S++, s-- } if (s >= 0 && S++, E = E.dblp(S), s < 0) break; for (c = 0; c < r; c++) { const O = k[c]; O !== 0 && (O > 0 ? u = d[c][O - 1 >> 1] : O < 0 && (u = d[c][-O - 1 >> 1].neg()), E = u.type === 'affine' ? E.mixedAdd(u) : E.add(u)) } } for (s = 0; s < r; s++)d[s] = null; return i ? E : E.toP() }, c.BasePoint = u, u.prototype.eq = function () { throw new Error('Not implemented') }, u.prototype.validate = function () { return this.curve.validate(this) }, c.prototype.decodePoint = function (e, t) { e = i.toArray(e, t); const n = this.p.byteLength(); if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 == 2 * n) return e[0] === 6 ? s(e[e.length - 1] % 2 == 0) : e[0] === 7 && s(e[e.length - 1] % 2 == 1), this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n)); if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n) return this.pointFromX(e.slice(1, 1 + n), e[0] === 3); throw new Error('Unknown point format') }, u.prototype.encodeCompressed = function (e) { return this.encode(e, !0) }, u.prototype._encode = function (e) { const t = this.curve.p.byteLength(); const n = this.getX().toArray('be', t); return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray('be', t)) }, u.prototype.encode = function (e, t) { return i.encode(this._encode(t), e) }, u.prototype.precompute = function (e) { if (this.precomputed) return this; const t = { doubles: null, naf: null, beta: null }; return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this }, u.prototype._hasDoubles = function (e) { if (!this.precomputed) return !1; const t = this.precomputed.doubles; return !!t && t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) }, u.prototype._getDoubles = function (e, t) { if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles; for (var n = [this], r = this, i = 0; i < t; i += e) { for (let o = 0; o < e; o++)r = r.dbl(); n.push(r) } return { step: e, points: n } }, u.prototype._getNAFPoints = function (e) { if (this.precomputed && this.precomputed.naf) return this.precomputed.naf; for (var t = [this], n = (1 << e) - 1, r = n === 1 ? null : this.dbl(), i = 1; i < n; i++)t[i] = t[i - 1].add(r); return { wnd: e, points: t } }, u.prototype._getBeta = function () { return null }, u.prototype.dblp = function (e) { for (var t = this, n = 0; n < e; n++)t = t.dbl(); return t } }, 1138: (e, t, n) => { 'use strict'; const r = n(953); const i = n(3550); const o = n(5717); const a = n(4918); const s = r.assert; function c (e) { this.twisted = (0 | e.a) != 1, this.mOneA = this.twisted && (0 | e.a) == -1, this.extended = this.mOneA, a.call(this, 'edwards', e), this.a = new i(e.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new i(e.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new i(e.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), s(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (0 | e.c) == 1 } function u (e, t, n, r, o) { a.BasePoint.call(this, e, 'projective'), t === null && n === null && r === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new i(t, 16), this.y = new i(n, 16), this.z = r ? new i(r, 16) : this.curve.one, this.t = o && new i(o, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm())))) }o(c, a), e.exports = c, c.prototype._mulA = function (e) { return this.mOneA ? e.redNeg() : this.a.redMul(e) }, c.prototype._mulC = function (e) { return this.oneC ? e : this.c.redMul(e) }, c.prototype.jpoint = function (e, t, n, r) { return this.point(e, t, n, r) }, c.prototype.pointFromX = function (e, t) { (e = new i(e, 16)).red || (e = e.toRed(this.red)); const n = e.redSqr(); const r = this.c2.redSub(this.a.redMul(n)); const o = this.one.redSub(this.c2.redMul(this.d).redMul(n)); const a = r.redMul(o.redInvm()); let s = a.redSqrt(); if (s.redSqr().redSub(a).cmp(this.zero) !== 0) throw new Error('invalid point'); const c = s.fromRed().isOdd(); return (t && !c || !t && c) && (s = s.redNeg()), this.point(e, s) }, c.prototype.pointFromY = function (e, t) { (e = new i(e, 16)).red || (e = e.toRed(this.red)); const n = e.redSqr(); const r = n.redSub(this.c2); const o = n.redMul(this.d).redMul(this.c2).redSub(this.a); const a = r.redMul(o.redInvm()); if (a.cmp(this.zero) === 0) { if (t) throw new Error('invalid point'); return this.point(this.zero, e) } let s = a.redSqrt(); if (s.redSqr().redSub(a).cmp(this.zero) !== 0) throw new Error('invalid point'); return s.fromRed().isOdd() !== t && (s = s.redNeg()), this.point(s, e) }, c.prototype.validate = function (e) { if (e.isInfinity()) return !0; e.normalize(); const t = e.x.redSqr(); const n = e.y.redSqr(); const r = t.redMul(this.a).redAdd(n); const i = this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(n))); return r.cmp(i) === 0 }, o(u, a.BasePoint), c.prototype.pointFromJSON = function (e) { return u.fromJSON(this, e) }, c.prototype.point = function (e, t, n, r) { return new u(this, e, t, n, r) }, u.fromJSON = function (e, t) { return new u(e, t[0], t[1], t[2]) }, u.prototype.inspect = function () { return this.isInfinity() ? '<EC Point Infinity>' : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>' }, u.prototype.isInfinity = function () { return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0) }, u.prototype._extDbl = function () { const e = this.x.redSqr(); const t = this.y.redSqr(); let n = this.z.redSqr(); n = n.redIAdd(n); const r = this.curve._mulA(e); const i = this.x.redAdd(this.y).redSqr().redISub(e).redISub(t); const o = r.redAdd(t); const a = o.redSub(n); const s = r.redSub(t); const c = i.redMul(a); const u = o.redMul(s); const l = i.redMul(s); const d = a.redMul(o); return this.curve.point(c, u, d, l) }, u.prototype._projDbl = function () { let e; let t; let n; let r; let i; let o; const a = this.x.redAdd(this.y).redSqr(); const s = this.x.redSqr(); const c = this.y.redSqr(); if (this.curve.twisted) { const u = (r = this.curve._mulA(s)).redAdd(c); this.zOne ? (e = a.redSub(s).redSub(c).redMul(u.redSub(this.curve.two)), t = u.redMul(r.redSub(c)), n = u.redSqr().redSub(u).redSub(u)) : (i = this.z.redSqr(), o = u.redSub(i).redISub(i), e = a.redSub(s).redISub(c).redMul(o), t = u.redMul(r.redSub(c)), n = u.redMul(o)) } else r = s.redAdd(c), i = this.curve._mulC(this.z).redSqr(), o = r.redSub(i).redSub(i), e = this.curve._mulC(a.redISub(r)).redMul(o), t = this.curve._mulC(r).redMul(s.redISub(c)), n = r.redMul(o); return this.curve.point(e, t, n) }, u.prototype.dbl = function () { return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl() }, u.prototype._extAdd = function (e) { const t = this.y.redSub(this.x).redMul(e.y.redSub(e.x)); const n = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)); const r = this.t.redMul(this.curve.dd).redMul(e.t); const i = this.z.redMul(e.z.redAdd(e.z)); const o = n.redSub(t); const a = i.redSub(r); const s = i.redAdd(r); const c = n.redAdd(t); const u = o.redMul(a); const l = s.redMul(c); const d = o.redMul(c); const f = a.redMul(s); return this.curve.point(u, l, f, d) }, u.prototype._projAdd = function (e) { let t; let n; const r = this.z.redMul(e.z); const i = r.redSqr(); const o = this.x.redMul(e.x); const a = this.y.redMul(e.y); const s = this.curve.d.redMul(o).redMul(a); const c = i.redSub(s); const u = i.redAdd(s); const l = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(o).redISub(a); const d = r.redMul(c).redMul(l); return this.curve.twisted ? (t = r.redMul(u).redMul(a.redSub(this.curve._mulA(o))), n = c.redMul(u)) : (t = r.redMul(u).redMul(a.redSub(o)), n = this.curve._mulC(c).redMul(u)), this.curve.point(d, t, n) }, u.prototype.add = function (e) { return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e) }, u.prototype.mul = function (e) { return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e) }, u.prototype.mulAdd = function (e, t, n) { return this.curve._wnafMulAdd(1, [this, t], [e, n], 2, !1) }, u.prototype.jmulAdd = function (e, t, n) { return this.curve._wnafMulAdd(1, [this, t], [e, n], 2, !0) }, u.prototype.normalize = function () { if (this.zOne) return this; const e = this.z.redInvm(); return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this }, u.prototype.neg = function () { return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg()) }, u.prototype.getX = function () { return this.normalize(), this.x.fromRed() }, u.prototype.getY = function () { return this.normalize(), this.y.fromRed() }, u.prototype.eq = function (e) { return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0 }, u.prototype.eqXToP = function (e) { const t = e.toRed(this.curve.red).redMul(this.z); if (this.x.cmp(t) === 0) return !0; for (let n = e.clone(), r = this.curve.redN.redMul(this.z); ;) { if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0) return !1; if (t.redIAdd(r), this.x.cmp(t) === 0) return !0 } }, u.prototype.toP = u.prototype.normalize, u.prototype.mixedAdd = u.prototype.add }, 8254: (e, t, n) => { 'use strict'; const r = t; r.base = n(4918), r.short = n(6673), r.mont = n(2881), r.edwards = n(1138) }, 2881: (e, t, n) => { 'use strict'; const r = n(3550); const i = n(5717); const o = n(4918); const a = n(953); function s (e) { o.call(this, 'mont', e), this.a = new r(e.a, 16).toRed(this.red), this.b = new r(e.b, 16).toRed(this.red), this.i4 = new r(4).toRed(this.red).redInvm(), this.two = new r(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two)) } function c (e, t, n) { o.BasePoint.call(this, e, 'projective'), t === null && n === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new r(t, 16), this.z = new r(n, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red))) }i(s, o), e.exports = s, s.prototype.validate = function (e) { const t = e.normalize().x; const n = t.redSqr(); const r = n.redMul(t).redAdd(n.redMul(this.a)).redAdd(t); return r.redSqrt().redSqr().cmp(r) === 0 }, i(c, o.BasePoint), s.prototype.decodePoint = function (e, t) { return this.point(a.toArray(e, t), 1) }, s.prototype.point = function (e, t) { return new c(this, e, t) }, s.prototype.pointFromJSON = function (e) { return c.fromJSON(this, e) }, c.prototype.precompute = function () {}, c.prototype._encode = function () { return this.getX().toArray('be', this.curve.p.byteLength()) }, c.fromJSON = function (e, t) { return new c(e, t[0], t[1] || e.one) }, c.prototype.inspect = function () { return this.isInfinity() ? '<EC Point Infinity>' : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>' }, c.prototype.isInfinity = function () { return this.z.cmpn(0) === 0 }, c.prototype.dbl = function () { const e = this.x.redAdd(this.z).redSqr(); const t = this.x.redSub(this.z).redSqr(); const n = e.redSub(t); const r = e.redMul(t); const i = n.redMul(t.redAdd(this.curve.a24.redMul(n))); return this.curve.point(r, i) }, c.prototype.add = function () { throw new Error('Not supported on Montgomery curve') }, c.prototype.diffAdd = function (e, t) { const n = this.x.redAdd(this.z); const r = this.x.redSub(this.z); const i = e.x.redAdd(e.z); const o = e.x.redSub(e.z).redMul(n); const a = i.redMul(r); const s = t.z.redMul(o.redAdd(a).redSqr()); const c = t.x.redMul(o.redISub(a).redSqr()); return this.curve.point(s, c) }, c.prototype.mul = function (e) { for (var t = e.clone(), n = this, r = this.curve.point(null, null), i = []; t.cmpn(0) !== 0; t.iushrn(1))i.push(t.andln(1)); for (let o = i.length - 1; o >= 0; o--)i[o] === 0 ? (n = n.diffAdd(r, this), r = r.dbl()) : (r = n.diffAdd(r, this), n = n.dbl()); return r }, c.prototype.mulAdd = function () { throw new Error('Not supported on Montgomery curve') }, c.prototype.jumlAdd = function () { throw new Error('Not supported on Montgomery curve') }, c.prototype.eq = function (e) { return this.getX().cmp(e.getX()) === 0 }, c.prototype.normalize = function () { return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this }, c.prototype.getX = function () { return this.normalize(), this.x.fromRed() } }, 6673: (e, t, n) => { 'use strict'; const r = n(953); const i = n(3550); const o = n(5717); const a = n(4918); const s = r.assert; function c (e) { a.call(this, 'short', e), this.a = new i(e.a, 16).toRed(this.red), this.b = new i(e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4) } function u (e, t, n, r) { a.BasePoint.call(this, e, 'affine'), t === null && n === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new i(t, 16), this.y = new i(n, 16), r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1) } function l (e, t, n, r) { a.BasePoint.call(this, e, 'jacobian'), t === null && n === null && r === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new i(0)) : (this.x = new i(t, 16), this.y = new i(n, 16), this.z = new i(r, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one }o(c, a), e.exports = c, c.prototype._getEndomorphism = function (e) { if (this.zeroA && this.g && this.n && this.p.modn(3) === 1) { let t, n; if (e.beta)t = new i(e.beta, 16).toRed(this.red); else { const r = this._getEndoRoots(this.p); t = (t = r[0].cmp(r[1]) < 0 ? r[0] : r[1]).toRed(this.red) } if (e.lambda)n = new i(e.lambda, 16); else { const o = this._getEndoRoots(this.n); this.g.mul(o[0]).x.cmp(this.g.x.redMul(t)) === 0 ? n = o[0] : (n = o[1], s(this.g.mul(n).x.cmp(this.g.x.redMul(t)) === 0)) } return { beta: t, lambda: n, basis: e.basis ? e.basis.map(function (e) { return { a: new i(e.a, 16), b: new i(e.b, 16) } }) : this._getEndoBasis(n) } } }, c.prototype._getEndoRoots = function (e) { const t = e === this.p ? this.red : i.mont(e); const n = new i(2).toRed(t).redInvm(); const r = n.redNeg(); const o = new i(3).toRed(t).redNeg().redSqrt().redMul(n); return [r.redAdd(o).fromRed(), r.redSub(o).fromRed()] }, c.prototype._getEndoBasis = function (e) { for (var t, n, r, o, a, s, c, u, l, d = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), f = e, h = this.n.clone(), p = new i(1), g = new i(0), m = new i(0), y = new i(1), b = 0; f.cmpn(0) !== 0;) { const v = h.div(f); u = h.sub(v.mul(f)), l = m.sub(v.mul(p)); const w = y.sub(v.mul(g)); if (!r && u.cmp(d) < 0)t = c.neg(), n = p, r = u.neg(), o = l; else if (r && ++b == 2) break; c = u, h = f, f = u, m = p, p = l, y = g, g = w }a = u.neg(), s = l; const _ = r.sqr().add(o.sqr()); return a.sqr().add(s.sqr()).cmp(_) >= 0 && (a = t, s = n), r.negative && (r = r.neg(), o = o.neg()), a.negative && (a = a.neg(), s = s.neg()), [{ a: r, b: o }, { a, b: s }] }, c.prototype._endoSplit = function (e) { const t = this.endo.basis; const n = t[0]; const r = t[1]; const i = r.b.mul(e).divRound(this.n); const o = n.b.neg().mul(e).divRound(this.n); const a = i.mul(n.a); const s = o.mul(r.a); const c = i.mul(n.b); const u = o.mul(r.b); return { k1: e.sub(a).sub(s), k2: c.add(u).neg() } }, c.prototype.pointFromX = function (e, t) { (e = new i(e, 16)).red || (e = e.toRed(this.red)); const n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b); let r = n.redSqrt(); if (r.redSqr().redSub(n).cmp(this.zero) !== 0) throw new Error('invalid point'); const o = r.fromRed().isOdd(); return (t && !o || !t && o) && (r = r.redNeg()), this.point(e, r) }, c.prototype.validate = function (e) { if (e.inf) return !0; const t = e.x; const n = e.y; const r = this.a.redMul(t); const i = t.redSqr().redMul(t).redIAdd(r).redIAdd(this.b); return n.redSqr().redISub(i).cmpn(0) === 0 }, c.prototype._endoWnafMulAdd = function (e, t, n) { for (var r = this._endoWnafT1, i = this._endoWnafT2, o = 0; o < e.length; o++) { const a = this._endoSplit(t[o]); let s = e[o]; let c = s._getBeta(); a.k1.negative && (a.k1.ineg(), s = s.neg(!0)), a.k2.negative && (a.k2.ineg(), c = c.neg(!0)), r[2 * o] = s, r[2 * o + 1] = c, i[2 * o] = a.k1, i[2 * o + 1] = a.k2 } for (var u = this._wnafMulAdd(1, r, i, 2 * o, n), l = 0; l < 2 * o; l++)r[l] = null, i[l] = null; return u }, o(u, a.BasePoint), c.prototype.point = function (e, t, n) { return new u(this, e, t, n) }, c.prototype.pointFromJSON = function (e, t) { return u.fromJSON(this, e, t) }, u.prototype._getBeta = function () { if (this.curve.endo) { const e = this.precomputed; if (e && e.beta) return e.beta; const t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y); if (e) { const n = this.curve; const r = function (e) { return n.point(e.x.redMul(n.endo.beta), e.y) }; e.beta = t, t.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(r) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(r) } } } return t } }, u.prototype.toJSON = function () { return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y] }, u.fromJSON = function (e, t, n) { typeof t === 'string' && (t = JSON.parse(t)); const r = e.point(t[0], t[1], n); if (!t[2]) return r; function i (t) { return e.point(t[0], t[1], n) } const o = t[2]; return r.precomputed = { beta: null, doubles: o.doubles && { step: o.doubles.step, points: [r].concat(o.doubles.points.map(i)) }, naf: o.naf && { wnd: o.naf.wnd, points: [r].concat(o.naf.points.map(i)) } }, r }, u.prototype.inspect = function () { return this.isInfinity() ? '<EC Point Infinity>' : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>' }, u.prototype.isInfinity = function () { return this.inf }, u.prototype.add = function (e) { if (this.inf) return e; if (e.inf) return this; if (this.eq(e)) return this.dbl(); if (this.neg().eq(e)) return this.curve.point(null, null); if (this.x.cmp(e.x) === 0) return this.curve.point(null, null); let t = this.y.redSub(e.y); t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm())); const n = t.redSqr().redISub(this.x).redISub(e.x); const r = t.redMul(this.x.redSub(n)).redISub(this.y); return this.curve.point(n, r) }, u.prototype.dbl = function () { if (this.inf) return this; const e = this.y.redAdd(this.y); if (e.cmpn(0) === 0) return this.curve.point(null, null); const t = this.curve.a; const n = this.x.redSqr(); const r = e.redInvm(); const i = n.redAdd(n).redIAdd(n).redIAdd(t).redMul(r); const o = i.redSqr().redISub(this.x.redAdd(this.x)); const a = i.redMul(this.x.redSub(o)).redISub(this.y); return this.curve.point(o, a) }, u.prototype.getX = function () { return this.x.fromRed() }, u.prototype.getY = function () { return this.y.fromRed() }, u.prototype.mul = function (e) { return e = new i(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e) }, u.prototype.mulAdd = function (e, t, n) { const r = [this, t]; const i = [e, n]; return this.curve.endo ? this.curve._endoWnafMulAdd(r, i) : this.curve._wnafMulAdd(1, r, i, 2) }, u.prototype.jmulAdd = function (e, t, n) { const r = [this, t]; const i = [e, n]; return this.curve.endo ? this.curve._endoWnafMulAdd(r, i, !0) : this.curve._wnafMulAdd(1, r, i, 2, !0) }, u.prototype.eq = function (e) { return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0) }, u.prototype.neg = function (e) { if (this.inf) return this; const t = this.curve.point(this.x, this.y.redNeg()); if (e && this.precomputed) { const n = this.precomputed; const r = function (e) { return e.neg() }; t.precomputed = { naf: n.naf && { wnd: n.naf.wnd, points: n.naf.points.map(r) }, doubles: n.doubles && { step: n.doubles.step, points: n.doubles.points.map(r) } } } return t }, u.prototype.toJ = function () { return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one) }, o(l, a.BasePoint), c.prototype.jpoint = function (e, t, n) { return new l(this, e, t, n) }, l.prototype.toP = function () { if (this.isInfinity()) return this.curve.point(null, null); const e = this.z.redInvm(); const t = e.redSqr(); const n = this.x.redMul(t); const r = this.y.redMul(t).redMul(e); return this.curve.point(n, r) }, l.prototype.neg = function () { return this.curve.jpoint(this.x, this.y.redNeg(), this.z) }, l.prototype.add = function (e) { if (this.isInfinity()) return e; if (e.isInfinity()) return this; const t = e.z.redSqr(); const n = this.z.redSqr(); const r = this.x.redMul(t); const i = e.x.redMul(n); const o = this.y.redMul(t.redMul(e.z)); const a = e.y.redMul(n.redMul(this.z)); const s = r.redSub(i); const c = o.redSub(a); if (s.cmpn(0) === 0) return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl(); const u = s.redSqr(); const l = u.redMul(s); const d = r.redMul(u); const f = c.redSqr().redIAdd(l).redISub(d).redISub(d); const h = c.redMul(d.redISub(f)).redISub(o.redMul(l)); const p = this.z.redMul(e.z).redMul(s); return this.curve.jpoint(f, h, p) }, l.prototype.mixedAdd = function (e) { if (this.isInfinity()) return e.toJ(); if (e.isInfinity()) return this; const t = this.z.redSqr(); const n = this.x; const r = e.x.redMul(t); const i = this.y; const o = e.y.redMul(t).redMul(this.z); const a = n.redSub(r); const s = i.redSub(o); if (a.cmpn(0) === 0) return s.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl(); const c = a.redSqr(); const u = c.redMul(a); const l = n.redMul(c); const d = s.redSqr().redIAdd(u).redISub(l).redISub(l); const f = s.redMul(l.redISub(d)).redISub(i.redMul(u)); const h = this.z.redMul(a); return this.curve.jpoint(d, f, h) }, l.prototype.dblp = function (e) { if (e === 0) return this; if (this.isInfinity()) return this; if (!e) return this.dbl(); let t; if (this.curve.zeroA || this.curve.threeA) { let n = this; for (t = 0; t < e; t++)n = n.dbl(); return n } const r = this.curve.a; const i = this.curve.tinv; let o = this.x; const a = this.y; let s = this.z; let c = s.redSqr().redSqr(); let u = a.redAdd(a); for (t = 0; t < e; t++) { const l = o.redSqr(); const d = u.redSqr(); const f = d.redSqr(); const h = l.redAdd(l).redIAdd(l).redIAdd(r.redMul(c)); const p = o.redMul(d); const g = h.redSqr().redISub(p.redAdd(p)); const m = p.redISub(g); let y = h.redMul(m); y = y.redIAdd(y).redISub(f); const b = u.redMul(s); t + 1 < e && (c = c.redMul(f)), o = g, s = b, u = y } return this.curve.jpoint(o, u.redMul(i), s) }, l.prototype.dbl = function () { return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl() }, l.prototype._zeroDbl = function () { let e, t, n; if (this.zOne) { const r = this.x.redSqr(); const i = this.y.redSqr(); const o = i.redSqr(); let a = this.x.redAdd(i).redSqr().redISub(r).redISub(o); a = a.redIAdd(a); const s = r.redAdd(r).redIAdd(r); const c = s.redSqr().redISub(a).redISub(a); let u = o.redIAdd(o); u = (u = u.redIAdd(u)).redIAdd(u), e = c, t = s.redMul(a.redISub(c)).redISub(u), n = this.y.redAdd(this.y) } else { const l = this.x.redSqr(); const d = this.y.redSqr(); const f = d.redSqr(); let h = this.x.redAdd(d).redSqr().redISub(l).redISub(f); h = h.redIAdd(h); const p = l.redAdd(l).redIAdd(l); const g = p.redSqr(); let m = f.redIAdd(f); m = (m = m.redIAdd(m)).redIAdd(m), e = g.redISub(h).redISub(h), t = p.redMul(h.redISub(e)).redISub(m), n = (n = this.y.redMul(this.z)).redIAdd(n) } return this.curve.jpoint(e, t, n) }, l.prototype._threeDbl = function () { let e, t, n; if (this.zOne) { const r = this.x.redSqr(); const i = this.y.redSqr(); const o = i.redSqr(); let a = this.x.redAdd(i).redSqr().redISub(r).redISub(o); a = a.redIAdd(a); const s = r.redAdd(r).redIAdd(r).redIAdd(this.curve.a); const c = s.redSqr().redISub(a).redISub(a); e = c; let u = o.redIAdd(o); u = (u = u.redIAdd(u)).redIAdd(u), t = s.redMul(a.redISub(c)).redISub(u), n = this.y.redAdd(this.y) } else { const l = this.z.redSqr(); const d = this.y.redSqr(); const f = this.x.redMul(d); let h = this.x.redSub(l).redMul(this.x.redAdd(l)); h = h.redAdd(h).redIAdd(h); let p = f.redIAdd(f); const g = (p = p.redIAdd(p)).redAdd(p); e = h.redSqr().redISub(g), n = this.y.redAdd(this.z).redSqr().redISub(d).redISub(l); let m = d.redSqr(); m = (m = (m = m.redIAdd(m)).redIAdd(m)).redIAdd(m), t = h.redMul(p.redISub(e)).redISub(m) } return this.curve.jpoint(e, t, n) }, l.prototype._dbl = function () { const e = this.curve.a; const t = this.x; const n = this.y; const r = this.z; const i = r.redSqr().redSqr(); const o = t.redSqr(); const a = n.redSqr(); const s = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(i)); let c = t.redAdd(t); const u = (c = c.redIAdd(c)).redMul(a); const l = s.redSqr().redISub(u.redAdd(u)); const d = u.redISub(l); let f = a.redSqr(); f = (f = (f = f.redIAdd(f)).redIAdd(f)).redIAdd(f); const h = s.redMul(d).redISub(f); const p = n.redAdd(n).redMul(r); return this.curve.jpoint(l, h, p) }, l.prototype.trpl = function () { if (!this.curve.zeroA) return this.dbl().add(this); const e = this.x.redSqr(); const t = this.y.redSqr(); const n = this.z.redSqr(); const r = t.redSqr(); const i = e.redAdd(e).redIAdd(e); const o = i.redSqr(); let a = this.x.redAdd(t).redSqr().redISub(e).redISub(r); const s = (a = (a = (a = a.redIAdd(a)).redAdd(a).redIAdd(a)).redISub(o)).redSqr(); let c = r.redIAdd(r); c = (c = (c = c.redIAdd(c)).redIAdd(c)).redIAdd(c); const u = i.redIAdd(a).redSqr().redISub(o).redISub(s).redISub(c); let l = t.redMul(u); l = (l = l.redIAdd(l)).redIAdd(l); let d = this.x.redMul(s).redISub(l); d = (d = d.redIAdd(d)).redIAdd(d); let f = this.y.redMul(u.redMul(c.redISub(u)).redISub(a.redMul(s))); f = (f = (f = f.redIAdd(f)).redIAdd(f)).redIAdd(f); const h = this.z.redAdd(a).redSqr().redISub(n).redISub(s); return this.curve.jpoint(d, f, h) }, l.prototype.mul = function (e, t) { return e = new i(e, t), this.curve._wnafMul(this, e) }, l.prototype.eq = function (e) { if (e.type === 'affine') return this.eq(e.toJ()); if (this === e) return !0; const t = this.z.redSqr(); const n = e.z.redSqr(); if (this.x.redMul(n).redISub(e.x.redMul(t)).cmpn(0) !== 0) return !1; const r = t.redMul(this.z); const i = n.redMul(e.z); return this.y.redMul(i).redISub(e.y.redMul(r)).cmpn(0) === 0 }, l.prototype.eqXToP = function (e) { const t = this.z.redSqr(); const n = e.toRed(this.curve.red).redMul(t); if (this.x.cmp(n) === 0) return !0; for (let r = e.clone(), i = this.curve.redN.redMul(t); ;) { if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) return !1; if (n.redIAdd(i), this.x.cmp(n) === 0) return !0 } }, l.prototype.inspect = function () { return this.isInfinity() ? '<EC JPoint Infinity>' : '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>' }, l.prototype.isInfinity = function () { return this.z.cmpn(0) === 0 } }, 5427: (e, t, n) => { 'use strict'; let r; const i = t; const o = n(3715); const a = n(8254); const s = n(953).assert; function c (e) { e.type === 'short' ? this.curve = new a.short(e) : e.type === 'edwards' ? this.curve = new a.edwards(e) : this.curve = new a.mont(e), this.g = this.curve.g, this.n = this.curve.n, this.hash = e.hash, s(this.g.validate(), 'Invalid curve'), s(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O') } function u (e, t) { Object.defineProperty(i, e, { configurable: !0, enumerable: !0, get: function () { const n = new c(t); return Object.defineProperty(i, e, { configurable: !0, enumerable: !0, value: n }), n } }) }i.PresetCurve = c, u('p192', { type: 'short', prime: 'p192', p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff', a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc', b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1', n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831', hash: o.sha256, gRed: !1, g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'] }), u('p224', { type: 'short', prime: 'p224', p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001', a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe', b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4', n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d', hash: o.sha256, gRed: !1, g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'] }), u('p256', { type: 'short', prime: null, p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff', a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc', b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b', n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551', hash: o.sha256, gRed: !1, g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'] }), u('p384', { type: 'short', prime: null, p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff', a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc', b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef', n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973', hash: o.sha384, gRed: !1, g: ['aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7', '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'] }), u('p521', { type: 'short', prime: null, p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff', a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc', b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00', n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409', hash: o.sha512, gRed: !1, g: ['000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66', '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650'] }), u('curve25519', { type: 'mont', prime: 'p25519', p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed', a: '76d06', b: '1', n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed', hash: o.sha256, gRed: !1, g: ['9'] }), u('ed25519', { type: 'edwards', prime: 'p25519', p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed', a: '-1', c: '1', d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3', n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed', hash: o.sha256, gRed: !1, g: ['216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a', '6666666666666666666666666666666666666666666666666666666666666658'] }); try { r = n(1037) } catch (e) { r = void 0 }u('secp256k1', { type: 'short', prime: 'k256', p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f', a: '0', b: '7', n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141', h: '1', hash: o.sha256, beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee', lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72', basis: [{ a: '3086d221a7d46bcde86c90e49284eb15', b: '-e4437ed6010e88286f547fa90abfe4c3' }, { a: '114ca50f7a8e2f3f657c1108d9d44cfd8', b: '3086d221a7d46bcde86c90e49284eb15' }], gRed: !1, g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', r] }) }, 7954: (e, t, n) => { 'use strict'; const r = n(3550); const i = n(2156); const o = n(953); const a = n(5427); const s = n(9931); const c = o.assert; const u = n(1251); const l = n(611); function d (e) { if (!(this instanceof d)) return new d(e); typeof e === 'string' && (c(Object.prototype.hasOwnProperty.call(a, e), 'Unknown curve ' + e), e = a[e]), e instanceof a.PresetCurve && (e = { curve: e }), this.curve = e.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e.curve.g, this.g.precompute(e.curve.n.bitLength() + 1), this.hash = e.hash || e.curve.hash }e.exports = d, d.prototype.keyPair = function (e) { return new u(this, e) }, d.prototype.keyFromPrivate = function (e, t) { return u.fromPrivate(this, e, t) }, d.prototype.keyFromPublic = function (e, t) { return u.fromPublic(this, e, t) }, d.prototype.genKeyPair = function (e) { e || (e = {}); for (let t = new i({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || 'utf8', entropy: e.entropy || s(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || 'utf8', nonce: this.n.toArray() }), n = this.n.byteLength(), o = this.n.sub(new r(2)); ;) { const a = new r(t.generate(n)); if (!(a.cmp(o) > 0)) return a.iaddn(1), this.keyFromPrivate(a) } }, d.prototype._truncateToN = function (e, t) { const n = 8 * e.byteLength() - this.n.bitLength(); return n > 0 && (e = e.ushrn(n)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e }, d.prototype.sign = function (e, t, n, o) { typeof n === 'object' && (o = n, n = null), o || (o = {}), t = this.keyFromPrivate(t, n), e = this._truncateToN(new r(e, 16)); for (let a = this.n.byteLength(), s = t.getPrivate().toArray('be', a), c = e.toArray('be', a), u = new i({ hash: this.hash, entropy: s, nonce: c, pers: o.pers, persEnc: o.persEnc || 'utf8' }), d = this.n.sub(new r(1)), f = 0; ;f++) { let h = o.k ? o.k(f) : new r(u.generate(this.n.byteLength())); if (!((h = this._truncateToN(h, !0)).cmpn(1) <= 0 || h.cmp(d) >= 0)) { const p = this.g.mul(h); if (!p.isInfinity()) { const g = p.getX(); const m = g.umod(this.n); if (m.cmpn(0) !== 0) { let y = h.invm(this.n).mul(m.mul(t.getPrivate()).iadd(e)); if ((y = y.umod(this.n)).cmpn(0) !== 0) { let b = (p.getY().isOdd() ? 1 : 0) | (g.cmp(m) !== 0 ? 2 : 0); return o.canonical && y.cmp(this.nh) > 0 && (y = this.n.sub(y), b ^= 1), new l({ r: m, s: y, recoveryParam: b }) } } } } } }, d.prototype.verify = function (e, t, n, i) { e = this._truncateToN(new r(e, 16)), n = this.keyFromPublic(n, i); const o = (t = new l(t, 'hex')).r; const a = t.s; if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1; if (a.cmpn(1) < 0 || a.cmp(this.n) >= 0) return !1; let s; const c = a.invm(this.n); const u = c.mul(e).umod(this.n); const d = c.mul(o).umod(this.n); return this.curve._maxwellTrick ? !(s = this.g.jmulAdd(u, n.getPublic(), d)).isInfinity() && s.eqXToP(o) : !(s = this.g.mulAdd(u, n.getPublic(), d)).isInfinity() && s.getX().umod(this.n).cmp(o) === 0 }, d.prototype.recoverPubKey = function (e, t, n, i) { c((3 & n) === n, 'The recovery param is more than two bits'), t = new l(t, i); const o = this.n; const a = new r(e); let s = t.r; const u = t.s; const d = 1 & n; const f = n >> 1; if (s.cmp(this.curve.p.umod(this.curve.n)) >= 0 && f) throw new Error('Unable to find sencond key candinate'); s = f ? this.curve.pointFromX(s.add(this.curve.n), d) : this.curve.pointFromX(s, d); const h = t.r.invm(o); const p = o.sub(a).mul(h).umod(o); const g = u.mul(h).umod(o); return this.g.mulAdd(p, s, g) }, d.prototype.getKeyRecoveryParam = function (e, t, n, r) { if ((t = new l(t, r)).recoveryParam !== null) return t.recoveryParam; for (let i = 0; i < 4; i++) { var o; try { o = this.recoverPubKey(e, t, i) } catch (e) { continue } if (o.eq(n)) return i } throw new Error('Unable to find valid recovery factor') } }, 1251: (e, t, n) => { 'use strict'; const r = n(3550); const i = n(953).assert; function o (e, t) { this.ec = e, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc) }e.exports = o, o.fromPublic = function (e, t, n) { return t instanceof o ? t : new o(e, { pub: t, pubEnc: n }) }, o.fromPrivate = function (e, t, n) { return t instanceof o ? t : new o(e, { priv: t, privEnc: n }) }, o.prototype.validate = function () { const e = this.getPublic(); return e.isInfinity() ? { result: !1, reason: 'Invalid public key' } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: 'Public key * N != O' } : { result: !1, reason: 'Public key is not a point' } }, o.prototype.getPublic = function (e, t) { return typeof e === 'string' && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub }, o.prototype.getPrivate = function (e) { return e === 'hex' ? this.priv.toString(16, 2) : this.priv }, o.prototype._importPrivate = function (e, t) { this.priv = new r(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n) }, o.prototype._importPublic = function (e, t) { if (e.x || e.y) return this.ec.curve.type === 'mont' ? i(e.x, 'Need x coordinate') : this.ec.curve.type !== 'short' && this.ec.curve.type !== 'edwards' || i(e.x && e.y, 'Need both x and y coordinate'), void (this.pub = this.ec.curve.point(e.x, e.y)); this.pub = this.ec.curve.decodePoint(e, t) }, o.prototype.derive = function (e) { return e.validate() || i(e.validate(), 'public point not validated'), e.mul(this.priv).getX() }, o.prototype.sign = function (e, t, n) { return this.ec.sign(e, this, t, n) }, o.prototype.verify = function (e, t) { return this.ec.verify(e, t, this) }, o.prototype.inspect = function () { return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >' } }, 611: (e, t, n) => { 'use strict'; const r = n(3550); const i = n(953); const o = i.assert; function a (e, t) { if (e instanceof a) return e; this._importDER(e, t) || (o(e.r && e.s, 'Signature without r or s'), this.r = new r(e.r, 16), this.s = new r(e.s, 16), void 0 === e.recoveryParam ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam) } function s () { this.place = 0 } function c (e, t) { const n = e[t.place++]; if (!(128 & n)) return n; const r = 15 & n; if (r === 0 || r > 4) return !1; for (var i = 0, o = 0, a = t.place; o < r; o++, a++)i <<= 8, i |= e[a], i >>>= 0; return !(i <= 127) && (t.place = a, i) } function u (e) { for (var t = 0, n = e.length - 1; !e[t] && !(128 & e[t + 1]) && t < n;)t++; return t === 0 ? e : e.slice(t) } function l (e, t) { if (t < 128)e.push(t); else { let n = 1 + (Math.log(t) / Math.LN2 >>> 3); for (e.push(128 | n); --n;)e.push(t >>> (n << 3) & 255); e.push(t) } }e.exports = a, a.prototype._importDER = function (e, t) { e = i.toArray(e, t); const n = new s(); if (e[n.place++] !== 48) return !1; const o = c(e, n); if (!1 === o) return !1; if (o + n.place !== e.length) return !1; if (e[n.place++] !== 2) return !1; const a = c(e, n); if (!1 === a) return !1; let u = e.slice(n.place, a + n.place); if (n.place += a, e[n.place++] !== 2) return !1; const l = c(e, n); if (!1 === l) return !1; if (e.length !== l + n.place) return !1; let d = e.slice(n.place, l + n.place); if (u[0] === 0) { if (!(128 & u[1])) return !1; u = u.slice(1) } if (d[0] === 0) { if (!(128 & d[1])) return !1; d = d.slice(1) } return this.r = new r(u), this.s = new r(d), this.recoveryParam = null, !0 }, a.prototype.toDER = function (e) { let t = this.r.toArray(); let n = this.s.toArray(); for (128 & t[0] && (t = [0].concat(t)), 128 & n[0] && (n = [0].concat(n)), t = u(t), n = u(n); !(n[0] || 128 & n[1]);)n = n.slice(1); let r = [2]; l(r, t.length), (r = r.concat(t)).push(2), l(r, n.length); const o = r.concat(n); let a = [48]; return l(a, o.length), a = a.concat(o), i.encode(a, e) } }, 5980: (e, t, n) => { 'use strict'; const r = n(3715); const i = n(5427); const o = n(953); const a = o.assert; const s = o.parseBytes; const c = n(9087); const u = n(3622); function l (e) { if (a(e === 'ed25519', 'only tested with ed25519 so far'), !(this instanceof l)) return new l(e); e = i[e].curve, this.curve = e, this.g = e.g, this.g.precompute(e.n.bitLength() + 1), this.pointClass = e.point().constructor, this.encodingLength = Math.ceil(e.n.bitLength() / 8), this.hash = r.sha512 }e.exports = l, l.prototype.sign = function (e, t) { e = s(e); const n = this.keyFromSecret(t); const r = this.hashInt(n.messagePrefix(), e); const i = this.g.mul(r); const o = this.encodePoint(i); const a = this.hashInt(o, n.pubBytes(), e).mul(n.priv()); const c = r.add(a).umod(this.curve.n); return this.makeSignature({ R: i, S: c, Rencoded: o }) }, l.prototype.verify = function (e, t, n) { e = s(e), t = this.makeSignature(t); const r = this.keyFromPublic(n); const i = this.hashInt(t.Rencoded(), r.pubBytes(), e); const o = this.g.mul(t.S()); return t.R().add(r.pub().mul(i)).eq(o) }, l.prototype.hashInt = function () { for (var e = this.hash(), t = 0; t < arguments.length; t++)e.update(arguments[t]); return o.intFromLE(e.digest()).umod(this.curve.n) }, l.prototype.keyFromPublic = function (e) { return c.fromPublic(this, e) }, l.prototype.keyFromSecret = function (e) { return c.fromSecret(this, e) }, l.prototype.makeSignature = function (e) { return e instanceof u ? e : new u(this, e) }, l.prototype.encodePoint = function (e) { const t = e.getY().toArray('le', this.encodingLength); return t[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, t }, l.prototype.decodePoint = function (e) { const t = (e = o.parseBytes(e)).length - 1; const n = e.slice(0, t).concat(-129 & e[t]); const r = (128 & e[t]) != 0; const i = o.intFromLE(n); return this.curve.pointFromY(i, r) }, l.prototype.encodeInt = function (e) { return e.toArray('le', this.encodingLength) }, l.prototype.decodeInt = function (e) { return o.intFromLE(e) }, l.prototype.isPoint = function (e) { return e instanceof this.pointClass } }, 9087: (e, t, n) => { 'use strict'; const r = n(953); const i = r.assert; const o = r.parseBytes; const a = r.cachedProperty; function s (e, t) { this.eddsa = e, this._secret = o(t.secret), e.isPoint(t.pub) ? this._pub = t.pub : this._pubBytes = o(t.pub) }s.fromPublic = function (e, t) { return t instanceof s ? t : new s(e, { pub: t }) }, s.fromSecret = function (e, t) { return t instanceof s ? t : new s(e, { secret: t }) }, s.prototype.secret = function () { return this._secret }, a(s, 'pubBytes', function () { return this.eddsa.encodePoint(this.pub()) }), a(s, 'pub', function () { return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv()) }), a(s, 'privBytes', function () { const e = this.eddsa; const t = this.hash(); const n = e.encodingLength - 1; const r = t.slice(0, e.encodingLength); return r[0] &= 248, r[n] &= 127, r[n] |= 64, r }), a(s, 'priv', function () { return this.eddsa.decodeInt(this.privBytes()) }), a(s, 'hash', function () { return this.eddsa.hash().update(this.secret()).digest() }), a(s, 'messagePrefix', function () { return this.hash().slice(this.eddsa.encodingLength) }), s.prototype.sign = function (e) { return i(this._secret, 'KeyPair can only verify'), this.eddsa.sign(e, this) }, s.prototype.verify = function (e, t) { return this.eddsa.verify(e, t, this) }, s.prototype.getSecret = function (e) { return i(this._secret, 'KeyPair is public only'), r.encode(this.secret(), e) }, s.prototype.getPublic = function (e) { return r.encode(this.pubBytes(), e) }, e.exports = s }, 3622: (e, t, n) => { 'use strict'; const r = n(3550); const i = n(953); const o = i.assert; const a = i.cachedProperty; const s = i.parseBytes; function c (e, t) { this.eddsa = e, typeof t !== 'object' && (t = s(t)), Array.isArray(t) && (t = { R: t.slice(0, e.encodingLength), S: t.slice(e.encodingLength) }), o(t.R && t.S, 'Signature without R or S'), e.isPoint(t.R) && (this._R = t.R), t.S instanceof r && (this._S = t.S), this._Rencoded = Array.isArray(t.R) ? t.R : t.Rencoded, this._Sencoded = Array.isArray(t.S) ? t.S : t.Sencoded }a(c, 'S', function () { return this.eddsa.decodeInt(this.Sencoded()) }), a(c, 'R', function () { return this.eddsa.decodePoint(this.Rencoded()) }), a(c, 'Rencoded', function () { return this.eddsa.encodePoint(this.R()) }), a(c, 'Sencoded', function () { return this.eddsa.encodeInt(this.S()) }), c.prototype.toBytes = function () { return this.Rencoded().concat(this.Sencoded()) }, c.prototype.toHex = function () { return i.encode(this.toBytes(), 'hex').toUpperCase() }, e.exports = c }, 1037: e => { e.exports = { doubles: { step: 4, points: [['e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a', 'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'], ['8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508', '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'], ['175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739', 'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'], ['363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640', '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'], ['8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c', '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'], ['723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda', '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'], ['eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa', '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'], ['100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0', 'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'], ['e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d', '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'], ['feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d', 'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'], ['da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1', '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'], ['53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0', '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'], ['8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047', '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'], ['385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862', '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'], ['6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7', '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'], ['3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd', '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'], ['85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83', '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'], ['948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a', '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'], ['6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8', 'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'], ['e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d', '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'], ['e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725', '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'], ['213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754', '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'], ['4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c', '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'], ['fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6', '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'], ['76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39', 'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'], ['c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891', '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'], ['d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b', 'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'], ['b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03', '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'], ['e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d', 'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'], ['a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070', '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'], ['90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4', 'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'], ['8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da', '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'], ['e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11', '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'], ['8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e', 'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'], ['e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41', '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'], ['b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef', '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'], ['d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8', 'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'], ['324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d', '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'], ['4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96', '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'], ['9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd', 'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'], ['6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5', '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'], ['a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266', '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'], ['7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71', '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'], ['928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac', 'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'], ['85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751', '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'], ['ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e', '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'], ['827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241', 'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'], ['eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3', 'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'], ['e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f', '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'], ['1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19', 'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'], ['146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be', 'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'], ['fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9', '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'], ['da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2', '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'], ['a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13', '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'], ['174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c', 'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'], ['959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba', '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'], ['d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151', 'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'], ['64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073', 'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'], ['8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458', '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'], ['13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b', '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'], ['bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366', 'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'], ['8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa', '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'], ['8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0', '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'], ['dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787', '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'], ['f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e', 'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82']] }, naf: { wnd: 7, points: [['f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9', '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'], ['2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4', 'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'], ['5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc', '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'], ['acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe', 'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'], ['774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb', 'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'], ['f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8', 'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'], ['d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e', '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'], ['defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34', '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'], ['2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c', '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'], ['352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5', '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'], ['2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f', '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'], ['9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714', '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'], ['daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729', 'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'], ['c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db', '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'], ['6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4', 'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'], ['1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5', 'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'], ['605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479', '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'], ['62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d', '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'], ['80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f', '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'], ['7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb', 'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'], ['d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9', 'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'], ['49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963', '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'], ['77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74', '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'], ['f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530', 'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'], ['463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b', '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'], ['f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247', 'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'], ['caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1', 'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'], ['2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120', '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'], ['7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435', '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'], ['754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18', '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'], ['e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8', '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'], ['186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb', '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'], ['df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f', '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'], ['5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143', 'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'], ['290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba', 'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'], ['af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45', 'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'], ['766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a', '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'], ['59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e', 'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'], ['f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8', 'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'], ['7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c', '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'], ['948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519', 'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'], ['7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab', '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'], ['3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca', 'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'], ['d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf', '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'], ['1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610', '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'], ['733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4', 'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'], ['15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c', 'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'], ['a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940', 'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'], ['e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980', 'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'], ['311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3', '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'], ['34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf', '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'], ['f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63', '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'], ['d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448', 'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'], ['32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf', '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'], ['7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5', '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'], ['ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6', '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'], ['16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5', '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'], ['eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99', 'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'], ['78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51', 'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'], ['494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5', '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'], ['a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5', '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'], ['c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997', '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'], ['841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881', '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'], ['5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5', '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'], ['36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66', 'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'], ['336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726', 'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'], ['8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede', '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'], ['1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94', '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'], ['85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31', '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'], ['29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51', 'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'], ['a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252', 'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'], ['4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5', 'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'], ['d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b', '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'], ['ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4', '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'], ['af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f', '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'], ['e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889', '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'], ['591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246', 'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'], ['11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984', '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'], ['3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a', 'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'], ['cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030', 'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'], ['c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197', '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'], ['c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593', 'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'], ['a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef', '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'], ['347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38', '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'], ['da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a', '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'], ['c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111', '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'], ['4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502', '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'], ['3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea', 'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'], ['cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26', '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'], ['b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986', '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'], ['d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e', '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'], ['48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4', '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'], ['dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda', 'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'], ['6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859', 'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'], ['e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f', 'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'], ['eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c', '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'], ['13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942', 'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'], ['ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a', '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'], ['b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80', '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'], ['ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d', '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'], ['8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1', 'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'], ['52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63', 'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'], ['e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352', '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'], ['7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193', 'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'], ['5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00', '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'], ['32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58', 'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'], ['e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7', 'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'], ['8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8', 'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'], ['4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e', '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'], ['3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d', 'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'], ['674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b', '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'], ['d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f', 'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'], ['30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6', '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'], ['be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297', '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'], ['93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a', '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'], ['b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c', 'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'], ['d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52', '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'], ['d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb', 'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'], ['463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065', 'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'], ['7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917', '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'], ['74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9', 'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'], ['30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3', '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'], ['9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57', '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'], ['176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66', 'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'], ['75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8', '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'], ['809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721', '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'], ['1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180', '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9']] } } }, 953: (e, t, n) => { 'use strict'; const r = t; const i = n(3550); const o = n(9746); const a = n(4504); r.assert = o, r.toArray = a.toArray, r.zero2 = a.zero2, r.toHex = a.toHex, r.encode = a.encode, r.getNAF = function (e, t, n) { const r = new Array(Math.max(e.bitLength(), n) + 1); r.fill(0); for (let i = 1 << t + 1, o = e.clone(), a = 0; a < r.length; a++) { var s; const c = o.andln(i - 1); o.isOdd() ? (s = c > (i >> 1) - 1 ? (i >> 1) - c : c, o.isubn(s)) : s = 0, r[a] = s, o.iushrn(1) } return r }, r.getJSF = function (e, t) { const n = [[], []]; e = e.clone(), t = t.clone(); for (var r, i = 0, o = 0; e.cmpn(-i) > 0 || t.cmpn(-o) > 0;) { var a; var s; let c = e.andln(3) + i & 3; let u = t.andln(3) + o & 3; c === 3 && (c = -1), u === 3 && (u = -1), a = (1 & c) == 0 ? 0 : (r = e.andln(7) + i & 7) !== 3 && r !== 5 || u !== 2 ? c : -c, n[0].push(a), s = (1 & u) == 0 ? 0 : (r = t.andln(7) + o & 7) !== 3 && r !== 5 || c !== 2 ? u : -u, n[1].push(s), 2 * i === a + 1 && (i = 1 - i), 2 * o === s + 1 && (o = 1 - o), e.iushrn(1), t.iushrn(1) } return n }, r.cachedProperty = function (e, t, n) { const r = '_' + t; e.prototype[t] = function () { return void 0 !== this[r] ? this[r] : this[r] = n.call(this) } }, r.parseBytes = function (e) { return typeof e === 'string' ? r.toArray(e, 'hex') : e }, r.intFromLE = function (e) { return new i(e, 'hex', 'le') } }, 7187: e => { 'use strict'; let t; const n = typeof Reflect === 'object' ? Reflect : null; const r = n && typeof n.apply === 'function' ? n.apply : function (e, t, n) { return Function.prototype.apply.call(e, t, n) }; t = n && typeof n.ownKeys === 'function' ? n.ownKeys : Object.getOwnPropertySymbols ? function (e) { return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)) } : function (e) { return Object.getOwnPropertyNames(e) }; const i = Number.isNaN || function (e) { return e != e }; function o () { o.init.call(this) }e.exports = o, e.exports.once = function (e, t) { return new Promise(function (n, r) { function i (n) { e.removeListener(t, o), r(n) } function o () { typeof e.removeListener === 'function' && e.removeListener('error', i), n([].slice.call(arguments)) }g(e, t, o, { once: !0 }), t !== 'error' && (function (e, t, n) { typeof e.on === 'function' && g(e, 'error', t, n) }(e, i, { once: !0 })) }) }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0; let a = 10; function s (e) { if (typeof e !== 'function') throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e) } function c (e) { return void 0 === e._maxListeners ? o.defaultMaxListeners : e._maxListeners } function u (e, t, n, r) { let i, o, a, u; if (s(n), void 0 === (o = e._events) ? (o = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== o.newListener && (e.emit('newListener', t, n.listener ? n.listener : n), o = e._events), a = o[t]), void 0 === a)a = o[t] = n, ++e._eventsCount; else if (typeof a === 'function' ? a = o[t] = r ? [n, a] : [a, n] : r ? a.unshift(n) : a.push(n), (i = c(e)) > 0 && a.length > i && !a.warned) { a.warned = !0; const l = new Error('Possible EventEmitter memory leak detected. ' + a.length + ' ' + String(t) + ' listeners added. Use emitter.setMaxListeners() to increase limit'); l.name = 'MaxListenersExceededWarning', l.emitter = e, l.type = t, l.count = a.length, u = l, console && console.warn && console.warn(u) } return e } function l () { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments) } function d (e, t, n) { const r = { fired: !1, wrapFn: void 0, target: e, type: t, listener: n }; const i = l.bind(r); return i.listener = n, r.wrapFn = i, i } function f (e, t, n) { const r = e._events; if (void 0 === r) return []; const i = r[t]; return void 0 === i ? [] : typeof i === 'function' ? n ? [i.listener || i] : [i] : n ? (function (e) { for (var t = new Array(e.length), n = 0; n < t.length; ++n)t[n] = e[n].listener || e[n]; return t }(i)) : p(i, i.length) } function h (e) { const t = this._events; if (void 0 !== t) { const n = t[e]; if (typeof n === 'function') return 1; if (void 0 !== n) return n.length } return 0 } function p (e, t) { for (var n = new Array(t), r = 0; r < t; ++r)n[r] = e[r]; return n } function g (e, t, n, r) { if (typeof e.on === 'function')r.once ? e.once(t, n) : e.on(t, n); else { if (typeof e.addEventListener !== 'function') throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e); e.addEventListener(t, function i (o) { r.once && e.removeEventListener(t, i), n(o) }) } }Object.defineProperty(o, 'defaultMaxListeners', { enumerable: !0, get: function () { return a }, set: function (e) { if (typeof e !== 'number' || e < 0 || i(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + '.'); a = e } }), o.init = function () { void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }, o.prototype.setMaxListeners = function (e) { if (typeof e !== 'number' || e < 0 || i(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + '.'); return this._maxListeners = e, this }, o.prototype.getMaxListeners = function () { return c(this) }, o.prototype.emit = function (e) { for (var t = [], n = 1; n < arguments.length; n++)t.push(arguments[n]); let i = e === 'error'; const o = this._events; if (void 0 !== o)i = i && void 0 === o.error; else if (!i) return !1; if (i) { let a; if (t.length > 0 && (a = t[0]), a instanceof Error) throw a; const s = new Error('Unhandled error.' + (a ? ' (' + a.message + ')' : '')); throw s.context = a, s } const c = o[e]; if (void 0 === c) return !1; if (typeof c === 'function')r(c, this, t); else { const u = c.length; const l = p(c, u); for (n = 0; n < u; ++n)r(l[n], this, t) } return !0 }, o.prototype.addListener = function (e, t) { return u(this, e, t, !1) }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function (e, t) { return u(this, e, t, !0) }, o.prototype.once = function (e, t) { return s(t), this.on(e, d(this, e, t)), this }, o.prototype.prependOnceListener = function (e, t) { return s(t), this.prependListener(e, d(this, e, t)), this }, o.prototype.removeListener = function (e, t) { let n, r, i, o, a; if (s(t), void 0 === (r = this._events)) return this; if (void 0 === (n = r[e])) return this; if (n === t || n.listener === t)--this._eventsCount == 0 ? this._events = Object.create(null) : (delete r[e], r.removeListener && this.emit('removeListener', e, n.listener || t)); else if (typeof n !== 'function') { for (i = -1, o = n.length - 1; o >= 0; o--) if (n[o] === t || n[o].listener === t) { a = n[o].listener, i = o; break } if (i < 0) return this; i === 0 ? n.shift() : (function (e, t) { for (;t + 1 < e.length; t++)e[t] = e[t + 1]; e.pop() }(n, i)), n.length === 1 && (r[e] = n[0]), void 0 !== r.removeListener && this.emit('removeListener', e, a || t) } return this }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function (e) { let t, n, r; if (void 0 === (n = this._events)) return this; if (void 0 === n.removeListener) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[e] && (--this._eventsCount == 0 ? this._events = Object.create(null) : delete n[e]), this; if (arguments.length === 0) { let i; const o = Object.keys(n); for (r = 0; r < o.length; ++r)(i = o[r]) !== 'removeListener' && this.removeAllListeners(i); return this.removeAllListeners('removeListener'), this._events = Object.create(null), this._eventsCount = 0, this } if (typeof (t = n[e]) === 'function') this.removeListener(e, t); else if (void 0 !== t) for (r = t.length - 1; r >= 0; r--) this.removeListener(e, t[r]); return this }, o.prototype.listeners = function (e) { return f(this, e, !0) }, o.prototype.rawListeners = function (e) { return f(this, e, !1) }, o.listenerCount = function (e, t) { return typeof e.listenerCount === 'function' ? e.listenerCount(t) : h.call(e, t) }, o.prototype.listenerCount = h, o.prototype.eventNames = function () { return this._eventsCount > 0 ? t(this._events) : [] } }, 3349: (e, t, n) => { 'use strict'; const r = n(9509).Buffer; const i = n(8473).Transform; function o (e) { i.call(this), this._block = r.allocUnsafe(e), this._blockSize = e, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1 }n(5717)(o, i), o.prototype._transform = function (e, t, n) { let r = null; try { this.update(e, t) } catch (e) { r = e }n(r) }, o.prototype._flush = function (e) { let t = null; try { this.push(this.digest()) } catch (e) { t = e }e(t) }, o.prototype.update = function (e, t) { if ((function (e, t) { if (!r.isBuffer(e) && typeof e !== 'string') throw new TypeError(t + ' must be a string or a buffer') }(e, 'Data')), this._finalized) throw new Error('Digest already called'); r.isBuffer(e) || (e = r.from(e, t)); for (var n = this._block, i = 0; this._blockOffset + e.length - i >= this._blockSize;) { for (let o = this._blockOffset; o < this._blockSize;)n[o++] = e[i++]; this._update(), this._blockOffset = 0 } for (;i < e.length;)n[this._blockOffset++] = e[i++]; for (let a = 0, s = 8 * e.length; s > 0; ++a) this._length[a] += s, (s = this._length[a] / 4294967296 | 0) > 0 && (this._length[a] -= 4294967296 * s); return this }, o.prototype._update = function () { throw new Error('_update is not implemented') }, o.prototype.digest = function (e) { if (this._finalized) throw new Error('Digest already called'); this._finalized = !0; let t = this._digest(); void 0 !== e && (t = t.toString(e)), this._block.fill(0), this._blockOffset = 0; for (let n = 0; n < 4; ++n) this._length[n] = 0; return t }, o.prototype._digest = function () { throw new Error('_digest is not implemented') }, e.exports = o }, 3715: (e, t, n) => { const r = t; r.utils = n(6436), r.common = n(5772), r.sha = n(9041), r.ripemd = n(2949), r.hmac = n(2344), r.sha1 = r.sha.sha1, r.sha256 = r.sha.sha256, r.sha224 = r.sha.sha224, r.sha384 = r.sha.sha384, r.sha512 = r.sha.sha512, r.ripemd160 = r.ripemd.ripemd160 }, 5772: (e, t, n) => { 'use strict'; const r = n(6436); const i = n(9746); function o () { this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = 'big', this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32 }t.BlockHash = o, o.prototype.update = function (e, t) { if (e = r.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) { const n = (e = this.pending).length % this._delta8; this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = r.join32(e, 0, e.length - n, this.endian); for (let i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32) } return this }, o.prototype.digest = function (e) { return this.update(this._pad()), i(this.pending === null), this._digest(e) }, o.prototype._pad = function () { let e = this.pendingTotal; const t = this._delta8; const n = t - (e + this.padLength) % t; const r = new Array(n + this.padLength); r[0] = 128; for (var i = 1; i < n; i++)r[i] = 0; if (e <<= 3, this.endian === 'big') { for (var o = 8; o < this.padLength; o++)r[i++] = 0; r[i++] = 0, r[i++] = 0, r[i++] = 0, r[i++] = 0, r[i++] = e >>> 24 & 255, r[i++] = e >>> 16 & 255, r[i++] = e >>> 8 & 255, r[i++] = 255 & e } else for (r[i++] = 255 & e, r[i++] = e >>> 8 & 255, r[i++] = e >>> 16 & 255, r[i++] = e >>> 24 & 255, r[i++] = 0, r[i++] = 0, r[i++] = 0, r[i++] = 0, o = 8; o < this.padLength; o++)r[i++] = 0; return r } }, 2344: (e, t, n) => { 'use strict'; const r = n(6436); const i = n(9746); function o (e, t, n) { if (!(this instanceof o)) return new o(e, t, n); this.Hash = e, this.blockSize = e.blockSize / 8, this.outSize = e.outSize / 8, this.inner = null, this.outer = null, this._init(r.toArray(t, n)) }e.exports = o, o.prototype._init = function (e) { e.length > this.blockSize && (e = (new this.Hash()).update(e).digest()), i(e.length <= this.blockSize); for (var t = e.length; t < this.blockSize; t++)e.push(0); for (t = 0; t < e.length; t++)e[t] ^= 54; for (this.inner = (new this.Hash()).update(e), t = 0; t < e.length; t++)e[t] ^= 106; this.outer = (new this.Hash()).update(e) }, o.prototype.update = function (e, t) { return this.inner.update(e, t), this }, o.prototype.digest = function (e) { return this.outer.update(this.inner.digest()), this.outer.digest(e) } }, 2949: (e, t, n) => { 'use strict'; const r = n(6436); const i = n(5772); const o = r.rotl32; const a = r.sum32; const s = r.sum32_3; const c = r.sum32_4; const u = i.BlockHash; function l () { if (!(this instanceof l)) return new l(); u.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = 'little' } function d (e, t, n, r) { return e <= 15 ? t ^ n ^ r : e <= 31 ? t & n | ~t & r : e <= 47 ? (t | ~n) ^ r : e <= 63 ? t & r | n & ~r : t ^ (n | ~r) } function f (e) { return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838 } function h (e) { return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0 }r.inherits(l, u), t.ripemd160 = l, l.blockSize = 512, l.outSize = 160, l.hmacStrength = 192, l.padLength = 64, l.prototype._update = function (e, t) { for (var n = this.h[0], r = this.h[1], i = this.h[2], u = this.h[3], l = this.h[4], b = n, v = r, w = i, _ = u, E = l, k = 0; k < 80; k++) { var S = a(o(c(n, d(k, r, i, u), e[p[k] + t], f(k)), m[k]), l); n = l, l = u, u = o(i, 10), i = r, r = S, S = a(o(c(b, d(79 - k, v, w, _), e[g[k] + t], h(k)), y[k]), E), b = E, E = _, _ = o(w, 10), w = v, v = S }S = s(this.h[1], i, _), this.h[1] = s(this.h[2], u, E), this.h[2] = s(this.h[3], l, b), this.h[3] = s(this.h[4], n, v), this.h[4] = s(this.h[0], r, w), this.h[0] = S }, l.prototype._digest = function (e) { return e === 'hex' ? r.toHex32(this.h, 'little') : r.split32(this.h, 'little') }; var p = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]; var g = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]; var m = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]; var y = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11] }, 9041: (e, t, n) => { 'use strict'; t.sha1 = n(4761), t.sha224 = n(799), t.sha256 = n(9344), t.sha384 = n(772), t.sha512 = n(5900) }, 4761: (e, t, n) => { 'use strict'; const r = n(6436); const i = n(5772); const o = n(7038); const a = r.rotl32; const s = r.sum32; const c = r.sum32_5; const u = o.ft_1; const l = i.BlockHash; const d = [1518500249, 1859775393, 2400959708, 3395469782]; function f () { if (!(this instanceof f)) return new f(); l.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80) }r.inherits(f, l), e.exports = f, f.blockSize = 512, f.outSize = 160, f.hmacStrength = 80, f.padLength = 64, f.prototype._update = function (e, t) { for (var n = this.W, r = 0; r < 16; r++)n[r] = e[t + r]; for (;r < n.length; r++)n[r] = a(n[r - 3] ^ n[r - 8] ^ n[r - 14] ^ n[r - 16], 1); let i = this.h[0]; let o = this.h[1]; let l = this.h[2]; let f = this.h[3]; let h = this.h[4]; for (r = 0; r < n.length; r++) { const p = ~~(r / 20); const g = c(a(i, 5), u(p, o, l, f), h, n[r], d[p]); h = f, f = l, l = a(o, 30), o = i, i = g } this.h[0] = s(this.h[0], i), this.h[1] = s(this.h[1], o), this.h[2] = s(this.h[2], l), this.h[3] = s(this.h[3], f), this.h[4] = s(this.h[4], h) }, f.prototype._digest = function (e) { return e === 'hex' ? r.toHex32(this.h, 'big') : r.split32(this.h, 'big') } }, 799: (e, t, n) => { 'use strict'; const r = n(6436); const i = n(9344); function o () { if (!(this instanceof o)) return new o(); i.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428] }r.inherits(o, i), e.exports = o, o.blockSize = 512, o.outSize = 224, o.hmacStrength = 192, o.padLength = 64, o.prototype._digest = function (e) { return e === 'hex' ? r.toHex32(this.h.slice(0, 7), 'big') : r.split32(this.h.slice(0, 7), 'big') } }, 9344: (e, t, n) => { 'use strict'; const r = n(6436); const i = n(5772); const o = n(7038); const a = n(9746); const s = r.sum32; const c = r.sum32_4; const u = r.sum32_5; const l = o.ch32; const d = o.maj32; const f = o.s0_256; const h = o.s1_256; const p = o.g0_256; const g = o.g1_256; const m = i.BlockHash; const y = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]; function b () { if (!(this instanceof b)) return new b(); m.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = y, this.W = new Array(64) }r.inherits(b, m), e.exports = b, b.blockSize = 512, b.outSize = 256, b.hmacStrength = 192, b.padLength = 64, b.prototype._update = function (e, t) { for (var n = this.W, r = 0; r < 16; r++)n[r] = e[t + r]; for (;r < n.length; r++)n[r] = c(g(n[r - 2]), n[r - 7], p(n[r - 15]), n[r - 16]); let i = this.h[0]; let o = this.h[1]; let m = this.h[2]; let y = this.h[3]; let b = this.h[4]; let v = this.h[5]; let w = this.h[6]; let _ = this.h[7]; for (a(this.k.length === n.length), r = 0; r < n.length; r++) { const E = u(_, h(b), l(b, v, w), this.k[r], n[r]); const k = s(f(i), d(i, o, m)); _ = w, w = v, v = b, b = s(y, E), y = m, m = o, o = i, i = s(E, k) } this.h[0] = s(this.h[0], i), this.h[1] = s(this.h[1], o), this.h[2] = s(this.h[2], m), this.h[3] = s(this.h[3], y), this.h[4] = s(this.h[4], b), this.h[5] = s(this.h[5], v), this.h[6] = s(this.h[6], w), this.h[7] = s(this.h[7], _) }, b.prototype._digest = function (e) { return e === 'hex' ? r.toHex32(this.h, 'big') : r.split32(this.h, 'big') } }, 772: (e, t, n) => { 'use strict'; const r = n(6436); const i = n(5900); function o () { if (!(this instanceof o)) return new o(); i.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428] }r.inherits(o, i), e.exports = o, o.blockSize = 1024, o.outSize = 384, o.hmacStrength = 192, o.padLength = 128, o.prototype._digest = function (e) { return e === 'hex' ? r.toHex32(this.h.slice(0, 12), 'big') : r.split32(this.h.slice(0, 12), 'big') } }, 5900: (e, t, n) => { 'use strict'; const r = n(6436); const i = n(5772); const o = n(9746); const a = r.rotr64_hi; const s = r.rotr64_lo; const c = r.shr64_hi; const u = r.shr64_lo; const l = r.sum64; const d = r.sum64_hi; const f = r.sum64_lo; const h = r.sum64_4_hi; const p = r.sum64_4_lo; const g = r.sum64_5_hi; const m = r.sum64_5_lo; const y = i.BlockHash; const b = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]; function v () { if (!(this instanceof v)) return new v(); y.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = b, this.W = new Array(160) } function w (e, t, n, r, i) { let o = e & n ^ ~e & i; return o < 0 && (o += 4294967296), o } function _ (e, t, n, r, i, o) { let a = t & r ^ ~t & o; return a < 0 && (a += 4294967296), a } function E (e, t, n, r, i) { let o = e & n ^ e & i ^ n & i; return o < 0 && (o += 4294967296), o } function k (e, t, n, r, i, o) { let a = t & r ^ t & o ^ r & o; return a < 0 && (a += 4294967296), a } function S (e, t) { let n = a(e, t, 28) ^ a(t, e, 2) ^ a(t, e, 7); return n < 0 && (n += 4294967296), n } function A (e, t) { let n = s(e, t, 28) ^ s(t, e, 2) ^ s(t, e, 7); return n < 0 && (n += 4294967296), n } function O (e, t) { let n = a(e, t, 14) ^ a(e, t, 18) ^ a(t, e, 9); return n < 0 && (n += 4294967296), n } function x (e, t) { let n = s(e, t, 14) ^ s(e, t, 18) ^ s(t, e, 9); return n < 0 && (n += 4294967296), n } function I (e, t) { let n = a(e, t, 1) ^ a(e, t, 8) ^ c(e, t, 7); return n < 0 && (n += 4294967296), n } function N (e, t) { let n = s(e, t, 1) ^ s(e, t, 8) ^ u(e, t, 7); return n < 0 && (n += 4294967296), n } function T (e, t) { let n = a(e, t, 19) ^ a(t, e, 29) ^ c(e, t, 6); return n < 0 && (n += 4294967296), n } function R (e, t) { let n = s(e, t, 19) ^ s(t, e, 29) ^ u(e, t, 6); return n < 0 && (n += 4294967296), n }r.inherits(v, y), e.exports = v, v.blockSize = 1024, v.outSize = 512, v.hmacStrength = 192, v.padLength = 128, v.prototype._prepareBlock = function (e, t) { for (var n = this.W, r = 0; r < 32; r++)n[r] = e[t + r]; for (;r < n.length; r += 2) { const i = T(n[r - 4], n[r - 3]); const o = R(n[r - 4], n[r - 3]); const a = n[r - 14]; const s = n[r - 13]; const c = I(n[r - 30], n[r - 29]); const u = N(n[r - 30], n[r - 29]); const l = n[r - 32]; const d = n[r - 31]; n[r] = h(i, o, a, s, c, u, l, d), n[r + 1] = p(i, o, a, s, c, u, l, d) } }, v.prototype._update = function (e, t) { this._prepareBlock(e, t); const n = this.W; let r = this.h[0]; let i = this.h[1]; let a = this.h[2]; let s = this.h[3]; let c = this.h[4]; let u = this.h[5]; let h = this.h[6]; let p = this.h[7]; let y = this.h[8]; let b = this.h[9]; let v = this.h[10]; let I = this.h[11]; let N = this.h[12]; let T = this.h[13]; let R = this.h[14]; let P = this.h[15]; o(this.k.length === n.length); for (let C = 0; C < n.length; C += 2) { let B = R; let L = P; let j = O(y, b); let D = x(y, b); const U = w(y, b, v, I, N); const M = _(y, b, v, I, N, T); const z = this.k[C]; const F = this.k[C + 1]; const H = n[C]; const q = n[C + 1]; const K = g(B, L, j, D, U, M, z, F, H, q); const V = m(B, L, j, D, U, M, z, F, H, q); B = S(r, i), L = A(r, i), j = E(r, i, a, s, c), D = k(r, i, a, s, c, u); const W = d(B, L, j, D); const $ = f(B, L, j, D); R = N, P = T, N = v, T = I, v = y, I = b, y = d(h, p, K, V), b = f(p, p, K, V), h = c, p = u, c = a, u = s, a = r, s = i, r = d(K, V, W, $), i = f(K, V, W, $) }l(this.h, 0, r, i), l(this.h, 2, a, s), l(this.h, 4, c, u), l(this.h, 6, h, p), l(this.h, 8, y, b), l(this.h, 10, v, I), l(this.h, 12, N, T), l(this.h, 14, R, P) }, v.prototype._digest = function (e) { return e === 'hex' ? r.toHex32(this.h, 'big') : r.split32(this.h, 'big') } }, 7038: (e, t, n) => { 'use strict'; const r = n(6436).rotr32; function i (e, t, n) { return e & t ^ ~e & n } function o (e, t, n) { return e & t ^ e & n ^ t & n } function a (e, t, n) { return e ^ t ^ n }t.ft_1 = function (e, t, n, r) { return e === 0 ? i(t, n, r) : e === 1 || e === 3 ? a(t, n, r) : e === 2 ? o(t, n, r) : void 0 }, t.ch32 = i, t.maj32 = o, t.p32 = a, t.s0_256 = function (e) { return r(e, 2) ^ r(e, 13) ^ r(e, 22) }, t.s1_256 = function (e) { return r(e, 6) ^ r(e, 11) ^ r(e, 25) }, t.g0_256 = function (e) { return r(e, 7) ^ r(e, 18) ^ e >>> 3 }, t.g1_256 = function (e) { return r(e, 17) ^ r(e, 19) ^ e >>> 10 } }, 6436: (e, t, n) => { 'use strict'; const r = n(9746); const i = n(5717); function o (e, t) { return (64512 & e.charCodeAt(t)) == 55296 && (!(t < 0 || t + 1 >= e.length) && (64512 & e.charCodeAt(t + 1)) == 56320) } function a (e) { return (e >>> 24 | e >>> 8 & 65280 | e << 8 & 16711680 | (255 & e) << 24) >>> 0 } function s (e) { return e.length === 1 ? '0' + e : e } function c (e) { return e.length === 7 ? '0' + e : e.length === 6 ? '00' + e : e.length === 5 ? '000' + e : e.length === 4 ? '0000' + e : e.length === 3 ? '00000' + e : e.length === 2 ? '000000' + e : e.length === 1 ? '0000000' + e : e }t.inherits = i, t.toArray = function (e, t) { if (Array.isArray(e)) return e.slice(); if (!e) return []; const n = []; if (typeof e === 'string') if (t) { if (t === 'hex') for ((e = e.replace(/[^a-z0-9]+/gi, '')).length % 2 != 0 && (e = '0' + e), i = 0; i < e.length; i += 2)n.push(parseInt(e[i] + e[i + 1], 16)) } else for (var r = 0, i = 0; i < e.length; i++) { let a = e.charCodeAt(i); a < 128 ? n[r++] = a : a < 2048 ? (n[r++] = a >> 6 | 192, n[r++] = 63 & a | 128) : o(e, i) ? (a = 65536 + ((1023 & a) << 10) + (1023 & e.charCodeAt(++i)), n[r++] = a >> 18 | 240, n[r++] = a >> 12 & 63 | 128, n[r++] = a >> 6 & 63 | 128, n[r++] = 63 & a | 128) : (n[r++] = a >> 12 | 224, n[r++] = a >> 6 & 63 | 128, n[r++] = 63 & a | 128) } else for (i = 0; i < e.length; i++)n[i] = 0 | e[i]; return n }, t.toHex = function (e) { for (var t = '', n = 0; n < e.length; n++)t += s(e[n].toString(16)); return t }, t.htonl = a, t.toHex32 = function (e, t) { for (var n = '', r = 0; r < e.length; r++) { let i = e[r]; t === 'little' && (i = a(i)), n += c(i.toString(16)) } return n }, t.zero2 = s, t.zero8 = c, t.join32 = function (e, t, n, i) { const o = n - t; r(o % 4 == 0); for (var a = new Array(o / 4), s = 0, c = t; s < a.length; s++, c += 4) { var u; u = i === 'big' ? e[c] << 24 | e[c + 1] << 16 | e[c + 2] << 8 | e[c + 3] : e[c + 3] << 24 | e[c + 2] << 16 | e[c + 1] << 8 | e[c], a[s] = u >>> 0 } return a }, t.split32 = function (e, t) { for (var n = new Array(4 * e.length), r = 0, i = 0; r < e.length; r++, i += 4) { const o = e[r]; t === 'big' ? (n[i] = o >>> 24, n[i + 1] = o >>> 16 & 255, n[i + 2] = o >>> 8 & 255, n[i + 3] = 255 & o) : (n[i + 3] = o >>> 24, n[i + 2] = o >>> 16 & 255, n[i + 1] = o >>> 8 & 255, n[i] = 255 & o) } return n }, t.rotr32 = function (e, t) { return e >>> t | e << 32 - t }, t.rotl32 = function (e, t) { return e << t | e >>> 32 - t }, t.sum32 = function (e, t) { return e + t >>> 0 }, t.sum32_3 = function (e, t, n) { return e + t + n >>> 0 }, t.sum32_4 = function (e, t, n, r) { return e + t + n + r >>> 0 }, t.sum32_5 = function (e, t, n, r, i) { return e + t + n + r + i >>> 0 }, t.sum64 = function (e, t, n, r) { const i = e[t]; const o = r + e[t + 1] >>> 0; const a = (o < r ? 1 : 0) + n + i; e[t] = a >>> 0, e[t + 1] = o }, t.sum64_hi = function (e, t, n, r) { return (t + r >>> 0 < t ? 1 : 0) + e + n >>> 0 }, t.sum64_lo = function (e, t, n, r) { return t + r >>> 0 }, t.sum64_4_hi = function (e, t, n, r, i, o, a, s) { let c = 0; let u = t; return c += (u = u + r >>> 0) < t ? 1 : 0, c += (u = u + o >>> 0) < o ? 1 : 0, e + n + i + a + (c += (u = u + s >>> 0) < s ? 1 : 0) >>> 0 }, t.sum64_4_lo = function (e, t, n, r, i, o, a, s) { return t + r + o + s >>> 0 }, t.sum64_5_hi = function (e, t, n, r, i, o, a, s, c, u) { let l = 0; let d = t; return l += (d = d + r >>> 0) < t ? 1 : 0, l += (d = d + o >>> 0) < o ? 1 : 0, l += (d = d + s >>> 0) < s ? 1 : 0, e + n + i + a + c + (l += (d = d + u >>> 0) < u ? 1 : 0) >>> 0 }, t.sum64_5_lo = function (e, t, n, r, i, o, a, s, c, u) { return t + r + o + s + u >>> 0 }, t.rotr64_hi = function (e, t, n) { return (t << 32 - n | e >>> n) >>> 0 }, t.rotr64_lo = function (e, t, n) { return (e << 32 - n | t >>> n) >>> 0 }, t.shr64_hi = function (e, t, n) { return e >>> n }, t.shr64_lo = function (e, t, n) { return (e << 32 - n | t >>> n) >>> 0 } }, 2156: (e, t, n) => { 'use strict'; const r = n(3715); const i = n(4504); const o = n(9746); function a (e) { if (!(this instanceof a)) return new a(e); this.hash = e.hash, this.predResist = !!e.predResist, this.outLen = this.hash.outSize, this.minEntropy = e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null; const t = i.toArray(e.entropy, e.entropyEnc || 'hex'); const n = i.toArray(e.nonce, e.nonceEnc || 'hex'); const r = i.toArray(e.pers, e.persEnc || 'hex'); o(t.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'), this._init(t, n, r) }e.exports = a, a.prototype._init = function (e, t, n) { const r = e.concat(t).concat(n); this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8); for (let i = 0; i < this.V.length; i++) this.K[i] = 0, this.V[i] = 1; this._update(r), this._reseed = 1, this.reseedInterval = 281474976710656 }, a.prototype._hmac = function () { return new r.hmac(this.hash, this.K) }, a.prototype._update = function (e) { let t = this._hmac().update(this.V).update([0]); e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest()) }, a.prototype.reseed = function (e, t, n, r) { typeof t !== 'string' && (r = n, n = t, t = null), e = i.toArray(e, t), n = i.toArray(n, r), o(e.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'), this._update(e.concat(n || [])), this._reseed = 1 }, a.prototype.generate = function (e, t, n, r) { if (this._reseed > this.reseedInterval) throw new Error('Reseed is required'); typeof t !== 'string' && (r = n, n = t, t = null), n && (n = i.toArray(n, r || 'hex'), this._update(n)); for (var o = []; o.length < e;) this.V = this._hmac().update(this.V).digest(), o = o.concat(this.V); const a = o.slice(0, e); return this._update(n), this._reseed++, i.encode(a, t) } }, 645: (e, t) => { t.read = function (e, t, n, r, i) { let o; let a; const s = 8 * i - r - 1; const c = (1 << s) - 1; const u = c >> 1; let l = -7; let d = n ? i - 1 : 0; const f = n ? -1 : 1; let h = e[t + d]; for (d += f, o = h & (1 << -l) - 1, h >>= -l, l += s; l > 0; o = 256 * o + e[t + d], d += f, l -= 8);for (a = o & (1 << -l) - 1, o >>= -l, l += r; l > 0; a = 256 * a + e[t + d], d += f, l -= 8);if (o === 0)o = 1 - u; else { if (o === c) return a ? NaN : 1 / 0 * (h ? -1 : 1); a += Math.pow(2, r), o -= u } return (h ? -1 : 1) * a * Math.pow(2, o - r) }, t.write = function (e, t, n, r, i, o) { let a; let s; let c; let u = 8 * o - i - 1; const l = (1 << u) - 1; const d = l >> 1; const f = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0; let h = r ? 0 : o - 1; const p = r ? 1 : -1; const g = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, a = l) : (a = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -a)) < 1 && (a--, c *= 2), (t += a + d >= 1 ? f / c : f * Math.pow(2, 1 - d)) * c >= 2 && (a++, c /= 2), a + d >= l ? (s = 0, a = l) : a + d >= 1 ? (s = (t * c - 1) * Math.pow(2, i), a += d) : (s = t * Math.pow(2, d - 1) * Math.pow(2, i), a = 0)); i >= 8; e[n + h] = 255 & s, h += p, s /= 256, i -= 8);for (a = a << i | s, u += i; u > 0; e[n + h] = 255 & a, h += p, a /= 256, u -= 8);e[n + h - p] |= 128 * g } }, 5717: e => { typeof Object.create === 'function' ? e.exports = function (e, t) { t && (e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })) } : e.exports = function (e, t) { if (t) { e.super_ = t; const n = function () {}; n.prototype = t.prototype, e.prototype = new n(), e.prototype.constructor = e } } }, 2378: (e, t, n) => { e = n.nmd(e); const r = '__lodash_hash_undefined__'; const i = 9007199254740991; const o = '[object Arguments]'; const a = '[object AsyncFunction]'; const s = '[object Function]'; const c = '[object GeneratorFunction]'; const u = '[object Null]'; const l = '[object Object]'; const d = '[object Proxy]'; const f = '[object Undefined]'; const h = /^\[object .+?Constructor\]$/; const p = /^(?:0|[1-9]\d*)$/; const g = {}; g['[object Float32Array]'] = g['[object Float64Array]'] = g['[object Int8Array]'] = g['[object Int16Array]'] = g['[object Int32Array]'] = g['[object Uint8Array]'] = g['[object Uint8ClampedArray]'] = g['[object Uint16Array]'] = g['[object Uint32Array]'] = !0, g[o] = g['[object Array]'] = g['[object ArrayBuffer]'] = g['[object Boolean]'] = g['[object DataView]'] = g['[object Date]'] = g['[object Error]'] = g[s] = g['[object Map]'] = g['[object Number]'] = g[l] = g['[object RegExp]'] = g['[object Set]'] = g['[object String]'] = g['[object WeakMap]'] = !1; const m = typeof n.g === 'object' && n.g && n.g.Object === Object && n.g; const y = typeof self === 'object' && self && self.Object === Object && self; const b = m || y || Function('return this')(); const v = t && !t.nodeType && t; const w = v && e && !e.nodeType && e; const _ = w && w.exports === v; const E = _ && m.process; const k = (function () { try { const e = w && w.require && w.require('util').types; return e || E && E.binding && E.binding('util') } catch (e) {} }()); const S = k && k.isTypedArray; let A; let O; let x; const I = Array.prototype; const N = Function.prototype; const T = Object.prototype; const R = b['__core-js_shared__']; const P = N.toString; const C = T.hasOwnProperty; const B = (A = /[^.]+$/.exec(R && R.keys && R.keys.IE_PROTO || '')) ? 'Symbol(src)_1.' + A : ''; const L = T.toString; const j = P.call(Object); const D = RegExp('^' + P.call(C).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'); const U = _ ? b.Buffer : void 0; const M = b.Symbol; const z = b.Uint8Array; const F = U ? U.allocUnsafe : void 0; const H = (O = Object.getPrototypeOf, x = Object, function (e) { return O(x(e)) }); const q = Object.create; const K = T.propertyIsEnumerable; const V = I.splice; const W = M ? M.toStringTag : void 0; const $ = (function () { try { const e = ve(Object, 'defineProperty'); return e({}, '', {}), e } catch (e) {} }()); const G = U ? U.isBuffer : void 0; const Y = Math.max; const Z = Date.now; const J = ve(b, 'Map'); const X = ve(Object, 'create'); const Q = (function () { function e () {} return function (t) { if (!Re(t)) return {}; if (q) return q(t); e.prototype = t; const n = new e(); return e.prototype = void 0, n } }()); function ee (e) { let t = -1; const n = e == null ? 0 : e.length; for (this.clear(); ++t < n;) { const r = e[t]; this.set(r[0], r[1]) } } function te (e) { let t = -1; const n = e == null ? 0 : e.length; for (this.clear(); ++t < n;) { const r = e[t]; this.set(r[0], r[1]) } } function ne (e) { let t = -1; const n = e == null ? 0 : e.length; for (this.clear(); ++t < n;) { const r = e[t]; this.set(r[0], r[1]) } } function re (e) { const t = this.__data__ = new te(e); this.size = t.size } function ie (e, t) { const n = Oe(e); const r = !n && Ae(e); const i = !n && !r && Ie(e); const o = !n && !r && !i && Ce(e); const a = n || r || i || o; const s = a ? (function (e, t) { for (var n = -1, r = Array(e); ++n < e;)r[n] = t(n); return r }(e.length, String)) : []; const c = s.length; for (const u in e)!t && !C.call(e, u) || a && (u == 'length' || i && (u == 'offset' || u == 'parent') || o && (u == 'buffer' || u == 'byteLength' || u == 'byteOffset') || we(u, c)) || s.push(u); return s } function oe (e, t, n) { (void 0 !== n && !Se(e[t], n) || void 0 === n && !(t in e)) && ce(e, t, n) } function ae (e, t, n) { const r = e[t]; C.call(e, t) && Se(r, n) && (void 0 !== n || t in e) || ce(e, t, n) } function se (e, t) { for (let n = e.length; n--;) if (Se(e[n][0], t)) return n; return -1 } function ce (e, t, n) { t == '__proto__' && $ ? $(e, t, { configurable: !0, enumerable: !0, value: n, writable: !0 }) : e[t] = n }ee.prototype.clear = function () { this.__data__ = X ? X(null) : {}, this.size = 0 }, ee.prototype.delete = function (e) { const t = this.has(e) && delete this.__data__[e]; return this.size -= t ? 1 : 0, t }, ee.prototype.get = function (e) { const t = this.__data__; if (X) { const n = t[e]; return n === r ? void 0 : n } return C.call(t, e) ? t[e] : void 0 }, ee.prototype.has = function (e) { const t = this.__data__; return X ? void 0 !== t[e] : C.call(t, e) }, ee.prototype.set = function (e, t) { const n = this.__data__; return this.size += this.has(e) ? 0 : 1, n[e] = X && void 0 === t ? r : t, this }, te.prototype.clear = function () { this.__data__ = [], this.size = 0 }, te.prototype.delete = function (e) { const t = this.__data__; const n = se(t, e); return !(n < 0) && (n == t.length - 1 ? t.pop() : V.call(t, n, 1), --this.size, !0) }, te.prototype.get = function (e) { const t = this.__data__; const n = se(t, e); return n < 0 ? void 0 : t[n][1] }, te.prototype.has = function (e) { return se(this.__data__, e) > -1 }, te.prototype.set = function (e, t) { const n = this.__data__; const r = se(n, e); return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this }, ne.prototype.clear = function () { this.size = 0, this.__data__ = { hash: new ee(), map: new (J || te)(), string: new ee() } }, ne.prototype.delete = function (e) { const t = be(this, e).delete(e); return this.size -= t ? 1 : 0, t }, ne.prototype.get = function (e) { return be(this, e).get(e) }, ne.prototype.has = function (e) { return be(this, e).has(e) }, ne.prototype.set = function (e, t) { const n = be(this, e); const r = n.size; return n.set(e, t), this.size += n.size == r ? 0 : 1, this }, re.prototype.clear = function () { this.__data__ = new te(), this.size = 0 }, re.prototype.delete = function (e) { const t = this.__data__; const n = t.delete(e); return this.size = t.size, n }, re.prototype.get = function (e) { return this.__data__.get(e) }, re.prototype.has = function (e) { return this.__data__.has(e) }, re.prototype.set = function (e, t) { let n = this.__data__; if (n instanceof te) { const r = n.__data__; if (!J || r.length < 199) return r.push([e, t]), this.size = ++n.size, this; n = this.__data__ = new ne(r) } return n.set(e, t), this.size = n.size, this }; let ue; const le = function (e, t, n) { for (let r = -1, i = Object(e), o = n(e), a = o.length; a--;) { const s = o[ue ? a : ++r]; if (!1 === t(i[s], s, i)) break } return e }; function de (e) { return e == null ? void 0 === e ? f : u : W && W in Object(e) ? (function (e) { const t = C.call(e, W); const n = e[W]; try { e[W] = void 0; var r = !0 } catch (e) {} const i = L.call(e); r && (t ? e[W] = n : delete e[W]); return i }(e)) : (function (e) { return L.call(e) }(e)) } function fe (e) { return Pe(e) && de(e) == o } function he (e) { return !(!Re(e) || (function (e) { return !!B && B in e }(e))) && (Ne(e) ? D : h).test(function (e) { if (e != null) { try { return P.call(e) } catch (e) {} try { return e + '' } catch (e) {} } return '' }(e)) } function pe (e) { if (!Re(e)) return (function (e) { const t = []; if (e != null) for (const n in Object(e))t.push(n); return t }(e)); const t = _e(e); const n = []; for (const r in e)(r != 'constructor' || !t && C.call(e, r)) && n.push(r); return n } function ge (e, t, n, r, i) { e !== t && le(t, function (o, a) { if (i || (i = new re()), Re(o))!(function (e, t, n, r, i, o, a) { const s = Ee(e, n); const c = Ee(t, n); const u = a.get(c); if (u) return void oe(e, n, u); let d = o ? o(s, c, n + '', e, t, a) : void 0; let f = void 0 === d; if (f) { const h = Oe(c); const p = !h && Ie(c); const g = !h && !p && Ce(c); d = c, h || p || g ? Oe(s) ? d = s : Pe(w = s) && xe(w) ? d = (function (e, t) { let n = -1; const r = e.length; t || (t = Array(r)); for (;++n < r;)t[n] = e[n]; return t }(s)) : p ? (f = !1, d = (function (e, t) { if (t) return e.slice(); const n = e.length; const r = F ? F(n) : new e.constructor(n); return e.copy(r), r }(c, !0))) : g ? (f = !1, m = c, y = !0 ? (b = m.buffer, v = new b.constructor(b.byteLength), new z(v).set(new z(b)), v) : m.buffer, d = new m.constructor(y, m.byteOffset, m.length)) : d = [] : (function (e) { if (!Pe(e) || de(e) != l) return !1; const t = H(e); if (t === null) return !0; const n = C.call(t, 'constructor') && t.constructor; return typeof n === 'function' && n instanceof n && P.call(n) == j }(c)) || Ae(c) ? (d = s, Ae(s) ? d = (function (e) { return (function (e, t, n, r) { const i = !n; n || (n = {}); let o = -1; const a = t.length; for (;++o < a;) { const s = t[o]; let c = r ? r(n[s], e[s], s, n, e) : void 0; void 0 === c && (c = e[s]), i ? ce(n, s, c) : ae(n, s, c) } return n }(e, Be(e))) }(s)) : Re(s) && !Ne(s) || (d = (function (e) { return typeof e.constructor !== 'function' || _e(e) ? {} : Q(H(e)) }(c)))) : f = !1 } let m, y, b, v; let w; f && (a.set(c, d), i(d, c, r, o, a), a.delete(c)); oe(e, n, d) }(e, t, a, n, ge, r, i)); else { let s = r ? r(Ee(e, a), o, a + '', e, t, i) : void 0; void 0 === s && (s = o), oe(e, a, s) } }, Be) } function me (e, t) { return ke((function (e, t, n) { return t = Y(void 0 === t ? e.length - 1 : t, 0), function () { for (var r = arguments, i = -1, o = Y(r.length - t, 0), a = Array(o); ++i < o;)a[i] = r[t + i]; i = -1; for (var s = Array(t + 1); ++i < t;)s[i] = r[i]; return s[t] = n(a), (function (e, t, n) { switch (n.length) { case 0:return e.call(t); case 1:return e.call(t, n[0]); case 2:return e.call(t, n[0], n[1]); case 3:return e.call(t, n[0], n[1], n[2]) } return e.apply(t, n) }(e, this, s)) } }(e, t, De)), e + '') } const ye = $ ? function (e, t) { return $(e, 'toString', { configurable: !0, enumerable: !1, value: (n = t, function () { return n }), writable: !0 }); let n } : De; function be (e, t) { let n; let r; const i = e.__data__; return ((r = typeof (n = t)) == 'string' || r == 'number' || r == 'symbol' || r == 'boolean' ? n !== '__proto__' : n === null) ? i[typeof t === 'string' ? 'string' : 'hash'] : i.map } function ve (e, t) { const n = (function (e, t) { return e == null ? void 0 : e[t] }(e, t)); return he(n) ? n : void 0 } function we (e, t) { const n = typeof e; return !!(t = t == null ? i : t) && (n == 'number' || n != 'symbol' && p.test(e)) && e > -1 && e % 1 == 0 && e < t } function _e (e) { const t = e && e.constructor; return e === (typeof t === 'function' && t.prototype || T) } function Ee (e, t) { if ((t !== 'constructor' || typeof e[t] !== 'function') && t != '__proto__') return e[t] } var ke = (function (e) { let t = 0; let n = 0; return function () { const r = Z(); const i = 16 - (r - n); if (n = r, i > 0) { if (++t >= 800) return arguments[0] } else t = 0; return e.apply(void 0, arguments) } }(ye)); function Se (e, t) { return e === t || e != e && t != t } var Ae = fe(function () { return arguments }()) ? fe : function (e) { return Pe(e) && C.call(e, 'callee') && !K.call(e, 'callee') }; var Oe = Array.isArray; function xe (e) { return e != null && Te(e.length) && !Ne(e) } var Ie = G || function () { return !1 }; function Ne (e) { if (!Re(e)) return !1; const t = de(e); return t == s || t == c || t == a || t == d } function Te (e) { return typeof e === 'number' && e > -1 && e % 1 == 0 && e <= i } function Re (e) { const t = typeof e; return e != null && (t == 'object' || t == 'function') } function Pe (e) { return e != null && typeof e === 'object' } var Ce = S ? (function (e) { return function (t) { return e(t) } }(S)) : function (e) { return Pe(e) && Te(e.length) && !!g[de(e)] }; function Be (e) { return xe(e) ? ie(e, !0) : pe(e) } let Le; const je = (Le = function (e, t, n) { ge(e, t, n) }, me(function (e, t) { let n = -1; let r = t.length; let i = r > 1 ? t[r - 1] : void 0; const o = r > 2 ? t[2] : void 0; for (i = Le.length > 3 && typeof i === 'function' ? (r--, i) : void 0, o && (function (e, t, n) { if (!Re(n)) return !1; const r = typeof t; return !!(r == 'number' ? xe(n) && we(t, n.length) : r == 'string' && t in n) && Se(n[t], e) }(t[0], t[1], o)) && (i = r < 3 ? void 0 : i, r = 1), e = Object(e); ++n < r;) { const a = t[n]; a && Le(e, a, n, i) } return e })); function De (e) { return e }e.exports = je }, 5030: (e, t, n) => { const r = 9007199254740991; const i = '[object Arguments]'; const o = '[object Function]'; const a = '[object GeneratorFunction]'; const s = '[object Symbol]'; const c = typeof n.g === 'object' && n.g && n.g.Object === Object && n.g; const u = typeof self === 'object' && self && self.Object === Object && self; const l = c || u || Function('return this')(); function d (e, t) { for (let n = -1, r = t.length, i = e.length; ++n < r;)e[i + n] = t[n]; return e } const f = Object.prototype; const h = f.hasOwnProperty; const p = f.toString; const g = l.Symbol; const m = f.propertyIsEnumerable; const y = g ? g.isConcatSpreadable : void 0; const b = Math.max; function v (e, t, n, r, i) { let o = -1; const a = e.length; for (n || (n = w), i || (i = []); ++o < a;) { const s = e[o]; t > 0 && n(s) ? t > 1 ? v(s, t - 1, n, r, i) : d(i, s) : r || (i[i.length] = s) } return i } function w (e) { return E(e) || (function (e) { return (function (e) { return k(e) && (function (e) { return e != null && (function (e) { return typeof e === 'number' && e > -1 && e % 1 == 0 && e <= r }(e.length)) && !(function (e) { const t = (function (e) { let t = typeof e; return !!e && (t=='object' || 'function' == t) }(e)) ? p.call(e) : ''; return t == o || t == a }(e)) }(e)) }(e)) && h.call(e, 'callee') && (!m.call(e, 'callee') || p.call(e) == i) }(e)) || !!(y && e && e[y]) } function _ (e) { if (typeof e === 'string' || (function (e) { return typeof e === 'symbol' || k(e) && p.call(e) == s }(e))) return e; const t = e + ''; return t == '0' && 1 / e == -Infinity ? '-0' : t } var E = Array.isArray; function k (e) { return !!e && typeof e === 'object' } let S; let A; const O = (S = function (e, t) { return e == null ? {} : (function (e, t) { return (function (e, t, n) { for (var r = -1, i = t.length, o = {}; ++r < i;) { const a = t[r]; const s = e[a]; n(s, a) && (o[a] = s) } return o }(e = Object(e), t, function (t, n) { return n in e })) }(e, (function (e, t) { for (var n = -1, r = e ? e.length : 0, i = Array(r); ++n < r;)i[n] = t(e[n], n, e); return i }(v(t, 1), _)))) }, A = b(void 0 === A ? S.length - 1 : A, 0), function () { for (var e = arguments, t = -1, n = b(e.length - A, 0), r = Array(n); ++t < n;)r[t] = e[A + t]; t = -1; for (var i = Array(A + 1); ++t < A;)i[t] = e[t]; return i[A] = r, (function (e, t, n) { switch (n.length) { case 0:return e.call(t); case 1:return e.call(t, n[0]); case 2:return e.call(t, n[0], n[1]); case 3:return e.call(t, n[0], n[1], n[2]) } return e.apply(t, n) }(S, this, i)) }); e.exports = O }, 7044: (e, t, n) => { const r = 1 / 0; const i = '[object Symbol]'; const o = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g; const a = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g; const s = '\\ud800-\\udfff'; const c = '\\u2700-\\u27bf'; const u = 'a-z\\xdf-\\xf6\\xf8-\\xff'; const l = 'A-Z\\xc0-\\xd6\\xd8-\\xde'; const d = '\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'; const f = "[']"; const h = '[' + d + ']'; const p = '[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]'; const g = '\\d+'; const m = '[' + c + ']'; const y = '[' + u + ']'; const b = '[^' + s + d + g + c + u + l + ']'; const v = '(?:\\ud83c[\\udde6-\\uddff]){2}'; const w = '[\\ud800-\\udbff][\\udc00-\\udfff]'; const _ = '[' + l + ']'; const E = '(?:' + y + '|' + b + ')'; const k = '(?:' + _ + '|' + b + ')'; const S = "(?:['](?:d|ll|m|re|s|t|ve))?"; const A = "(?:['](?:D|LL|M|RE|S|T|VE))?"; const O = '(?:' + p + '|\\ud83c[\\udffb-\\udfff])' + '?'; const x = '[\\ufe0e\\ufe0f]?'; const I = x + O + ('(?:\\u200d(?:' + ['[^' + s + ']', v, w].join('|') + ')' + x + O + ')*'); const N = '(?:' + [m, v, w].join('|') + ')' + I; const T = RegExp(f, 'g'); const R = RegExp(p, 'g'); const P = RegExp([_ + '?' + y + '+' + S + '(?=' + [h, _, '$'].join('|') + ')', k + '+' + A + '(?=' + [h, _ + E, '$'].join('|') + ')', _ + '?' + E + '+' + S, _ + '+' + A, g, N].join('|'), 'g'); const C = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/; const B = typeof n.g === 'object' && n.g && n.g.Object === Object && n.g; const L = typeof self === 'object' && self && self.Object === Object && self; const j = B || L || Function('return this')(); let D; const U = (D = { : 'A', : 'A', : 'A', : 'A', : 'A', : 'A', : 'a', : 'a', : 'a', : 'a', : 'a', : 'a', : 'C', : 'c', : 'D', : 'd', : 'E', : 'E', : 'E', : 'E', : 'e', : 'e', : 'e', : 'e', : 'I', : 'I', : 'I', : 'I', : 'i', : 'i', : 'i', : 'i', : 'N', : 'n', : 'O', : 'O', : 'O', : 'O', : 'O', : 'O', : 'o', : 'o', : 'o', : 'o', : 'o', : 'o', : 'U', : 'U', : 'U', : 'U', : 'u', : 'u', : 'u', : 'u', : 'Y', : 'y', : 'y', : 'Ae', : 'ae', : 'Th', : 'th', : 'ss', : 'A', : 'A', : 'A', : 'a', : 'a', : 'a', : 'C', : 'C', : 'C', : 'C', : 'c', : 'c', : 'c', : 'c', : 'D', : 'D', : 'd', : 'd', : 'E', : 'E', : 'E', : 'E', : 'E', : 'e', : 'e', : 'e', : 'e', : 'e', : 'G', : 'G', : 'G', : 'G', : 'g', : 'g', : 'g', : 'g', : 'H', : 'H', : 'h', : 'h', : 'I', : 'I', : 'I', : 'I', : 'I', : 'i', : 'i', : 'i', : 'i', : 'i', : 'J', : 'j', : 'K', : 'k', : 'k', : 'L', : 'L', : 'L', : 'L', : 'L', : 'l', : 'l', : 'l', : 'l', : 'l', : 'N', : 'N', : 'N', : 'N', : 'n', : 'n', : 'n', : 'n', : 'O', : 'O', : 'O', : 'o', : 'o', : 'o', : 'R', : 'R', : 'R', : 'r', : 'r', : 'r', : 'S', : 'S', : 'S', : 'S', : 's', : 's', : 's', : 's', : 'T', : 'T', : 'T', : 't', : 't', : 't', : 'U', : 'U', : 'U', : 'U', : 'U', : 'U', : 'u', : 'u', : 'u', : 'u', : 'u', : 'u', : 'W', : 'w', : 'Y', : 'y', : 'Y', : 'Z', : 'Z', : 'Z', : 'z', : 'z', : 'z', : 'IJ', : 'ij', : 'Oe', : 'oe', : "'n", : 'ss' }, function (e) { return D == null ? void 0 : D[e] }); const M = Object.prototype.toString; const z = j.Symbol; const F = z ? z.prototype : void 0; const H = F ? F.toString : void 0; function q (e) { if (typeof e === 'string') return e; if (function (e) { return typeof e === 'symbol' || (function (e) { return !!e && typeof e === 'object' }(e)) && M.call(e) == i }(e)) return H ? H.call(e) : ''; const t = e + ''; return t == '0' && 1 / e == -r ? '-0' : t } function K (e) { return e == null ? '' : q(e) } let V; const W = (V = function (e, t, n) { return e + (n ? '_' : '') + t.toLowerCase() }, function (e) { return (function (e, t, n, r) { let i = -1; const o = e ? e.length : 0; for (r && o && (n = e[++i]); ++i < o;)n = t(n, e[i], i, e); return n }((function (e, t, n) { return e = K(e), void 0 === (t = n ? void 0 : t) ? (function (e) { return C.test(e) }(e)) ? (function (e) { return e.match(P) || [] }(e)) : (function (e) { return e.match(o) || [] }(e)) : e.match(t) || [] }((function (e) { return (e = K(e)) && e.replace(a, U).replace(R, '') }(e)).replace(T, ''))), V, '')) }); e.exports = W }, 8552: (e, t, n) => { const r = n(852)(n(5639), 'DataView'); e.exports = r }, 1989: (e, t, n) => { const r = n(1789); const i = n(401); const o = n(7667); const a = n(1327); const s = n(1866); function c (e) { let t = -1; const n = e == null ? 0 : e.length; for (this.clear(); ++t < n;) { const r = e[t]; this.set(r[0], r[1]) } }c.prototype.clear = r, c.prototype.delete = i, c.prototype.get = o, c.prototype.has = a, c.prototype.set = s, e.exports = c }, 8407: (e, t, n) => { const r = n(7040); const i = n(4125); const o = n(2117); const a = n(7518); const s = n(4705); function c (e) { let t = -1; const n = e == null ? 0 : e.length; for (this.clear(); ++t < n;) { const r = e[t]; this.set(r[0], r[1]) } }c.prototype.clear = r, c.prototype.delete = i, c.prototype.get = o, c.prototype.has = a, c.prototype.set = s, e.exports = c }, 7071: (e, t, n) => { const r = n(852)(n(5639), 'Map'); e.exports = r }, 3369: (e, t, n) => { const r = n(4785); const i = n(1285); const o = n(6e3); const a = n(9916); const s = n(5265); function c (e) { let t = -1; const n = e == null ? 0 : e.length; for (this.clear(); ++t < n;) { const r = e[t]; this.set(r[0], r[1]) } }c.prototype.clear = r, c.prototype.delete = i, c.prototype.get = o, c.prototype.has = a, c.prototype.set = s, e.exports = c }, 3818: (e, t, n) => { const r = n(852)(n(5639), 'Promise'); e.exports = r }, 8525: (e, t, n) => { const r = n(852)(n(5639), 'Set'); e.exports = r }, 6384: (e, t, n) => { const r = n(8407); const i = n(7465); const o = n(3779); const a = n(7599); const s = n(4758); const c = n(4309); function u (e) { const t = this.__data__ = new r(e); this.size = t.size }u.prototype.clear = i, u.prototype.delete = o, u.prototype.get = a, u.prototype.has = s, u.prototype.set = c, e.exports = u }, 2705: (e, t, n) => { const r = n(5639).Symbol; e.exports = r }, 1149: (e, t, n) => { const r = n(5639).Uint8Array; e.exports = r }, 577: (e, t, n) => { const r = n(852)(n(5639), 'WeakMap'); e.exports = r }, 7412: e => { e.exports = function (e, t) { for (let n = -1, r = e == null ? 0 : e.length; ++n < r && !1 !== t(e[n], n, e););return e } }, 4963: e => { e.exports = function (e, t) { for (var n = -1, r = e == null ? 0 : e.length, i = 0, o = []; ++n < r;) { const a = e[n]; t(a, n, e) && (o[i++] = a) } return o } }, 4636: (e, t, n) => { const r = n(2545); const i = n(5694); const o = n(1469); const a = n(4144); const s = n(5776); const c = n(6719); const u = Object.prototype.hasOwnProperty; e.exports = function (e, t) { const n = o(e); const l = !n && i(e); const d = !n && !l && a(e); const f = !n && !l && !d && c(e); const h = n || l || d || f; const p = h ? r(e.length, String) : []; const g = p.length; for (const m in e)!t && !u.call(e, m) || h && (m == 'length' || d && (m == 'offset' || m == 'parent') || f && (m == 'buffer' || m == 'byteLength' || m == 'byteOffset') || s(m, g)) || p.push(m); return p } }, 2488: e => { e.exports = function (e, t) { for (let n = -1, r = t.length, i = e.length; ++n < r;)e[i + n] = t[n]; return e } }, 4865: (e, t, n) => { const r = n(9465); const i = n(7813); const o = Object.prototype.hasOwnProperty; e.exports = function (e, t, n) { const a = e[t]; o.call(e, t) && i(a, n) && (void 0 !== n || t in e) || r(e, t, n) } }, 8470: (e, t, n) => { const r = n(7813); e.exports = function (e, t) { for (let n = e.length; n--;) if (r(e[n][0], t)) return n; return -1 } }, 4037: (e, t, n) => { const r = n(8363); const i = n(3674); e.exports = function (e, t) { return e && r(t, i(t), e) } }, 3886: (e, t, n) => { const r = n(8363); const i = n(1704); e.exports = function (e, t) { return e && r(t, i(t), e) } }, 9465: (e, t, n) => { const r = n(8777); e.exports = function (e, t, n) { t == '__proto__' && r ? r(e, t, { configurable: !0, enumerable: !0, value: n, writable: !0 }) : e[t] = n } }, 5990: (e, t, n) => { const r = n(6384); const i = n(7412); const o = n(4865); const a = n(4037); const s = n(3886); const c = n(4626); const u = n(278); const l = n(5341); const d = n(1911); const f = n(8234); const h = n(6904); const p = n(4160); const g = n(3824); const m = n(9148); const y = n(8517); const b = n(1469); const v = n(4144); const w = n(6688); const _ = n(3218); const E = n(2928); const k = n(3674); const S = n(1704); const A = '[object Arguments]'; const O = '[object Function]'; const x = '[object Object]'; const I = {}; I[A] = I['[object Array]'] = I['[object ArrayBuffer]'] = I['[object DataView]'] = I['[object Boolean]'] = I['[object Date]'] = I['[object Float32Array]'] = I['[object Float64Array]'] = I['[object Int8Array]'] = I['[object Int16Array]'] = I['[object Int32Array]'] = I['[object Map]'] = I['[object Number]'] = I[x] = I['[object RegExp]'] = I['[object Set]'] = I['[object String]'] = I['[object Symbol]'] = I['[object Uint8Array]'] = I['[object Uint8ClampedArray]'] = I['[object Uint16Array]'] = I['[object Uint32Array]'] = !0, I['[object Error]'] = I[O] = I['[object WeakMap]'] = !1, e.exports = function e (t, n, N, T, R, P) { let C; const B = 1 & n; const L = 2 & n; const j = 4 & n; if (N && (C = R ? N(t, T, R, P) : N(t)), void 0 !== C) return C; if (!_(t)) return t; const D = b(t); if (D) { if (C = g(t), !B) return u(t, C) } else { const U = p(t); const M = U == O || U == '[object GeneratorFunction]'; if (v(t)) return c(t, B); if (U == x || U == A || M && !R) { if (C = L || M ? {} : y(t), !B) return L ? d(t, s(C, t)) : l(t, a(C, t)) } else { if (!I[U]) return R ? t : {}; C = m(t, U, B) } }P || (P = new r()); const z = P.get(t); if (z) return z; P.set(t, C), E(t) ? t.forEach(function (r) { C.add(e(r, n, N, r, t, P)) }) : w(t) && t.forEach(function (r, i) { C.set(i, e(r, n, N, i, t, P)) }); const F = D ? void 0 : (j ? L ? h : f : L ? S : k)(t); return i(F || t, function (r, i) { F && (r = t[i = r]), o(C, i, e(r, n, N, i, t, P)) }), C } }, 3118: (e, t, n) => { const r = n(3218); const i = Object.create; const o = (function () { function e () {} return function (t) { if (!r(t)) return {}; if (i) return i(t); e.prototype = t; const n = new e(); return e.prototype = void 0, n } }()); e.exports = o }, 8866: (e, t, n) => { const r = n(2488); const i = n(1469); e.exports = function (e, t, n) { const o = t(e); return i(e) ? o : r(o, n(e)) } }, 4239: (e, t, n) => { const r = n(2705); const i = n(9607); const o = n(2333); const a = r ? r.toStringTag : void 0; e.exports = function (e) { return e == null ? void 0 === e ? '[object Undefined]' : '[object Null]' : a && a in Object(e) ? i(e) : o(e) } }, 9454: (e, t, n) => { const r = n(4239); const i = n(7005); e.exports = function (e) { return i(e) && r(e) == '[object Arguments]' } }, 5588: (e, t, n) => { const r = n(4160); const i = n(7005); e.exports = function (e) { return i(e) && r(e) == '[object Map]' } }, 8458: (e, t, n) => { const r = n(3560); const i = n(5346); const o = n(3218); const a = n(346); const s = /^\[object .+?Constructor\]$/; const c = Function.prototype; const u = Object.prototype; const l = c.toString; const d = u.hasOwnProperty; const f = RegExp('^' + l.call(d).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'); e.exports = function (e) { return !(!o(e) || i(e)) && (r(e) ? f : s).test(a(e)) } }, 9221: (e, t, n) => { const r = n(4160); const i = n(7005); e.exports = function (e) { return i(e) && r(e) == '[object Set]' } }, 8749: (e, t, n) => { const r = n(4239); const i = n(1780); const o = n(7005); const a = {}; a['[object Float32Array]'] = a['[object Float64Array]'] = a['[object Int8Array]'] = a['[object Int16Array]'] = a['[object Int32Array]'] = a['[object Uint8Array]'] = a['[object Uint8ClampedArray]'] = a['[object Uint16Array]'] = a['[object Uint32Array]'] = !0, a['[object Arguments]'] = a['[object Array]'] = a['[object ArrayBuffer]'] = a['[object Boolean]'] = a['[object DataView]'] = a['[object Date]'] = a['[object Error]'] = a['[object Function]'] = a['[object Map]'] = a['[object Number]'] = a['[object Object]'] = a['[object RegExp]'] = a['[object Set]'] = a['[object String]'] = a['[object WeakMap]'] = !1, e.exports = function (e) { return o(e) && i(e.length) && !!a[r(e)] } }, 280: (e, t, n) => { const r = n(5726); const i = n(6916); const o = Object.prototype.hasOwnProperty; e.exports = function (e) { if (!r(e)) return i(e); const t = []; for (const n in Object(e))o.call(e, n) && n != 'constructor' && t.push(n); return t } }, 313: (e, t, n) => { const r = n(3218); const i = n(5726); const o = n(3498); const a = Object.prototype.hasOwnProperty; e.exports = function (e) { if (!r(e)) return o(e); const t = i(e); const n = []; for (const s in e)(s != 'constructor' || !t && a.call(e, s)) && n.push(s); return n } }, 2545: e => { e.exports = function (e, t) { for (var n = -1, r = Array(e); ++n < e;)r[n] = t(n); return r } }, 1717: e => { e.exports = function (e) { return function (t) { return e(t) } } }, 4318: (e, t, n) => { const r = n(1149); e.exports = function (e) { const t = new e.constructor(e.byteLength); return new r(t).set(new r(e)), t } }, 4626: (e, t, n) => { e = n.nmd(e); const r = n(5639); const i = t && !t.nodeType && t; const o = i && e && !e.nodeType && e; const a = o && o.exports === i ? r.Buffer : void 0; const s = a ? a.allocUnsafe : void 0; e.exports = function (e, t) { if (t) return e.slice(); const n = e.length; const r = s ? s(n) : new e.constructor(n); return e.copy(r), r } }, 7157: (e, t, n) => { const r = n(4318); e.exports = function (e, t) { const n = t ? r(e.buffer) : e.buffer; return new e.constructor(n, e.byteOffset, e.byteLength) } }, 3147: e => { const t = /\w*$/; e.exports = function (e) { const n = new e.constructor(e.source, t.exec(e)); return n.lastIndex = e.lastIndex, n } }, 419: (e, t, n) => { const r = n(2705); const i = r ? r.prototype : void 0; const o = i ? i.valueOf : void 0; e.exports = function (e) { return o ? Object(o.call(e)) : {} } }, 7133: (e, t, n) => { const r = n(4318); e.exports = function (e, t) { const n = t ? r(e.buffer) : e.buffer; return new e.constructor(n, e.byteOffset, e.length) } }, 278: e => { e.exports = function (e, t) { let n = -1; const r = e.length; for (t || (t = Array(r)); ++n < r;)t[n] = e[n]; return t } }, 8363: (e, t, n) => { const r = n(4865); const i = n(9465); e.exports = function (e, t, n, o) { const a = !n; n || (n = {}); for (let s = -1, c = t.length; ++s < c;) { const u = t[s]; let l = o ? o(n[u], e[u], u, n, e) : void 0; void 0 === l && (l = e[u]), a ? i(n, u, l) : r(n, u, l) } return n } }, 5341: (e, t, n) => { const r = n(8363); const i = n(9551); e.exports = function (e, t) { return r(e, i(e), t) } }, 1911: (e, t, n) => { const r = n(8363); const i = n(1442); e.exports = function (e, t) { return r(e, i(e), t) } }, 4429: (e, t, n) => { const r = n(5639)['__core-js_shared__']; e.exports = r }, 8777: (e, t, n) => { const r = n(852); const i = (function () { try { const e = r(Object, 'defineProperty'); return e({}, '', {}), e } catch (e) {} }()); e.exports = i }, 1957: (e, t, n) => { const r = typeof n.g === 'object' && n.g && n.g.Object === Object && n.g; e.exports = r }, 8234: (e, t, n) => { const r = n(8866); const i = n(9551); const o = n(3674); e.exports = function (e) { return r(e, o, i) } }, 6904: (e, t, n) => { const r = n(8866); const i = n(1442); const o = n(1704); e.exports = function (e) { return r(e, o, i) } }, 5050: (e, t, n) => { const r = n(7019); e.exports = function (e, t) { const n = e.__data__; return r(t) ? n[typeof t === 'string' ? 'string' : 'hash'] : n.map } }, 852: (e, t, n) => { const r = n(8458); const i = n(7801); e.exports = function (e, t) { const n = i(e, t); return r(n) ? n : void 0 } }, 5924: (e, t, n) => { const r = n(5569)(Object.getPrototypeOf, Object); e.exports = r }, 9607: (e, t, n) => { const r = n(2705); const i = Object.prototype; const o = i.hasOwnProperty; const a = i.toString; const s = r ? r.toStringTag : void 0; e.exports = function (e) { const t = o.call(e, s); const n = e[s]; try { e[s] = void 0; var r = !0 } catch (e) {} const i = a.call(e); return r && (t ? e[s] = n : delete e[s]), i } }, 9551: (e, t, n) => { const r = n(4963); const i = n(479); const o = Object.prototype.propertyIsEnumerable; const a = Object.getOwnPropertySymbols; const s = a ? function (e) { return e == null ? [] : (e = Object(e), r(a(e), function (t) { return o.call(e, t) })) } : i; e.exports = s }, 1442: (e, t, n) => { const r = n(2488); const i = n(5924); const o = n(9551); const a = n(479); const s = Object.getOwnPropertySymbols ? function (e) { for (var t = []; e;)r(t, o(e)), e = i(e); return t } : a; e.exports = s }, 4160: (e, t, n) => { const r = n(8552); const i = n(7071); const o = n(3818); const a = n(8525); const s = n(577); const c = n(4239); const u = n(346); const l = '[object Map]'; const d = '[object Promise]'; const f = '[object Set]'; const h = '[object WeakMap]'; const p = '[object DataView]'; const g = u(r); const m = u(i); const y = u(o); const b = u(a); const v = u(s); let w = c; (r && w(new r(new ArrayBuffer(1))) != p || i && w(new i()) != l || o && w(o.resolve()) != d || a && w(new a()) != f || s && w(new s()) != h) && (w = function (e) { const t = c(e); const n = t == '[object Object]' ? e.constructor : void 0; const r = n ? u(n) : ''; if (r) switch (r) { case g:return p; case m:return l; case y:return d; case b:return f; case v:return h } return t }), e.exports = w }, 7801: e => { e.exports = function (e, t) { return e == null ? void 0 : e[t] } }, 1789: (e, t, n) => { const r = n(4536); e.exports = function () { this.__data__ = r ? r(null) : {}, this.size = 0 } }, 401: e => { e.exports = function (e) { const t = this.has(e) && delete this.__data__[e]; return this.size -= t ? 1 : 0, t } }, 7667: (e, t, n) => { const r = n(4536); const i = Object.prototype.hasOwnProperty; e.exports = function (e) { const t = this.__data__; if (r) { const n = t[e]; return n === '__lodash_hash_undefined__' ? void 0 : n } return i.call(t, e) ? t[e] : void 0 } }, 1327: (e, t, n) => { const r = n(4536); const i = Object.prototype.hasOwnProperty; e.exports = function (e) { const t = this.__data__; return r ? void 0 !== t[e] : i.call(t, e) } }, 1866: (e, t, n) => { const r = n(4536); e.exports = function (e, t) { const n = this.__data__; return this.size += this.has(e) ? 0 : 1, n[e] = r && void 0 === t ? '__lodash_hash_undefined__' : t, this } }, 3824: e => { const t = Object.prototype.hasOwnProperty; e.exports = function (e) { const n = e.length; const r = new e.constructor(n); return n && typeof e[0] === 'string' && t.call(e, 'index') && (r.index = e.index, r.input = e.input), r } }, 9148: (e, t, n) => { const r = n(4318); const i = n(7157); const o = n(3147); const a = n(419); const s = n(7133); e.exports = function (e, t, n) { const c = e.constructor; switch (t) { case '[object ArrayBuffer]':return r(e); case '[object Boolean]':case '[object Date]':return new c(+e); case '[object DataView]':return i(e, n); case '[object Float32Array]':case '[object Float64Array]':case '[object Int8Array]':case '[object Int16Array]':case '[object Int32Array]':case '[object Uint8Array]':case '[object Uint8ClampedArray]':case '[object Uint16Array]':case '[object Uint32Array]':return s(e, n); case '[object Map]':case '[object Set]':return new c(); case '[object Number]':case '[object String]':return new c(e); case '[object RegExp]':return o(e); case '[object Symbol]':return a(e) } } }, 8517: (e, t, n) => { const r = n(3118); const i = n(5924); const o = n(5726); e.exports = function (e) { return typeof e.constructor !== 'function' || o(e) ? {} : r(i(e)) } }, 5776: e => { const t = /^(?:0|[1-9]\d*)$/; e.exports = function (e, n) { const r = typeof e; return !!(n = n == null ? 9007199254740991 : n) && (r == 'number' || r != 'symbol' && t.test(e)) && e > -1 && e % 1 == 0 && e < n } }, 7019: e => { e.exports = function (e) { const t = typeof e; return t == 'string' || t == 'number' || t == 'symbol' || t == 'boolean' ? e !== '__proto__' : e === null } }, 5346: (e, t, n) => { let r; const i = n(4429); const o = (r = /[^.]+$/.exec(i && i.keys && i.keys.IE_PROTO || '')) ? 'Symbol(src)_1.' + r : ''; e.exports = function (e) { return !!o && o in e } }, 5726: e => { const t = Object.prototype; e.exports = function (e) { const n = e && e.constructor; return e === (typeof n === 'function' && n.prototype || t) } }, 7040: e => { e.exports = function () { this.__data__ = [], this.size = 0 } }, 4125: (e, t, n) => { const r = n(8470); const i = Array.prototype.splice; e.exports = function (e) { const t = this.__data__; const n = r(t, e); return !(n < 0) && (n == t.length - 1 ? t.pop() : i.call(t, n, 1), --this.size, !0) } }, 2117: (e, t, n) => { const r = n(8470); e.exports = function (e) { const t = this.__data__; const n = r(t, e); return n < 0 ? void 0 : t[n][1] } }, 7518: (e, t, n) => { const r = n(8470); e.exports = function (e) { return r(this.__data__, e) > -1 } }, 4705: (e, t, n) => { const r = n(8470); e.exports = function (e, t) { const n = this.__data__; const i = r(n, e); return i < 0 ? (++this.size, n.push([e, t])) : n[i][1] = t, this } }, 4785: (e, t, n) => { const r = n(1989); const i = n(8407); const o = n(7071); e.exports = function () { this.size = 0, this.__data__ = { hash: new r(), map: new (o || i)(), string: new r() } } }, 1285: (e, t, n) => { const r = n(5050); e.exports = function (e) { const t = r(this, e).delete(e); return this.size -= t ? 1 : 0, t } }, 6e3: (e, t, n) => { const r = n(5050); e.exports = function (e) { return r(this, e).get(e) } }, 9916: (e, t, n) => { const r = n(5050); e.exports = function (e) { return r(this, e).has(e) } }, 5265: (e, t, n) => { const r = n(5050); e.exports = function (e, t) { const n = r(this, e); const i = n.size; return n.set(e, t), this.size += n.size == i ? 0 : 1, this } }, 4536: (e, t, n) => { const r = n(852)(Object, 'create'); e.exports = r }, 6916: (e, t, n) => { const r = n(5569)(Object.keys, Object); e.exports = r }, 3498: e => { e.exports = function (e) { const t = []; if (e != null) for (const n in Object(e))t.push(n); return t } }, 1167: (e, t, n) => { e = n.nmd(e); const r = n(1957); const i = t && !t.nodeType && t; const o = i && e && !e.nodeType && e; const a = o && o.exports === i && r.process; const s = (function () { try { const e = o && o.require && o.require('util').types; return e || a && a.binding && a.binding('util') } catch (e) {} }()); e.exports = s }, 2333: e => { const t = Object.prototype.toString; e.exports = function (e) { return t.call(e) } }, 5569: e => { e.exports = function (e, t) { return function (n) { return e(t(n)) } } }, 5639: (e, t, n) => { const r = n(1957); const i = typeof self === 'object' && self && self.Object === Object && self; const o = r || i || Function('return this')(); e.exports = o }, 7465: (e, t, n) => { const r = n(8407); e.exports = function () { this.__data__ = new r(), this.size = 0 } }, 3779: e => { e.exports = function (e) { const t = this.__data__; const n = t.delete(e); return this.size = t.size, n } }, 7599: e => { e.exports = function (e) { return this.__data__.get(e) } }, 4758: e => { e.exports = function (e) { return this.__data__.has(e) } }, 4309: (e, t, n) => { const r = n(8407); const i = n(7071); const o = n(3369); e.exports = function (e, t) { let n = this.__data__; if (n instanceof r) { const a = n.__data__; if (!i || a.length < 199) return a.push([e, t]), this.size = ++n.size, this; n = this.__data__ = new o(a) } return n.set(e, t), this.size = n.size, this } }, 346: e => { const t = Function.prototype.toString; e.exports = function (e) { if (e != null) { try { return t.call(e) } catch (e) {} try { return e + '' } catch (e) {} } return '' } }, 361: (e, t, n) => { const r = n(5990); e.exports = function (e) { return r(e, 5) } }, 7813: e => { e.exports = function (e, t) { return e === t || e != e && t != t } }, 5694: (e, t, n) => { const r = n(9454); const i = n(7005); const o = Object.prototype; const a = o.hasOwnProperty; const s = o.propertyIsEnumerable; const c = r(function () { return arguments }()) ? r : function (e) { return i(e) && a.call(e, 'callee') && !s.call(e, 'callee') }; e.exports = c }, 1469: e => { const t = Array.isArray; e.exports = t }, 8612: (e, t, n) => { const r = n(3560); const i = n(1780); e.exports = function (e) { return e != null && i(e.length) && !r(e) } }, 4144: (e, t, n) => { e = n.nmd(e); const r = n(5639); const i = n(5062); const o = t && !t.nodeType && t; const a = o && e && !e.nodeType && e; const s = a && a.exports === o ? r.Buffer : void 0; const c = (s ? s.isBuffer : void 0) || i; e.exports = c }, 3560: (e, t, n) => { const r = n(4239); const i = n(3218); e.exports = function (e) { if (!i(e)) return !1; const t = r(e); return t == '[object Function]' || t == '[object GeneratorFunction]' || t == '[object AsyncFunction]' || t == '[object Proxy]' } }, 1780: e => { e.exports = function (e) { return typeof e === 'number' && e > -1 && e % 1 == 0 && e <= 9007199254740991 } }, 6688: (e, t, n) => { const r = n(5588); const i = n(1717); const o = n(1167); const a = o && o.isMap; const s = a ? i(a) : r; e.exports = s }, 3218: e => { e.exports = function (e) { const t = typeof e; return e != null && (t == 'object' || t == 'function') } }, 7005: e => { e.exports = function (e) { return e != null && typeof e === 'object' } }, 2928: (e, t, n) => { const r = n(9221); const i = n(1717); const o = n(1167); const a = o && o.isSet; const s = a ? i(a) : r; e.exports = s }, 6719: (e, t, n) => { const r = n(8749); const i = n(1717); const o = n(1167); const a = o && o.isTypedArray; const s = a ? i(a) : r; e.exports = s }, 3674: (e, t, n) => { const r = n(4636); const i = n(280); const o = n(8612); e.exports = function (e) { return o(e) ? r(e) : i(e) } }, 1704: (e, t, n) => { const r = n(4636); const i = n(313); const o = n(8612); e.exports = function (e) { return o(e) ? r(e, !0) : i(e) } }, 479: e => { e.exports = function () { return [] } }, 5062: e => { e.exports = function () { return !1 } }, 2318: (e, t, n) => { 'use strict'; const r = n(5717); const i = n(3349); const o = n(9509).Buffer; const a = new Array(16); function s () { i.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878 } function c (e, t) { return e << t | e >>> 32 - t } function u (e, t, n, r, i, o, a) { return c(e + (t & n | ~t & r) + i + o | 0, a) + t | 0 } function l (e, t, n, r, i, o, a) { return c(e + (t & r | n & ~r) + i + o | 0, a) + t | 0 } function d (e, t, n, r, i, o, a) { return c(e + (t ^ n ^ r) + i + o | 0, a) + t | 0 } function f (e, t, n, r, i, o, a) { return c(e + (n ^ (t | ~r)) + i + o | 0, a) + t | 0 }r(s, i), s.prototype._update = function () { for (var e = a, t = 0; t < 16; ++t)e[t] = this._block.readInt32LE(4 * t); let n = this._a; let r = this._b; let i = this._c; let o = this._d; n = u(n, r, i, o, e[0], 3614090360, 7), o = u(o, n, r, i, e[1], 3905402710, 12), i = u(i, o, n, r, e[2], 606105819, 17), r = u(r, i, o, n, e[3], 3250441966, 22), n = u(n, r, i, o, e[4], 4118548399, 7), o = u(o, n, r, i, e[5], 1200080426, 12), i = u(i, o, n, r, e[6], 2821735955, 17), r = u(r, i, o, n, e[7], 4249261313, 22), n = u(n, r, i, o, e[8], 1770035416, 7), o = u(o, n, r, i, e[9], 2336552879, 12), i = u(i, o, n, r, e[10], 4294925233, 17), r = u(r, i, o, n, e[11], 2304563134, 22), n = u(n, r, i, o, e[12], 1804603682, 7), o = u(o, n, r, i, e[13], 4254626195, 12), i = u(i, o, n, r, e[14], 2792965006, 17), n = l(n, r = u(r, i, o, n, e[15], 1236535329, 22), i, o, e[1], 4129170786, 5), o = l(o, n, r, i, e[6], 3225465664, 9), i = l(i, o, n, r, e[11], 643717713, 14), r = l(r, i, o, n, e[0], 3921069994, 20), n = l(n, r, i, o, e[5], 3593408605, 5), o = l(o, n, r, i, e[10], 38016083, 9), i = l(i, o, n, r, e[15], 3634488961, 14), r = l(r, i, o, n, e[4], 3889429448, 20), n = l(n, r, i, o, e[9], 568446438, 5), o = l(o, n, r, i, e[14], 3275163606, 9), i = l(i, o, n, r, e[3], 4107603335, 14), r = l(r, i, o, n, e[8], 1163531501, 20), n = l(n, r, i, o, e[13], 2850285829, 5), o = l(o, n, r, i, e[2], 4243563512, 9), i = l(i, o, n, r, e[7], 1735328473, 14), n = d(n, r = l(r, i, o, n, e[12], 2368359562, 20), i, o, e[5], 4294588738, 4), o = d(o, n, r, i, e[8], 2272392833, 11), i = d(i, o, n, r, e[11], 1839030562, 16), r = d(r, i, o, n, e[14], 4259657740, 23), n = d(n, r, i, o, e[1], 2763975236, 4), o = d(o, n, r, i, e[4], 1272893353, 11), i = d(i, o, n, r, e[7], 4139469664, 16), r = d(r, i, o, n, e[10], 3200236656, 23), n = d(n, r, i, o, e[13], 681279174, 4), o = d(o, n, r, i, e[0], 3936430074, 11), i = d(i, o, n, r, e[3], 3572445317, 16), r = d(r, i, o, n, e[6], 76029189, 23), n = d(n, r, i, o, e[9], 3654602809, 4), o = d(o, n, r, i, e[12], 3873151461, 11), i = d(i, o, n, r, e[15], 530742520, 16), n = f(n, r = d(r, i, o, n, e[2], 3299628645, 23), i, o, e[0], 4096336452, 6), o = f(o, n, r, i, e[7], 1126891415, 10), i = f(i, o, n, r, e[14], 2878612391, 15), r = f(r, i, o, n, e[5], 4237533241, 21), n = f(n, r, i, o, e[12], 1700485571, 6), o = f(o, n, r, i, e[3], 2399980690, 10), i = f(i, o, n, r, e[10], 4293915773, 15), r = f(r, i, o, n, e[1], 2240044497, 21), n = f(n, r, i, o, e[8], 1873313359, 6), o = f(o, n, r, i, e[15], 4264355552, 10), i = f(i, o, n, r, e[6], 2734768916, 15), r = f(r, i, o, n, e[13], 1309151649, 21), n = f(n, r, i, o, e[4], 4149444226, 6), o = f(o, n, r, i, e[11], 3174756917, 10), i = f(i, o, n, r, e[2], 718787259, 15), r = f(r, i, o, n, e[9], 3951481745, 21), this._a = this._a + n | 0, this._b = this._b + r | 0, this._c = this._c + i | 0, this._d = this._d + o | 0 }, s.prototype._digest = function () { this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update(); const e = o.allocUnsafe(16); return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e }, e.exports = s }, 9746: e => { function t (e, t) { if (!e) throw new Error(t || 'Assertion failed') }e.exports = t, t.equal = function (e, t, n) { if (e != t) throw new Error(n || 'Assertion failed: ' + e + ' != ' + t) } }, 4504: (e, t) => { 'use strict'; const n = t; function r (e) { return e.length === 1 ? '0' + e : e } function i (e) { for (var t = '', n = 0; n < e.length; n++)t += r(e[n].toString(16)); return t }n.toArray = function (e, t) { if (Array.isArray(e)) return e.slice(); if (!e) return []; const n = []; if (typeof e !== 'string') { for (var r = 0; r < e.length; r++)n[r] = 0 | e[r]; return n } if (t === 'hex') { (e = e.replace(/[^a-z0-9]+/gi, '')).length % 2 != 0 && (e = '0' + e); for (r = 0; r < e.length; r += 2)n.push(parseInt(e[r] + e[r + 1], 16)) } else for (r = 0; r < e.length; r++) { const i = e.charCodeAt(r); const o = i >> 8; const a = 255 & i; o ? n.push(o, a) : n.push(a) } return n }, n.zero2 = r, n.toHex = i, n.encode = function (e, t) { return t === 'hex' ? i(e) : e } }, 5435: (e, t, n) => { 'use strict'; t.Z1 = t._I = t.OF = void 0; const r = n(6642); const i = n(5194); const o = n(7035); const a = n(8558); const s = n(6462); const c = n(9187); const u = e => e[0] === ''; function l (e) { if (typeof e !== 'string') throw new TypeError('Invalid mnemonic type: ' + typeof e); return e.normalize('NFKD') } function d (e) { const t = l(e); const n = t.split(' '); if (![12, 15, 18, 21, 24].includes(n.length)) throw new Error('Invalid mnemonic'); return { nfkd: t, words: n } } function f (e) { r.default.bytes(e, 16, 20, 24, 28, 32) }t.OF = function (e, t = 128) { if (r.default.number(t), t % 32 != 0 || t > 256) throw new TypeError('Invalid entropy'); return m((0, s.randomBytes)(t / 8), e) }; const h = e => { const t = 8 - e.length / 4; return new Uint8Array([(0, o.sha256)(e)[0] >> t << t]) }; function p (e) { if (!Array.isArray(e) || e.length !== 2048 || typeof e[0] !== 'string') throw new Error('Worlist: expected array of 2048 strings'); return e.forEach(e => { if (typeof e !== 'string') throw new Error(`Wordlist: non-string element: ${e}`) }), c.utils.chain(c.utils.checksum(1, h), c.utils.radix2(11, !0), c.utils.alphabet(e)) } function g (e, t) { const { words: n } = d(e); const r = p(t).decode(n); return f(r), r } function m (e, t) { f(e); return p(t).encode(e).join(u(t) ? '' : ' ') }t._I = function (e, t) { try { g(e, t) } catch (e) { return !1 } return !0 }; const y = e => l(`mnemonic${e}`); t.Z1 = function (e, t = '') { return (0, i.pbkdf2)(a.sha512, d(e).nfkd, y(t), { c: 2048, dkLen: 64 }) } }, 6642: (e, t) => { 'use strict'; function n (e) { if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`) } function r (e) { if (typeof e !== 'boolean') throw new Error(`Expected boolean, not ${e}`) } function i (e, ...t) { if (!(e instanceof Uint8Array)) throw new Error('Expected Uint8Array'); if (t.length > 0 && !t.includes(e.length)) throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`) } function o (e) { if (typeof e !== 'function' || typeof e.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor'); n(e.outputLen), n(e.blockLen) } function a (e, t = !0) { if (e.destroyed) throw new Error('Hash instance has been destroyed'); if (t && e.finished) throw new Error('Hash#digest() has already been called') } function s (e, t) { i(e); const n = t.outputLen; if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`) }Object.defineProperty(t, '__esModule', { value: !0 }), t.output = t.exists = t.hash = t.bytes = t.bool = t.number = void 0, t.number = n, t.bool = r, t.bytes = i, t.hash = o, t.exists = a, t.output = s; const c = { number: n, bool: r, bytes: i, hash: o, exists: a, output: s }; t.default = c }, 6919: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.SHA2 = void 0; const r = n(6642); const i = n(6462); class o extends i.Hash {constructor (e, t, n, r) { super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, i.createView)(this.buffer) }update (e) { r.default.exists(this); const { view: t, buffer: n, blockLen: o } = this; const a = (e = (0, i.toBytes)(e)).length; for (let r = 0; r < a;) { const s = Math.min(o - this.pos, a - r); if (s !== o)n.set(e.subarray(r, r + s), this.pos), this.pos += s, r += s, this.pos === o && (this.process(t, 0), this.pos = 0); else { const t = (0, i.createView)(e); for (;o <= a - r; r += o) this.process(t, r) } } return this.length += e.length, this.roundClean(), this }digestInto (e) { r.default.exists(this), r.default.output(e, this), this.finished = !0; const { buffer: t, view: n, blockLen: o, isLE: a } = this; let { pos: s } = this; t[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o - s && (this.process(n, 0), s = 0); for (let e = s; e < o; e++)t[e] = 0; !(function (e, t, n, r) { if (typeof e.setBigUint64 === 'function') return e.setBigUint64(t, n, r); const i = BigInt(32); const o = BigInt(4294967295); const a = Number(n >> i & o); const s = Number(n & o); const c = r ? 4 : 0; const u = r ? 0 : 4; e.setUint32(t + c, a, r), e.setUint32(t + u, s, r) }(n, o - 8, BigInt(8 * this.length), a)), this.process(n, 0); const c = (0, i.createView)(e); const u = this.outputLen; if (u % 4) throw new Error('_sha2: outputLen should be aligned to 32bit'); const l = u / 4; const d = this.get(); if (l > d.length) throw new Error('_sha2: outputLen bigger than state'); for (let e = 0; e < l; e++)c.setUint32(4 * e, d[e], a) }digest () { const { buffer: e, outputLen: t } = this; this.digestInto(e); const n = e.slice(0, t); return this.destroy(), n }_cloneInto (e) { e || (e = new this.constructor()), e.set(...this.get()); const { blockLen: t, buffer: n, length: r, finished: i, destroyed: o, pos: a } = this; return e.length = r, e.pos = a, e.finished = i, e.destroyed = o, r % t && e.buffer.set(n), e }}t.SHA2 = o }, 3376: (e, t) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.add = t.toBig = t.split = t.fromBig = void 0; const n = BigInt(2 ** 32 - 1); const r = BigInt(32); function i (e, t = !1) { return t ? { h: Number(e & n), l: Number(e >> r & n) } : { h: 0 | Number(e >> r & n), l: 0 | Number(e & n) } } function o (e, t = !1) { const n = new Uint32Array(e.length); const r = new Uint32Array(e.length); for (let o = 0; o < e.length; o++) { const { h: a, l: s } = i(e[o], t); [n[o], r[o]] = [a, s] } return [n, r] }t.fromBig = i, t.split = o; t.toBig = (e, t) => BigInt(e >>> 0) << r | BigInt(t >>> 0); function a (e, t, n, r) { const i = (t >>> 0) + (r >>> 0); return { h: e + n + (i / 2 ** 32 | 0) | 0, l: 0 | i } }t.add = a; const s = { fromBig: i, split: o, toBig: t.toBig, shrSH: (e, t, n) => e >>> n, shrSL: (e, t, n) => e << 32 - n | t >>> n, rotrSH: (e, t, n) => e >>> n | t << 32 - n, rotrSL: (e, t, n) => e << 32 - n | t >>> n, rotrBH: (e, t, n) => e << 64 - n | t >>> n - 32, rotrBL: (e, t, n) => e >>> n - 32 | t << 64 - n, rotr32H: (e, t) => t, rotr32L: (e, t) => e, rotlSH: (e, t, n) => e << n | t >>> 32 - n, rotlSL: (e, t, n) => t << n | e >>> 32 - n, rotlBH: (e, t, n) => t << n - 32 | e >>> 64 - n, rotlBL: (e, t, n) => e << n - 32 | t >>> 64 - n, add: a, add3L: (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0), add3H: (e, t, n, r) => t + n + r + (e / 2 ** 32 | 0) | 0, add4L: (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0), add4H: (e, t, n, r, i) => t + n + r + i + (e / 2 ** 32 | 0) | 0, add5H: (e, t, n, r, i, o) => t + n + r + i + o + (e / 2 ** 32 | 0) | 0, add5L: (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0) }; t.default = s }, 2210: (e, t) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.crypto = void 0, t.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0 }, 6211: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.hmac = t.HMAC = void 0; const r = n(6642); const i = n(6462); class o extends i.Hash {constructor (e, t) { super(), this.finished = !1, this.destroyed = !1, r.default.hash(e); const n = (0, i.toBytes)(t); if (this.iHash = e.create(), typeof this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash'); this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen; const o = this.blockLen; const a = new Uint8Array(o); a.set(n.length > o ? e.create().update(n).digest() : n); for (let e = 0; e < a.length; e++)a[e] ^= 54; this.iHash.update(a), this.oHash = e.create(); for (let e = 0; e < a.length; e++)a[e] ^= 106; this.oHash.update(a), a.fill(0) }update (e) { return r.default.exists(this), this.iHash.update(e), this }digestInto (e) { r.default.exists(this), r.default.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy() }digest () { const e = new Uint8Array(this.oHash.outputLen); return this.digestInto(e), e }_cloneInto (e) { e || (e = Object.create(Object.getPrototypeOf(this), {})); const { oHash: t, iHash: n, finished: r, destroyed: i, blockLen: o, outputLen: a } = this; return e.finished = r, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e }destroy () { this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy() }}t.HMAC = o; t.hmac = (e, t, n) => new o(e, t).update(n).digest(), t.hmac.create = (e, t) => new o(e, t) }, 5194: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.pbkdf2Async = t.pbkdf2 = void 0; const r = n(6642); const i = n(6211); const o = n(6462); function a (e, t, n, a) { r.default.hash(e); const s = (0, o.checkOpts)({ dkLen: 32, asyncTick: 10 }, a); const { c, dkLen: u, asyncTick: l } = s; if (r.default.number(c), r.default.number(u), r.default.number(l), c < 1) throw new Error('PBKDF2: iterations (c) should be >= 1'); const d = (0, o.toBytes)(t); const f = (0, o.toBytes)(n); const h = new Uint8Array(u); const p = i.hmac.create(e, d); const g = p._cloneInto().update(f); return { c, dkLen: u, asyncTick: l, DK: h, PRF: p, PRFSalt: g } } function s (e, t, n, r, i) { return e.destroy(), t.destroy(), r && r.destroy(), i.fill(0), n }t.pbkdf2 = function (e, t, n, r) { const { c: i, dkLen: c, DK: u, PRF: l, PRFSalt: d } = a(e, t, n, r); let f; const h = new Uint8Array(4); const p = (0, o.createView)(h); const g = new Uint8Array(l.outputLen); for (let e = 1, t = 0; t < c; e++, t += l.outputLen) { const n = u.subarray(t, t + l.outputLen); p.setInt32(0, e, !1), (f = d._cloneInto(f)).update(h).digestInto(g), n.set(g.subarray(0, n.length)); for (let e = 1; e < i; e++) { l._cloneInto(f).update(g).digestInto(g); for (let e = 0; e < n.length; e++)n[e] ^= g[e] } } return s(l, d, u, f, g) }, t.pbkdf2Async = async function (e, t, n, r) { const { c: i, dkLen: c, asyncTick: u, DK: l, PRF: d, PRFSalt: f } = a(e, t, n, r); let h; const p = new Uint8Array(4); const g = (0, o.createView)(p); const m = new Uint8Array(d.outputLen); for (let e = 1, t = 0; t < c; e++, t += d.outputLen) { const n = l.subarray(t, t + d.outputLen); g.setInt32(0, e, !1), (h = f._cloneInto(h)).update(p).digestInto(m), n.set(m.subarray(0, n.length)), await (0, o.asyncLoop)(i - 1, u, e => { d._cloneInto(h).update(m).digestInto(m); for (let e = 0; e < n.length; e++)n[e] ^= m[e] }) } return s(d, f, l, h, m) } }, 7035: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.sha224 = t.sha256 = void 0; const r = n(6919); const i = n(6462); const o = (e, t, n) => e & t ^ e & n ^ t & n; const a = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]); const s = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]); const c = new Uint32Array(64); class u extends r.SHA2 {constructor () { super(64, 32, 8, !1), this.A = 0 | s[0], this.B = 0 | s[1], this.C = 0 | s[2], this.D = 0 | s[3], this.E = 0 | s[4], this.F = 0 | s[5], this.G = 0 | s[6], this.H = 0 | s[7] }get () { const { A: e, B: t, C: n, D: r, E: i, F: o, G: a, H: s } = this; return [e, t, n, r, i, o, a, s] }set (e, t, n, r, i, o, a, s) { this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | o, this.G = 0 | a, this.H = 0 | s }process (e, t) { for (let n = 0; n < 16; n++, t += 4)c[n] = e.getUint32(t, !1); for (let e = 16; e < 64; e++) { const t = c[e - 15]; const n = c[e - 2]; const r = (0, i.rotr)(t, 7) ^ (0, i.rotr)(t, 18) ^ t >>> 3; const o = (0, i.rotr)(n, 17) ^ (0, i.rotr)(n, 19) ^ n >>> 10; c[e] = o + c[e - 7] + r + c[e - 16] | 0 } let { A: n, B: r, C: s, D: u, E: l, F: d, G: f, H: h } = this; for (let e = 0; e < 64; e++) { const t = h + ((0, i.rotr)(l, 6) ^ (0, i.rotr)(l, 11) ^ (0, i.rotr)(l, 25)) + ((p = l) & d ^ ~p & f) + a[e] + c[e] | 0; const g = ((0, i.rotr)(n, 2) ^ (0, i.rotr)(n, 13) ^ (0, i.rotr)(n, 22)) + o(n, r, s) | 0; h = f, f = d, d = l, l = u + t | 0, u = s, s = r, r = n, n = t + g | 0 } let p; n = n + this.A | 0, r = r + this.B | 0, s = s + this.C | 0, u = u + this.D | 0, l = l + this.E | 0, d = d + this.F | 0, f = f + this.G | 0, h = h + this.H | 0, this.set(n, r, s, u, l, d, f, h) }roundClean () { c.fill(0) }destroy () { this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0) }} class l extends u {constructor () { super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28 }}t.sha256 = (0, i.wrapConstructor)(() => new u()), t.sha224 = (0, i.wrapConstructor)(() => new l()) }, 8558: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.sha384 = t.sha512_256 = t.sha512_224 = t.sha512 = t.SHA512 = void 0; const r = n(6919); const i = n(3376); const o = n(6462); const [a, s] = i.default.split(['0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc', '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118', '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2', '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694', '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65', '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5', '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4', '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70', '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df', '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b', '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30', '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8', '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8', '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3', '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec', '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b', '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178', '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b', '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c', '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'].map(e => BigInt(e))); const c = new Uint32Array(80); const u = new Uint32Array(80); class l extends r.SHA2 {constructor () { super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209 }get () { const { Ah: e, Al: t, Bh: n, Bl: r, Ch: i, Cl: o, Dh: a, Dl: s, Eh: c, El: u, Fh: l, Fl: d, Gh: f, Gl: h, Hh: p, Hl: g } = this; return [e, t, n, r, i, o, a, s, c, u, l, d, f, h, p, g] }set (e, t, n, r, i, o, a, s, c, u, l, d, f, h, p, g) { this.Ah = 0 | e, this.Al = 0 | t, this.Bh = 0 | n, this.Bl = 0 | r, this.Ch = 0 | i, this.Cl = 0 | o, this.Dh = 0 | a, this.Dl = 0 | s, this.Eh = 0 | c, this.El = 0 | u, this.Fh = 0 | l, this.Fl = 0 | d, this.Gh = 0 | f, this.Gl = 0 | h, this.Hh = 0 | p, this.Hl = 0 | g }process (e, t) { for (let n = 0; n < 16; n++, t += 4)c[n] = e.getUint32(t), u[n] = e.getUint32(t += 4); for (let e = 16; e < 80; e++) { const t = 0 | c[e - 15]; const n = 0 | u[e - 15]; const r = i.default.rotrSH(t, n, 1) ^ i.default.rotrSH(t, n, 8) ^ i.default.shrSH(t, n, 7); const o = i.default.rotrSL(t, n, 1) ^ i.default.rotrSL(t, n, 8) ^ i.default.shrSL(t, n, 7); const a = 0 | c[e - 2]; const s = 0 | u[e - 2]; const l = i.default.rotrSH(a, s, 19) ^ i.default.rotrBH(a, s, 61) ^ i.default.shrSH(a, s, 6); const d = i.default.rotrSL(a, s, 19) ^ i.default.rotrBL(a, s, 61) ^ i.default.shrSL(a, s, 6); const f = i.default.add4L(o, d, u[e - 7], u[e - 16]); const h = i.default.add4H(f, r, l, c[e - 7], c[e - 16]); c[e] = 0 | h, u[e] = 0 | f } let { Ah: n, Al: r, Bh: o, Bl: l, Ch: d, Cl: f, Dh: h, Dl: p, Eh: g, El: m, Fh: y, Fl: b, Gh: v, Gl: w, Hh: _, Hl: E } = this; for (let e = 0; e < 80; e++) { const t = i.default.rotrSH(g, m, 14) ^ i.default.rotrSH(g, m, 18) ^ i.default.rotrBH(g, m, 41); const k = i.default.rotrSL(g, m, 14) ^ i.default.rotrSL(g, m, 18) ^ i.default.rotrBL(g, m, 41); const S = g & y ^ ~g & v; const A = m & b ^ ~m & w; const O = i.default.add5L(E, k, A, s[e], u[e]); const x = i.default.add5H(O, _, t, S, a[e], c[e]); const I = 0 | O; const N = i.default.rotrSH(n, r, 28) ^ i.default.rotrBH(n, r, 34) ^ i.default.rotrBH(n, r, 39); const T = i.default.rotrSL(n, r, 28) ^ i.default.rotrBL(n, r, 34) ^ i.default.rotrBL(n, r, 39); const R = n & o ^ n & d ^ o & d; const P = r & l ^ r & f ^ l & f; _ = 0 | v, E = 0 | w, v = 0 | y, w = 0 | b, y = 0 | g, b = 0 | m, ({ h: g, l: m } = i.default.add(0 | h, 0 | p, 0 | x, 0 | I)), h = 0 | d, p = 0 | f, d = 0 | o, f = 0 | l, o = 0 | n, l = 0 | r; const C = i.default.add3L(I, T, P); n = i.default.add3H(C, x, N, R), r = 0 | C }({ h: n, l: r } = i.default.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)), ({ h: o, l } = i.default.add(0 | this.Bh, 0 | this.Bl, 0 | o, 0 | l)), ({ h: d, l: f } = i.default.add(0 | this.Ch, 0 | this.Cl, 0 | d, 0 | f)), ({ h, l: p } = i.default.add(0 | this.Dh, 0 | this.Dl, 0 | h, 0 | p)), ({ h: g, l: m } = i.default.add(0 | this.Eh, 0 | this.El, 0 | g, 0 | m)), ({ h: y, l: b } = i.default.add(0 | this.Fh, 0 | this.Fl, 0 | y, 0 | b)), ({ h: v, l: w } = i.default.add(0 | this.Gh, 0 | this.Gl, 0 | v, 0 | w)), ({ h: _, l: E } = i.default.add(0 | this.Hh, 0 | this.Hl, 0 | _, 0 | E)), this.set(n, r, o, l, d, f, h, p, g, m, y, b, v, w, _, E) }roundClean () { c.fill(0), u.fill(0) }destroy () { this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) }}t.SHA512 = l; class d extends l {constructor () { super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28 }} class f extends l {constructor () { super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32 }} class h extends l {constructor () { super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48 }}t.sha512 = (0, o.wrapConstructor)(() => new l()), t.sha512_224 = (0, o.wrapConstructor)(() => new d()), t.sha512_256 = (0, o.wrapConstructor)(() => new f()), t.sha384 = (0, o.wrapConstructor)(() => new h()) }, 6462: (e, t, n) => { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }), t.randomBytes = t.wrapXOFConstructorWithOpts = t.wrapConstructorWithOpts = t.wrapConstructor = t.checkOpts = t.Hash = t.concatBytes = t.toBytes = t.utf8ToBytes = t.asyncLoop = t.nextTick = t.hexToBytes = t.bytesToHex = t.isLE = t.rotr = t.createView = t.u32 = t.u8 = void 0; const r = n(2210); const i = e => e instanceof Uint8Array; t.u8 = e => new Uint8Array(e.buffer, e.byteOffset, e.byteLength); t.u32 = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)); t.createView = e => new DataView(e.buffer, e.byteOffset, e.byteLength); if (t.rotr = (e, t) => e << 32 - t | e >>> t, t.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !t.isLE) throw new Error('Non little-endian hardware is not supported'); const o = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0')); t.bytesToHex = function (e) { if (!i(e)) throw new Error('Uint8Array expected'); let t = ''; for (let n = 0; n < e.length; n++)t += o[e[n]]; return t }, t.hexToBytes = function (e) { if (typeof e !== 'string') throw new Error('hex string expected, got ' + typeof e); const t = e.length; if (t % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + t); const n = new Uint8Array(t / 2); for (let t = 0; t < n.length; t++) { const r = 2 * t; const i = e.slice(r, r + 2); const o = Number.parseInt(i, 16); if (Number.isNaN(o) || o < 0) throw new Error('Invalid byte sequence'); n[t] = o } return n }; function a (e) { if (typeof e !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof e); return new Uint8Array((new TextEncoder()).encode(e)) } function s (e) { if (typeof e === 'string' && (e = a(e)), !i(e)) throw new Error('expected Uint8Array, got ' + typeof e); return e }t.nextTick = async () => {}, t.asyncLoop = async function (e, n, r) { let i = Date.now(); for (let o = 0; o < e; o++) { r(o); const e = Date.now() - i; e >= 0 && e < n || (await (0, t.nextTick)(), i += e) } }, t.utf8ToBytes = a, t.toBytes = s, t.concatBytes = function (...e) { const t = new Uint8Array(e.reduce((e, t) => e + t.length, 0)); let n = 0; return e.forEach(e => { if (!i(e)) throw new Error('Uint8Array expected'); t.set(e, n), n += e.length }), t }; t.Hash = class {clone () { return this._cloneInto() }}; t.checkOpts = function (e, t) { if (void 0 !== t && (typeof t !== 'object' || (n = t, Object.prototype.toString.call(n) !== '[object Object]' || n.constructor !== Object))) throw new Error('Options should be object or undefined'); let n; return Object.assign(e, t) }, t.wrapConstructor = function (e) { const t = t => e().update(s(t)).digest(); const n = e(); return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t }, t.wrapConstructorWithOpts = function (e) { const t = (t, n) => e(n).update(s(t)).digest(); const n = e({}); return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = t => e(t), t }, t.wrapXOFConstructorWithOpts = function (e) { const t = (t, n) => e(n).update(s(t)).digest(); const n = e({}); return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = t => e(t), t }, t.randomBytes = function (e = 32) { if (r.crypto && typeof r.crypto.getRandomValues === 'function') return r.crypto.getRandomValues(new Uint8Array(e)); throw new Error('crypto.getRandomValues must be defined') } }, 8883: (e, t) => { 'use strict'; t.U = void 0, t.U = 'abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo'.split('\n') }, 4155: e => { let t; let n; const r = e.exports = {}; function i () { throw new Error('setTimeout has not been defined') } function o () { throw new Error('clearTimeout has not been defined') } function a (e) { if (t === setTimeout) return setTimeout(e, 0); if ((t === i || !t) && setTimeout) return t = setTimeout, setTimeout(e, 0); try { return t(e, 0) } catch (n) { try { return t.call(null, e, 0) } catch (n) { return t.call(this, e, 0) } } }!(function () { try { t = typeof setTimeout === 'function' ? setTimeout : i } catch (e) { t = i } try { n = typeof clearTimeout === 'function' ? clearTimeout : o } catch (e) { n = o } }()); let s; let c = []; let u = !1; let l = -1; function d () { u && s && (u = !1, s.length ? c = s.concat(c) : l = -1, c.length && f()) } function f () { if (!u) { const e = a(d); u = !0; for (let t = c.length; t;) { for (s = c, c = []; ++l < t;)s && s[l].run(); l = -1, t = c.length }s = null, u = !1, (function (e) { if (n === clearTimeout) return clearTimeout(e); if ((n === o || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e); try { return n(e) } catch (t) { try { return n.call(null, e) } catch (t) { return n.call(this, e) } } }(e)) } } function h (e, t) { this.fun = e, this.array = t } function p () {}r.nextTick = function (e) { const t = new Array(arguments.length - 1); if (arguments.length > 1) for (let n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; c.push(new h(e, t)), c.length !== 1 || u || a(f) }, h.prototype.run = function () { this.fun.apply(null, this.array) }, r.title = 'browser', r.browser = !0, r.env = {}, r.argv = [], r.version = '', r.versions = {}, r.on = p, r.addListener = p, r.once = p, r.off = p, r.removeListener = p, r.removeAllListeners = p, r.emit = p, r.prependListener = p, r.prependOnceListener = p, r.listeners = function (e) { return [] }, r.binding = function (e) { throw new Error('process.binding is not supported') }, r.cwd = function () { return '/' }, r.chdir = function (e) { throw new Error('process.chdir is not supported') }, r.umask = function () { return 0 } }, 1798: function (e, t, n) { e = n.nmd(e), (function (n, r) { 'use strict'; let i = {}; n.PubSub ? (i = n.PubSub, console.warn('PubSub already loaded, using existing version')) : (n.PubSub = i, (function (e) { let t = {}; let n = -1; const r = '*'; function i (e) { let t; for (t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !0; return !1 } function o (e) { return function () { throw e } } function a (e, t, n) { try { e(t, n) } catch (e) { setTimeout(o(e), 0) } } function s (e, t, n) { e(t, n) } function c (e, n, r, i) { let o; const c = t[n]; const u = i ? s : a; if (Object.prototype.hasOwnProperty.call(t, n)) for (o in c)Object.prototype.hasOwnProperty.call(c, o) && u(c[o], e, r) } function u (e, t, n) { return function () { let i = String(e); let o = i.lastIndexOf('.'); for (c(e, e, t, n); o !== -1;)o = (i = i.substr(0, o)).lastIndexOf('.'), c(e, i, t, n); c(e, r, t, n) } } function l (e) { const n = String(e); return Boolean(Object.prototype.hasOwnProperty.call(t, n) && i(t[n])) } function d (e) { for (var t = String(e), n = l(t) || l(r), i = t.lastIndexOf('.'); !n && i !== -1;)i = (t = t.substr(0, i)).lastIndexOf('.'), n = l(t); return n } function f (e, t, n, r) { const i = u(e = typeof e === 'symbol' ? e.toString() : e, t, r); return !!d(e) && (!0 === n ? i() : setTimeout(i, 0), !0) }e.publish = function (t, n) { return f(t, n, !1, e.immediateExceptions) }, e.publishSync = function (t, n) { return f(t, n, !0, e.immediateExceptions) }, e.subscribe = function (e, r) { if (typeof r !== 'function') return !1; e = typeof e === 'symbol' ? e.toString() : e, Object.prototype.hasOwnProperty.call(t, e) || (t[e] = {}); const i = 'uid_' + String(++n); return t[e][i] = r, i }, e.subscribeAll = function (t) { return e.subscribe(r, t) }, e.subscribeOnce = function (t, n) { var r = e.subscribe(t, function () { e.unsubscribe(r), n.apply(this, arguments) }); return e }, e.clearAllSubscriptions = function () { t = {} }, e.clearSubscriptions = function (e) { let n; for (n in t)Object.prototype.hasOwnProperty.call(t, n) && n.indexOf(e) === 0 && delete t[n] }, e.countSubscriptions = function (e) { let n; let r; let i = 0; for (n in t) if (Object.prototype.hasOwnProperty.call(t, n) && n.indexOf(e) === 0) { for (r in t[n])i++; break } return i }, e.getSubscriptions = function (e) { let n; const r = []; for (n in t)Object.prototype.hasOwnProperty.call(t, n) && n.indexOf(e) === 0 && r.push(n); return r }, e.unsubscribe = function (n) { let r; let i; let o; const a = function (e) { let n; for (n in t) if (Object.prototype.hasOwnProperty.call(t, n) && n.indexOf(e) === 0) return !0; return !1 }; const s = typeof n === 'string' && (Object.prototype.hasOwnProperty.call(t, n) || a(n)); const c = !s && typeof n === 'string'; const u = typeof n === 'function'; let l = !1; if (!s) { for (r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (i = t[r], c && i[n]) { delete i[n], l = n; break } if (u) for (o in i)Object.prototype.hasOwnProperty.call(i, o) && i[o] === n && (delete i[o], l = !0) } return l }e.clearSubscriptions(n) } }(i))), void 0 !== e && e.exports && (t = e.exports = i), t.PubSub = i, e.exports = t = i }(typeof window === 'object' && window || this)) }, 2408: (e, t) => { 'use strict'; const n = Symbol.for('react.element'); const r = Symbol.for('react.portal'); const i = Symbol.for('react.fragment'); const o = Symbol.for('react.strict_mode'); const a = Symbol.for('react.profiler'); const s = Symbol.for('react.provider'); const c = Symbol.for('react.context'); const u = Symbol.for('react.forward_ref'); const l = Symbol.for('react.suspense'); const d = Symbol.for('react.memo'); const f = Symbol.for('react.lazy'); const h = Symbol.iterator; const p = { isMounted: function () { return !1 }, enqueueForceUpdate: function () {}, enqueueReplaceState: function () {}, enqueueSetState: function () {} }; const g = Object.assign; const m = {}; function y (e, t, n) { this.props = e, this.context = t, this.refs = m, this.updater = n || p } function b () {} function v (e, t, n) { this.props = e, this.context = t, this.refs = m, this.updater = n || p }y.prototype.isReactComponent = {}, y.prototype.setState = function (e, t) { if (typeof e !== 'object' && typeof e !== 'function' && e != null) throw Error('setState(...): takes an object of state variables to update or a function which returns an object of state variables.'); this.updater.enqueueSetState(this, e, t, 'setState') }, y.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, 'forceUpdate') }, b.prototype = y.prototype; const w = v.prototype = new b(); w.constructor = v, g(w, y.prototype), w.isPureReactComponent = !0; const _ = Array.isArray; const E = Object.prototype.hasOwnProperty; const k = { current: null }; const S = { key: !0, ref: !0, __self: !0, __source: !0 }; function A (e, t, r) { let i; const o = {}; let a = null; let s = null; if (t != null) for (i in void 0 !== t.ref && (s = t.ref), void 0 !== t.key && (a = '' + t.key), t)E.call(t, i) && !S.hasOwnProperty(i) && (o[i] = t[i]); let c = arguments.length - 2; if (c === 1)o.children = r; else if (c > 1) { for (var u = Array(c), l = 0; l < c; l++)u[l] = arguments[l + 2]; o.children = u } if (e && e.defaultProps) for (i in c = e.defaultProps) void 0 === o[i] && (o[i] = c[i]); return { $$typeof: n, type: e, key: a, ref: s, props: o, _owner: k.current } } function O (e) { return typeof e === 'object' && e !== null && e.$$typeof === n } const x = /\/+/g; function I (e, t) { return typeof e === 'object' && e !== null && e.key != null ? (function (e) { const t = { '=': '=0', ':': '=2' }; return '$' + e.replace(/[=:]/g, function (e) { return t[e] }) }('' + e.key)) : t.toString(36) } function N (e, t, i, o, a) { let s = typeof e; s !== 'undefined' && s !== 'boolean' || (e = null); let c = !1; if (e === null)c = !0; else switch (s) { case 'string':case 'number':c = !0; break; case 'object':switch (e.$$typeof) { case n:case r:c = !0 } } if (c) return a = a(c = e), e = o === '' ? '.' + I(c, 0) : o, _(a) ? (i = '', e != null && (i = e.replace(x, '$&/') + '/'), N(a, t, i, '', function (e) { return e })) : a != null && (O(a) && (a = (function (e, t) { return { $$typeof: n, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } }(a, i + (!a.key || c && c.key === a.key ? '' : ('' + a.key).replace(x, '$&/') + '/') + e))), t.push(a)), 1; if (c = 0, o = o === '' ? '.' : o + ':', _(e)) for (var u = 0; u < e.length; u++) { var l = o + I(s = e[u], u); c += N(s, t, i, l, a) } else if (l = (function (e) { return e === null || typeof e !== 'object' ? null : typeof (e = h && e[h] || e['@@iterator']) === 'function' ? e : null }(e)), typeof l === 'function') for (e = l.call(e), u = 0; !(s = e.next()).done;)c += N(s = s.value, t, i, l = o + I(s, u++), a); else if (s === 'object') throw t = String(e), Error('Objects are not valid as a React child (found: ' + (t === '[object Object]' ? 'object with keys {' + Object.keys(e).join(', ') + '}' : t) + '). If you meant to render a collection of children, use an array instead.'); return c } function T (e, t, n) { if (e == null) return e; const r = []; let i = 0; return N(e, r, '', '', function (e) { return t.call(n, e, i++) }), r } function R (e) { if (e._status === -1) { let t = e._result; (t = t()).then(function (t) { e._status !== 0 && e._status !== -1 || (e._status = 1, e._result = t) }, function (t) { e._status !== 0 && e._status !== -1 || (e._status = 2, e._result = t) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } const P = { current: null }; const C = { transition: null }; t.createContext = function (e) { return (e = { $$typeof: c, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }).Provider = { $$typeof: s, _context: e }, e.Consumer = e }, t.useDebugValue = function () {}, t.useEffect = function (e, t) { return P.current.useEffect(e, t) }, t.useLayoutEffect = function (e, t) { return P.current.useLayoutEffect(e, t) }, t.useReducer = function (e, t, n) { return P.current.useReducer(e, t, n) }, t.useRef = function (e) { return P.current.useRef(e) } }, 7294: (e, t, n) => { 'use strict'; e.exports = n(2408) }, 4281: e => { 'use strict'; const t = {}; function n (e, n, r) { r || (r = Error); const i = (function (e) { let t, r; function i (t, r, i) { return e.call(this, (function (e, t, r) { return typeof n === 'string' ? n : n(e, t, r) }(t, r, i))) || this } return r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r, i }(r)); i.prototype.name = r.name, i.prototype.code = e, t[e] = i } function r (e, t) { if (Array.isArray(e)) { const n = e.length; return e = e.map(function (e) { return String(e) }), n > 2 ? 'one of '.concat(t, ' ').concat(e.slice(0, n - 1).join(', '), ', or ') + e[n - 1] : n === 2 ? 'one of '.concat(t, ' ').concat(e[0], ' or ').concat(e[1]) : 'of '.concat(t, ' ').concat(e[0]) } return 'of '.concat(t, ' ').concat(String(e)) }n('ERR_INVALID_OPT_VALUE', function (e, t) { return 'The value "' + t + '" is invalid for option "' + e + '"' }, TypeError), n('ERR_INVALID_ARG_TYPE', function (e, t, n) { let i, o, a, s; if (typeof t === 'string' && (o = 'not ', t.substr(!a || a < 0 ? 0 : +a, o.length) === o) ? (i = 'must not be', t = t.replace(/^not /, '')) : i = 'must be', (function (e, t, n) { return (void 0 === n || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t }(e, ' argument')))s = 'The '.concat(e, ' ').concat(i, ' ').concat(r(t, 'type')); else { const c = (function (e, t, n) { return typeof n !== 'number' && (n = 0), !(n + t.length > e.length) && e.indexOf(t, n) !== -1 }(e, '.')) ? 'property' : 'argument'; s = 'The "'.concat(e, '" ').concat(c, ' ').concat(i, ' ').concat(r(t, 'type')) } return s += '. Received type '.concat(typeof n) }, TypeError), n('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF'), n('ERR_METHOD_NOT_IMPLEMENTED', function (e) { return 'The ' + e + ' method is not implemented' }), n('ERR_STREAM_PREMATURE_CLOSE', 'Premature close'), n('ERR_STREAM_DESTROYED', function (e) { return 'Cannot call ' + e + ' after a stream was destroyed' }), n('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times'), n('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable'), n('ERR_STREAM_WRITE_AFTER_END', 'write after end'), n('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError), n('ERR_UNKNOWN_ENCODING', function (e) { return 'Unknown encoding: ' + e }, TypeError), n('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event'), e.exports.q = t }, 6753: (e, t, n) => { 'use strict'; const r = n(4155); const i = Object.keys || function (e) { const t = []; for (const n in e)t.push(n); return t }; e.exports = l; const o = n(9481); const a = n(4229); n(5717)(l, o); for (let s = i(a.prototype), c = 0; c < s.length; c++) { const u = s[c]; l.prototype[u] || (l.prototype[u] = a.prototype[u]) } function l (e) { if (!(this instanceof l)) return new l(e); o.call(this, e), a.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once('end', d))) } function d () { this._writableState.ended || r.nextTick(f, this) } function f (e) { e.end() }Object.defineProperty(l.prototype, 'writableHighWaterMark', { enumerable: !1, get: function () { return this._writableState.highWaterMark } }), Object.defineProperty(l.prototype, 'writableBuffer', { enumerable: !1, get: function () { return this._writableState && this._writableState.getBuffer() } }), Object.defineProperty(l.prototype, 'writableLength', { enumerable: !1, get: function () { return this._writableState.length } }), Object.defineProperty(l.prototype, 'destroyed', { enumerable: !1, get: function () { return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed) }, set: function (e) { void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e) } }) }, 2725: (e, t, n) => { 'use strict'; e.exports = i; const r = n(4605); function i (e) { if (!(this instanceof i)) return new i(e); r.call(this, e) }n(5717)(i, r), i.prototype._transform = function (e, t, n) { n(null, e) } }, 9481: (e, t, n) => { 'use strict'; let r; const i = n(4155); e.exports = A, A.ReadableState = S; n(7187).EventEmitter; const o = function (e, t) { return e.listeners(t).length }; const a = n(2503); const s = n(8764).Buffer; const c = n.g.Uint8Array || function () {}; let u; const l = n(4616); u = l && l.debuglog ? l.debuglog('stream') : function () {}; let d; let f; let h; const p = n(7327); const g = n(1195); const m = n(2457).getHighWaterMark; const y = n(4281).q; const b = y.ERR_INVALID_ARG_TYPE; const v = y.ERR_STREAM_PUSH_AFTER_EOF; const w = y.ERR_METHOD_NOT_IMPLEMENTED; const _ = y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; n(5717)(A, a); const E = g.errorOrDestroy; const k = ['error', 'close', 'destroy', 'pause', 'resume']; function S (e, t, i) { r = r || n(6753), e = e || {}, typeof i !== 'boolean' && (i = t instanceof r), this.objectMode = !!e.objectMode, i && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = m(this, e, 'readableHighWaterMark', i), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || 'utf8', this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (d || (d = n(2553).s), this.decoder = new d(e.encoding), this.encoding = e.encoding) } function A (e) { if (r = r || n(6753), !(this instanceof A)) return new A(e); const t = this instanceof r; this._readableState = new S(e, this, t), this.readable = !0, e && (typeof e.read === 'function' && (this._read = e.read), typeof e.destroy === 'function' && (this._destroy = e.destroy)), a.call(this) } function O (e, t, n, r, i) { u('readableAddChunk', t); let o; const a = e._readableState; if (t === null)a.reading = !1, (function (e, t) { if (u('onEofChunk'), t.ended) return; if (t.decoder) { const n = t.decoder.end(); n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length) }t.ended = !0, t.sync ? T(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, R(e))) }(e, a)); else if (i || (o = (function (e, t) { let n; r = t, s.isBuffer(r) || r instanceof c || typeof t === 'string' || void 0 === t || e.objectMode || (n = new b('chunk', ['string', 'Buffer', 'Uint8Array'], t)); let r; return n }(a, t))), o)E(e, o); else if (a.objectMode || t && t.length > 0) if (typeof t === 'string' || a.objectMode || Object.getPrototypeOf(t) === s.prototype || (t = (function (e) { return s.from(e) }(t))), r)a.endEmitted ? E(e, new _()) : x(e, a, t, !0); else if (a.ended)E(e, new v()); else { if (a.destroyed) return !1; a.reading = !1, a.decoder && !n ? (t = a.decoder.write(t), a.objectMode || t.length !== 0 ? x(e, a, t, !1) : P(e, a)) : x(e, a, t, !1) } else r || (a.reading = !1, P(e, a)); return !a.ended && (a.length < a.highWaterMark || a.length === 0) } function x (e, t, n, r) { t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit('data', n)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && T(e)), P(e, t) }Object.defineProperty(A.prototype, 'destroyed', { enumerable: !1, get: function () { return void 0 !== this._readableState && this._readableState.destroyed }, set: function (e) { this._readableState && (this._readableState.destroyed = e) } }), A.prototype.destroy = g.destroy, A.prototype._undestroy = g.undestroy, A.prototype._destroy = function (e, t) { t(e) }, A.prototype.push = function (e, t) { let n; const r = this._readableState; return r.objectMode ? n = !0 : typeof e === 'string' && ((t = t || r.defaultEncoding) !== r.encoding && (e = s.from(e, t), t = ''), n = !0), O(this, e, t, !1, n) }, A.prototype.unshift = function (e) { return O(this, e, null, !0, !1) }, A.prototype.isPaused = function () { return !1 === this._readableState.flowing }, A.prototype.setEncoding = function (e) { d || (d = n(2553).s); const t = new d(e); this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding; for (var r = this._readableState.buffer.head, i = ''; r !== null;)i += t.write(r.data), r = r.next; return this._readableState.buffer.clear(), i !== '' && this._readableState.buffer.push(i), this._readableState.length = i.length, this }; const I = 1073741824; function N (e, t) { return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = (function (e) { return e >= I ? e = I : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e }(e))), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0)) } function T (e) { const t = e._readableState; u('emitReadable', t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (u('emitReadable', t.flowing), t.emittedReadable = !0, i.nextTick(R, e)) } function R (e) { const t = e._readableState; u('emitReadable_', t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit('readable'), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, D(e) } function P (e, t) { t.readingMore || (t.readingMore = !0, i.nextTick(C, e, t)) } function C (e, t) { for (;!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0);) { const n = t.length; if (u('maybeReadMore read 0'), e.read(0), n === t.length) break }t.readingMore = !1 } function B (e) { const t = e._readableState; t.readableListening = e.listenerCount('readable') > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount('data') > 0 && e.resume() } function L (e) { u('readable nexttick read 0'), e.read(0) } function j (e, t) { u('resume', t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit('resume'), D(e), t.flowing && !t.reading && e.read(0) } function D (e) { const t = e._readableState; for (u('flow', t.flowing); t.flowing && e.read() !== null;); } function U (e, t) { return t.length === 0 ? null : (t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (n = t.decoder ? t.buffer.join('') : t.buffer.length === 1 ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : n = t.buffer.consume(e, t.decoder), n); let n } function M (e) { const t = e._readableState; u('endReadable', t.endEmitted), t.endEmitted || (t.ended = !0, i.nextTick(z, t, e)) } function z (e, t) { if (u('endReadableNT', e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit('end'), e.autoDestroy)) { const n = t._writableState; (!n || n.autoDestroy && n.finished) && t.destroy() } } function F (e, t) { for (let n = 0, r = e.length; n < r; n++) if (e[n] === t) return n; return -1 }A.prototype.read = function (e) { u('read', e), e = parseInt(e, 10); const t = this._readableState; const n = e; if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return u('read: emitReadable', t.length, t.ended), t.length === 0 && t.ended ? M(this) : T(this), null; if ((e = N(e, t)) === 0 && t.ended) return t.length === 0 && M(this), null; let r; let i = t.needReadable; return u('need readable', i), (t.length === 0 || t.length - e < t.highWaterMark) && u('length less than watermark', i = !0), t.ended || t.reading ? u('reading or ended', i = !1) : i && (u('do read'), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = N(n, t))), (r = e > 0 ? U(e, t) : null) === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = !0), n !== e && t.ended && M(this)), r !== null && this.emit('data', r), r }, A.prototype._read = function (e) { E(this, new w('_read()')) }, A.prototype.pipe = function (e, t) { const n = this; const r = this._readableState; switch (r.pipesCount) { case 0:r.pipes = e; break; case 1:r.pipes = [r.pipes, e]; break; default:r.pipes.push(e) }r.pipesCount += 1, u('pipe count=%d opts=%j', r.pipesCount, t); const a = (!t || !1 !== t.end) && e !== i.stdout && e !== i.stderr ? c : m; function s (t, i) { u('onunpipe'), t === n && i && !1 === i.hasUnpiped && (i.hasUnpiped = !0, u('cleanup'), e.removeListener('close', p), e.removeListener('finish', g), e.removeListener('drain', l), e.removeListener('error', h), e.removeListener('unpipe', s), n.removeListener('end', c), n.removeListener('end', m), n.removeListener('data', f), d = !0, !r.awaitDrain || e._writableState && !e._writableState.needDrain || l()) } function c () { u('onend'), e.end() }r.endEmitted ? i.nextTick(a) : n.once('end', a), e.on('unpipe', s); var l = (function (e) { return function () { const t = e._readableState; u('pipeOnDrain', t.awaitDrain), t.awaitDrain && t.awaitDrain--, t.awaitDrain === 0 && o(e, 'data') && (t.flowing = !0, D(e)) } }(n)); e.on('drain', l); var d = !1; function f (t) { u('ondata'); const i = e.write(t); u('dest.write', i), !1 === i && ((r.pipesCount === 1 && r.pipes === e || r.pipesCount > 1 && F(r.pipes, e) !== -1) && !d && (u('false write response, pause', r.awaitDrain), r.awaitDrain++), n.pause()) } function h (t) { u('onerror', t), m(), e.removeListener('error', h), o(e, 'error') === 0 && E(e, t) } function p () { e.removeListener('finish', g), m() } function g () { u('onfinish'), e.removeListener('close', p), m() } function m () { u('unpipe'), n.unpipe(e) } return n.on('data', f), (function (e, t, n) { if (typeof e.prependListener === 'function') return e.prependListener(t, n); e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [n, e._events[t]] : e.on(t, n) }(e, 'error', h)), e.once('close', p), e.once('finish', g), e.emit('pipe', n), r.flowing || (u('pipe resume'), n.resume()), e }, A.prototype.unpipe = function (e) { const t = this._readableState; const n = { hasUnpiped: !1 }; if (t.pipesCount === 0) return this; if (t.pipesCount === 1) return e && e !== t.pipes || (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit('unpipe', this, n)), this; if (!e) { const r = t.pipes; const i = t.pipesCount; t.pipes = null, t.pipesCount = 0, t.flowing = !1; for (let o = 0; o < i; o++)r[o].emit('unpipe', this, { hasUnpiped: !1 }); return this } const a = F(t.pipes, e); return a === -1 || (t.pipes.splice(a, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit('unpipe', this, n)), this }, A.prototype.on = function (e, t) { const n = a.prototype.on.call(this, e, t); const r = this._readableState; return e === 'data' ? (r.readableListening = this.listenerCount('readable') > 0, !1 !== r.flowing && this.resume()) : e === 'readable' && (r.endEmitted || r.readableListening || (r.readableListening = r.needReadable = !0, r.flowing = !1, r.emittedReadable = !1, u('on readable', r.length, r.reading), r.length ? T(this) : r.reading || i.nextTick(L, this))), n }, A.prototype.addListener = A.prototype.on, A.prototype.removeListener = function (e, t) { const n = a.prototype.removeListener.call(this, e, t); return e === 'readable' && i.nextTick(B, this), n }, A.prototype.removeAllListeners = function (e) { const t = a.prototype.removeAllListeners.apply(this, arguments); return e !== 'readable' && void 0 !== e || i.nextTick(B, this), t }, A.prototype.resume = function () { const e = this._readableState; return e.flowing || (u('resume'), e.flowing = !e.readableListening, (function (e, t) { t.resumeScheduled || (t.resumeScheduled = !0, i.nextTick(j, e, t)) }(this, e))), e.paused = !1, this }, A.prototype.pause = function () { return u('call pause flowing=%j', this._readableState.flowing), !1 !== this._readableState.flowing && (u('pause'), this._readableState.flowing = !1, this.emit('pause')), this._readableState.paused = !0, this }, A.prototype.wrap = function (e) { const t = this; const n = this._readableState; let r = !1; for (const i in e.on('end', function () { if (u('wrapped end'), n.decoder && !n.ended) { const e = n.decoder.end(); e && e.length && t.push(e) }t.push(null) }), e.on('data', function (i) { (u('wrapped data'), n.decoder && (i = n.decoder.write(i)), n.objectMode && i == null) || (n.objectMode || i && i.length) && (t.push(i) || (r = !0, e.pause())) }), e) void 0 === this[i] && typeof e[i] === 'function' && (this[i] = (function (t) { return function () { return e[t].apply(e, arguments) } }(i))); for (let o = 0; o < k.length; o++)e.on(k[o], this.emit.bind(this, k[o])); return this._read = function (t) { u('wrapped _read', t), r && (r = !1, e.resume()) }, this }, typeof Symbol === 'function' && (A.prototype[Symbol.asyncIterator] = function () { return void 0 === f && (f = n(5850)), f(this) }), Object.defineProperty(A.prototype, 'readableHighWaterMark', { enumerable: !1, get: function () { return this._readableState.highWaterMark } }), Object.defineProperty(A.prototype, 'readableBuffer', { enumerable: !1, get: function () { return this._readableState && this._readableState.buffer } }), Object.defineProperty(A.prototype, 'readableFlowing', { enumerable: !1, get: function () { return this._readableState.flowing }, set: function (e) { this._readableState && (this._readableState.flowing = e) } }), A._fromList = U, Object.defineProperty(A.prototype, 'readableLength', { enumerable: !1, get: function () { return this._readableState.length } }), typeof Symbol === 'function' && (A.from = function (e, t) { return void 0 === h && (h = n(5167)), h(A, e, t) }) }, 4605: (e, t, n) => { 'use strict'; e.exports = l; const r = n(4281).q; const i = r.ERR_METHOD_NOT_IMPLEMENTED; const o = r.ERR_MULTIPLE_CALLBACK; const a = r.ERR_TRANSFORM_ALREADY_TRANSFORMING; const s = r.ERR_TRANSFORM_WITH_LENGTH_0; const c = n(6753); function u (e, t) { const n = this._transformState; n.transforming = !1; const r = n.writecb; if (r === null) return this.emit('error', new o()); n.writechunk = null, n.writecb = null, t != null && this.push(t), r(e); const i = this._readableState; i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark) } function l (e) { if (!(this instanceof l)) return new l(e); c.call(this, e), this._transformState = { afterTransform: u.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform === 'function' && (this._transform = e.transform), typeof e.flush === 'function' && (this._flush = e.flush)), this.on('prefinish', d) } function d () { const e = this; typeof this._flush !== 'function' || this._readableState.destroyed ? f(this, null, null) : this._flush(function (t, n) { f(e, t, n) }) } function f (e, t, n) { if (t) return e.emit('error', t); if (n != null && e.push(n), e._writableState.length) throw new s(); if (e._transformState.transforming) throw new a(); return e.push(null) }n(5717)(l, c), l.prototype.push = function (e, t) { return this._transformState.needTransform = !1, c.prototype.push.call(this, e, t) }, l.prototype._transform = function (e, t, n) { n(new i('_transform()')) }, l.prototype._write = function (e, t, n) { const r = this._transformState; if (r.writecb = n, r.writechunk = e, r.writeencoding = t, !r.transforming) { const i = this._readableState; (r.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark) } }, l.prototype._read = function (e) { const t = this._transformState; t.writechunk === null || t.transforming ? t.needTransform = !0 : (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) }, l.prototype._destroy = function (e, t) { c.prototype._destroy.call(this, e, function (e) { t(e) }) } }, 4229: (e, t, n) => { 'use strict'; let r; const i = n(4155); function o (e) { const t = this; this.next = null, this.entry = null, this.finish = function () { !(function (e, t, n) { let r = e.entry; e.entry = null; for (;r;) { const i = r.callback; t.pendingcb--, i(n), r = r.next }t.corkedRequestsFree.next = e }(t, e)) } }e.exports = A, A.WritableState = S; const a = { deprecate: n(4927) }; const s = n(2503); const c = n(8764).Buffer; const u = n.g.Uint8Array || function () {}; let l; const d = n(1195); const f = n(2457).getHighWaterMark; const h = n(4281).q; const p = h.ERR_INVALID_ARG_TYPE; const g = h.ERR_METHOD_NOT_IMPLEMENTED; const m = h.ERR_MULTIPLE_CALLBACK; const y = h.ERR_STREAM_CANNOT_PIPE; const b = h.ERR_STREAM_DESTROYED; const v = h.ERR_STREAM_NULL_VALUES; const w = h.ERR_STREAM_WRITE_AFTER_END; const _ = h.ERR_UNKNOWN_ENCODING; const E = d.errorOrDestroy; function k () {} function S (e, t, a) { r = r || n(6753), e = e || {}, typeof a !== 'boolean' && (a = t instanceof r), this.objectMode = !!e.objectMode, a && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = f(this, e, 'writableHighWaterMark', a), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1; const s = !1 === e.decodeStrings; this.decodeStrings = !s, this.defaultEncoding = e.defaultEncoding || 'utf8', this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (e) { !(function (e, t) { const n = e._writableState; const r = n.sync; const o = n.writecb; if (typeof o !== 'function') throw new m(); if ((function (e) { e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0 }(n)), t)!(function (e, t, n, r, o) { --t.pendingcb, n ? (i.nextTick(o, r), i.nextTick(R, e, t), e._writableState.errorEmitted = !0, E(e, r)) : (o(r), e._writableState.errorEmitted = !0, E(e, r), R(e, t)) }(e, n, r, t, o)); else { const a = N(n) || e.destroyed; a || n.corked || n.bufferProcessing || !n.bufferedRequest || I(e, n), r ? i.nextTick(x, e, n, a, o) : x(e, n, a, o) } }(t, e)) }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new o(this) } function A (e) { const t = this instanceof (r = r || n(6753)); if (!t && !l.call(A, this)) return new A(e); this._writableState = new S(e, this, t), this.writable = !0, e && (typeof e.write === 'function' && (this._write = e.write), typeof e.writev === 'function' && (this._writev = e.writev), typeof e.destroy === 'function' && (this._destroy = e.destroy), typeof e.final === 'function' && (this._final = e.final)), s.call(this) } function O (e, t, n, r, i, o, a) { t.writelen = r, t.writecb = a, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new b('write')) : n ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1 } function x (e, t, n, r) { n || (function (e, t) { t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit('drain')) }(e, t)), t.pendingcb--, r(), R(e, t) } function I (e, t) { t.bufferProcessing = !0; let n = t.bufferedRequest; if (e._writev && n && n.next) { const r = t.bufferedRequestCount; const i = new Array(r); const a = t.corkedRequestsFree; a.entry = n; for (var s = 0, c = !0; n;)i[s] = n, n.isBuf || (c = !1), n = n.next, s += 1; i.allBuffers = c, O(e, t, !0, t.length, i, '', a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new o(t), t.bufferedRequestCount = 0 } else { for (;n;) { const u = n.chunk; const l = n.encoding; const d = n.callback; if (O(e, t, !1, t.objectMode ? 1 : u.length, u, l, d), n = n.next, t.bufferedRequestCount--, t.writing) break }n === null && (t.lastBufferedRequest = null) }t.bufferedRequest = n, t.bufferProcessing = !1 } function N (e) { return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing } function T (e, t) { e._final(function (n) { t.pendingcb--, n && E(e, n), t.prefinished = !0, e.emit('prefinish'), R(e, t) }) } function R (e, t) { const n = N(t); if (n && ((function (e, t) { t.prefinished || t.finalCalled || (typeof e._final !== 'function' || t.destroyed ? (t.prefinished = !0, e.emit('prefinish')) : (t.pendingcb++, t.finalCalled = !0, i.nextTick(T, e, t))) }(e, t)), t.pendingcb === 0 && (t.finished = !0, e.emit('finish'), t.autoDestroy))) { const r = e._readableState; (!r || r.autoDestroy && r.endEmitted) && e.destroy() } return n }n(5717)(A, s), S.prototype.getBuffer = function () { for (var e = this.bufferedRequest, t = []; e;)t.push(e), e = e.next; return t }, (function () { try { Object.defineProperty(S.prototype, 'buffer', { get: a.deprecate(function () { return this.getBuffer() }, '_writableState.buffer is deprecated. Use _writableState.getBuffer instead.', 'DEP0003') }) } catch (e) {} }()), typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function' ? (l = Function.prototype[Symbol.hasInstance], Object.defineProperty(A, Symbol.hasInstance, { value: function (e) { return !!l.call(this, e) || this === A && (e && e._writableState instanceof S) } })) : l = function (e) { return e instanceof this }, A.prototype.pipe = function () { E(this, new y()) }, A.prototype.write = function (e, t, n) { let r; const o = this._writableState; let a = !1; const s = !o.objectMode && (r = e, c.isBuffer(r) || r instanceof u); return s && !c.isBuffer(e) && (e = (function (e) { return c.from(e) }(e))), typeof t === 'function' && (n = t, t = null), s ? t = 'buffer' : t || (t = o.defaultEncoding), typeof n !== 'function' && (n = k), o.ending ? (function (e, t) { const n = new w(); E(e, n), i.nextTick(t, n) }(this, n)) : (s || (function (e, t, n, r) { let o; return n === null ? o = new v() : typeof n === 'string' || t.objectMode || (o = new p('chunk', ['string', 'Buffer'], n)), !o || (E(e, o), i.nextTick(r, o), !1) }(this, o, e, n))) && (o.pendingcb++, a = (function (e, t, n, r, i, o) { if (!n) { const a = (function (e, t, n) { e.objectMode || !1 === e.decodeStrings || typeof t !== 'string' || (t = c.from(t, n)); return t }(t, r, i)); r !== a && (n = !0, i = 'buffer', r = a) } const s = t.objectMode ? 1 : r.length; t.length += s; const u = t.length < t.highWaterMark; u || (t.needDrain = !0); if (t.writing || t.corked) { const l = t.lastBufferedRequest; t.lastBufferedRequest = { chunk: r, encoding: i, isBuf: n, callback: o, next: null }, l ? l.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1 } else O(e, t, !1, s, r, i, o); return u }(this, o, s, e, t, n))), a }, A.prototype.cork = function () { this._writableState.corked++ }, A.prototype.uncork = function () { const e = this._writableState; e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || I(this, e)) }, A.prototype.setDefaultEncoding = function (e) { if (typeof e === 'string' && (e = e.toLowerCase()), !(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((e + '').toLowerCase()) > -1)) throw new _(e); return this._writableState.defaultEncoding = e, this }, Object.defineProperty(A.prototype, 'writableBuffer', { enumerable: !1, get: function () { return this._writableState && this._writableState.getBuffer() } }), Object.defineProperty(A.prototype, 'writableHighWaterMark', { enumerable: !1, get: function () { return this._writableState.highWaterMark } }), A.prototype._write = function (e, t, n) { n(new g('_write()')) }, A.prototype._writev = null, A.prototype.end = function (e, t, n) { const r = this._writableState; return typeof e === 'function' ? (n = e, e = null, t = null) : typeof t === 'function' && (n = t, t = null), e != null && this.write(e, t), r.corked && (r.corked = 1, this.uncork()), r.ending || (function (e, t, n) { t.ending = !0, R(e, t), n && (t.finished ? i.nextTick(n) : e.once('finish', n)); t.ended = !0, e.writable = !1 }(this, r, n)), this }, Object.defineProperty(A.prototype, 'writableLength', { enumerable: !1, get: function () { return this._writableState.length } }), Object.defineProperty(A.prototype, 'destroyed', { enumerable: !1, get: function () { return void 0 !== this._writableState && this._writableState.destroyed }, set: function (e) { this._writableState && (this._writableState.destroyed = e) } }), A.prototype.destroy = d.destroy, A.prototype._undestroy = d.undestroy, A.prototype._destroy = function (e, t) { t(e) } }, 5850: (e, t, n) => { 'use strict'; let r; const i = n(4155); function o (e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } const a = n(8610); const s = Symbol('lastResolve'); const c = Symbol('lastReject'); const u = Symbol('error'); const l = Symbol('ended'); const d = Symbol('lastPromise'); const f = Symbol('handlePromise'); const h = Symbol('stream'); function p (e, t) { return { value: e, done: t } } function g (e) { const t = e[s]; if (t !== null) { const n = e[h].read(); n !== null && (e[d] = null, e[s] = null, e[c] = null, t(p(n, !1))) } } function m (e) { i.nextTick(g, e) } const y = Object.getPrototypeOf(function () {}); const b = Object.setPrototypeOf((o(r = { get stream () { return this[h] }, next: function () { const e = this; const t = this[u]; if (t !== null) return Promise.reject(t); if (this[l]) return Promise.resolve(p(void 0, !0)); if (this[h].destroyed) return new Promise(function (t, n) { i.nextTick(function () { e[u] ? n(e[u]) : t(p(void 0, !0)) }) }); let n; const r = this[d]; if (r)n = new Promise(function (e, t) { return function (n, r) { e.then(function () { t[l] ? n(p(void 0, !0)) : t[f](n, r) }, r) } }(r, this)); else { const o = this[h].read(); if (o !== null) return Promise.resolve(p(o, !1)); n = new Promise(this[f]) } return this[d] = n, n } }, Symbol.asyncIterator, function () { return this }), o(r, 'return', function () { const e = this; return new Promise(function (t, n) { e[h].destroy(null, function (e) { e ? n(e) : t(p(void 0, !0)) }) }) }), r), y); e.exports = function (e) { let t; var n = Object.create(b, (o(t = {}, h, { value: e, writable: !0 }), o(t, s, { value: null, writable: !0 }), o(t, c, { value: null, writable: !0 }), o(t, u, { value: null, writable: !0 }), o(t, l, { value: e._readableState.endEmitted, writable: !0 }), o(t, f, { value: function (e, t) { const r = n[h].read(); r ? (n[d] = null, n[s] = null, n[c] = null, e(p(r, !1))) : (n[s] = e, n[c] = t) }, writable: !0 }), t)); return n[d] = null, a(e, function (e) { if (e && e.code !== 'ERR_STREAM_PREMATURE_CLOSE') { const t = n[c]; return t !== null && (n[d] = null, n[s] = null, n[c] = null, t(e)), void (n[u] = e) } const r = n[s]; r !== null && (n[d] = null, n[s] = null, n[c] = null, r(p(void 0, !0))), n[l] = !0 }), e.on('readable', m.bind(null, n)), n } }, 7327: (e, t, n) => { 'use strict'; function r (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function i (e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function o (e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } const a = n(8764).Buffer; const s = n(2361).inspect; const c = s && s.custom || 'inspect'; e.exports = (function () { function e () { !(function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') }(this, e)), this.head = null, this.tail = null, this.length = 0 } let t, n, u; return t = e, n = [{ key: 'push', value: function (e) { const t = { data: e, next: null }; this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length } }, { key: 'unshift', value: function (e) { const t = { data: e, next: this.head }; this.length === 0 && (this.tail = t), this.head = t, ++this.length } }, { key: 'shift', value: function () { if (this.length !== 0) { const e = this.head.data; return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e } } }, { key: 'clear', value: function () { this.head = this.tail = null, this.length = 0 } }, { key: 'join', value: function (e) { if (this.length === 0) return ''; for (var t = this.head, n = '' + t.data; t = t.next;)n += e + t.data; return n } }, { key: 'concat', value: function (e) { if (this.length === 0) return a.alloc(0); for (var t, n, r, i = a.allocUnsafe(e >>> 0), o = this.head, s = 0; o;)t = o.data, n = i, r = s, a.prototype.copy.call(t, n, r), s += o.data.length, o = o.next; return i } }, { key: 'consume', value: function (e, t) { let n; return e < this.head.data.length ? (n = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : n = e === this.head.data.length ? this.shift() : t ? this._getString(e) : this._getBuffer(e), n } }, { key: 'first', value: function () { return this.head.data } }, { key: '_getString', value: function (e) { let t = this.head; let n = 1; let r = t.data; for (e -= r.length; t = t.next;) { const i = t.data; const o = e > i.length ? i.length : e; if (o === i.length ? r += i : r += i.slice(0, e), (e -= o) == 0) { o === i.length ? (++n, t.next ? this.head = t.next : this.head = this.tail = null) : (this.head = t, t.data = i.slice(o)); break }++n } return this.length -= n, r } }, { key: '_getBuffer', value: function (e) { const t = a.allocUnsafe(e); let n = this.head; let r = 1; for (n.data.copy(t), e -= n.data.length; n = n.next;) { const i = n.data; const o = e > i.length ? i.length : e; if (i.copy(t, t.length - e, 0, o), (e -= o) == 0) { o === i.length ? (++r, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = i.slice(o)); break }++r } return this.length -= r, t } }, { key: c, value: function (e, t) { return s(this, (function (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? r(Object(n), !0).forEach(function (t) { i(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e }({}, t, { depth: 0, customInspect: !1 }))) } }], n && o(t.prototype, n), u && o(t, u), e }()) }, 1195: (e, t, n) => { 'use strict'; const r = n(4155); function i (e, t) { a(e, t), o(e) } function o (e) { e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit('close') } function a (e, t) { e.emit('error', t) }e.exports = { destroy: function (e, t) { const n = this; const s = this._readableState && this._readableState.destroyed; const c = this._writableState && this._writableState.destroyed; return s || c ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, r.nextTick(a, this, e)) : r.nextTick(a, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function (e) { !t && e ? n._writableState ? n._writableState.errorEmitted ? r.nextTick(o, n) : (n._writableState.errorEmitted = !0, r.nextTick(i, n, e)) : r.nextTick(i, n, e) : t ? (r.nextTick(o, n), t(e)) : r.nextTick(o, n) }), this) }, undestroy: function () { this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1) }, errorOrDestroy: function (e, t) { const n = e._readableState; const r = e._writableState; n && n.autoDestroy || r && r.autoDestroy ? e.destroy(t) : e.emit('error', t) } } }, 8610: (e, t, n) => { 'use strict'; const r = n(4281).q.ERR_STREAM_PREMATURE_CLOSE; function i () {}e.exports = function e (t, n, o) { if (typeof n === 'function') return e(t, null, n); n || (n = {}), o = (function (e) { let t = !1; return function () { if (!t) { t = !0; for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; e.apply(this, r) } } }(o || i)); let a = n.readable || !1 !== n.readable && t.readable; let s = n.writable || !1 !== n.writable && t.writable; const c = function () { t.writable || l() }; let u = t._writableState && t._writableState.finished; var l = function () { s = !1, u = !0, a || o.call(t) }; let d = t._readableState && t._readableState.endEmitted; const f = function () { a = !1, d = !0, s || o.call(t) }; const h = function (e) { o.call(t, e) }; const p = function () { let e; return a && !d ? (t._readableState && t._readableState.ended || (e = new r()), o.call(t, e)) : s && !u ? (t._writableState && t._writableState.ended || (e = new r()), o.call(t, e)) : void 0 }; const g = function () { t.req.on('finish', l) }; return !(function (e) { return e.setHeader && typeof e.abort === 'function' }(t)) ? s && !t._writableState && (t.on('end', c), t.on('close', c)) : (t.on('complete', l), t.on('abort', p), t.req ? g() : t.on('request', g)), t.on('end', f), t.on('finish', l), !1 !== n.error && t.on('error', h), t.on('close', p), function () { t.removeListener('complete', l), t.removeListener('abort', p), t.removeListener('request', g), t.req && t.req.removeListener('finish', l), t.removeListener('end', c), t.removeListener('close', c), t.removeListener('finish', l), t.removeListener('end', f), t.removeListener('error', h), t.removeListener('close', p) } } }, 5167: e => { e.exports = function () { throw new Error('Readable.from is not available in the browser') } }, 9946: (e, t, n) => { 'use strict'; let r; const i = n(4281).q; const o = i.ERR_MISSING_ARGS; const a = i.ERR_STREAM_DESTROYED; function s (e) { if (e) throw e } function c (e) { e() } function u (e, t) { return e.pipe(t) }e.exports = function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; let l; const d = (function (e) { return e.length ? typeof e[e.length - 1] !== 'function' ? s : e.pop() : s }(t)); if (Array.isArray(t[0]) && (t = t[0]), t.length < 2) throw new o('streams'); var f = t.map(function (e, i) { const o = i < t.length - 1; return (function (e, t, i, o) { o = (function (e) { let t = !1; return function () { t || (t = !0, e.apply(void 0, arguments)) } }(o)); let s = !1; e.on('close', function () { s = !0 }), void 0 === r && (r = n(8610)), r(e, { readable: t, writable: i }, function (e) { if (e) return o(e); s = !0, o() }); let c = !1; return function (t) { if (!s && !c) return c = !0, (function (e) { return e.setHeader && typeof e.abort === 'function' }(e)) ? e.abort() : typeof e.destroy === 'function' ? e.destroy() : void o(t || new a('pipe')) } }(e, o, i > 0, function (e) { l || (l = e), e && f.forEach(c), o || (f.forEach(c), d(l)) })) }); return t.reduce(u) } }, 2457: (e, t, n) => { 'use strict'; const r = n(4281).q.ERR_INVALID_OPT_VALUE; e.exports = { getHighWaterMark: function (e, t, n, i) { const o = (function (e, t, n) { return e.highWaterMark != null ? e.highWaterMark : t ? e[n] : null }(t, i, n)); if (o != null) { if (!isFinite(o) || Math.floor(o) !== o || o < 0) throw new r(i ? n : 'highWaterMark', o); return Math.floor(o) } return e.objectMode ? 16 : 16384 } } }, 2503: (e, t, n) => { e.exports = n(7187).EventEmitter }, 8473: (e, t, n) => { (t = e.exports = n(9481)).Stream = t, t.Readable = t, t.Writable = n(4229), t.Duplex = n(6753), t.Transform = n(4605), t.PassThrough = n(2725), t.finished = n(8610), t.pipeline = n(9946) }, 3694: (e, t, n) => { let r; const i = n(8764).Buffer; e.exports = (function () { function e (t, n, r) { function i (a, s) { if (!n[a]) { if (!t[a]) { if (o) return o(a, !0); const c = new Error("Cannot find module '" + a + "'"); throw c.code = 'MODULE_NOT_FOUND', c } const u = n[a] = { exports: {} }; t[a][0].call(u.exports, function (e) { return i(t[a][1][e] || e) }, u, u.exports, e, t, n, r) } return n[a].exports } for (var o = void 0, a = 0; a < r.length; a++)i(r[a]); return i } return e }())({ 1: [function (e, t, r) { 'use strict'; const i = e('domexception'); const o = e('typeson'); const a = e('typeson-registry/dist/presets/structured-cloning-throwing'); const s = typeof window !== 'undefined' ? window : typeof WorkerGlobalScope !== 'undefined' ? self : void 0 !== n.g ? n.g : Function('return this;')(); s.DOMException || (s.DOMException = i); const c = (new o()).register(a); function u (e) { return c.revive(c.encapsulate(e)) }t.exports = u }, { domexception: 5, typeson: 8, 'typeson-registry/dist/presets/structured-cloning-throwing': 7 }], 2: [function (e, t, n) { 'use strict'; const r = (function () { function e (e, t) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !t || n.length !== t); r = !0); } catch (e) { i = !0, o = e } finally { try { !r && s.return && s.return() } finally { if (i) throw o } } return n } return function (t, n) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return e(t, n); throw new TypeError('Invalid attempt to destructure non-iterable instance') } }()); const i = (function () { function e (e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }()); function o (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') } const a = e('./legacy-error-codes.json'); const s = e('./utils.js'); n.implementation = (function () { function e (t) { const n = r(t, 2); const i = n[0]; const a = n[1]; o(this, e), this.name = a, this.message = i } return i(e, [{ key: 'code', get: function () { return a[this.name] || 0 } }]), e }()), n.init = function (e) { if (Error.captureStackTrace) { const t = s.wrapperForImpl(e); Error.captureStackTrace(t, t.constructor) } } }, { './legacy-error-codes.json': 4, './utils.js': 6 }], 3: [function (e, t, n) { 'use strict'; const r = e('webidl-conversions'); const i = e('./utils.js'); const o = i.implSymbol; function a () { for (var e = [], t = 0; t < arguments.length && t < 2; ++t)e[t] = arguments[t]; void 0 !== e[0] ? e[0] = r.DOMString(e[0], { context: "Failed to construct 'DOMException': parameter 1" }) : e[0] = '', void 0 !== e[1] ? e[1] = r.DOMString(e[1], { context: "Failed to construct 'DOMException': parameter 2" }) : e[1] = 'Error', s.setup(this, e) }Object.defineProperty(a, 'prototype', { value: a.prototype, writable: !1, enumerable: !1, configurable: !1 }), Object.defineProperty(a.prototype, 'name', { get: function () { return this[o].name }, enumerable: !0, configurable: !0 }), Object.defineProperty(a.prototype, 'message', { get: function () { return this[o].message }, enumerable: !0, configurable: !0 }), Object.defineProperty(a.prototype, 'code', { get: function () { return this[o].code }, enumerable: !0, configurable: !0 }), Object.defineProperty(a, 'INDEX_SIZE_ERR', { value: 1, enumerable: !0 }), Object.defineProperty(a.prototype, 'INDEX_SIZE_ERR', { value: 1, enumerable: !0 }), Object.defineProperty(a, 'DOMSTRING_SIZE_ERR', { value: 2, enumerable: !0 }), Object.defineProperty(a.prototype, 'DOMSTRING_SIZE_ERR', { value: 2, enumerable: !0 }), Object.defineProperty(a, 'HIERARCHY_REQUEST_ERR', { value: 3, enumerable: !0 }), Object.defineProperty(a.prototype, 'HIERARCHY_REQUEST_ERR', { value: 3, enumerable: !0 }), Object.defineProperty(a, 'WRONG_DOCUMENT_ERR', { value: 4, enumerable: !0 }), Object.defineProperty(a.prototype, 'WRONG_DOCUMENT_ERR', { value: 4, enumerable: !0 }), Object.defineProperty(a, 'INVALID_CHARACTER_ERR', { value: 5, enumerable: !0 }), Object.defineProperty(a.prototype, 'INVALID_CHARACTER_ERR', { value: 5, enumerable: !0 }), Object.defineProperty(a, 'NO_DATA_ALLOWED_ERR', { value: 6, enumerable: !0 }), Object.defineProperty(a.prototype, 'NO_DATA_ALLOWED_ERR', { value: 6, enumerable: !0 }), Object.defineProperty(a, 'NO_MODIFICATION_ALLOWED_ERR', { value: 7, enumerable: !0 }), Object.defineProperty(a.prototype, 'NO_MODIFICATION_ALLOWED_ERR', { value: 7, enumerable: !0 }), Object.defineProperty(a, 'NOT_FOUND_ERR', { value: 8, enumerable: !0 }), Object.defineProperty(a.prototype, 'NOT_FOUND_ERR', { value: 8, enumerable: !0 }), Object.defineProperty(a, 'NOT_SUPPORTED_ERR', { value: 9, enumerable: !0 }), Object.defineProperty(a.prototype, 'NOT_SUPPORTED_ERR', { value: 9, enumerable: !0 }), Object.defineProperty(a, 'INUSE_ATTRIBUTE_ERR', { value: 10, enumerable: !0 }), Object.defineProperty(a.prototype, 'INUSE_ATTRIBUTE_ERR', { value: 10, enumerable: !0 }), Object.defineProperty(a, 'INVALID_STATE_ERR', { value: 11, enumerable: !0 }), Object.defineProperty(a.prototype, 'INVALID_STATE_ERR', { value: 11, enumerable: !0 }), Object.defineProperty(a, 'SYNTAX_ERR', { value: 12, enumerable: !0 }), Object.defineProperty(a.prototype, 'SYNTAX_ERR', { value: 12, enumerable: !0 }), Object.defineProperty(a, 'INVALID_MODIFICATION_ERR', { value: 13, enumerable: !0 }), Object.defineProperty(a.prototype, 'INVALID_MODIFICATION_ERR', { value: 13, enumerable: !0 }), Object.defineProperty(a, 'NAMESPACE_ERR', { value: 14, enumerable: !0 }), Object.defineProperty(a.prototype, 'NAMESPACE_ERR', { value: 14, enumerable: !0 }), Object.defineProperty(a, 'INVALID_ACCESS_ERR', { value: 15, enumerable: !0 }), Object.defineProperty(a.prototype, 'INVALID_ACCESS_ERR', { value: 15, enumerable: !0 }), Object.defineProperty(a, 'VALIDATION_ERR', { value: 16, enumerable: !0 }), Object.defineProperty(a.prototype, 'VALIDATION_ERR', { value: 16, enumerable: !0 }), Object.defineProperty(a, 'TYPE_MISMATCH_ERR', { value: 17, enumerable: !0 }), Object.defineProperty(a.prototype, 'TYPE_MISMATCH_ERR', { value: 17, enumerable: !0 }), Object.defineProperty(a, 'SECURITY_ERR', { value: 18, enumerable: !0 }), Object.defineProperty(a.prototype, 'SECURITY_ERR', { value: 18, enumerable: !0 }), Object.defineProperty(a, 'NETWORK_ERR', { value: 19, enumerable: !0 }), Object.defineProperty(a.prototype, 'NETWORK_ERR', { value: 19, enumerable: !0 }), Object.defineProperty(a, 'ABORT_ERR', { value: 20, enumerable: !0 }), Object.defineProperty(a.prototype, 'ABORT_ERR', { value: 20, enumerable: !0 }), Object.defineProperty(a, 'URL_MISMATCH_ERR', { value: 21, enumerable: !0 }), Object.defineProperty(a.prototype, 'URL_MISMATCH_ERR', { value: 21, enumerable: !0 }), Object.defineProperty(a, 'QUOTA_EXCEEDED_ERR', { value: 22, enumerable: !0 }), Object.defineProperty(a.prototype, 'QUOTA_EXCEEDED_ERR', { value: 22, enumerable: !0 }), Object.defineProperty(a, 'TIMEOUT_ERR', { value: 23, enumerable: !0 }), Object.defineProperty(a.prototype, 'TIMEOUT_ERR', { value: 23, enumerable: !0 }), Object.defineProperty(a, 'INVALID_NODE_TYPE_ERR', { value: 24, enumerable: !0 }), Object.defineProperty(a.prototype, 'INVALID_NODE_TYPE_ERR', { value: 24, enumerable: !0 }), Object.defineProperty(a, 'DATA_CLONE_ERR', { value: 25, enumerable: !0 }), Object.defineProperty(a.prototype, 'DATA_CLONE_ERR', { value: 25, enumerable: !0 }), Object.defineProperty(a.prototype, Symbol.toStringTag, { value: 'DOMException', writable: !1, enumerable: !1, configurable: !0 }); var s = { mixedInto: [], is: function (e) { if (e) { if (e[o] instanceof c.implementation) return !0; for (let n = 0; n < t.exports.mixedInto.length; ++n) if (e instanceof t.exports.mixedInto[n]) return !0 } return !1 }, isImpl: function (e) { if (e) { if (e instanceof c.implementation) return !0; for (let n = i.wrapperForImpl(e), r = 0; r < t.exports.mixedInto.length; ++r) if (n instanceof t.exports.mixedInto[r]) return !0 } return !1 }, convert: function (e) { const n = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).context; const r = void 0 === n ? 'The provided value' : n; if (t.exports.is(e)) return i.implForWrapper(e); throw new TypeError(r + " is not of type 'DOMException'.") }, create: function (e, t) { const n = Object.create(a.prototype); return this.setup(n, e, t), n }, createImpl: function (e, t) { const n = Object.create(a.prototype); return this.setup(n, e, t), i.implForWrapper(n) }, _internalSetup: function (e) {}, setup: function (e, t, n) { n || (n = {}), n.wrapper = e, this._internalSetup(e), Object.defineProperty(e, o, { value: new c.implementation(t, n), writable: !1, enumerable: !1, configurable: !0 }), e[o][i.wrapperSymbol] = e, c.init && c.init(e[o], n) }, interface: a, expose: { Window: { DOMException: a }, Worker: { DOMException: a } } }; t.exports = s; var c = e('.//DOMException-impl.js') }, { './/DOMException-impl.js': 2, './utils.js': 6, 'webidl-conversions': 9 }], 4: [function (e, t, n) { t.exports = { IndexSizeError: 1, DOMStringSizeError: 2, HierarchyRequestError: 3, WrongDocumentError: 4, InvalidCharacterError: 5, NoDataAllowedError: 6, NoModificationAllowedError: 7, NotFoundError: 8, NotSupportedError: 9, InUseAttributeError: 10, InvalidStateError: 11, SyntaxError: 12, InvalidModificationError: 13, NamespaceError: 14, InvalidAccessError: 15, ValidationError: 16, TypeMismatchError: 17, SecurityError: 18, NetworkError: 19, AbortError: 20, URLMismatchError: 21, QuotaExceededError: 22, TimeoutError: 23, InvalidNodeTypeError: 24, DataCloneError: 25 } }, {}], 5: [function (e, t, n) { 'use strict'; t.exports = e('./DOMException').interface, Object.setPrototypeOf(t.exports.prototype, Error.prototype) }, { './DOMException': 3 }], 6: [function (e, t, n) { 'use strict'; const r = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; function o (e) { return (void 0 === e ? 'undefined' : r(e)) === 'object' && e !== null || typeof e === 'function' } function a (e) { return Object.getPrototypeOf(e) === i.prototype ? e : e instanceof ArrayBuffer ? i.from(e) : i.from(e.buffer, e.byteOffset, e.byteLength) } function s (e) { return i.from(a(e)) } function c (e, t) { for (let n = Object.getOwnPropertyNames(t), r = 0; r < n.length; ++r)n[r] in e || Object.defineProperty(e, n[r], Object.getOwnPropertyDescriptor(t, n[r])) } const u = Symbol('wrapper'); const l = Symbol('impl'); const d = Symbol('SameObject caches'); function f (e, t, n) { return e[d] || (e[d] = Object.create(null)), t in e[d] || (e[d][t] = n()), e[d][t] } function h (e) { return e ? e[u] : null } function p (e) { return e ? e[l] : null } function g (e) { const t = h(e); return t || e } function m (e) { const t = p(e); return t || e } const y = Symbol('internal'); const b = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())); t.exports = { isObject: o, getReferenceToBytes: a, getCopyToBytes: s, mixin: c, wrapperSymbol: u, implSymbol: l, getSameObject: f, wrapperForImpl: h, implForWrapper: p, tryWrapperForImpl: g, tryImplForWrapper: m, iterInternalSymbol: y, IteratorPrototype: b } }, {}], 7: [function (e, t, i) { 'use strict'; let o; let a; const s = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; o = void 0, a = function () { function e (t) { return (e = typeof Symbol === 'function' && s(Symbol.iterator) == 'symbol' ? function (e) { return void 0 === e ? 'undefined' : s(e) } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : void 0 === e ? 'undefined' : s(e) })(t) } function t (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') } function r (e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } function i (e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function o (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function a (e) { return (function (e) { if (Array.isArray(e)) return c(e) }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && Symbol.iterator in Object(e)) return Array.from(e) }(e)) || (function (e, t) { if (e) { if (typeof e === 'string') return c(e, t); let n = Object.prototype.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? c(e, t) : void 0 } }(e)) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.') }()) } function c (e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } function u (e) { return (u = typeof Symbol === 'function' && s(Symbol.iterator) == 'symbol' ? function (e) { return void 0 === e ? 'undefined' : s(e) } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : void 0 === e ? 'undefined' : s(e) })(e) } function l (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') } function d (e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } function f (e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function h (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function p (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? h(Object(n), !0).forEach(function (t) { f(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : h(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function g (e, t) { return (function (e) { if (Array.isArray(e)) return e }(e)) || (function (e, t) { if (typeof Symbol !== 'undefined' && Symbol.iterator in Object(e)) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !t || n.length !== t); r = !0); } catch (e) { i = !0, o = e } finally { try { r || s.return == null || s.return() } finally { if (i) throw o } } return n } }(e, t)) || y(e, t) || (function () { throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.') }()) } function m (e) { return (function (e) { if (Array.isArray(e)) return b(e) }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && Symbol.iterator in Object(e)) return Array.from(e) }(e)) || y(e) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.') }()) } function y (e, t) { if (e) { if (typeof e === 'string') return b(e, t); let n = Object.prototype.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? b(e, t) : void 0 } } function b (e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } const v = function e (t) { l(this, e), this.p = new Promise(t) }; v.__typeson__type__ = 'TypesonPromise', typeof Symbol !== 'undefined' && (v.prototype[Symbol.toStringTag] = 'TypesonPromise'), v.prototype.then = function (e, t) { const n = this; return new v(function (r, i) { n.p.then(function (t) { r(e ? e(t) : t) }).catch(function (e) { return t ? t(e) : Promise.reject(e) }).then(r, i) }) }, v.prototype.catch = function (e) { return this.then(null, e) }, v.resolve = function (e) { return new v(function (t) { t(e) }) }, v.reject = function (e) { return new v(function (t, n) { n(e) }) }, ['all', 'race'].forEach(function (e) { v[e] = function (t) { return new v(function (n, r) { Promise[e](t.map(function (e) { return e && e.constructor && e.constructor.__typeson__type__ === 'TypesonPromise' ? e.p : e })).then(n, r) }) } }); const w = {}.toString; const _ = {}.hasOwnProperty; const E = Object.getPrototypeOf; const k = _.toString; function S (e, t) { return I(e) && typeof e.then === 'function' && (!t || typeof e.catch === 'function') } function A (e) { return w.call(e).slice(8, -1) } function O (e, t) { if (!e || u(e) !== 'object') return !1; const n = E(e); if (!n) return t === null; const r = _.call(n, 'constructor') && n.constructor; return typeof r !== 'function' ? t === null : t === r || t !== null && k.call(r) === k.call(t) || typeof t === 'function' && typeof r.__typeson__type__ === 'string' && r.__typeson__type__ === t.__typeson__type__ } function x (e) { return !(!e || A(e) !== 'Object') && (!E(e) || O(e, Object)) } function I (e) { return e && u(e) === 'object' } function N (e) { return e.replace(/~/g, '~0').replace(/\./g, '~1') } function T (e) { return e.replace(/~1/g, '.').replace(/~0/g, '~') } function R (e, t) { if (t === '') return e; const n = t.indexOf('.'); if (n > -1) { const r = e[T(t.slice(0, n))]; return void 0 === r ? void 0 : R(r, t.slice(n + 1)) } return e[T(t)] } function P (e, t, n) { if (t === '') return n; const r = t.indexOf('.'); return r > -1 ? P(e[T(t.slice(0, r))], t.slice(r + 1), n) : (e[T(t)] = n, e) } function C (e, t, n) { return n ? t ? t(e) : e : (e && e.then || (e = Promise.resolve(e)), t ? e.then(t) : e) } const B = Object.keys; const L = Array.isArray; const j = {}.hasOwnProperty; const D = ['type', 'replaced', 'iterateIn', 'iterateUnsetNumeric']; function U (e) { return function () { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; try { return Promise.resolve(e.apply(this, t)) } catch (e) { return Promise.reject(e) } } } function M (e, t) { if (e.keypath === '') return -1; let n = e.keypath.match(/\./g) || 0; let r = t.keypath.match(/\./g) || 0; return n && (n = n.length), r && (r = r.length), n > r ? -1 : n < r ? 1 : e.keypath < t.keypath ? -1 : e.keypath > t.keypath } const z = (function () { function e (t) { l(this, e), this.options = t, this.plainObjectReplacers = [], this.nonplainObjectReplacers = [], this.revivers = {}, this.types = {} } return (function (e, t, n) { t && d(e.prototype, t), n && d(e, n) }(e, [{ key: 'stringify', value: function (e, t, n, r) { r = p(p(p({}, this.options), r), {}, { stringification: !0 }); const i = this.encapsulate(e, null, r); return L(i) ? JSON.stringify(i[0], t, n) : i.then(function (e) { return JSON.stringify(e, t, n) }) } }, { key: 'stringifySync', value: function (e, t, n, r) { return this.stringify(e, t, n, p(p({ throwOnBadSyncType: !0 }, r), {}, { sync: !0 })) } }, { key: 'stringifyAsync', value: function (e, t, n, r) { return this.stringify(e, t, n, p(p({ throwOnBadSyncType: !0 }, r), {}, { sync: !1 })) } }, { key: 'parse', value: function (e, t, n) { return n = p(p(p({}, this.options), n), {}, { parse: !0 }), this.revive(JSON.parse(e, t), n) } }, { key: 'parseSync', value: function (e, t, n) { return this.parse(e, t, p(p({ throwOnBadSyncType: !0 }, n), {}, { sync: !0 })) } }, { key: 'parseAsync', value: function (e, t, n) { return this.parse(e, t, p(p({ throwOnBadSyncType: !0 }, n), {}, { sync: !1 })) } }, { key: 'specialTypeNames', value: function (e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return n.returnTypeNames = !0, this.encapsulate(e, t, n) } }, { key: 'rootTypeName', value: function (e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return n.iterateNone = !0, this.encapsulate(e, t, n) } }, { key: 'encapsulate', value: function (t, n, r) { var i = U(function (e, t) { return C(Promise.all(t.map(function (e) { return e[1].p })), function (n) { return C(Promise.all(n.map(U(function (n) { let r = !1; let o = []; let a = g(t.splice(0, 1), 1); let s = g(a[0], 7); let c = s[0]; let u = s[2]; let l = s[3]; let d = s[4]; let f = s[5]; let h = s[6]; let p = _(c, n, u, l, o, !0, h); let m = O(p, v); return (function (e, t) { var n = e(); return n && n.then ? n.then(t) : t(n) }(function(){if(c&&m)return C(p.p,(function(t){return d[f]=t,r=!0,i(e,o)}))}, (function (t) { return r ? t : (c ? d[f] = p : e = m ? p.p : p, i(e, o)) }))) }))), function () { return e }) }) }); const o = (r = p(p({ sync: !0 }, this.options), r)).sync; const a = this; const s = {}; const c = []; const l = []; const d = []; const f = !('cyclic' in r) || r.cyclic; const h = r.encapsulateObserver; const y = _('', t, f, n || {}, d); function b (t) { const n = Object.values(s); if (r.iterateNone) return n.length ? n[0] : e.getJSONType(t); if (n.length) { if (r.returnTypeNames) return m(new Set(n)); t && x(t) && !j.call(t, '$types') ? t.$types = s : t = { $: t, $types: { $: s } } } else I(t) && j.call(t, '$types') && (t = { $: t, $types: !0 }); return !r.returnTypeNames && t } function w (e, t, n) { Object.assign(e, t); const r = D.map(function (t) { const n = e[t]; return delete e[t], n }); n(), D.forEach(function (t, n) { e[t] = r[n] }) } function _ (t, n, i, o, d, f, p) { let g; let m = {}; const y = u(n); const b = h ? function (r) { const a = p || o.type || e.getJSONType(n); h(Object.assign(r || m, { keypath: t, value: n, cyclic: i, stateObj: o, promisesData: d, resolvingTypesonPromise: f, awaitingTypesonPromise: O(n, v) }, { type: a })) } : null; if (['string', 'boolean', 'number', 'undefined'].includes(y)) return void 0 === n || Number.isNaN(n) || n === Number.NEGATIVE_INFINITY || n === Number.POSITIVE_INFINITY ? (g = o.replaced ? n : E(t, n, o, d, !1, f, b)) !== n && (m = { replaced: g }) : g = n, b && b(), g; if (n === null) return b && b(), n; if (i && !o.iterateIn && !o.iterateUnsetNumeric && n && u(n) === 'object') { const k = c.indexOf(n); if (!(k < 0)) return s[t] = '#', b && b({ cyclicKeypath: l[k] }), '#' + l[k]; !0 === i && (c.push(n), l.push(t)) } let S; const A = x(n); const I = L(n); const T = (A || I) && (!a.plainObjectReplacers.length || o.replaced) || o.iterateIn ? n : E(t, n, o, d, A || I, null, b); if (T !== n ? (g = T, m = { replaced: T }) : t === '' && O(n, v) ? (d.push([t, n, i, o, void 0, void 0, o.type]), g = n) : I && o.iterateIn !== 'object' || o.iterateIn === 'array' ? (S = new Array(n.length), m = { clone: S }) : (['function', 'symbol'].includes(u(n)) || 'toJSON' in n || O(n, v) || O(n, Promise) || O(n, ArrayBuffer)) && !A && o.iterateIn !== 'object' ? g = n : (S = {}, o.addLength && (S.length = n.length), m = { clone: S }), b && b(), r.iterateNone) return S || g; if (!S) return g; if (o.iterateIn) { const R = function (e) { const r = { ownKeys: j.call(n, e) }; w(o, r, function () { const r = t + (t ? '.' : '') + N(e); const a = _(r, n[e], Boolean(i), o, d, f); O(a, v) ? d.push([r, a, Boolean(i), o, S, e, o.type]) : void 0 !== a && (S[e] = a) }) }; for (const P in n)R(P); b && b({ endIterateIn: !0, end: !0 }) } else B(n).forEach(function (e) { const r = t + (t ? '.' : '') + N(e); w(o, { ownKeys: !0 }, function () { const t = _(r, n[e], Boolean(i), o, d, f); O(t, v) ? d.push([r, t, Boolean(i), o, S, e, o.type]) : void 0 !== t && (S[e] = t) }) }), b && b({ endIterateOwn: !0, end: !0 }); if (o.iterateUnsetNumeric) { for (let C = n.length, D = function (e) { if (!(e in n)) { const r = t + (t ? '.' : '') + e; w(o, { ownKeys: !1 }, function () { const t = _(r, void 0, Boolean(i), o, d, f); O(t, v) ? d.push([r, t, Boolean(i), o, S, e, o.type]) : void 0 !== t && (S[e] = t) }) } }, U = 0; U < C; U++)D(U); b && b({ endIterateUnsetNumeric: !0, end: !0 }) } return S } function E (e, t, n, r, i, c, u) { for (let l = i ? a.plainObjectReplacers : a.nonplainObjectReplacers, d = l.length; d--;) { const h = l[d]; if (h.test(t, n)) { const p = h.type; if (a.revivers[p]) { const g = s[e]; s[e] = g ? [p].concat(g) : p } return Object.assign(n, { type: p, replaced: !0 }), !o && h.replaceAsync || h.replace ? (u && u({ replacing: !0 }), _(e, h[o || !h.replaceAsync ? 'replace' : 'replaceAsync'](t, n), f && 'readonly', n, r, c, p)) : (u && u({ typeDetected: !0 }), _(e, t, f && 'readonly', n, r, c, p)) } } return t } return d.length ? o && r.throwOnBadSyncType ? (function () { throw new TypeError('Sync method requested but async result obtained') }()) : Promise.resolve(i(y, d)).then(b) : !o && r.throwOnBadSyncType ? (function () { throw new TypeError('Async method requested but sync result obtained') }()) : r.stringification && o ? [b(y)] : o ? b(y) : Promise.resolve(b(y)) } }, { key: 'encapsulateSync', value: function (e, t, n) { return this.encapsulate(e, t, p(p({ throwOnBadSyncType: !0 }, n), {}, { sync: !0 })) } }, { key: 'encapsulateAsync', value: function (e, t, n) { return this.encapsulate(e, t, p(p({ throwOnBadSyncType: !0 }, n), {}, { sync: !1 })) } }, { key: 'revive', value: function (e, t) { let n = e && e.$types; if (!n) return e; if (!0 === n) return e.$; const r = (t = p(p({ sync: !0 }, this.options), t)).sync; const i = []; const o = {}; let a = !0; n.$ && x(n.$) && (e = e.$, n = n.$, a = !1); const s = this; function c (e, t) { const n = g(s.revivers[e] || [], 1)[0]; if (!n) throw new Error('Unregistered type: ' + e); return r && !('revive' in n) ? t : n[r && n.revive ? 'revive' : !r && n.reviveAsync ? 'reviveAsync' : 'revive'](t, o) } const u = []; function l (e) { return O(e, F) ? void 0 : e } let d; const f = (function () { const t = []; if (Object.entries(n).forEach(function (e) { let r = g(e, 2); let i = r[0]; let o = r[1]; '#' !== o && [].concat(o).forEach(function (e) { g(s.revivers[e] || [null, {}], 2)[1].plain && (t.push({ keypath: i, type: e }), delete n[i]) }) }), t.length) return t.sort(M).reduce(function t (n, r) { let i = r.keypath; let o = r.type; if (S(n)) return n.then(function (e) { return t(e, { keypath: i, type: o }) }); let a = R(e, i); if (O(a = c(o, a), v)) return a.then(function (t) { var n = P(e, i, t); n === t && (e = n) }); let s = P(e, i, a); s === a && (e = s) }, void 0) }()); return O(f, v) ? d = f.then(function () { return e }) : (d = (function e (t, r, o, s, l) { if (!a || t !== '$types') { const d = n[t]; const f = L(r); if (f || x(r)) { const h = f ? new Array(r.length) : {}; for (B(r).forEach(function (n) { const i = e(t + (t ? '.' : '') + N(n), r[n], o || h, h, n); const a = function (e) { return O(e, F) ? h[n] = void 0 : void 0 !== e && (h[n] = e), e }; O(i, v) ? u.push(i.then(function (e) { return a(e) })) : a(i) }), r = h; i.length;) { const p = g(i[0], 4); const m = p[0]; const y = p[1]; const b = p[2]; const w = p[3]; const _ = R(m, y); if (void 0 === _) break; b[w] = _, i.splice(0, 1) } } if (!d) return r; if (d === '#') { const E = R(o, r.slice(1)); return void 0 === E && i.push([o, r.slice(1), s, l]), E } return [].concat(d).reduce(function e (t, n) { return O(t, v) ? t.then(function (t) { return e(t, n) }) : c(n, t) }, r) } }('', e, null)), u.length && (d = v.resolve(d).then(function (e) { return v.all([e].concat(u)) }).then(function (e) { return g(e, 1)[0] }))), S(d) ? r && t.throwOnBadSyncType ? (function () { throw new TypeError('Sync method requested but async result obtained') }()) : O(d, v) ? d.p.then(l) : d : !r && t.throwOnBadSyncType ? (function () { throw new TypeError('Async method requested but sync result obtained') }()) : r ? l(d) : Promise.resolve(l(d)) } }, { key: 'reviveSync', value: function (e, t) { return this.revive(e, p(p({ throwOnBadSyncType: !0 }, t), {}, { sync: !0 })) } }, { key: 'reviveAsync', value: function (e, t) { return this.revive(e, p(p({ throwOnBadSyncType: !0 }, t), {}, { sync: !1 })) } }, { key: 'register', value: function (t, n) { return n = n || {}, [].concat(t).forEach(function t (r) { const i = this; if (L(r)) return r.map(function (e) { return t.call(i, e) }); r && B(r).forEach(function (t) { if (t === '#') throw new TypeError('# cannot be used as a type name as it is reserved for cyclic objects'); if (e.JSON_TYPES.includes(t)) throw new TypeError('Plain JSON object types are reserved as type names'); let i = r[t]; const o = i && i.testPlainObjects ? this.plainObjectReplacers : this.nonplainObjectReplacers; const a = o.filter(function (e) { return e.type === t }); if (a.length && (o.splice(o.indexOf(a[0]), 1), delete this.revivers[t], delete this.types[t]), typeof i==='function') { const s = i; i = { test: function (e) { return e && e.constructor === s }, replace: function (e) { return p({}, e) }, revive: function (e) { return Object.assign(Object.create(s.prototype), e) } } } else if (L(i)) { const c = g(i, 3); i = { test: c[0], replace: c[1], revive: c[2] } } if (i && i.test) { const u = { type: t, test: i.test.bind(i) }; i.replace && (u.replace = i.replace.bind(i)), i.replaceAsync && (u.replaceAsync = i.replaceAsync.bind(i)); const l = 'number'===typeof n.fallback ? n.fallback : n.fallback ? 0 : Number.POSITIVE_INFINITY; if (i.testPlainObjects ? this.plainObjectReplacers.splice(l, 0, u) : this.nonplainObjectReplacers.splice(l, 0, u), i.revive || i.reviveAsync) { const d = {}; i.revive && (d.revive = i.revive.bind(i)), i.reviveAsync && (d.reviveAsync = i.reviveAsync.bind(i)), this.revivers[t] = [d, { plain: i.testPlainObjects }] } this.types[t] = i } }, this) }, this), this } }])), e }()); var F = function e () { l(this, e) }; F.__typeson__type__ = 'TypesonUndefined', z.Undefined = F, z.Promise = v, z.isThenable = S, z.toStringTag = A, z.hasConstructorOf = O, z.isObject = I, z.isPlainObject = x, z.isUserObject = function e (t) { if (!t || A(t) !== 'Object') return !1; const n = E(t); return !n || O(t, Object) || e(n) }, z.escapeKeyPathComponent = N, z.unescapeKeyPathComponent = T, z.getByKeyPath = R, z.getJSONType = function (e) { return e === null ? 'null' : Array.isArray(e) ? 'array' : u(e) }, z.JSON_TYPES = ['null', 'boolean', 'number', 'string', 'array', 'object']; for (var H = { userObject: { test: function (e, t) { return z.isUserObject(e) }, replace: function (e) { return (function (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? o(Object(n), !0).forEach(function (t) { i(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e }({}, e)) }, revive: function (e) { return e } } }, q = [{ arrayNonindexKeys: { testPlainObjects: !0, test: function (e, t) { return !!Array.isArray(e) && (Object.keys(e).some(function (e) { return String(Number.parseInt(e)) !== e }) && (t.iterateIn = 'object', t.addLength = !0), !0) }, replace: function (e, t) { return t.iterateUnsetNumeric = !0, e }, revive: function (e) { if (Array.isArray(e)) return e; const t = []; return Object.keys(e).forEach(function (n) { const r = e[n]; t[n] = r }), t } } }, { sparseUndefined: { test: function (e, t) { return void 0 === e && !1 === t.ownKeys }, replace: function (e) { return 0 }, revive: function (e) {} } }], K = { undef: { test: function (e, t) { return void 0 === e && (t.ownKeys || !('ownKeys' in t)) }, replace: function (e) { return 0 }, revive: function (e) { return new z.Undefined() } } }, V = { StringObject: { test: function (t) { return z.toStringTag(t) === 'String' && e(t) === 'object' }, replace: function (e) { return String(e) }, revive: function (e) { return new String(e) } }, BooleanObject: { test: function (t) { return z.toStringTag(t) === 'Boolean' && e(t) === 'object' }, replace: function (e) { return Boolean(e) }, revive: function (e) { return new Boolean(e) } }, NumberObject: { test: function (t) { return z.toStringTag(t) === 'Number' && e(t) === 'object' }, replace: function (e) { return Number(e) }, revive: function (e) { return new Number(e) } } }, W = [{ nan: { test: function (e) { return Number.isNaN(e) }, replace: function (e) { return 'NaN' }, revive: function (e) { return Number.NaN } } }, { infinity: { test: function (e) { return e === Number.POSITIVE_INFINITY }, replace: function (e) { return 'Infinity' }, revive: function (e) { return Number.POSITIVE_INFINITY } } }, { negativeInfinity: { test: function (e) { return e === Number.NEGATIVE_INFINITY }, replace: function (e) { return '-Infinity' }, revive: function (e) { return Number.NEGATIVE_INFINITY } } }], $ = { date: { test: function (e) { return z.toStringTag(e) === 'Date' }, replace: function (e) { const t = e.getTime(); return Number.isNaN(t) ? 'NaN' : t }, revive: function (e) { return e === 'NaN' ? new Date(Number.NaN) : new Date(e) } } }, G = { regexp: { test: function (e) { return z.toStringTag(e) === 'RegExp' }, replace: function (e) { return { source: e.source, flags: (e.global ? 'g' : '') + (e.ignoreCase ? 'i' : '') + (e.multiline ? 'm' : '') + (e.sticky ? 'y' : '') + (e.unicode ? 'u' : '') } }, revive: function (e) { const t = e.source; const n = e.flags; return new RegExp(t, n) } } }, Y = { map: { test: function (e) { return z.toStringTag(e) === 'Map' }, replace: function (e) { return a(e.entries()) }, revive: function (e) { return new Map(e) } } }, Z = { set: { test: function (e) { return z.toStringTag(e) === 'Set' }, replace: function (e) { return a(e.values()) }, revive: function (e) { return new Set(e) } } }, J = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', X = new Uint8Array(256), Q = 0; Q < J.length; Q++)X[J.charCodeAt(Q)] = Q; const ee = function (e, t, n) { n == null && (n = e.byteLength); for (var r = new Uint8Array(e, t || 0, n), i = r.length, o = '', a = 0; a < i; a += 3)o += J[r[a] >> 2], o += J[(3 & r[a]) << 4 | r[a + 1] >> 4], o += J[(15 & r[a + 1]) << 2 | r[a + 2] >> 6], o += J[63 & r[a + 2]]; return i % 3 == 2 ? o = o.slice(0, -1) + '=' : i % 3 == 1 && (o = o.slice(0, -2) + '=='), o }; const te = function (e) { let t; let n; let r; let i; const o = e.length; let a = 0.75 * e.length; let s = 0; e[e.length - 1] === '=' && (a--, e[e.length - 2] === '=' && a--); for (var c = new ArrayBuffer(a), u = new Uint8Array(c), l = 0; l < o; l += 4)t = X[e.charCodeAt(l)], n = X[e.charCodeAt(l + 1)], r = X[e.charCodeAt(l + 2)], i = X[e.charCodeAt(l + 3)], u[s++] = t << 2 | n >> 4, u[s++] = (15 & n) << 4 | r >> 2, u[s++] = (3 & r) << 6 | 63 & i; return c }; const ne = { arraybuffer: { test: function (e) { return z.toStringTag(e) === 'ArrayBuffer' }, replace: function (e, t) { t.buffers || (t.buffers = []); const n = t.buffers.indexOf(e); return n > -1 ? { index: n } : (t.buffers.push(e), ee(e)) }, revive: function (t, n) { if (n.buffers || (n.buffers = []), e(t) === 'object') return n.buffers[t.index]; const r = te(t); return n.buffers.push(r), r } } }; const re = typeof self === 'undefined' ? n.g : self; const ie = {}; ['Int8Array', 'Uint8Array', 'Uint8ClampedArray', 'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array', 'Float32Array', 'Float64Array'].forEach(function (e) { const t = e; const n = re[t]; n && (ie[e.toLowerCase()] = { test: function (e) { return z.toStringTag(e) === t }, replace: function (e, t) { const n = e.buffer; const r = e.byteOffset; const i = e.length; t.buffers || (t.buffers = []); const o = t.buffers.indexOf(n); return o > -1 ? { index: o, byteOffset: r, length: i } : (t.buffers.push(n), { encoded: ee(n), byteOffset: r, length: i }) }, revive: function (e, t) { t.buffers || (t.buffers = []); let r; const i = e.byteOffset; const o = e.length; const a = e.encoded; const s = e.index; return 'index' in e ? r = t.buffers[s] : (r = te(a), t.buffers.push(r)), new n(r, i, o) } }) }); const oe = { dataview: { test: function (e) { return z.toStringTag(e) === 'DataView' }, replace: function (e, t) { const n = e.buffer; const r = e.byteOffset; const i = e.byteLength; t.buffers || (t.buffers = []); const o = t.buffers.indexOf(n); return o > -1 ? { index: o, byteOffset: r, byteLength: i } : (t.buffers.push(n), { encoded: ee(n), byteOffset: r, byteLength: i }) }, revive: function (e, t) { t.buffers || (t.buffers = []); let n; const r = e.byteOffset; const i = e.byteLength; const o = e.encoded; const a = e.index; return 'index' in e ? n = t.buffers[a] : (n = te(o), t.buffers.push(n)), new DataView(n, r, i) } } }; const ae = { IntlCollator: { test: function (e) { return z.hasConstructorOf(e, Intl.Collator) }, replace: function (e) { return e.resolvedOptions() }, revive: function (e) { return new Intl.Collator(e.locale, e) } }, IntlDateTimeFormat: { test: function (e) { return z.hasConstructorOf(e, Intl.DateTimeFormat) }, replace: function (e) { return e.resolvedOptions() }, revive: function (e) { return new Intl.DateTimeFormat(e.locale, e) } }, IntlNumberFormat: { test: function (e) { return z.hasConstructorOf(e, Intl.NumberFormat) }, replace: function (e) { return e.resolvedOptions() }, revive: function (e) { return new Intl.NumberFormat(e.locale, e) } } }; function se (e) { for (var t = new Uint8Array(e.length), n = 0; n < e.length; n++)t[n] = e.charCodeAt(n); return t.buffer } const ce = { file: { test: function (e) { return z.toStringTag(e) === 'File' }, replace: function (e) { const t = new XMLHttpRequest(); if (t.overrideMimeType('text/plain; charset=x-user-defined'), t.open('GET', URL.createObjectURL(e), !1), t.send(), t.status !== 200 && t.status !== 0) throw new Error('Bad File access: ' + t.status); return { type: e.type, stringContents: t.responseText, name: e.name, lastModified: e.lastModified } }, revive: function (e) { const t = e.name; const n = e.type; const r = e.stringContents; const i = e.lastModified; return new File([se(r)], t, { type: n, lastModified: i }) }, replaceAsync: function (e) { return new z.Promise(function (t, n) { const r = new FileReader(); r.addEventListener('load', function () { t({ type: e.type, stringContents: r.result, name: e.name, lastModified: e.lastModified }) }), r.addEventListener('error', function () { n(r.error) }), r.readAsBinaryString(e) }) } } }; const ue = { bigint: { test: function (e) { return typeof e === 'bigint' }, replace: function (e) { return String(e) }, revive: function (e) { return BigInt(e) } } }; const le = { bigintObject: { test: function (t) { return e(t) === 'object' && z.hasConstructorOf(t, BigInt) }, replace: function (e) { return String(e) }, revive: function (e) { return new Object(BigInt(e)) } } }; const de = { cryptokey: { test: function (e) { return z.toStringTag(e) === 'CryptoKey' && e.extractable }, replaceAsync: function (e) { return new z.Promise(function (t, n) { crypto.subtle.exportKey('jwk', e).catch(function (e) { n(e) }).then(function (n) { t({ jwk: n, algorithm: e.algorithm, usages: e.usages }) }) }) }, revive: function (e) { const t = e.jwk; const n = e.algorithm; const r = e.usages; return crypto.subtle.importKey('jwk', t, n, !0, r) } } }; return [H, K, q, V, W, $, G, { imagedata: { test: function (e) { return z.toStringTag(e) === 'ImageData' }, replace: function (e) { return { array: a(e.data), width: e.width, height: e.height } }, revive: function (e) { return new ImageData(new Uint8ClampedArray(e.array), e.width, e.height) } } }, { imagebitmap: { test: function (e) { return z.toStringTag(e) === 'ImageBitmap' || e && e.dataset && e.dataset.toStringTag === 'ImageBitmap' }, replace: function (e) { const t = document.createElement('canvas'); return t.getContext('2d').drawImage(e, 0, 0), t.toDataURL() }, revive: function (e) { const t = document.createElement('canvas'); const n = t.getContext('2d'); const r = document.createElement('img'); return r.addEventListener('load', function () { n.drawImage(r, 0, 0) }), r.src = e, t }, reviveAsync: function (e) { const t = document.createElement('canvas'); const n = t.getContext('2d'); const r = document.createElement('img'); return r.addEventListener('load', function () { n.drawImage(r, 0, 0) }), r.src = e, createImageBitmap(t) } } }, ce, { file: ce.file, filelist: { test: function (e) { return z.toStringTag(e) === 'FileList' }, replace: function (e) { for (var t = [], n = 0; n < e.length; n++)t[n] = e.item(n); return t }, revive: function (e) { return new (function () { function e () { t(this, e), this._files = arguments[0], this.length = this._files.length } return (function (e, t, n) { t && r(e.prototype, t), n && r(e, n) }(e, [{ key: 'item', value: function (e) { return this._files[e] } }, { key: Symbol.toStringTag, get: function () { return 'FileList' } }])), e }())(e) } } }, { blob: { test: function (e) { return z.toStringTag(e) === 'Blob' }, replace: function (e) { const t = new XMLHttpRequest(); if (t.overrideMimeType('text/plain; charset=x-user-defined'), t.open('GET', URL.createObjectURL(e), !1), t.send(), t.status !== 200 && t.status !== 0) throw new Error('Bad Blob access: ' + t.status); return { type: e.type, stringContents: t.responseText } }, revive: function (e) { const t = e.type; const n = e.stringContents; return new Blob([se(n)], { type: t }) }, replaceAsync: function (e) { return new z.Promise(function (t, n) { const r = new FileReader(); r.addEventListener('load', function () { t({ type: e.type, stringContents: r.result }) }), r.addEventListener('error', function () { n(r.error) }), r.readAsBinaryString(e) }) } } }].concat(typeof Map === 'function' ? Y : [], typeof Set === 'function' ? Z : [], typeof ArrayBuffer === 'function' ? ne : [], typeof Uint8Array === 'function' ? ie : [], typeof DataView === 'function' ? oe : [], typeof Intl !== 'undefined' ? ae : [], typeof crypto !== 'undefined' ? de : [], typeof BigInt !== 'undefined' ? [ue, le] : []).concat({ checkDataCloneException: { test: function (t) { const n = {}.toString.call(t).slice(8, -1); if (['symbol', 'function'].includes(e(t)) || ['Arguments', 'Module', 'Error', 'Promise', 'WeakMap', 'WeakSet', 'Event', 'MessageChannel'].includes(n) || t && e(t) === 'object' && typeof t.nodeType === 'number' && typeof t.insertBefore === 'function') throw new DOMException('The object cannot be cloned.', 'DataCloneError'); return !1 } } }) }, (void 0 === i ? 'undefined' : s(i)) == 'object' && void 0 !== t ? t.exports = a() : typeof r === 'function' && r.amd ? r(a) : ((o = typeof globalThis !== 'undefined' ? globalThis : o || self).Typeson = o.Typeson || {}, o.Typeson.presets = o.Typeson.presets || {}, o.Typeson.presets.structuredCloningThrowing = a()) }, {}], 8: [function (e, t, n) { 'use strict'; const r = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; function i (e) { return (i = typeof Symbol === 'function' && r(Symbol.iterator) == 'symbol' ? function (e) { return void 0 === e ? 'undefined' : r(e) } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : void 0 === e ? 'undefined' : r(e) })(e) } function o (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') } function a (e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } function s (e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function c (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function u (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? c(Object(n), !0).forEach(function (t) { s(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function l (e, t) { return (function (e) { if (Array.isArray(e)) return e }(e)) || (function (e, t) { if (typeof Symbol !== 'undefined' && Symbol.iterator in Object(e)) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !t || n.length !== t); r = !0); } catch (e) { i = !0, o = e } finally { try { r || s.return == null || s.return() } finally { if (i) throw o } } return n } }(e, t)) || f(e, t) || (function () { throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.') }()) } function d (e) { return (function (e) { if (Array.isArray(e)) return h(e) }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && Symbol.iterator in Object(e)) return Array.from(e) }(e)) || f(e) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.') }()) } function f (e, t) { if (e) { if (typeof e === 'string') return h(e, t); let n = Object.prototype.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? h(e, t) : void 0 } } function h (e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } const p = function e (t) { o(this, e), this.p = new Promise(t) }; p.__typeson__type__ = 'TypesonPromise', typeof Symbol !== 'undefined' && (p.prototype[Symbol.toStringTag] = 'TypesonPromise'), p.prototype.then = function (e, t) { const n = this; return new p(function (r, i) { n.p.then(function (t) { r(e ? e(t) : t) }).catch(function (e) { return t ? t(e) : Promise.reject(e) }).then(r, i) }) }, p.prototype.catch = function (e) { return this.then(null, e) }, p.resolve = function (e) { return new p(function (t) { t(e) }) }, p.reject = function (e) { return new p(function (t, n) { n(e) }) }, ['all', 'race', 'allSettled'].forEach(function (e) { p[e] = function (t) { return new p(function (n, r) { Promise[e](t.map(function (e) { return e && e.constructor && e.constructor.__typeson__type__ === 'TypesonPromise' ? e.p : e })).then(n, r) }) } }); const g = {}.toString; const m = {}.hasOwnProperty; const y = Object.getPrototypeOf; const b = m.toString; function v (e, t) { return k(e) && typeof e.then === 'function' && (!t || typeof e.catch === 'function') } function w (e) { return g.call(e).slice(8, -1) } function _ (e, t) { if (!e || i(e) !== 'object') return !1; const n = y(e); if (!n) return t === null; const r = m.call(n, 'constructor') && n.constructor; return typeof r !== 'function' ? t === null : t === r || t !== null && b.call(r) === b.call(t) || typeof t === 'function' && typeof r.__typeson__type__ === 'string' && r.__typeson__type__ === t.__typeson__type__ } function E (e) { return !(!e || w(e) !== 'Object') && (!y(e) || _(e, Object)) } function k (e) { return e && i(e) === 'object' } function S (e) { return e.replace(/~/g, '~0').replace(/\./g, '~1') } function A (e) { return e.replace(/~1/g, '.').replace(/~0/g, '~') } function O (e, t) { if (t === '') return e; const n = t.indexOf('.'); if (n > -1) { const r = e[A(t.slice(0, n))]; return void 0 === r ? void 0 : O(r, t.slice(n + 1)) } return e[A(t)] } function x (e, t, n) { if (t === '') return n; const r = t.indexOf('.'); return r > -1 ? x(e[A(t.slice(0, r))], t.slice(r + 1), n) : (e[A(t)] = n, e) } function I (e, t, n) { return n ? t ? t(e) : e : (e && e.then || (e = Promise.resolve(e)), t ? e.then(t) : e) } const N = Object.keys; const T = Array.isArray; const R = {}.hasOwnProperty; const P = ['type', 'replaced', 'iterateIn', 'iterateUnsetNumeric']; function C (e) { return function () { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; try { return Promise.resolve(e.apply(this, t)) } catch (e) { return Promise.reject(e) } } } function B (e, t) { if (e.keypath === '') return -1; let n = e.keypath.match(/\./g) || 0; let r = t.keypath.match(/\./g) || 0; return n && (n = n.length), r && (r = r.length), n > r ? -1 : n < r ? 1 : e.keypath < t.keypath ? -1 : e.keypath > t.keypath } const L = (function () { function e (t) { o(this, e), this.options = t, this.plainObjectReplacers = [], this.nonplainObjectReplacers = [], this.revivers = {}, this.types = {} } return (function (e, t, n) { t && a(e.prototype, t), n && a(e, n) }(e, [{ key: 'stringify', value: function (e, t, n, r) { r = u(u(u({}, this.options), r), {}, { stringification: !0 }); const i = this.encapsulate(e, null, r); return T(i) ? JSON.stringify(i[0], t, n) : i.then(function (e) { return JSON.stringify(e, t, n) }) } }, { key: 'stringifySync', value: function (e, t, n, r) { return this.stringify(e, t, n, u(u({ throwOnBadSyncType: !0 }, r), {}, { sync: !0 })) } }, { key: 'stringifyAsync', value: function (e, t, n, r) { return this.stringify(e, t, n, u(u({ throwOnBadSyncType: !0 }, r), {}, { sync: !1 })) } }, { key: 'parse', value: function (e, t, n) { return n = u(u(u({}, this.options), n), {}, { parse: !0 }), this.revive(JSON.parse(e, t), n) } }, { key: 'parseSync', value: function (e, t, n) { return this.parse(e, t, u(u({ throwOnBadSyncType: !0 }, n), {}, { sync: !0 })) } }, { key: 'parseAsync', value: function (e, t, n) { return this.parse(e, t, u(u({ throwOnBadSyncType: !0 }, n), {}, { sync: !1 })) } }, { key: 'specialTypeNames', value: function (e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return n.returnTypeNames = !0, this.encapsulate(e, t, n) } }, { key: 'rootTypeName', value: function (e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return n.iterateNone = !0, this.encapsulate(e, t, n) } }, { key: 'encapsulate', value: function (t, n, r) { var o = C(function (e, t) { return I(Promise.all(t.map(function (e) { return e[1].p })), function (n) { return I(Promise.all(n.map(C(function (n) { let r = !1; let i = []; let a = l(t.splice(0, 1), 1); let s = l(a[0], 7); let c = s[0]; let u = s[2]; let d = s[3]; let f = s[4]; let h = s[5]; let g = s[6]; let m = A(c, n, u, d, i, !0, g); let y = _(m, p); return (function (e, t) { var n = e(); return n && n.then ? n.then(t) : t(n) }(function(){if(c&&y)return I(m.p,(function(t){return f[h]=t,r=!0,o(e,i)}))}, (function (t) { return r ? t : (c ? f[h] = m : e = y ? m.p : m, o(e, i)) }))) }))), function () { return e }) }) }); const a = (r = u(u({ sync: !0 }, this.options), r)).sync; const s = this; const c = {}; const f = []; const h = []; const g = []; const m = !('cyclic' in r) || r.cyclic; const y = r.encapsulateObserver; const b = A('', t, m, n || {}, g); function v (t) { const n = Object.values(c); if (r.iterateNone) return n.length ? n[0] : e.getJSONType(t); if (n.length) { if (r.returnTypeNames) return d(new Set(n)); t && E(t) && !R.call(t, '$types') ? t.$types = c : t = { $: t, $types: { $: c } } } else k(t) && R.call(t, '$types') && (t = { $: t, $types: !0 }); return !r.returnTypeNames && t } function w (e, t, n) { Object.assign(e, t); const r = P.map(function (t) { const n = e[t]; return delete e[t], n }); n(), P.forEach(function (t, n) { e[t] = r[n] }) } function A (t, n, o, a, u, l, d) { let g; let m = {}; const b = i(n); const v = y ? function (r) { const i = d || a.type || e.getJSONType(n); y(Object.assign(r || m, { keypath: t, value: n, cyclic: o, stateObj: a, promisesData: u, resolvingTypesonPromise: l, awaitingTypesonPromise: _(n, p) }, { type: i })) } : null; if (['string', 'boolean', 'number', 'undefined'].includes(b)) return void 0 === n || Number.isNaN(n) || n === Number.NEGATIVE_INFINITY || n === Number.POSITIVE_INFINITY ? (g = a.replaced ? n : O(t, n, a, u, !1, l, v)) !== n && (m = { replaced: g }) : g = n, v && v(), g; if (n === null) return v && v(), n; if (o && !a.iterateIn && !a.iterateUnsetNumeric && n && i(n) === 'object') { const k = f.indexOf(n); if (!(k < 0)) return c[t] = '#', v && v({ cyclicKeypath: h[k] }), '#' + h[k]; !0 === o && (f.push(n), h.push(t)) } let x; const I = E(n); const P = T(n); const C = (I || P) && (!s.plainObjectReplacers.length || a.replaced) || a.iterateIn ? n : O(t, n, a, u, I || P, null, v); if (C !== n ? (g = C, m = { replaced: C }) : t === '' && _(n, p) ? (u.push([t, n, o, a, void 0, void 0, a.type]), g = n) : P && a.iterateIn !== 'object' || a.iterateIn === 'array' ? (x = new Array(n.length), m = { clone: x }) : (['function', 'symbol'].includes(i(n)) || 'toJSON' in n || _(n, p) || _(n, Promise) || _(n, ArrayBuffer)) && !I && a.iterateIn !== 'object' ? g = n : (x = {}, a.addLength && (x.length = n.length), m = { clone: x }), v && v(), r.iterateNone) return x || g; if (!x) return g; if (a.iterateIn) { const B = function (e) { const r = { ownKeys: R.call(n, e) }; w(a, r, function () { const r = t + (t ? '.' : '') + S(e); const i = A(r, n[e], Boolean(o), a, u, l); _(i, p) ? u.push([r, i, Boolean(o), a, x, e, a.type]) : void 0 !== i && (x[e] = i) }) }; for (const L in n)B(L); v && v({ endIterateIn: !0, end: !0 }) } else N(n).forEach(function (e) { const r = t + (t ? '.' : '') + S(e); w(a, { ownKeys: !0 }, function () { const t = A(r, n[e], Boolean(o), a, u, l); _(t, p) ? u.push([r, t, Boolean(o), a, x, e, a.type]) : void 0 !== t && (x[e] = t) }) }), v && v({ endIterateOwn: !0, end: !0 }); if (a.iterateUnsetNumeric) { for (let j = n.length, D = function (e) { if (!(e in n)) { const r = t + (t ? '.' : '') + e; w(a, { ownKeys: !1 }, function () { const t = A(r, void 0, Boolean(o), a, u, l); _(t, p) ? u.push([r, t, Boolean(o), a, x, e, a.type]) : void 0 !== t && (x[e] = t) }) } }, U = 0; U < j; U++)D(U); v && v({ endIterateUnsetNumeric: !0, end: !0 }) } return x } function O (e, t, n, r, i, o, u) { for (let l = i ? s.plainObjectReplacers : s.nonplainObjectReplacers, d = l.length; d--;) { const f = l[d]; if (f.test(t, n)) { const h = f.type; if (s.revivers[h]) { const p = c[e]; c[e] = p ? [h].concat(p) : h } return Object.assign(n, { type: h, replaced: !0 }), !a && f.replaceAsync || f.replace ? (u && u({ replacing: !0 }), A(e, f[a || !f.replaceAsync ? 'replace' : 'replaceAsync'](t, n), m && 'readonly', n, r, o, h)) : (u && u({ typeDetected: !0 }), A(e, t, m && 'readonly', n, r, o, h)) } } return t } return g.length ? a && r.throwOnBadSyncType ? (function () { throw new TypeError('Sync method requested but async result obtained') }()) : Promise.resolve(o(b, g)).then(v) : !a && r.throwOnBadSyncType ? (function () { throw new TypeError('Async method requested but sync result obtained') }()) : r.stringification && a ? [v(b)] : a ? v(b) : Promise.resolve(v(b)) } }, { key: 'encapsulateSync', value: function (e, t, n) { return this.encapsulate(e, t, u(u({ throwOnBadSyncType: !0 }, n), {}, { sync: !0 })) } }, { key: 'encapsulateAsync', value: function (e, t, n) { return this.encapsulate(e, t, u(u({ throwOnBadSyncType: !0 }, n), {}, { sync: !1 })) } }, { key: 'revive', value: function (e, t) { let n = e && e.$types; if (!n) return e; if (!0 === n) return e.$; const r = (t = u(u({ sync: !0 }, this.options), t)).sync; const i = []; const o = {}; let a = !0; n.$ && E(n.$) && (e = e.$, n = n.$, a = !1); const s = this; function c (e, t) { const n = l(s.revivers[e] || [], 1)[0]; if (!n) throw new Error('Unregistered type: ' + e); return r && !('revive' in n) ? t : n[r && n.revive ? 'revive' : !r && n.reviveAsync ? 'reviveAsync' : 'revive'](t, o) } const d = []; function f (e) { return _(e, j) ? void 0 : e } let h; const g = (function () { const t = []; if (Object.entries(n).forEach(function (e) { let r = l(e, 2); let i = r[0]; let o = r[1]; '#' !== o && [].concat(o).forEach(function (e) { l(s.revivers[e] || [null, {}], 2)[1].plain && (t.push({ keypath: i, type: e }), delete n[i]) }) }), t.length) return t.sort(B).reduce(function t (n, r) { let i = r.keypath; let o = r.type; if (v(n)) return n.then(function (e) { return t(e, { keypath: i, type: o }) }); let a = O(e, i); if (_(a = c(o, a), p)) return a.then(function (t) { var n = x(e, i, t); n === t && (e = n) }); let s = x(e, i, a); s === a && (e = s) }, void 0) }()); return _(g, p) ? h = g.then(function () { return e }) : (h = (function e (t, r, o, s, u) { if (!a || t !== '$types') { const f = n[t]; const h = T(r); if (h || E(r)) { const g = h ? new Array(r.length) : {}; for (N(r).forEach(function (n) { const i = e(t + (t ? '.' : '') + S(n), r[n], o || g, g, n); const a = function (e) { return _(e, j) ? g[n] = void 0 : void 0 !== e && (g[n] = e), e }; _(i, p) ? d.push(i.then(function (e) { return a(e) })) : a(i) }), r = g; i.length;) { const m = l(i[0], 4); const y = m[0]; const b = m[1]; const v = m[2]; const w = m[3]; const k = O(y, b); if (void 0 === k) break; v[w] = k, i.splice(0, 1) } } if (!f) return r; if (f === '#') { const A = O(o, r.slice(1)); return void 0 === A && i.push([o, r.slice(1), s, u]), A } return [].concat(f).reduce(function e (t, n) { return _(t, p) ? t.then(function (t) { return e(t, n) }) : c(n, t) }, r) } }('', e, null)), d.length && (h = p.resolve(h).then(function (e) { return p.all([e].concat(d)) }).then(function (e) { return l(e, 1)[0] }))), v(h) ? r && t.throwOnBadSyncType ? (function () { throw new TypeError('Sync method requested but async result obtained') }()) : _(h, p) ? h.p.then(f) : h : !r && t.throwOnBadSyncType ? (function () { throw new TypeError('Async method requested but sync result obtained') }()) : r ? f(h) : Promise.resolve(f(h)) } }, { key: 'reviveSync', value: function (e, t) { return this.revive(e, u(u({ throwOnBadSyncType: !0 }, t), {}, { sync: !0 })) } }, { key: 'reviveAsync', value: function (e, t) { return this.revive(e, u(u({ throwOnBadSyncType: !0 }, t), {}, { sync: !1 })) } }, { key: 'register', value: function (t, n) { return n = n || {}, [].concat(t).forEach(function t (r) { const i = this; if (T(r)) return r.map(function (e) { return t.call(i, e) }); r && N(r).forEach(function (t) { if (t === '#') throw new TypeError('# cannot be used as a type name as it is reserved for cyclic objects'); if (e.JSON_TYPES.includes(t)) throw new TypeError('Plain JSON object types are reserved as type names'); let i = r[t]; const o = i && i.testPlainObjects ? this.plainObjectReplacers : this.nonplainObjectReplacers; const a = o.filter(function (e) { return e.type === t }); if (a.length && (o.splice(o.indexOf(a[0]), 1), delete this.revivers[t], delete this.types[t]), typeof i==='function') { const s = i; i = { test: function (e) { return e && e.constructor === s }, replace: function (e) { return u({}, e) }, revive: function (e) { return Object.assign(Object.create(s.prototype), e) } } } else if (T(i)) { const c = l(i, 3); i = { test: c[0], replace: c[1], revive: c[2] } } if (i && i.test) { const d = { type: t, test: i.test.bind(i) }; i.replace && (d.replace = i.replace.bind(i)), i.replaceAsync && (d.replaceAsync = i.replaceAsync.bind(i)); const f = 'number'===typeof n.fallback ? n.fallback : n.fallback ? 0 : Number.POSITIVE_INFINITY; if (i.testPlainObjects ? this.plainObjectReplacers.splice(f, 0, d) : this.nonplainObjectReplacers.splice(f, 0, d), i.revive || i.reviveAsync) { const h = {}; i.revive && (h.revive = i.revive.bind(i)), i.reviveAsync && (h.reviveAsync = i.reviveAsync.bind(i)), this.revivers[t] = [h, { plain: i.testPlainObjects }] } this.types[t] = i } }, this) }, this), this } }])), e }()); var j = function e () { o(this, e) }; j.__typeson__type__ = 'TypesonUndefined', L.Undefined = j, L.Promise = p, L.isThenable = v, L.toStringTag = w, L.hasConstructorOf = _, L.isObject = k, L.isPlainObject = E, L.isUserObject = function e (t) { if (!t || w(t) !== 'Object') return !1; const n = y(t); return !n || _(t, Object) || e(n) }, L.escapeKeyPathComponent = S, L.unescapeKeyPathComponent = A, L.getByKeyPath = O, L.getJSONType = function (e) { return e === null ? 'null' : Array.isArray(e) ? 'array' : i(e) }, L.JSON_TYPES = ['null', 'boolean', 'number', 'string', 'array', 'object'], t.exports = L }, {}], 9: [function (e, t, n) { 'use strict'; const r = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; function i (e, t) { return (t && t.context ? t.context : 'Value') + ' ' + e + '.' } function o (e) { if (e === null) return 'Null'; switch (void 0 === e ? 'undefined' : r(e)) { case 'undefined':return 'Undefined'; case 'boolean':return 'Boolean'; case 'number':return 'Number'; case 'string':return 'String'; case 'symbol':return 'Symbol'; default:return 'Object' } } function a (e) { return l(e > 0 && e % 1 == 0.5 && (1 & e) == 0 || e < 0 && e % 1 == -0.5 && (1 & e) == 1 ? Math.floor(e) : Math.round(e)) } function s (e) { return l(Math.trunc(e)) } function c (e) { return e < 0 ? -1 : 1 } function u (e, t) { const n = e % t; return c(t) !== c(n) ? n + t : n } function l (e) { return e === 0 ? 0 : e } function d (e, t) { const n = !t.unsigned; let r = void 0; let o = void 0; e === 64 ? (o = Math.pow(2, 53) - 1, r = n ? 1 - Math.pow(2, 53) : 0) : n ? (r = -Math.pow(2, e - 1), o = Math.pow(2, e - 1) - 1) : (r = 0, o = Math.pow(2, e) - 1); const c = Math.pow(2, e); const d = Math.pow(2, e - 1); return function (e, t) { void 0 === t && (t = {}); let f = +e; if (f = l(f), t.enforceRange) { if (!Number.isFinite(f)) throw new TypeError(i('is not a finite number', t)); if ((f = s(f)) < r || f > o) throw new TypeError(i('is outside the accepted range of ' + r + ' to ' + o + ', inclusive', t)); return f } return !Number.isNaN(f) && t.clamp ? f = a(f = Math.min(Math.max(f, r), o)) : Number.isFinite(f) && f !== 0 ? (f = s(f)) >= r && f <= o ? f : (f = u(f, c), n && f >= d ? f - c : f) : 0 } } function f (e, t) { if (typeof e !== 'function') throw new TypeError(i('is not a function', t)); return e }n.any = function (e) { return e }, n.void = function () {}, n.boolean = function (e) { return !!e }, n.byte = d(8, { unsigned: !1 }), n.octet = d(8, { unsigned: !0 }), n.short = d(16, { unsigned: !1 }), n['unsigned short'] = d(16, { unsigned: !0 }), n.long = d(32, { unsigned: !1 }), n['unsigned long'] = d(32, { unsigned: !0 }), n['long long'] = d(64, { unsigned: !1 }), n['unsigned long long'] = d(64, { unsigned: !0 }), n.double = function (e, t) { const n = +e; if (!Number.isFinite(n)) throw new TypeError(i('is not a finite floating-point value', t)); return n }, n['unrestricted double'] = function (e) { return +e }, n.float = function (e, t) { const n = +e; if (!Number.isFinite(n)) throw new TypeError(i('is not a finite floating-point value', t)); if (Object.is(n, -0)) return n; const r = Math.fround(n); if (!Number.isFinite(r)) throw new TypeError(i('is outside the range of a single-precision floating-point value', t)); return r }, n['unrestricted float'] = function (e) { const t = +e; return isNaN(t) || Object.is(t, -0) ? t : Math.fround(t) }, n.DOMString = function (e, t) { if (void 0 === t && (t = {}), t.treatNullAsEmptyString && e === null) return ''; if ((void 0 === e ? 'undefined' : r(e)) === 'symbol') throw new TypeError(i('is a symbol, which cannot be converted to a string', t)); return String(e) }, n.ByteString = function (e, t) { for (var r = n.DOMString(e, t), o = void 0, a = 0; void 0 !== (o = r.codePointAt(a)); ++a) if (o > 255) throw new TypeError(i('is not a valid ByteString', t)); return r }, n.USVString = function (e, t) { for (var r = n.DOMString(e, t), i = r.length, o = [], a = 0; a < i; ++a) { const s = r.charCodeAt(a); if (s < 55296 || s > 57343)o.push(String.fromCodePoint(s)); else if (s >= 56320 && s <= 57343)o.push(String.fromCodePoint(65533)); else if (a === i - 1)o.push(String.fromCodePoint(65533)); else { const c = r.charCodeAt(a + 1); if (c >= 56320 && c <= 57343) { const u = 1023 & s; const l = 1023 & c; o.push(String.fromCodePoint(65536 + 1024 * u + l)), ++a } else o.push(String.fromCodePoint(65533)) } } return o.join('') }, n.object = function (e, t) { if (o(e) !== 'Object') throw new TypeError(i('is not an object', t)); return e }, [Error, ArrayBuffer, DataView, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array, Float64Array].forEach(function (e) { const t = e.name; const r = /^[AEIOU]/.test(t) ? 'an' : 'a'; n[t] = function (n, o) { if (!(n instanceof e)) throw new TypeError(i('is not ' + r + ' ' + t + ' object', o)); return n } }), n.ArrayBufferView = function (e, t) { if (!ArrayBuffer.isView(e)) throw new TypeError(i('is not a view on an ArrayBuffer object', t)); return e }, n.BufferSource = function (e, t) { if (!(ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) throw new TypeError(i('is not an ArrayBuffer object or a view on one', t)); return e }, n.DOMTimeStamp = n['unsigned long long'], n.Function = f, n.VoidFunction = f }, {}] }, {}, [1])(1) }, 9785: (e, t, n) => { 'use strict'; const r = n(8764).Buffer; const i = n(5717); const o = n(3349); const a = new Array(16); const s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]; const c = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]; const u = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]; const l = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]; const d = [0, 1518500249, 1859775393, 2400959708, 2840853838]; const f = [1352829926, 1548603684, 1836072691, 2053994217, 0]; function h () { o.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520 } function p (e, t) { return e << t | e >>> 32 - t } function g (e, t, n, r, i, o, a, s) { return p(e + (t ^ n ^ r) + o + a | 0, s) + i | 0 } function m (e, t, n, r, i, o, a, s) { return p(e + (t & n | ~t & r) + o + a | 0, s) + i | 0 } function y (e, t, n, r, i, o, a, s) { return p(e + ((t | ~n) ^ r) + o + a | 0, s) + i | 0 } function b (e, t, n, r, i, o, a, s) { return p(e + (t & r | n & ~r) + o + a | 0, s) + i | 0 } function v (e, t, n, r, i, o, a, s) { return p(e + (t ^ (n | ~r)) + o + a | 0, s) + i | 0 }i(h, o), h.prototype._update = function () { for (var e = a, t = 0; t < 16; ++t)e[t] = this._block.readInt32LE(4 * t); for (var n = 0 | this._a, r = 0 | this._b, i = 0 | this._c, o = 0 | this._d, h = 0 | this._e, w = 0 | this._a, _ = 0 | this._b, E = 0 | this._c, k = 0 | this._d, S = 0 | this._e, A = 0; A < 80; A += 1) { var O, x; A < 16 ? (O = g(n, r, i, o, h, e[s[A]], d[0], u[A]), x = v(w, _, E, k, S, e[c[A]], f[0], l[A])) : A < 32 ? (O = m(n, r, i, o, h, e[s[A]], d[1], u[A]), x = b(w, _, E, k, S, e[c[A]], f[1], l[A])) : A < 48 ? (O = y(n, r, i, o, h, e[s[A]], d[2], u[A]), x = y(w, _, E, k, S, e[c[A]], f[2], l[A])) : A < 64 ? (O = b(n, r, i, o, h, e[s[A]], d[3], u[A]), x = m(w, _, E, k, S, e[c[A]], f[3], l[A])) : (O = v(n, r, i, o, h, e[s[A]], d[4], u[A]), x = g(w, _, E, k, S, e[c[A]], f[4], l[A])), n = h, h = o, o = p(i, 10), i = r, r = O, w = S, S = k, k = p(E, 10), E = _, _ = x } const I = this._b + i + k | 0; this._b = this._c + o + S | 0, this._c = this._d + h + w | 0, this._d = this._e + n + _ | 0, this._e = this._a + r + E | 0, this._a = I }, h.prototype._digest = function () { this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update(); const e = r.alloc ? r.alloc(20) : new r(20); return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e.writeInt32LE(this._e, 16), e }, e.exports = h }, 9509: (e, t, n) => { const r = n(8764); const i = r.Buffer; function o (e, t) { for (const n in e)t[n] = e[n] } function a (e, t, n) { return i(e, t, n) }i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = r : (o(r, t), t.Buffer = a), a.prototype = Object.create(i.prototype), o(i, a), a.from = function (e, t, n) { if (typeof e === 'number') throw new TypeError('Argument must not be a number'); return i(e, t, n) }, a.alloc = function (e, t, n) { if (typeof e !== 'number') throw new TypeError('Argument must be a number'); const r = i(e); return void 0 !== t ? typeof n === 'string' ? r.fill(t, n) : r.fill(t) : r.fill(0), r }, a.allocUnsafe = function (e) { if (typeof e !== 'number') throw new TypeError('Argument must be a number'); return i(e) }, a.allocUnsafeSlow = function (e) { if (typeof e !== 'number') throw new TypeError('Argument must be a number'); return r.SlowBuffer(e) } }, 7221: (e, t, n) => { e.exports = n(9119)(n(8573)) }, 8573: (e, t, n) => { const r = new (0, n(6266).ec)('secp256k1'); const i = r.curve; const o = i.n.constructor; function a (e) { const t = e[0]; switch (t) { case 2:case 3:return e.length !== 33 ? null : (function (e, t) { let n = new o(t); if (n.cmp(i.p) >= 0) return null; n = n.toRed(i.red); let a = n.redSqr().redIMul(n).redIAdd(i.b).redSqrt(); return e === 3 !== a.isOdd() && (a = a.redNeg()), r.keyPair({ pub: { x: n, y: a } }) }(t, e.subarray(1, 33))); case 4:case 6:case 7:return e.length !== 65 ? null : (function (e, t, n) { let a = new o(t); let s = new o(n); if (a.cmp(i.p) >= 0 || s.cmp(i.p) >= 0) return null; if (a = a.toRed(i.red), s = s.toRed(i.red), (e === 6 || e === 7) && s.isOdd() !== (e === 7)) return null; const c = a.redSqr().redIMul(a); return s.redSqr().redISub(c.redIAdd(i.b)).isZero() ? r.keyPair({ pub: { x: a, y: s } }) : null }(t, e.subarray(1, 33), e.subarray(33, 65))); default:return null } } function s (e, t) { const n = t.encode(null, e.length === 33); for (let t = 0; t < e.length; ++t)e[t] = n[t] }e.exports = { contextRandomize: () => 0, privateKeyVerify (e) { const t = new o(e); return t.cmp(i.n) < 0 && !t.isZero() ? 0 : 1 }, privateKeyNegate (e) { const t = new o(e); const n = i.n.sub(t).umod(i.n).toArrayLike(Uint8Array, 'be', 32); return e.set(n), 0 }, privateKeyTweakAdd (e, t) { const n = new o(t); if (n.cmp(i.n) >= 0) return 1; if (n.iadd(new o(e)), n.cmp(i.n) >= 0 && n.isub(i.n), n.isZero()) return 1; const r = n.toArrayLike(Uint8Array, 'be', 32); return e.set(r), 0 }, privateKeyTweakMul (e, t) { let n = new o(t); if (n.cmp(i.n) >= 0 || n.isZero()) return 1; n.imul(new o(e)), n.cmp(i.n) >= 0 && (n = n.umod(i.n)); const r = n.toArrayLike(Uint8Array, 'be', 32); return e.set(r), 0 }, publicKeyVerify: e => a(e) === null ? 1 : 0, publicKeyCreate (e, t) { const n = new o(t); if (n.cmp(i.n) >= 0 || n.isZero()) return 1; return s(e, r.keyFromPrivate(t).getPublic()), 0 }, publicKeyConvert (e, t) { const n = a(t); if (n === null) return 1; return s(e, n.getPublic()), 0 }, publicKeyNegate (e, t) { const n = a(t); if (n === null) return 1; const r = n.getPublic(); return r.y = r.y.redNeg(), s(e, r), 0 }, publicKeyCombine (e, t) { const n = new Array(t.length); for (let e = 0; e < t.length; ++e) if (n[e] = a(t[e]), n[e] === null) return 1; let r = n[0].getPublic(); for (let e = 1; e < n.length; ++e)r = r.add(n[e].pub); return r.isInfinity() ? 2 : (s(e, r), 0) }, publicKeyTweakAdd (e, t, n) { const r = a(t); if (r === null) return 1; if ((n = new o(n)).cmp(i.n) >= 0) return 2; const c = r.getPublic().add(i.g.mul(n)); return c.isInfinity() ? 2 : (s(e, c), 0) }, publicKeyTweakMul (e, t, n) { const r = a(t); if (r === null) return 1; if ((n = new o(n)).cmp(i.n) >= 0 || n.isZero()) return 2; return s(e, r.getPublic().mul(n)), 0 }, signatureNormalize (e) { const t = new o(e.subarray(0, 32)); const n = new o(e.subarray(32, 64)); return t.cmp(i.n) >= 0 || n.cmp(i.n) >= 0 ? 1 : (n.cmp(r.nh) === 1 && e.set(i.n.sub(n).toArrayLike(Uint8Array, 'be', 32), 32), 0) }, signatureExport (e, t) { const n = t.subarray(0, 32); const r = t.subarray(32, 64); if (new o(n).cmp(i.n) >= 0) return 1; if (new o(r).cmp(i.n) >= 0) return 1; const { output: a } = e; let s = a.subarray(4, 37); s[0] = 0, s.set(n, 1); let c = 33; let u = 0; for (;c > 1 && s[u] === 0 && !(128 & s[u + 1]); --c, ++u);if (s = s.subarray(u), 128 & s[0]) return 1; if (c > 1 && s[0] === 0 && !(128 & s[1])) return 1; let l = a.subarray(39, 72); l[0] = 0, l.set(r, 1); let d = 33; let f = 0; for (;d > 1 && l[f] === 0 && !(128 & l[f + 1]); --d, ++f);return l = l.subarray(f), 128 & l[0] || d > 1 && l[0] === 0 && !(128 & l[1]) ? 1 : (e.outputlen = 6 + c + d, a[0] = 48, a[1] = e.outputlen - 2, a[2] = 2, a[3] = s.length, a.set(s, 4), a[4 + c] = 2, a[5 + c] = l.length, a.set(l, 6 + c), 0) }, signatureImport (e, t) { if (t.length < 8) return 1; if (t.length > 72) return 1; if (t[0] !== 48) return 1; if (t[1] !== t.length - 2) return 1; if (t[2] !== 2) return 1; const n = t[3]; if (n === 0) return 1; if (5 + n >= t.length) return 1; if (t[4 + n] !== 2) return 1; const r = t[5 + n]; if (r === 0) return 1; if (6 + n + r !== t.length) return 1; if (128 & t[4]) return 1; if (n > 1 && t[4] === 0 && !(128 & t[5])) return 1; if (128 & t[n + 6]) return 1; if (r > 1 && t[n + 6] === 0 && !(128 & t[n + 7])) return 1; let a = t.subarray(4, 4 + n); if (a.length === 33 && a[0] === 0 && (a = a.subarray(1)), a.length > 32) return 1; let s = t.subarray(6 + n); if (s.length === 33 && s[0] === 0 && (s = s.slice(1)), s.length > 32) throw new Error('S length is too long'); let c = new o(a); c.cmp(i.n) >= 0 && (c = new o(0)); let u = new o(t.subarray(6 + n)); return u.cmp(i.n) >= 0 && (u = new o(0)), e.set(c.toArrayLike(Uint8Array, 'be', 32), 0), e.set(u.toArrayLike(Uint8Array, 'be', 32), 32), 0 }, ecdsaSign (e, t, n, a, s) { if (s) { const e = s; s = r => { const i = e(t, n, null, a, r); if (!(i instanceof Uint8Array && i.length === 32)) throw new Error('This is the way'); return new o(i) } } const c = new o(n); if (c.cmp(i.n) >= 0 || c.isZero()) return 1; let u; try { u = r.sign(t, n, { canonical: !0, k: s, pers: a }) } catch (e) { return 1 } return e.signature.set(u.r.toArrayLike(Uint8Array, 'be', 32), 0), e.signature.set(u.s.toArrayLike(Uint8Array, 'be', 32), 32), e.recid = u.recoveryParam, 0 }, ecdsaVerify (e, t, n) { const s = { r: e.subarray(0, 32), s: e.subarray(32, 64) }; const c = new o(s.r); const u = new o(s.s); if (c.cmp(i.n) >= 0 || u.cmp(i.n) >= 0) return 1; if (u.cmp(r.nh) === 1 || c.isZero() || u.isZero()) return 3; const l = a(n); if (l === null) return 2; const d = l.getPublic(); return r.verify(t, s, d) ? 0 : 3 }, ecdsaRecover (e, t, n, a) { const c = { r: t.slice(0, 32), s: t.slice(32, 64) }; const u = new o(c.r); const l = new o(c.s); if (u.cmp(i.n) >= 0 || l.cmp(i.n) >= 0) return 1; if (u.isZero() || l.isZero()) return 2; let d; try { d = r.recoverPubKey(a, c, n) } catch (e) { return 2 } return s(e, d), 0 }, ecdh (e, t, n, s, c, u, l) { const d = a(t); if (d === null) return 1; const f = new o(n); if (f.cmp(i.n) >= 0 || f.isZero()) return 2; const h = d.getPublic().mul(f); if (void 0 === c) { const t = h.encode(null, !0); const n = r.hash().update(t).digest(); for (let t = 0; t < 32; ++t)e[t] = n[t] } else { u || (u = new Uint8Array(32)); const t = h.getX().toArray('be', 32); for (let e = 0; e < 32; ++e)u[e] = t[e]; l || (l = new Uint8Array(32)); const n = h.getY().toArray('be', 32); for (let e = 0; e < 32; ++e)l[e] = n[e]; const r = c(u, l, s); if (!(r instanceof Uint8Array && r.length === e.length)) return 2; e.set(r) } return 0 } } }, 9119: e => { const t = 'Impossible case. Please create issue.'; const n = 'The tweak was out of range or the resulted private key is invalid'; const r = 'The tweak was out of range or equal to zero'; const i = 'Unknow error on context randomization'; const o = 'Private Key is invalid'; const a = 'Public Key could not be parsed'; const s = 'Public Key serialization error'; const c = 'The sum of the public keys is not valid'; const u = 'Signature could not be parsed'; const l = 'The nonce generation function failed, or the private key was invalid'; const d = 'Public key could not be recover'; const f = 'Scalar was invalid (zero or overflow)'; function h (e, t) { if (!e) throw new Error(t) } function p (e, t, n) { if (h(t instanceof Uint8Array, `Expected ${e} to be an Uint8Array`), void 0 !== n) if (Array.isArray(n)) { const r = `Expected ${e} to be an Uint8Array with length [${n.join(', ')}]`; h(n.includes(t.length), r) } else { const r = `Expected ${e} to be an Uint8Array with length ${n}`; h(t.length === n, r) } } function g (e) { h(y(e) === 'Boolean', 'Expected compressed to be a Boolean') } function m (e = e => new Uint8Array(e), t) { return typeof e === 'function' && (e = e(t)), p('output', e, t), e } function y (e) { return Object.prototype.toString.call(e).slice(8, -1) }e.exports = e => ({ contextRandomize (t) { if (h(t === null || t instanceof Uint8Array, 'Expected seed to be an Uint8Array or null'), t !== null && p('seed', t, 32), e.contextRandomize(t) === 1) throw new Error(i) }, privateKeyVerify: t => (p('private key', t, 32), e.privateKeyVerify(t) === 0), privateKeyNegate (n) { switch (p('private key', n, 32), e.privateKeyNegate(n)) { case 0:return n; case 1:throw new Error(t) } }, privateKeyTweakAdd (t, r) { switch (p('private key', t, 32), p('tweak', r, 32), e.privateKeyTweakAdd(t, r)) { case 0:return t; case 1:throw new Error(n) } }, privateKeyTweakMul (t, n) { switch (p('private key', t, 32), p('tweak', n, 32), e.privateKeyTweakMul(t, n)) { case 0:return t; case 1:throw new Error(r) } }, publicKeyVerify: t => (p('public key', t, [33, 65]), e.publicKeyVerify(t) === 0), publicKeyCreate (t, n = !0, r) { switch (p('private key', t, 32), g(n), r = m(r, n ? 33 : 65), e.publicKeyCreate(r, t)) { case 0:return r; case 1:throw new Error(o); case 2:throw new Error(s) } }, publicKeyConvert (t, n = !0, r) { switch (p('public key', t, [33, 65]), g(n), r = m(r, n ? 33 : 65), e.publicKeyConvert(r, t)) { case 0:return r; case 1:throw new Error(a); case 2:throw new Error(s) } }, publicKeyNegate (n, r = !0, i) { switch (p('public key', n, [33, 65]), g(r), i = m(i, r ? 33 : 65), e.publicKeyNegate(i, n)) { case 0:return i; case 1:throw new Error(a); case 2:throw new Error(t); case 3:throw new Error(s) } }, publicKeyCombine (t, n = !0, r) { h(Array.isArray(t), 'Expected public keys to be an Array'), h(t.length > 0, 'Expected public keys array will have more than zero items'); for (const e of t)p('public key', e, [33, 65]); switch (g(n), r = m(r, n ? 33 : 65), e.publicKeyCombine(r, t)) { case 0:return r; case 1:throw new Error(a); case 2:throw new Error(c); case 3:throw new Error(s) } }, publicKeyTweakAdd (t, r, i = !0, o) { switch (p('public key', t, [33, 65]), p('tweak', r, 32), g(i), o = m(o, i ? 33 : 65), e.publicKeyTweakAdd(o, t, r)) { case 0:return o; case 1:throw new Error(a); case 2:throw new Error(n) } }, publicKeyTweakMul (t, n, i = !0, o) { switch (p('public key', t, [33, 65]), p('tweak', n, 32), g(i), o = m(o, i ? 33 : 65), e.publicKeyTweakMul(o, t, n)) { case 0:return o; case 1:throw new Error(a); case 2:throw new Error(r) } }, signatureNormalize (t) { switch (p('signature', t, 64), e.signatureNormalize(t)) { case 0:return t; case 1:throw new Error(u) } }, signatureExport (n, r) { p('signature', n, 64); const i = { output: r = m(r, 72), outputlen: 72 }; switch (e.signatureExport(i, n)) { case 0:return r.slice(0, i.outputlen); case 1:throw new Error(u); case 2:throw new Error(t) } }, signatureImport (n, r) { switch (p('signature', n), r = m(r, 64), e.signatureImport(r, n)) { case 0:return r; case 1:throw new Error(u); case 2:throw new Error(t) } }, ecdsaSign (n, r, i = {}, o) { p('message', n, 32), p('private key', r, 32), h(y(i) === 'Object', 'Expected options to be an Object'), void 0 !== i.data && p('options.data', i.data), void 0 !== i.noncefn && h(y(i.noncefn) === 'Function', 'Expected options.noncefn to be a Function'); const a = { signature: o = m(o, 64), recid: null }; switch (e.ecdsaSign(a, n, r, i.data, i.noncefn)) { case 0:return a; case 1:throw new Error(l); case 2:throw new Error(t) } }, ecdsaVerify (t, n, r) { switch (p('signature', t, 64), p('message', n, 32), p('public key', r, [33, 65]), e.ecdsaVerify(t, n, r)) { case 0:return !0; case 3:return !1; case 1:throw new Error(u); case 2:throw new Error(a) } }, ecdsaRecover (n, r, i, o = !0, a) { switch (p('signature', n, 64), h(y(r) === 'Number' && r >= 0 && r <= 3, 'Expected recovery id to be a Number within interval [0, 3]'), p('message', i, 32), g(o), a = m(a, o ? 33 : 65), e.ecdsaRecover(a, n, r, i)) { case 0:return a; case 1:throw new Error(u); case 2:throw new Error(d); case 3:throw new Error(t) } }, ecdh (t, n, r = {}, i) { switch (p('public key', t, [33, 65]), p('private key', n, 32), h(y(r) === 'Object', 'Expected options to be an Object'), void 0 !== r.data && p('options.data', r.data), void 0 !== r.hashfn ? (h(y(r.hashfn) === 'Function', 'Expected options.hashfn to be a Function'), void 0 !== r.xbuf && p('options.xbuf', r.xbuf, 32), void 0 !== r.ybuf && p('options.ybuf', r.ybuf, 32), p('output', i)) : i = m(i, 32), e.ecdh(i, t, n, r.data, r.hashfn, r.xbuf, r.ybuf)) { case 0:return i; case 1:throw new Error(a); case 2:throw new Error(f) } } }) }, 4189: (e, t, n) => { const r = n(9509).Buffer; function i (e, t) { this._block = r.alloc(e), this._finalSize = t, this._blockSize = e, this._len = 0 }i.prototype.update = function (e, t) { typeof e === 'string' && (t = t || 'utf8', e = r.from(e, t)); for (var n = this._block, i = this._blockSize, o = e.length, a = this._len, s = 0; s < o;) { for (var c = a % i, u = Math.min(o - s, i - c), l = 0; l < u; l++)n[c + l] = e[s + l]; s += u, (a += u) % i == 0 && this._update(n) } return this._len += o, this }, i.prototype.digest = function (e) { const t = this._len % this._blockSize; this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0)); const n = 8 * this._len; if (n <= 4294967295) this._block.writeUInt32BE(n, this._blockSize - 4); else { const r = (4294967295 & n) >>> 0; const i = (n - r) / 4294967296; this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(r, this._blockSize - 4) } this._update(this._block); const o = this._hash(); return e ? o.toString(e) : o }, i.prototype._update = function () { throw new Error('_update must be implemented by subclass') }, e.exports = i }, 9072: (e, t, n) => { var r = e.exports = function (e) { e = e.toLowerCase(); const t = r[e]; if (!t) throw new Error(e + ' is not supported (we accept pull requests)'); return new t() }; r.sha = n(4448), r.sha1 = n(8336), r.sha224 = n(8432), r.sha256 = n(7499), r.sha384 = n(1686), r.sha512 = n(7816) }, 4448: (e, t, n) => { const r = n(5717); const i = n(4189); const o = n(9509).Buffer; const a = [1518500249, 1859775393, -1894007588, -899497514]; const s = new Array(80); function c () { this.init(), this._w = s, i.call(this, 64, 56) } function u (e) { return e << 30 | e >>> 2 } function l (e, t, n, r) { return e === 0 ? t & n | ~t & r : e === 2 ? t & n | t & r | n & r : t ^ n ^ r }r(c, i), c.prototype.init = function () { return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this }, c.prototype._update = function (e) { for (var t, n = this._w, r = 0 | this._a, i = 0 | this._b, o = 0 | this._c, s = 0 | this._d, c = 0 | this._e, d = 0; d < 16; ++d)n[d] = e.readInt32BE(4 * d); for (;d < 80; ++d)n[d] = n[d - 3] ^ n[d - 8] ^ n[d - 14] ^ n[d - 16]; for (let f = 0; f < 80; ++f) { const h = ~~(f / 20); const p = 0 | ((t = r) << 5 | t >>> 27) + l(h, i, o, s) + c + n[f] + a[h]; c = s, s = o, o = u(i), i = r, r = p } this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = o + this._c | 0, this._d = s + this._d | 0, this._e = c + this._e | 0 }, c.prototype._hash = function () { const e = o.allocUnsafe(20); return e.writeInt32BE(0 | this._a, 0), e.writeInt32BE(0 | this._b, 4), e.writeInt32BE(0 | this._c, 8), e.writeInt32BE(0 | this._d, 12), e.writeInt32BE(0 | this._e, 16), e }, e.exports = c }, 8336: (e, t, n) => { const r = n(5717); const i = n(4189); const o = n(9509).Buffer; const a = [1518500249, 1859775393, -1894007588, -899497514]; const s = new Array(80); function c () { this.init(), this._w = s, i.call(this, 64, 56) } function u (e) { return e << 5 | e >>> 27 } function l (e) { return e << 30 | e >>> 2 } function d (e, t, n, r) { return e === 0 ? t & n | ~t & r : e === 2 ? t & n | t & r | n & r : t ^ n ^ r }r(c, i), c.prototype.init = function () { return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this }, c.prototype._update = function (e) { for (var t, n = this._w, r = 0 | this._a, i = 0 | this._b, o = 0 | this._c, s = 0 | this._d, c = 0 | this._e, f = 0; f < 16; ++f)n[f] = e.readInt32BE(4 * f); for (;f < 80; ++f)n[f] = (t = n[f - 3] ^ n[f - 8] ^ n[f - 14] ^ n[f - 16]) << 1 | t >>> 31; for (let h = 0; h < 80; ++h) { const p = ~~(h / 20); const g = u(r) + d(p, i, o, s) + c + n[h] + a[p] | 0; c = s, s = o, o = l(i), i = r, r = g } this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = o + this._c | 0, this._d = s + this._d | 0, this._e = c + this._e | 0 }, c.prototype._hash = function () { const e = o.allocUnsafe(20); return e.writeInt32BE(0 | this._a, 0), e.writeInt32BE(0 | this._b, 4), e.writeInt32BE(0 | this._c, 8), e.writeInt32BE(0 | this._d, 12), e.writeInt32BE(0 | this._e, 16), e }, e.exports = c }, 8432: (e, t, n) => { const r = n(5717); const i = n(7499); const o = n(4189); const a = n(9509).Buffer; const s = new Array(64); function c () { this.init(), this._w = s, o.call(this, 64, 56) }r(c, i), c.prototype.init = function () { return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this }, c.prototype._hash = function () { const e = a.allocUnsafe(28); return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e }, e.exports = c }, 7499: (e, t, n) => { const r = n(5717); const i = n(4189); const o = n(9509).Buffer; const a = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]; const s = new Array(64); function c () { this.init(), this._w = s, i.call(this, 64, 56) } function u (e, t, n) { return n ^ e & (t ^ n) } function l (e, t, n) { return e & t | n & (e | t) } function d (e) { return (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10) } function f (e) { return (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7) } function h (e) { return (e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3 }r(c, i), c.prototype.init = function () { return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this }, c.prototype._update = function (e) { for (var t, n = this._w, r = 0 | this._a, i = 0 | this._b, o = 0 | this._c, s = 0 | this._d, c = 0 | this._e, p = 0 | this._f, g = 0 | this._g, m = 0 | this._h, y = 0; y < 16; ++y)n[y] = e.readInt32BE(4 * y); for (;y < 64; ++y)n[y] = 0 | (((t = n[y - 2]) >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10) + n[y - 7] + h(n[y - 15]) + n[y - 16]; for (let b = 0; b < 64; ++b) { const v = m + f(c) + u(c, p, g) + a[b] + n[b] | 0; const w = d(r) + l(r, i, o) | 0; m = g, g = p, p = c, c = s + v | 0, s = o, o = i, i = r, r = v + w | 0 } this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = o + this._c | 0, this._d = s + this._d | 0, this._e = c + this._e | 0, this._f = p + this._f | 0, this._g = g + this._g | 0, this._h = m + this._h | 0 }, c.prototype._hash = function () { const e = o.allocUnsafe(32); return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e.writeInt32BE(this._h, 28), e }, e.exports = c }, 1686: (e, t, n) => { const r = n(5717); const i = n(7816); const o = n(4189); const a = n(9509).Buffer; const s = new Array(160); function c () { this.init(), this._w = s, o.call(this, 128, 112) }r(c, i), c.prototype.init = function () { return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this }, c.prototype._hash = function () { const e = a.allocUnsafe(48); function t (t, n, r) { e.writeInt32BE(t, r), e.writeInt32BE(n, r + 4) } return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), e }, e.exports = c }, 7816: (e, t, n) => { const r = n(5717); const i = n(4189); const o = n(9509).Buffer; const a = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]; const s = new Array(160); function c () { this.init(), this._w = s, i.call(this, 128, 112) } function u (e, t, n) { return n ^ e & (t ^ n) } function l (e, t, n) { return e & t | n & (e | t) } function d (e, t) { return (e >>> 28 | t << 4) ^ (t >>> 2 | e << 30) ^ (t >>> 7 | e << 25) } function f (e, t) { return (e >>> 14 | t << 18) ^ (e >>> 18 | t << 14) ^ (t >>> 9 | e << 23) } function h (e, t) { return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ e >>> 7 } function p (e, t) { return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ (e >>> 7 | t << 25) } function g (e, t) { return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ e >>> 6 } function m (e, t) { return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ (e >>> 6 | t << 26) } function y (e, t) { return e >>> 0 < t >>> 0 ? 1 : 0 }r(c, i), c.prototype.init = function () { return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this }, c.prototype._update = function (e) { for (var t = this._w, n = 0 | this._ah, r = 0 | this._bh, i = 0 | this._ch, o = 0 | this._dh, s = 0 | this._eh, c = 0 | this._fh, b = 0 | this._gh, v = 0 | this._hh, w = 0 | this._al, _ = 0 | this._bl, E = 0 | this._cl, k = 0 | this._dl, S = 0 | this._el, A = 0 | this._fl, O = 0 | this._gl, x = 0 | this._hl, I = 0; I < 32; I += 2)t[I] = e.readInt32BE(4 * I), t[I + 1] = e.readInt32BE(4 * I + 4); for (;I < 160; I += 2) { let N = t[I - 30]; let T = t[I - 30 + 1]; const R = h(N, T); const P = p(T, N); const C = g(N = t[I - 4], T = t[I - 4 + 1]); const B = m(T, N); const L = t[I - 14]; const j = t[I - 14 + 1]; const D = t[I - 32]; const U = t[I - 32 + 1]; var M = P + j | 0; var z = R + L + y(M, P) | 0; z = (z = z + C + y(M = M + B | 0, B) | 0) + D + y(M = M + U | 0, U) | 0, t[I] = z, t[I + 1] = M } for (let F = 0; F < 160; F += 2) { z = t[F], M = t[F + 1]; const H = l(n, r, i); const q = l(w, _, E); const K = d(n, w); const V = d(w, n); const W = f(s, S); const $ = f(S, s); const G = a[F]; const Y = a[F + 1]; const Z = u(s, c, b); const J = u(S, A, O); let X = x + $ | 0; let Q = v + W + y(X, x) | 0; Q = (Q = (Q = Q + Z + y(X = X + J | 0, J) | 0) + G + y(X = X + Y | 0, Y) | 0) + z + y(X = X + M | 0, M) | 0; const ee = V + q | 0; const te = K + H + y(ee, V) | 0; v = b, x = O, b = c, O = A, c = s, A = S, s = o + Q + y(S = k + X | 0, k) | 0, o = i, k = E, i = r, E = _, r = n, _ = w, n = Q + te + y(w = X + ee | 0, X) | 0 } this._al = this._al + w | 0, this._bl = this._bl + _ | 0, this._cl = this._cl + E | 0, this._dl = this._dl + k | 0, this._el = this._el + S | 0, this._fl = this._fl + A | 0, this._gl = this._gl + O | 0, this._hl = this._hl + x | 0, this._ah = this._ah + n + y(this._al, w) | 0, this._bh = this._bh + r + y(this._bl, _) | 0, this._ch = this._ch + i + y(this._cl, E) | 0, this._dh = this._dh + o + y(this._dl, k) | 0, this._eh = this._eh + s + y(this._el, S) | 0, this._fh = this._fh + c + y(this._fl, A) | 0, this._gh = this._gh + b + y(this._gl, O) | 0, this._hh = this._hh + v + y(this._hl, x) | 0 }, c.prototype._hash = function () { const e = o.allocUnsafe(64); function t (t, n, r) { e.writeInt32BE(t, r), e.writeInt32BE(n, r + 4) } return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), t(this._gh, this._gl, 48), t(this._hh, this._hl, 56), e }, e.exports = c }, 2830: (e, t, n) => { e.exports = i; const r = n(7187).EventEmitter; function i () { r.call(this) }n(5717)(i, r), i.Readable = n(9481), i.Writable = n(4229), i.Duplex = n(6753), i.Transform = n(4605), i.PassThrough = n(2725), i.finished = n(8610), i.pipeline = n(9946), i.Stream = i, i.prototype.pipe = function (e, t) { const n = this; function i (t) { e.writable && !1 === e.write(t) && n.pause && n.pause() } function o () { n.readable && n.resume && n.resume() }n.on('data', i), e.on('drain', o), e._isStdio || t && !1 === t.end || (n.on('end', s), n.on('close', c)); let a = !1; function s () { a || (a = !0, e.end()) } function c () { a || (a = !0, typeof e.destroy === 'function' && e.destroy()) } function u (e) { if (l(), r.listenerCount(this, 'error') === 0) throw e } function l () { n.removeListener('data', i), e.removeListener('drain', o), n.removeListener('end', s), n.removeListener('close', c), n.removeListener('error', u), e.removeListener('error', u), n.removeListener('end', l), n.removeListener('close', l), e.removeListener('close', l) } return n.on('error', u), e.on('error', u), n.on('end', l), n.on('close', l), e.on('close', l), e.emit('pipe', n), e } }, 2553: (e, t, n) => { 'use strict'; const r = n(9509).Buffer; const i = r.isEncoding || function (e) { switch ((e = '' + e) && e.toLowerCase()) { case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':return !0; default:return !1 } }; function o (e) { let t; switch (this.encoding = (function (e) { const t = (function (e) { if (!e) return 'utf8'; for (var t; ;) switch (e) { case 'utf8':case 'utf-8':return 'utf8'; case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':return 'utf16le'; case 'latin1':case 'binary':return 'latin1'; case 'base64':case 'ascii':case 'hex':return e; default:if (t) return; e = ('' + e).toLowerCase(), t = !0 } }(e)); if (typeof t !== 'string' && (r.isEncoding === i || !i(e))) throw new Error('Unknown encoding: ' + e); return t || e }(e)), this.encoding) { case 'utf16le':this.text = c, this.end = u, t = 4; break; case 'utf8':this.fillLast = s, t = 4; break; case 'base64':this.text = l, this.end = d, t = 3; break; default:return this.write = f, void (this.end = h) } this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r.allocUnsafe(t) } function a (e) { return e <= 127 ? 0 : e >> 5 == 6 ? 2 : e >> 4 == 14 ? 3 : e >> 3 == 30 ? 4 : e >> 6 == 2 ? -1 : -2 } function s (e) { const t = this.lastTotal - this.lastNeed; const n = (function (e, t, n) { if ((192 & t[0]) != 128) return e.lastNeed = 0, ''; if (e.lastNeed > 1 && t.length > 1) { if ((192 & t[1]) != 128) return e.lastNeed = 1, ''; if (e.lastNeed > 2 && t.length > 2 && (192 & t[2]) != 128) return e.lastNeed = 2, '' } }(this, e)); return void 0 !== n ? n : this.lastNeed <= e.length ? (e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e.copy(this.lastChar, t, 0, e.length), void (this.lastNeed -= e.length)) } function c (e, t) { if ((e.length - t) % 2 == 0) { const n = e.toString('utf16le', t); if (n) { const r = n.charCodeAt(n.length - 1); if (r >= 55296 && r <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], n.slice(0, -1) } return n } return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString('utf16le', t, e.length - 1) } function u (e) { const t = e && e.length ? this.write(e) : ''; if (this.lastNeed) { const n = this.lastTotal - this.lastNeed; return t + this.lastChar.toString('utf16le', 0, n) } return t } function l (e, t) { const n = (e.length - t) % 3; return n === 0 ? e.toString('base64', t) : (this.lastNeed = 3 - n, this.lastTotal = 3, n === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString('base64', t, e.length - n)) } function d (e) { const t = e && e.length ? this.write(e) : ''; return this.lastNeed ? t + this.lastChar.toString('base64', 0, 3 - this.lastNeed) : t } function f (e) { return e.toString(this.encoding) } function h (e) { return e && e.length ? this.write(e) : '' }t.s = o, o.prototype.write = function (e) { if (e.length === 0) return ''; let t, n; if (this.lastNeed) { if (void 0 === (t = this.fillLast(e))) return ''; n = this.lastNeed, this.lastNeed = 0 } else n = 0; return n < e.length ? t ? t + this.text(e, n) : this.text(e, n) : t || '' }, o.prototype.end = function (e) { const t = e && e.length ? this.write(e) : ''; return this.lastNeed ? t + '' : t }, o.prototype.text = function (e, t) { const n = (function (e, t, n) { let r = t.length - 1; if (r < n) return 0; let i = a(t[r]); if (i >= 0) return i > 0 && (e.lastNeed = i - 1), i; if (--r < n || i === -2) return 0; if (i = a(t[r]), i >= 0) return i > 0 && (e.lastNeed = i - 2), i; if (--r < n || i === -2) return 0; if (i = a(t[r]), i >= 0) return i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i; return 0 }(this, e, t)); if (!this.lastNeed) return e.toString('utf8', t); this.lastTotal = n; const r = e.length - (n - this.lastNeed); return e.copy(this.lastChar, 0, r), e.toString('utf8', t, r) }, o.prototype.fillLast = function (e) { if (this.lastNeed <= e.length) return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal); e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length } }, 6647: (e, t, n) => { const r = n(247); function i (e) { return e.name || e.toString().match(/function (.*?)\s*\(/)[1] } function o (e) { return r.Nil(e) ? '' : i(e.constructor) } function a (e, t) { Error.captureStackTrace && Error.captureStackTrace(e, t) } function s (e) { return r.Function(e) ? e.toJSON ? e.toJSON() : i(e) : r.Array(e) ? 'Array' : e && r.Object(e) ? 'Object' : void 0 !== e ? e : '' } function c (e, t, n) { const i = (function (e) { return r.Function(e) ? '' : r.String(e) ? JSON.stringify(e) : e && r.Object(e) ? '' : e }(t)); return 'Expected ' + s(e) + ', got' + (n !== '' ? ' ' + n : '') + (i !== '' ? ' ' + i : '') } function u (e, t, n) { n = n || o(t), this.message = c(e, t, n), a(this, u), this.__type = e, this.__value = t, this.__valueTypeName = n } function l (e, t, n, r, i) { e ? (i = i || o(r), this.message = (function (e, t, n, r, i) { let o = '" of type '; return t === 'key' && (o = '" with key type '), c('property "' + s(n) + o + s(e), r, i) }(e, n, t, r, i))) : this.message = 'Unexpected property "' + t + '"', a(this, u), this.__label = n, this.__property = t, this.__type = e, this.__value = r, this.__valueTypeName = i }u.prototype = Object.create(Error.prototype), u.prototype.constructor = u, l.prototype = Object.create(Error.prototype), l.prototype.constructor = u, e.exports = { TfTypeError: u, TfPropertyTypeError: l, tfCustomError: function (e, t) { return new u(e, {}, t) }, tfSubError: function (e, t, n) { return e instanceof l ? (t = t + '.' + e.__property, e = new l(e.__type, t, e.__label, e.__value, e.__valueTypeName)) : e instanceof u && (e = new l(e.__type, t, n, e.__value, e.__valueTypeName)), a(e), e }, tfJSON: s, getValueTypeName: o } }, 4307: (e, t, n) => { const r = n(8764).Buffer; const i = n(247); const o = n(6647); function a (e) { return r.isBuffer(e) } function s (e) { return typeof e === 'string' && /^([0-9a-f]{2})+$/i.test(e) } function c (e, t) { const n = e.toJSON(); function r (r) { if (!e(r)) return !1; if (r.length === t) return !0; throw o.tfCustomError(n + '(Length: ' + t + ')', n + '(Length: ' + r.length + ')') } return r.toJSON = function () { return n }, r } const u = c.bind(null, i.Array); const l = c.bind(null, a); const d = c.bind(null, s); const f = c.bind(null, i.String); const h = Math.pow(2, 53) - 1; const p = { ArrayN: u, Buffer: a, BufferN: l, Finite: function (e) { return typeof e === 'number' && isFinite(e) }, Hex: s, HexN: d, Int8: function (e) { return e << 24 >> 24 === e }, Int16: function (e) { return e << 16 >> 16 === e }, Int32: function (e) { return (0 | e) === e }, Int53: function (e) { return typeof e === 'number' && e >= -h && e <= h && Math.floor(e) === e }, Range: function (e, t, n) { function r (r, i) { return n(r, i) && r > e && r < t } return n = n || i.Number, r.toJSON = function () { return `${n.toJSON()} between [${e}, ${t}]` }, r }, StringN: f, UInt8: function (e) { return (255 & e) === e }, UInt16: function (e) { return (65535 & e) === e }, UInt32: function (e) { return e >>> 0 === e }, UInt53: function (e) { return typeof e === 'number' && e >= 0 && e <= h && Math.floor(e) === e } }; for (const g in p)p[g].toJSON = function (e) { return e }.bind(null, g); e.exports = p }, 2401: (e, t, n) => { const r = n(6647); const i = n(247); const o = r.tfJSON; const a = r.TfTypeError; const s = r.TfPropertyTypeError; const c = r.tfSubError; const u = r.getValueTypeName; const l = { arrayOf: function (e, t) { function n (n, r) { return !!i.Array(n) && (!i.Nil(n) && (!(void 0 !== t.minLength && n.length < t.minLength) && (!(void 0 !== t.maxLength && n.length > t.maxLength) && ((void 0 === t.length || n.length === t.length) && n.every(function (t, n) { try { return f(e, t, r) } catch (e) { throw c(e, n) } }))))) } return e = d(e), t = t || {}, n.toJSON = function () { let n = '[' + o(e) + ']'; return void 0 !== t.length ? n += '{' + t.length + '}' : void 0 === t.minLength && void 0 === t.maxLength || (n += '{' + (void 0 === t.minLength ? 0 : t.minLength) + ',' + (void 0 === t.maxLength ? 1 / 0 : t.maxLength) + '}'), n }, n }, maybe: function e (t) { function n (n, r) { return i.Nil(n) || t(n, r, e) } return t = d(t), n.toJSON = function () { return '?' + o(t) }, n }, map: function (e, t) { function n (n, r) { if (!i.Object(n)) return !1; if (i.Nil(n)) return !1; for (const o in n) { try { t && f(t, o, r) } catch (e) { throw c(e, o, 'key') } try { const a = n[o]; f(e, a, r) } catch (e) { throw c(e, o) } } return !0 } return e = d(e), t && (t = d(t)), n.toJSON = t ? function () { return '{' + o(t) + ': ' + o(e) + '}' } : function () { return '{' + o(e) + '}' }, n }, object: function (e) { const t = {}; for (const n in e)t[n] = d(e[n]); function r (e, n) { if (!i.Object(e)) return !1; if (i.Nil(e)) return !1; let r; try { for (r in t) { f(t[r], e[r], n) } } catch (e) { throw c(e, r) } if (n) for (r in e) if (!t[r]) throw new s(void 0, r); return !0 } return r.toJSON = function () { return o(t) }, r }, anyOf: function () { const e = [].slice.call(arguments).map(d); function t (t, n) { return e.some(function (e) { try { return f(e, t, n) } catch (e) { return !1 } }) } return t.toJSON = function () { return e.map(o).join('|') }, t }, allOf: function () { const e = [].slice.call(arguments).map(d); function t (t, n) { return e.every(function (e) { try { return f(e, t, n) } catch (e) { return !1 } }) } return t.toJSON = function () { return e.map(o).join(' & ') }, t }, quacksLike: function (e) { function t (t) { return e === u(t) } return t.toJSON = function () { return e }, t }, tuple: function () { const e = [].slice.call(arguments).map(d); function t (t, n) { return !i.Nil(t) && (!i.Nil(t.length) && ((!n || t.length === e.length) && e.every(function (e, r) { try { return f(e, t[r], n) } catch (e) { throw c(e, r) } }))) } return t.toJSON = function () { return '(' + e.map(o).join(', ') + ')' }, t }, value: function (e) { function t (t) { return t === e } return t.toJSON = function () { return e }, t } }; function d (e) { if (i.String(e)) return e[0] === '?' ? l.maybe(e.slice(1)) : i[e] || l.quacksLike(e); if (e && i.Object(e)) { if (i.Array(e)) { if (e.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1'); return l.arrayOf(e[0]) } return l.object(e) } return i.Function(e) ? e : l.value(e) } function f (e, t, n, r) { if (i.Function(e)) { if (e(t, n)) return !0; throw new a(r || e, t) } return f(d(e), t, n) } for (var h in l.oneOf = l.anyOf, i)f[h] = i[h]; for (h in l)f[h] = l[h]; const p = n(4307); for (h in p)f[h] = p[h]; f.compile = d, f.TfTypeError = a, f.TfPropertyTypeError = s, e.exports = f }, 247: e => { const t = { Array: function (e) { return e != null && e.constructor === Array }, Boolean: function (e) { return typeof e === 'boolean' }, Function: function (e) { return typeof e === 'function' }, Nil: function (e) { return e == null }, Number: function (e) { return typeof e === 'number' }, Object: function (e) { return typeof e === 'object' }, String: function (e) { return typeof e === 'string' }, '': function () { return !0 } }; for (const n in t.Null = t.Nil, t)t[n].toJSON = function (e) { return e }.bind(null, n); e.exports = t }, 4927: (e, t, n) => { function r (e) { try { if (!n.g.localStorage) return !1 } catch (e) { return !1 } const t = n.g.localStorage[e]; return t != null && String(t).toLowerCase() === 'true' }e.exports = function (e, t) { if (r('noDeprecation')) return e; let n = !1; return function () { if (!n) { if (r('throwDeprecation')) throw new Error(t); r('traceDeprecation') ? console.trace(t) : console.warn(t), n = !0 } return e.apply(this, arguments) } } }, 7795: (e, t, n) => { 'use strict'; const r = n(9509).Buffer; const i = 9007199254740991; function o (e) { if (e < 0 || e > i || e % 1 != 0) throw new RangeError('value out of range') } function a (e) { return o(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9 }e.exports = { encode: function e (t, n, i) { if (o(t), n || (n = r.allocUnsafe(a(t))), !r.isBuffer(n)) throw new TypeError('buffer must be a Buffer instance'); return i || (i = 0), t < 253 ? (n.writeUInt8(t, i), e.bytes = 1) : t <= 65535 ? (n.writeUInt8(253, i), n.writeUInt16LE(t, i + 1), e.bytes = 3) : t <= 4294967295 ? (n.writeUInt8(254, i), n.writeUInt32LE(t, i + 1), e.bytes = 5) : (n.writeUInt8(255, i), n.writeUInt32LE(t >>> 0, i + 1), n.writeUInt32LE(t / 4294967296 | 0, i + 5), e.bytes = 9), n }, decode: function e (t, n) { if (!r.isBuffer(t)) throw new TypeError('buffer must be a Buffer instance'); n || (n = 0); const i = t.readUInt8(n); if (i < 253) return e.bytes = 1, i; if (i === 253) return e.bytes = 3, t.readUInt16LE(n + 1); if (i === 254) return e.bytes = 5, t.readUInt32LE(n + 1); e.bytes = 9; const a = t.readUInt32LE(n + 1); const s = 4294967296 * t.readUInt32LE(n + 5) + a; return o(s), s }, encodingLength: a } }, 1739: e => { e.exports = { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 } }, 3150: function (e, t) { let n, r, i; typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' && self, r = [e], n = function (e) { 'use strict'; if (!globalThis.chrome?.runtime?.id) throw new Error('This script should only be loaded in a browser extension.'); if (void 0 === globalThis.browser || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) { const t = 'The message port closed before a response was received.'; const n = e => { const n = { alarms: { clear: { minArgs: 0, maxArgs: 1 }, clearAll: { minArgs: 0, maxArgs: 0 }, get: { minArgs: 0, maxArgs: 1 }, getAll: { minArgs: 0, maxArgs: 0 } }, bookmarks: { create: { minArgs: 1, maxArgs: 1 }, get: { minArgs: 1, maxArgs: 1 }, getChildren: { minArgs: 1, maxArgs: 1 }, getRecent: { minArgs: 1, maxArgs: 1 }, getSubTree: { minArgs: 1, maxArgs: 1 }, getTree: { minArgs: 0, maxArgs: 0 }, move: { minArgs: 2, maxArgs: 2 }, remove: { minArgs: 1, maxArgs: 1 }, removeTree: { minArgs: 1, maxArgs: 1 }, search: { minArgs: 1, maxArgs: 1 }, update: { minArgs: 2, maxArgs: 2 } }, browserAction: { disable: { minArgs: 0, maxArgs: 1, fallbackToNoCallback: !0 }, enable: { minArgs: 0, maxArgs: 1, fallbackToNoCallback: !0 }, getBadgeBackgroundColor: { minArgs: 1, maxArgs: 1 }, getBadgeText: { minArgs: 1, maxArgs: 1 }, getPopup: { minArgs: 1, maxArgs: 1 }, getTitle: { minArgs: 1, maxArgs: 1 }, openPopup: { minArgs: 0, maxArgs: 0 }, setBadgeBackgroundColor: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, setBadgeText: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, setIcon: { minArgs: 1, maxArgs: 1 }, setPopup: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, setTitle: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 } }, browsingData: { remove: { minArgs: 2, maxArgs: 2 }, removeCache: { minArgs: 1, maxArgs: 1 }, removeCookies: { minArgs: 1, maxArgs: 1 }, removeDownloads: { minArgs: 1, maxArgs: 1 }, removeFormData: { minArgs: 1, maxArgs: 1 }, removeHistory: { minArgs: 1, maxArgs: 1 }, removeLocalStorage: { minArgs: 1, maxArgs: 1 }, removePasswords: { minArgs: 1, maxArgs: 1 }, removePluginData: { minArgs: 1, maxArgs: 1 }, settings: { minArgs: 0, maxArgs: 0 } }, commands: { getAll: { minArgs: 0, maxArgs: 0 } }, contextMenus: { remove: { minArgs: 1, maxArgs: 1 }, removeAll: { minArgs: 0, maxArgs: 0 }, update: { minArgs: 2, maxArgs: 2 } }, cookies: { get: { minArgs: 1, maxArgs: 1 }, getAll: { minArgs: 1, maxArgs: 1 }, getAllCookieStores: { minArgs: 0, maxArgs: 0 }, remove: { minArgs: 1, maxArgs: 1 }, set: { minArgs: 1, maxArgs: 1 } }, devtools: { inspectedWindow: { eval: { minArgs: 1, maxArgs: 2, singleCallbackArg: !1 } }, panels: { create: { minArgs: 3, maxArgs: 3, singleCallbackArg: !0 }, elements: { createSidebarPane: { minArgs: 1, maxArgs: 1 } } } }, downloads: { cancel: { minArgs: 1, maxArgs: 1 }, download: { minArgs: 1, maxArgs: 1 }, erase: { minArgs: 1, maxArgs: 1 }, getFileIcon: { minArgs: 1, maxArgs: 2 }, open: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, pause: { minArgs: 1, maxArgs: 1 }, removeFile: { minArgs: 1, maxArgs: 1 }, resume: { minArgs: 1, maxArgs: 1 }, search: { minArgs: 1, maxArgs: 1 }, show: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 } }, extension: { isAllowedFileSchemeAccess: { minArgs: 0, maxArgs: 0 }, isAllowedIncognitoAccess: { minArgs: 0, maxArgs: 0 } }, history: { addUrl: { minArgs: 1, maxArgs: 1 }, deleteAll: { minArgs: 0, maxArgs: 0 }, deleteRange: { minArgs: 1, maxArgs: 1 }, deleteUrl: { minArgs: 1, maxArgs: 1 }, getVisits: { minArgs: 1, maxArgs: 1 }, search: { minArgs: 1, maxArgs: 1 } }, i18n: { detectLanguage: { minArgs: 1, maxArgs: 1 }, getAcceptLanguages: { minArgs: 0, maxArgs: 0 } }, identity: { launchWebAuthFlow: { minArgs: 1, maxArgs: 1 } }, idle: { queryState: { minArgs: 1, maxArgs: 1 } }, management: { get: { minArgs: 1, maxArgs: 1 }, getAll: { minArgs: 0, maxArgs: 0 }, getSelf: { minArgs: 0, maxArgs: 0 }, setEnabled: { minArgs: 2, maxArgs: 2 }, uninstallSelf: { minArgs: 0, maxArgs: 1 } }, notifications: { clear: { minArgs: 1, maxArgs: 1 }, create: { minArgs: 1, maxArgs: 2 }, getAll: { minArgs: 0, maxArgs: 0 }, getPermissionLevel: { minArgs: 0, maxArgs: 0 }, update: { minArgs: 2, maxArgs: 2 } }, pageAction: { getPopup: { minArgs: 1, maxArgs: 1 }, getTitle: { minArgs: 1, maxArgs: 1 }, hide: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, setIcon: { minArgs: 1, maxArgs: 1 }, setPopup: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, setTitle: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, show: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 } }, permissions: { contains: { minArgs: 1, maxArgs: 1 }, getAll: { minArgs: 0, maxArgs: 0 }, remove: { minArgs: 1, maxArgs: 1 }, request: { minArgs: 1, maxArgs: 1 } }, runtime: { getBackgroundPage: { minArgs: 0, maxArgs: 0 }, getPlatformInfo: { minArgs: 0, maxArgs: 0 }, openOptionsPage: { minArgs: 0, maxArgs: 0 }, requestUpdateCheck: { minArgs: 0, maxArgs: 0 }, sendMessage: { minArgs: 1, maxArgs: 3 }, sendNativeMessage: { minArgs: 2, maxArgs: 2 }, setUninstallURL: { minArgs: 1, maxArgs: 1 } }, sessions: { getDevices: { minArgs: 0, maxArgs: 1 }, getRecentlyClosed: { minArgs: 0, maxArgs: 1 }, restore: { minArgs: 0, maxArgs: 1 } }, storage: { local: { clear: { minArgs: 0, maxArgs: 0 }, get: { minArgs: 0, maxArgs: 1 }, getBytesInUse: { minArgs: 0, maxArgs: 1 }, remove: { minArgs: 1, maxArgs: 1 }, set: { minArgs: 1, maxArgs: 1 } }, managed: { get: { minArgs: 0, maxArgs: 1 }, getBytesInUse: { minArgs: 0, maxArgs: 1 } }, sync: { clear: { minArgs: 0, maxArgs: 0 }, get: { minArgs: 0, maxArgs: 1 }, getBytesInUse: { minArgs: 0, maxArgs: 1 }, remove: { minArgs: 1, maxArgs: 1 }, set: { minArgs: 1, maxArgs: 1 } } }, tabs: { captureVisibleTab: { minArgs: 0, maxArgs: 2 }, create: { minArgs: 1, maxArgs: 1 }, detectLanguage: { minArgs: 0, maxArgs: 1 }, discard: { minArgs: 0, maxArgs: 1 }, duplicate: { minArgs: 1, maxArgs: 1 }, executeScript: { minArgs: 1, maxArgs: 2 }, get: { minArgs: 1, maxArgs: 1 }, getCurrent: { minArgs: 0, maxArgs: 0 }, getZoom: { minArgs: 0, maxArgs: 1 }, getZoomSettings: { minArgs: 0, maxArgs: 1 }, goBack: { minArgs: 0, maxArgs: 1 }, goForward: { minArgs: 0, maxArgs: 1 }, highlight: { minArgs: 1, maxArgs: 1 }, insertCSS: { minArgs: 1, maxArgs: 2 }, move: { minArgs: 2, maxArgs: 2 }, query: { minArgs: 1, maxArgs: 1 }, reload: { minArgs: 0, maxArgs: 2 }, remove: { minArgs: 1, maxArgs: 1 }, removeCSS: { minArgs: 1, maxArgs: 2 }, sendMessage: { minArgs: 2, maxArgs: 3 }, setZoom: { minArgs: 1, maxArgs: 2 }, setZoomSettings: { minArgs: 1, maxArgs: 2 }, update: { minArgs: 1, maxArgs: 2 } }, topSites: { get: { minArgs: 0, maxArgs: 0 } }, webNavigation: { getAllFrames: { minArgs: 1, maxArgs: 1 }, getFrame: { minArgs: 1, maxArgs: 1 } }, webRequest: { handlerBehaviorChanged: { minArgs: 0, maxArgs: 0 } }, windows: { create: { minArgs: 0, maxArgs: 1 }, get: { minArgs: 1, maxArgs: 2 }, getAll: { minArgs: 0, maxArgs: 1 }, getCurrent: { minArgs: 0, maxArgs: 1 }, getLastFocused: { minArgs: 0, maxArgs: 1 }, remove: { minArgs: 1, maxArgs: 1 }, update: { minArgs: 2, maxArgs: 2 } } }; if (Object.keys(n).length === 0) throw new Error('api-metadata.json has not been included in browser-polyfill'); class r extends WeakMap {constructor (e, t = void 0) { super(t), this.createItem = e }get (e) { return this.has(e) || this.set(e, this.createItem(e)), super.get(e) }} const i = e => e && typeof e === 'object' && typeof e.then === 'function'; const o = (t, n) => (...r) => { e.runtime.lastError ? t.reject(new Error(e.runtime.lastError.message)) : n.singleCallbackArg || r.length <= 1 && !1 !== n.singleCallbackArg ? t.resolve(r[0]) : t.resolve(r) }; const a = e => e == 1 ? 'argument' : 'arguments'; const s = (e, t) => function (n, ...r) { if (r.length < t.minArgs) throw new Error(`Expected at least ${t.minArgs} ${a(t.minArgs)} for ${e}(), got ${r.length}`); if (r.length > t.maxArgs) throw new Error(`Expected at most ${t.maxArgs} ${a(t.maxArgs)} for ${e}(), got ${r.length}`); return new Promise((i, a) => { if (t.fallbackToNoCallback) try { n[e](...r, o({ resolve: i, reject: a }, t)) } catch (o) { console.warn(`${e} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `, o), n[e](...r), t.fallbackToNoCallback = !1, t.noCallback = !0, i() } else t.noCallback ? (n[e](...r), i()) : n[e](...r, o({ resolve: i, reject: a }, t)) }) }; const c = (e, t, n) => new Proxy(t, { apply: (t, r, i) => n.call(r, e, ...i) }); const u = Function.call.bind(Object.prototype.hasOwnProperty); const l = (e, t = {}, n = {}) => { const r = Object.create(null); const i = { has: (t, n) => n in e || n in r, get (i, o, a) { if (o in r) return r[o]; if (!(o in e)) return; let d = e[o]; if (typeof d === 'function') if (typeof t[o] === 'function')d = c(e, e[o], t[o]); else if (u(n, o)) { const t = s(o, n[o]); d = c(e, e[o], t) } else d = d.bind(e); else if (typeof d === 'object' && d !== null && (u(t, o) || u(n, o)))d = l(d, t[o], n[o]); else { if (!u(n, '*')) return Object.defineProperty(r, o, { configurable: !0, enumerable: !0, get: () => e[o], set (t) { e[o] = t } }), d; d = l(d, t[o], n['*']) } return r[o] = d, d }, set: (t, n, i, o) => (n in r ? r[n] = i : e[n] = i, !0), defineProperty: (e, t, n) => Reflect.defineProperty(r, t, n), deleteProperty: (e, t) => Reflect.deleteProperty(r, t) }; const o = Object.create(e); return new Proxy(o, i) }; const d = e => ({ addListener (t, n, ...r) { t.addListener(e.get(n), ...r) }, hasListener: (t, n) => t.hasListener(e.get(n)), removeListener (t, n) { t.removeListener(e.get(n)) } }); const f = new r(e => typeof e !== 'function' ? e : function (t) { const n = l(t, {}, { getContent: { minArgs: 0, maxArgs: 0 } }); e(n) }); const h = new r(e => typeof e !== 'function' ? e : function (t, n, r) { let o; let a; let s = !1; const c = new Promise(e => { o = function (t) { s = !0, e(t) } }); try { a = e(t, n, o) } catch (e) { a = Promise.reject(e) } const u = !0 !== a && i(a); if (!0 !== a && !u && !s) return !1; const l = e => { e.then(e => { r(e) }, e => { let t; t = e && (e instanceof Error || typeof e.message === 'string') ? e.message : 'An unexpected error occurred', r({ __mozWebExtensionPolyfillReject__: !0, message: t }) }).catch(e => { console.error('Failed to send onMessage rejected reply', e) }) }; return l(u ? a : c), !0 }); const p = ({ reject: n, resolve: r }, i) => { e.runtime.lastError ? e.runtime.lastError.message === t ? r() : n(new Error(e.runtime.lastError.message)) : i && i.__mozWebExtensionPolyfillReject__ ? n(new Error(i.message)) : r(i) }; const g = (e, t, n, ...r) => { if (r.length < t.minArgs) throw new Error(`Expected at least ${t.minArgs} ${a(t.minArgs)} for ${e}(), got ${r.length}`); if (r.length > t.maxArgs) throw new Error(`Expected at most ${t.maxArgs} ${a(t.maxArgs)} for ${e}(), got ${r.length}`); return new Promise((e, t) => { const i = p.bind(null, { resolve: e, reject: t }); r.push(i), n.sendMessage(...r) }) }; const m = { devtools: { network: { onRequestFinished: d(f) } }, runtime: { onMessage: d(h), onMessageExternal: d(h), sendMessage: g.bind(null, 'sendMessage', { minArgs: 1, maxArgs: 3 }) }, tabs: { sendMessage: g.bind(null, 'sendMessage', { minArgs: 2, maxArgs: 3 }) } }; const y = { clear: { minArgs: 1, maxArgs: 1 }, get: { minArgs: 1, maxArgs: 1 }, set: { minArgs: 1, maxArgs: 1 } }; return n.privacy = { network: { '*': y }, services: { '*': y }, websites: { '*': y } }, l(e, m, n) }; e.exports = n(chrome) } else e.exports = globalThis.browser }, void 0 === (i = typeof n === 'function' ? n.apply(t, r) : n) || (e.exports = i) }, 6601: () => {}, 9214: () => {}, 2480: () => {}, 6403: () => {}, 2361: () => {}, 4616: () => {}, 8597: e => { 'use strict'; e.exports = { i8: '6.5.4' } } }; const o = {}; function a (e) { const t = o[e]; if (void 0 !== t) return t.exports; const n = o[e] = { id: e, loaded: !1, exports: {} }; return i[e].call(n.exports, n, n.exports, a), n.loaded = !0, n.exports }a.m = i, a.n = e => { const t = e && e.__esModule ? () => e.default : () => e; return a.d(t, { a: t }), t }, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__, a.t = function (n, r) { if (1 & r && (n = this(n)), 8 & r) return n; if (typeof n === 'object' && n) { if (4 & r && n.__esModule) return n; if (16 & r && typeof n.then === 'function') return n } const i = Object.create(null); a.r(i); const o = {}; e = e || [null, t({}), t([]), t(t)]; for (let s = 2 & r && n; typeof s === 'object' && !~e.indexOf(s); s = t(s))Object.getOwnPropertyNames(s).forEach(e => o[e] = () => n[e]); return o.default = () => n, a.d(i, o), i }, a.d = (e, t) => { for (const n in t)a.o(t, n) && !a.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }, a.f = {}, a.e = e => Promise.all(Object.keys(a.f).reduce((t, n) => (a.f[n](e, t), t), [])), a.u = e => 'js/' + e + '.bundle.js', a.miniCssF = e => {}, a.g = (function () { if (typeof globalThis === 'object') return globalThis; try { return this || new Function('return this')() } catch (e) { if (typeof window === 'object') return window } }()), a.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n = {}, r = 'lightning-browser-extension:', a.l = (e, t, i, o) => { if (n[e])n[e].push(t); else { let s, c; if (void 0 !== i) for (let u = document.getElementsByTagName('script'), l = 0; l < u.length; l++) { const d = u[l]; if (d.getAttribute('src') == e || d.getAttribute('data-webpack') == r + i) { s = d; break } }s || (c = !0, (s = document.createElement('script')).charset = 'utf-8', s.timeout = 120, a.nc && s.setAttribute('nonce', a.nc), s.setAttribute('data-webpack', r + i), s.src = e), n[e] = [t]; const f = (t, r) => { s.onerror = s.onload = null, clearTimeout(h); const i = n[e]; if (delete n[e], s.parentNode && s.parentNode.removeChild(s), i && i.forEach(e => e(r)), t) return t(r) }; var h = setTimeout(f.bind(null, void 0, { type: 'timeout', target: s }), 12e4); s.onerror = f.bind(null, s.onerror), s.onload = f.bind(null, s.onload), c && document.head.appendChild(s) } }, a.r = e => { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(e, '__esModule', { value: !0 }) }, a.nmd = e => (e.paths = [], e.children || (e.children = []), e), (() => { let e; a.g.importScripts && (e = a.g.location + ''); const t = a.g.document; if (!e && t && (t.currentScript && (e = t.currentScript.src), !e)) { const n = t.getElementsByTagName('script'); if (n.length) for (let r = n.length - 1; r > -1 && !e;)e = n[r--].src } if (!e) throw new Error('Automatic publicPath is not supported in this browser'); e = e.replace(/#.*$/, '').replace(/\?.*$/, '').replace(/\/[^\/]+$/, '/'), a.p = e + '../' })(), (() => { const e = { 352: 0 }; a.f.j = (t, n) => { let r = a.o(e, t) ? e[t] : void 0; if (r !== 0) if (r)n.push(r[2]); else { const i = new Promise((n, i) => r = e[t] = [n, i]); n.push(r[2] = i); const o = a.p + a.u(t); const s = new Error(); a.l(o, n => { if (a.o(e, t) && ((r = e[t]) !== 0 && (e[t] = void 0), r)) { const i = n && (n.type === 'load' ? 'missing' : n.type); const o = n && n.target && n.target.src; s.message = 'Loading chunk ' + t + ' failed.\n(' + i + ': ' + o + ')', s.name = 'ChunkLoadError', s.type = i, s.request = o, r[1](s) } }, 'chunk-' + t, t) } }; const t = (t, n) => { let r; let i; const [o, s, c] = n; let u = 0; if (o.some(t => e[t] !== 0)) { for (r in s)a.o(s, r) && (a.m[r] = s[r]); if (c)c(a) } for (t && t(n); u < o.length; u++)i = o[u], a.o(e, i) && e[i] && e[i][0](), e[i] = 0 }; const n = self.webpackChunklightning_browser_extension = self.webpackChunklightning_browser_extension || []; n.forEach(t.bind(null, 0)), n.push = t.bind(null, n.push.bind(n)) })(), (() => { 'use strict'; const e = {}; a.r(e), a.d(e, { dQ: () => nr, ci: () => Wn, bytesToNumberBE: () => Yn, ty: () => Zn, eV: () => er, n$: () => or, ql: () => Qn, hexToBytes: () => Gn, tL: () => Jn, S5: () => Xn, iY: () => tr, FF: () => sr }); const t = {}; a.r(t), a.d(t, { dQ: () => Pc, ci: () => kc, bytesToNumberBE: () => Oc, ty: () => xc, eV: () => Rc, n$: () => Lc, ql: () => Tc, hexToBytes: () => Ac, tL: () => Ic, S5: () => Nc, FF: () => Dc }); const n = {}; a.r(n), a.d(n, { dQ: () => Vl, ci: () => Ll, bytesToNumberBE: () => Ul, ty: () => Ml, eV: () => ql, n$: () => Gl, ql: () => Hl, hexToBytes: () => Dl, tL: () => zl, S5: () => Fl, iY: () => Kl, FF: () => Zl }); const r = a(3150); const i = a.n(r); const o = 'User rejected'; let s, c; !(function (e) { e.AED = 'AED', e.AFN = 'AFN', e.ALL = 'ALL', e.AMD = 'AMD', e.ANG = 'ANG', e.AOA = 'AOA', e.ARS = 'ARS', e.AUD = 'AUD', e.AWG = 'AWG', e.AZN = 'AZN', e.BAM = 'BAM', e.BBD = 'BBD', e.BDT = 'BDT', e.BGN = 'BGN', e.BHD = 'BHD', e.BIF = 'BIF', e.BMD = 'BMD', e.BND = 'BND', e.BOB = 'BOB', e.BRL = 'BRL', e.BSD = 'BSD', e.BTN = 'BTN', e.BWP = 'BWP', e.BZD = 'BZD', e.CAD = 'CAD', e.CDF = 'CDF', e.CHF = 'CHF', e.CNY = 'CNY', e.COP = 'COP', e.CRC = 'CRC', e.CUP = 'CUP', e.CVE = 'CVE', e.CZK = 'CZK', e.DJF = 'DJF', e.DKK = 'DKK', e.DOP = 'DOP', e.DZD = 'DZD', e.EGP = 'EGP', e.ERN = 'ERN', e.ETB = 'ETB', e.EUR = 'EUR', e.FJD = 'FJD', e.GBP = 'GBP', e.GEL = 'GEL', e.GHS = 'GHS', e.GIP = 'GIP', e.GMD = 'GMD', e.GNF = 'GNF', e.GTQ = 'GTQ', e.GYD = 'GYD', e.HKD = 'HKD', e.HNL = 'HNL', e.HRK = 'HRK', e.HTG = 'HTG', e.HUF = 'HUF', e.IDR = 'IDR', e.ILS = 'ILS', e.INR = 'INR', e.IQD = 'IQD', e.IRR = 'IRR', e.ISK = 'ISK', e.JMD = 'JMD', e.JOD = 'JOD', e.JPY = 'JPY', e.KES = 'KES', e.KGS = 'KGS', e.KHR = 'KHR', e.KMF = 'KMF', e.KPW = 'KPW', e.KRW = 'KRW', e.KWD = 'KWD', e.KYD = 'KYD', e.KZT = 'KZT', e.LAK = 'LAK', e.LBP = 'LBP', e.LKR = 'LKR', e.LRD = 'LRD', e.LSL = 'LSL', e.LYD = 'LYD', e.MAD = 'MAD', e.MDL = 'MDL', e.MGA = 'MGA', e.MKD = 'MKD', e.MMK = 'MMK', e.MNT = 'MNT', e.MOP = 'MOP', e.MUR = 'MUR', e.MVR = 'MVR', e.MWK = 'MWK', e.MXN = 'MXN', e.MYR = 'MYR', e.NAD = 'NAD', e.NGN = 'NGN', e.NIO = 'NIO', e.NOK = 'NOK', e.NPR = 'NPR', e.NZD = 'NZD', e.OMR = 'OMR', e.PAB = 'PAB', e.PEN = 'PEN', e.PGK = 'PGK', e.PHP = 'PHP', e.PKR = 'PKR', e.PLN = 'PLN', e.PYG = 'PYG', e.QAR = 'QAR', e.RON = 'RON', e.RSD = 'RSD', e.RUB = 'RUB', e.RWF = 'RWF', e.SAR = 'SAR', e.SBD = 'SBD', e.SCR = 'SCR', e.SDG = 'SDG', e.SEK = 'SEK', e.SGD = 'SGD', e.SHP = 'SHP', e.SLL = 'SLL', e.SOS = 'SOS', e.SRD = 'SRD', e.SVC = 'SVC', e.SYP = 'SYP', e.SZL = 'SZL', e.THB = 'THB', e.TMT = 'TMT', e.TND = 'TND', e.TOP = 'TOP', e.TRY = 'TRY', e.TTD = 'TTD', e.TWD = 'TWD', e.TZS = 'TZS', e.UAH = 'UAH', e.UGX = 'UGX', e.USD = 'USD', e.UYU = 'UYU', e.UZS = 'UZS', e.VND = 'VND', e.VUV = 'VUV', e.WST = 'WST', e.XAF = 'XAF', e.XCD = 'XCD', e.XOF = 'XOF', e.XPF = 'XPF', e.ZAR = 'ZAR', e.ZMW = 'ZMW', e.ZWL = 'ZWL' }(s || (s = {}))), (function (e) { e.TOP_UP_WALLET = 'top_up_wallet', e.DEMO = 'demo', e.MNEMONIC = 'mnemonic' }(c || (c = {}))); const u = { base64ToHex: e => { const t = []; for (let n = 0, r = atob(e.replace(/[ \r\n]+$/, '')); n < r.length; ++n) { let e = r.charCodeAt(n).toString(16); e.length === 1 && (e = '0' + e), t[t.length] = e } return t.join('') }, urlSafeBase64ToHex: e => u.base64ToHex(e.replace(/_/g, '/').replace(/-/g, '+')), bytesToHexString: e => Array.from(e, e => ('0' + (255 & e).toString(16)).slice(-2)).join(''), bytesToString: e => String.fromCharCode.apply(null, e), hexToUint8Array: e => { const t = e.match(/.{1,2}/g); if (t) return new Uint8Array(t.map(e => parseInt(e, 16))) }, stringToUint8Array: e => Uint8Array.from(e, e => e.charCodeAt(0)), deferredPromise: () => { let e, t; return { promise: new Promise((n, r) => { e = n, t = r }), resolve: e, reject: t } }, openPage: e => { i().tabs.create({ url: i().runtime.getURL(e) }) }, redirectPage: e => { i().tabs.update({ url: i().runtime.getURL(e) }) }, openUrl: e => { i().tabs.create({ url: e }) }, openPrompt: async e => { const t = new URLSearchParams(); e.args && t.set('args', JSON.stringify(e.args)), e.origin && t.set('origin', JSON.stringify(e.origin)), t.set('action', e.action); const n = `${i().runtime.getURL('prompt.html')}?${t.toString()}`; const { top: r, left: o } = await (async function (e, t) { let n = 0; let r = 0; try { const o = await i().windows.getLastFocused(); o && o.top != null && o.left != null && o.width != null && o.height != null && (r = Math.round(o.top + (o.height - t) / 2), n = Math.round(o.left + (o.width - e) / 2)) } catch (t) { const { screenX: i, screenY: o, outerWidth: a } = window; r = Math.max(o, 0), n = Math.max(i + (a - e), 0) } return { top: r, left: n } }(400, 600)); return new Promise((e, t) => { i().windows.create({ url: n, type: 'popup', width: 400, height: 600, top: r, left: o }).then(n => { let r; let o = !0; n.tabs && (r = n.tabs[0].id), n.tabs && n.tabs?.length > 1 && (r = n.tabs?.find(e => e.active)?.id, o = !1); const a = setInterval(() => { n.id && i().windows.update(n.id, { drawAttention: !0 }) }, 2100); const s = (n, s) => { if (n && n.response && s.tab && s.tab.id === r && s.tab.windowId) { let r; return clearInterval(a), i().tabs.onRemoved.removeListener(c), r = o ? i().windows.remove(s.tab.windowId) : i().tabs.remove(s.tab.id), r.then(() => n.error ? t(new Error(n.error)) : e(n)) } }; const c = e => { clearInterval(a), r === e && (i().runtime.onMessage.removeListener(s), t(new Error('Prompt was closed'))) }; i().runtime.onMessage.addListener(s), i().tabs.onRemoved.addListener(c) }) }) }, getBoostagramFromInvoiceCustomRecords: e => { try { let t; const n = e?.[7629169]; return n && (t = atob(n)), t ? JSON.parse(t) : void 0 } catch (e) { return void console.error(e) } } }; const l = u; const d = i().runtime.getManifest().manifest_version === 3; const f = a(2378); const h = a.n(f); const p = a(5030); const g = a.n(p); const m = a(7294); function y (e) { let t; const n = new Set(); const r = (e, r) => { const i = typeof e === 'function' ? e(t) : e; if (i !== t) { const e = t; t = r ? i : Object.assign({}, t, i), n.forEach(n => n(t, e)) } }; const i = () => t; const o = { setState: r, getState: i, subscribe: (e, r, o) => r || o ? ((e, r = i, o = Object.is) => { console.warn('[DEPRECATED] Please use `subscribeWithSelector` middleware'); let a = r(t); function s () { const n = r(t); if (!o(a, n)) { const t = a; e(a = n, t) } } return n.add(s), () => n.delete(s) })(e, r, o) : (n.add(e), () => n.delete(e)), destroy: () => n.clear() }; return t = e(r, i, o), o } const b = typeof window === 'undefined' || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent) ? m.useEffect : m.useLayoutEffect; const v = a(1354); function w (e, t) { return v.AES.encrypt(JSON.stringify(e), t).toString() } function _ (e, t) { const n = v.AES.decrypt(e, t); return JSON.parse(n.toString(v.enc.Utf8)) }a(8507), a(7427), a(7763), a(7822), a(6023), a(5551), a(5473), a(1987), a(7548), a(1876), a(3852); function E (e) { return E = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }, E(e) } function k (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') } function S (e) { const t = (function (e, t) { if (E(e) !== 'object' || e === null) return e; const n = e[Symbol.toPrimitive]; if (void 0 !== n) { const r = n.call(e, t || 'default'); if (E(r) !== 'object') return r; throw new TypeError('@@toPrimitive must return a primitive value.') } return (t === 'string' ? String : Number)(e) }(e, 'string')); return E(t) === 'symbol' ? t : String(t) } function A (e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, S(r.key), r) } } function O (e, t, n) { return t && A(e.prototype, t), n && A(e, n), Object.defineProperty(e, 'prototype', { writable: !1 }), e } function x (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function I (e, t) { return I = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) { return e.__proto__ = t, e }, I(e, t) } function N (e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Super expression must either be null or a function'); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, 'prototype', { writable: !1 }), t && I(e, t) } function T (e, t) { if (t && (E(t) === 'object' || typeof t === 'function')) return t; if (void 0 !== t) throw new TypeError('Derived constructors may only return object or undefined'); return x(e) } function R (e) { return R = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, R(e) } function P (e, t, n) { return (t = S(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function C (e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } function B (e) { return (function (e) { if (Array.isArray(e)) return e }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e) }(e)) || (function (e, t) { if (e) { if (typeof e === 'string') return C(e, t); let n = Object.prototype.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? C(e, t) : void 0 } }(e)) || (function () { throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.') }()) } function L (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function j (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? L(Object(n), !0).forEach(function (t) { P(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : L(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } const D = { type: 'logger', log: function (e) { this.output('log', e) }, warn: function (e) { this.output('warn', e) }, error: function (e) { this.output('error', e) }, output: function (e, t) { console && console[e] && console[e].apply(console, t) } }; const U = (function () { function e (t) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; k(this, e), this.init(t, n) } return O(e, [{ key: 'init', value: function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.prefix = t.prefix || 'i18next:', this.logger = e || D, this.options = t, this.debug = t.debug } }, { key: 'setDebug', value: function (e) { this.debug = e } }, { key: 'log', value: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return this.forward(t, 'log', '', !0) } }, { key: 'warn', value: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return this.forward(t, 'warn', '', !0) } }, { key: 'error', value: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return this.forward(t, 'error', '') } }, { key: 'deprecate', value: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return this.forward(t, 'warn', 'WARNING DEPRECATED: ', !0) } }, { key: 'forward', value: function (e, t, n, r) { return r && !this.debug ? null : (typeof e[0] === 'string' && (e[0] = ''.concat(n).concat(this.prefix, ' ').concat(e[0])), this.logger[t](e)) } }, { key: 'create', value: function (t) { return new e(this.logger, j(j({}, { prefix: ''.concat(this.prefix, ':').concat(t, ':') }), this.options)) } }, { key: 'clone', value: function (t) { return (t = t || this.options).prefix = t.prefix || this.prefix, new e(this.logger, t) } }]), e }()); const M = new U(); const z = (function () { function e () { k(this, e), this.observers = {} } return O(e, [{ key: 'on', value: function (e, t) { const n = this; return e.split(' ').forEach(function (e) { n.observers[e] = n.observers[e] || [], n.observers[e].push(t) }), this } }, { key: 'off', value: function (e, t) { this.observers[e] && (t ? this.observers[e] = this.observers[e].filter(function (e) { return e !== t }) : delete this.observers[e]) } }, { key: 'emit', value: function (e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; this.observers[e] && [].concat(this.observers[e]).forEach(function (e) { e.apply(void 0, n) }); this.observers['*'] && [].concat(this.observers['*']).forEach(function (t) { t.apply(t, [e].concat(n)) }) } }]), e }()); function F () { let e; let t; const n = new Promise(function (n, r) { e = n, t = r }); return n.resolve = e, n.reject = t, n } function H (e) { return e == null ? '' : '' + e } function q (e, t, n) { function r (e) { return e && e.indexOf('###') > -1 ? e.replace(/###/g, '.') : e } function i () { return !e || typeof e === 'string' } for (var o = typeof t !== 'string' ? [].concat(t) : t.split('.'); o.length > 1;) { if (i()) return {}; const a = r(o.shift()); !e[a] && n && (e[a] = new n()), e = Object.prototype.hasOwnProperty.call(e, a) ? e[a] : {} } return i() ? {} : { obj: e, k: r(o.shift()) } } function K (e, t, n) { const r = q(e, t, Object); r.obj[r.k] = n } function V (e, t) { const n = q(e, t); const r = n.obj; const i = n.k; if (r) return r[i] } function W (e, t, n) { for (const r in t)r !== '__proto__' && r !== 'constructor' && (r in e ? typeof e[r] === 'string' || e[r] instanceof String || typeof t[r] === 'string' || t[r] instanceof String ? n && (e[r] = t[r]) : W(e[r], t[r], n) : e[r] = t[r]); return e } function $ (e) { return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&') } const G = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', '/': '&#x2F;' }; function Y (e) { return typeof e === 'string' ? e.replace(/[&<>"'\/]/g, function (e) { return G[e] }) : e } const Z = typeof window !== 'undefined' && window.navigator && void 0 === window.navigator.userAgentData && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1; const J = [' ', ',', '?', '!', ';']; function X (e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : '.'; if (e) { if (e[t]) return e[t]; for (var r = t.split(n), i = e, o = 0; o < r.length; ++o) { if (!i) return; if (typeof i[r[o]] === 'string' && o + 1 < r.length) return; if (void 0 === i[r[o]]) { for (var a = 2, s = r.slice(o, o + a).join(n), c = i[s]; void 0 === c && r.length > o + a;)a++, c = i[s = r.slice(o, o + a).join(n)]; if (void 0 === c) return; if (c === null) return null; if (t.endsWith(s)) { if (typeof c === 'string') return c; if (s && typeof c[s] === 'string') return c[s] } const u = r.slice(o + a).join(n); return u ? X(c, u, n) : void 0 }i = i[r[o]] } return i } } function Q (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function ee (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? Q(Object(n), !0).forEach(function (t) { P(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function te (e) { const t = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0 } catch (e) { return !1 } }()); return function () { let n; const r = R(e); if (t) { const i = R(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return T(this, n) } } const ne = (function (e) { N(n, e); const t = te(n); function n (e) { let r; const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { ns: ['translation'], defaultNS: 'translation' }; return k(this, n), r = t.call(this), Z && z.call(x(r)), r.data = e || {}, r.options = i, void 0 === r.options.keySeparator && (r.options.keySeparator = '.'), void 0 === r.options.ignoreJSONStructure && (r.options.ignoreJSONStructure = !0), r } return O(n, [{ key: 'addNamespaces', value: function (e) { this.options.ns.indexOf(e) < 0 && this.options.ns.push(e) } }, { key: 'removeNamespaces', value: function (e) { const t = this.options.ns.indexOf(e); t > -1 && this.options.ns.splice(t, 1) } }, { key: 'getResource', value: function (e, t, n) { const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const i = void 0 !== r.keySeparator ? r.keySeparator : this.options.keySeparator; const o = void 0 !== r.ignoreJSONStructure ? r.ignoreJSONStructure : this.options.ignoreJSONStructure; let a = [e, t]; n && typeof n !== 'string' && (a = a.concat(n)), n && typeof n === 'string' && (a = a.concat(i ? n.split(i) : n)), e.indexOf('.') > -1 && (a = e.split('.')); const s = V(this.data, a); return s || !o || typeof n !== 'string' ? s : X(this.data && this.data[e] && this.data[e][t], n, i) } }, { key: 'addResource', value: function (e, t, n, r) { const i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : { silent: !1 }; const o = void 0 !== i.keySeparator ? i.keySeparator : this.options.keySeparator; let a = [e, t]; n && (a = a.concat(o ? n.split(o) : n)), e.indexOf('.') > -1 && (r = t, t = (a = e.split('.'))[1]), this.addNamespaces(t), K(this.data, a, r), i.silent || this.emit('added', e, t, n, r) } }, { key: 'addResources', value: function (e, t, n) { const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : { silent: !1 }; for (const i in n) typeof n[i] !== 'string' && Object.prototype.toString.apply(n[i]) !== '[object Array]' || this.addResource(e, t, i, n[i], { silent: !0 }); r.silent || this.emit('added', e, t, n) } }, { key: 'addResourceBundle', value: function (e, t, n, r, i) { const o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : { silent: !1 }; let a = [e, t]; e.indexOf('.') > -1 && (r = n, n = t, t = (a = e.split('.'))[1]), this.addNamespaces(t); let s = V(this.data, a) || {}; r ? W(s, n, i) : s = ee(ee({}, s), n), K(this.data, a, s), o.silent || this.emit('added', e, t, n) } }, { key: 'removeResourceBundle', value: function (e, t) { this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit('removed', e, t) } }, { key: 'hasResourceBundle', value: function (e, t) { return void 0 !== this.getResource(e, t) } }, { key: 'getResourceBundle', value: function (e, t) { return t || (t = this.options.defaultNS), this.options.compatibilityAPI === 'v1' ? ee(ee({}, {}), this.getResource(e, t)) : this.getResource(e, t) } }, { key: 'getDataByLanguage', value: function (e) { return this.data[e] } }, { key: 'hasLanguageSomeTranslations', value: function (e) { const t = this.getDataByLanguage(e); return !!(t && Object.keys(t) || []).find(function (e) { return t[e] && Object.keys(t[e]).length > 0 }) } }, { key: 'toJSON', value: function () { return this.data } }]), n }(z)); const re = { processors: {}, addPostProcessor: function (e) { this.processors[e.name] = e }, handle: function (e, t, n, r, i) { const o = this; return e.forEach(function (e) { o.processors[e] && (t = o.processors[e].process(t, n, r, i)) }), t } }; function ie (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function oe (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? ie(Object(n), !0).forEach(function (t) { P(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ie(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function ae (e) { const t = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0 } catch (e) { return !1 } }()); return function () { let n; const r = R(e); if (t) { const i = R(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return T(this, n) } } const se = {}; const ce = (function (e) { N(n, e); const t = ae(n); function n (e) { let r; const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return k(this, n), r = t.call(this), Z && z.call(x(r)), (function (e, t, n) { e.forEach(function (e) { t[e] && (n[e] = t[e]) }) }(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], e, x(r))), r.options = i, void 0 === r.options.keySeparator && (r.options.keySeparator = '.'), r.logger = M.create('translator'), r } return O(n, [{ key: 'changeLanguage', value: function (e) { e && (this.language = e) } }, { key: 'exists', value: function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { interpolation: {} }; if (e == null) return !1; const n = this.resolve(e, t); return n && void 0 !== n.res } }, { key: 'extractFromKey', value: function (e, t) { let n = void 0 !== t.nsSeparator ? t.nsSeparator : this.options.nsSeparator; void 0 === n && (n = ':'); const r = void 0 !== t.keySeparator ? t.keySeparator : this.options.keySeparator; let i = t.ns || this.options.defaultNS || []; const o = n && e.indexOf(n) > -1; const a = !(this.options.userDefinedKeySeparator || t.keySeparator || this.options.userDefinedNsSeparator || t.nsSeparator || (function (e, t, n) { t = t || '', n = n || ''; const r = J.filter(function (e) { return t.indexOf(e) < 0 && n.indexOf(e) < 0 }); if (r.length === 0) return !0; const i = new RegExp('('.concat(r.map(function (e) { return e === '?' ? '\\?' : e }).join('|'), ')')); let o = !i.test(e); if (!o) { const a = e.indexOf(n); a > 0 && !i.test(e.substring(0, a)) && (o = !0) } return o }(e, n, r))); if (o && !a) { const s = e.match(this.interpolator.nestingRegexp); if (s && s.length > 0) return { key: e, namespaces: i }; const c = e.split(n); (n !== r || n === r && this.options.ns.indexOf(c[0]) > -1) && (i = c.shift()), e = c.join(r) } return typeof i === 'string' && (i = [i]), { key: e, namespaces: i } } }, { key: 'translate', value: function (e, t, r) { const i = this; if (E(t) !== 'object' && this.options.overloadTranslationOptionHandler && (t = this.options.overloadTranslationOptionHandler(arguments)), E(t) === 'object' && (t = oe({}, t)), t || (t = {}), e == null) return ''; Array.isArray(e) || (e = [String(e)]); const o = void 0 !== t.returnDetails ? t.returnDetails : this.options.returnDetails; const a = void 0 !== t.keySeparator ? t.keySeparator : this.options.keySeparator; const s = this.extractFromKey(e[e.length - 1], t); const c = s.key; const u = s.namespaces; const l = u[u.length - 1]; const d = t.lng || this.language; const f = t.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode; if (d && d.toLowerCase() === 'cimode') { if (f) { const h = t.nsSeparator || this.options.nsSeparator; return o ? { res: ''.concat(l).concat(h).concat(c), usedKey: c, exactUsedKey: c, usedLng: d, usedNS: l } : ''.concat(l).concat(h).concat(c) } return o ? { res: c, usedKey: c, exactUsedKey: c, usedLng: d, usedNS: l } : c } const p = this.resolve(e, t); let g = p && p.res; const m = p && p.usedKey || c; const y = p && p.exactUsedKey || c; const b = Object.prototype.toString.apply(g); const v = void 0 !== t.joinArrays ? t.joinArrays : this.options.joinArrays; const w = !this.i18nFormat || this.i18nFormat.handleAsObject; if (w && g && (typeof g !== 'string' && typeof g !== 'boolean' && typeof g !== 'number') && ['[object Number]', '[object Function]', '[object RegExp]'].indexOf(b) < 0 && (typeof v !== 'string' || b !== '[object Array]')) { if (!t.returnObjects && !this.options.returnObjects) { this.options.returnedObjectHandler || this.logger.warn('accessing an object - but returnObjects options is not enabled!'); const _ = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(m, g, oe(oe({}, t), {}, { ns: u })) : "key '".concat(c, ' (').concat(this.language, ")' returned an object instead of string."); return o ? (p.res = _, p) : _ } if (a) { const k = b === '[object Array]'; const S = k ? [] : {}; const A = k ? y : m; for (const O in g) if (Object.prototype.hasOwnProperty.call(g, O)) { const x = ''.concat(A).concat(a).concat(O); S[O] = this.translate(x, oe(oe({}, t), { joinArrays: !1, ns: u })), S[O] === x && (S[O] = g[O]) }g = S } } else if (w && typeof v === 'string' && b === '[object Array]')(g = g.join(v)) && (g = this.extendTranslation(g, e, t, r)); else { let I = !1; let N = !1; const T = void 0 !== t.count && typeof t.count !== 'string'; const R = n.hasDefaultValue(t); const P = T ? this.pluralResolver.getSuffix(d, t.count, t) : ''; const C = t['defaultValue'.concat(P)] || t.defaultValue; !this.isValidLookup(g) && R && (I = !0, g = C), this.isValidLookup(g) || (N = !0, g = c); const B = (t.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && N ? void 0 : g; const L = R && C !== g && this.options.updateMissing; if (N || I || L) { if (this.logger.log(L ? 'updateKey' : 'missingKey', d, l, c, L ? C : g), a) { const j = this.resolve(c, oe(oe({}, t), {}, { keySeparator: !1 })); j && j.res && this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.') } let D = []; const U = this.languageUtils.getFallbackCodes(this.options.fallbackLng, t.lng || this.language); if (this.options.saveMissingTo === 'fallback' && U && U[0]) for (let M = 0; M < U.length; M++)D.push(U[M]); else this.options.saveMissingTo === 'all' ? D = this.languageUtils.toResolveHierarchy(t.lng || this.language) : D.push(t.lng || this.language); const z = function (e, n, r) { const o = R && r !== g ? r : B; i.options.missingKeyHandler ? i.options.missingKeyHandler(e, l, n, o, L, t) : i.backendConnector && i.backendConnector.saveMissing && i.backendConnector.saveMissing(e, l, n, o, L, t), i.emit('missingKey', e, l, n, g) }; this.options.saveMissing && (this.options.saveMissingPlurals && T ? D.forEach(function (e) { i.pluralResolver.getSuffixes(e, t).forEach(function (n) { z([e], c + n, t['defaultValue'.concat(n)] || C) }) }) : z(D, c, C)) }g = this.extendTranslation(g, e, t, p, r), N && g === c && this.options.appendNamespaceToMissingKey && (g = ''.concat(l, ':').concat(c)), (N || I) && this.options.parseMissingKeyHandler && (g = this.options.compatibilityAPI !== 'v1' ? this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? ''.concat(l, ':').concat(c) : c, I ? g : void 0) : this.options.parseMissingKeyHandler(g)) } return o ? (p.res = g, p) : g } }, { key: 'extendTranslation', value: function (e, t, n, r, i) { const o = this; if (this.i18nFormat && this.i18nFormat.parse)e = this.i18nFormat.parse(e, oe(oe({}, this.options.interpolation.defaultVariables), n), r.usedLng, r.usedNS, r.usedKey, { resolved: r }); else if (!n.skipInterpolation) { n.interpolation && this.interpolator.init(oe(oe({}, n), { interpolation: oe(oe({}, this.options.interpolation), n.interpolation) })); let a; const s = typeof e === 'string' && (n && n.interpolation && void 0 !== n.interpolation.skipOnVariables ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables); if (s) { const c = e.match(this.interpolator.nestingRegexp); a = c && c.length } let u = n.replace && typeof n.replace !== 'string' ? n.replace : n; if (this.options.interpolation.defaultVariables && (u = oe(oe({}, this.options.interpolation.defaultVariables), u)), e = this.interpolator.interpolate(e, u, n.lng || this.language, n), s) { const l = e.match(this.interpolator.nestingRegexp); a < (l && l.length) && (n.nest = !1) }!n.lng && this.options.compatibilityAPI !== 'v1' && r && r.res && (n.lng = r.usedLng), !1 !== n.nest && (e = this.interpolator.nest(e, function () { for (var e = arguments.length, r = new Array(e), a = 0; a < e; a++)r[a] = arguments[a]; return i && i[0] === r[0] && !n.context ? (o.logger.warn('It seems you are nesting recursively key: '.concat(r[0], ' in key: ').concat(t[0])), null) : o.translate.apply(o, r.concat([t])) }, n)), n.interpolation && this.interpolator.reset() } const d = n.postProcess || this.options.postProcess; const f = typeof d === 'string' ? [d] : d; return e != null && f && f.length && !1 !== n.applyPostProcessor && (e = re.handle(f, e, t, this.options && this.options.postProcessPassResolved ? oe({ i18nResolved: r }, n) : n, this)), e } }, { key: 'resolve', value: function (e) { let t; let n; let r; let i; let o; const a = this; const s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return typeof e === 'string' && (e = [e]), e.forEach(function (e) { if (!a.isValidLookup(t)) { const c = a.extractFromKey(e, s); const u = c.key; n = u; let l = c.namespaces; a.options.fallbackNS && (l = l.concat(a.options.fallbackNS)); const d = void 0 !== s.count && typeof s.count !== 'string'; const f = d && !s.ordinal && s.count === 0 && a.pluralResolver.shouldUseIntlApi(); const h = void 0 !== s.context && (typeof s.context === 'string' || typeof s.context === 'number') && s.context !== ''; const p = s.lngs ? s.lngs : a.languageUtils.toResolveHierarchy(s.lng || a.language, s.fallbackLng); l.forEach(function (e) { a.isValidLookup(t) || (o = e, !se[''.concat(p[0], '-').concat(e)] && a.utils && a.utils.hasLoadedNamespace && !a.utils.hasLoadedNamespace(o) && (se[''.concat(p[0], '-').concat(e)] = !0, a.logger.warn('key "'.concat(n, '" for languages "').concat(p.join(', '), '" won\'t get resolved as namespace "').concat(o, '" was not yet loaded'), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!')), p.forEach(function (n) { if (!a.isValidLookup(t)) { i = n; let o; const c = [u]; if (a.i18nFormat && a.i18nFormat.addLookupKeys)a.i18nFormat.addLookupKeys(c, u, n, e, s); else { let l; d && (l = a.pluralResolver.getSuffix(n, s.count, s)); const p = ''.concat(a.options.pluralSeparator, 'zero'); if (d && (c.push(u + l), f && c.push(u + p)), h) { const g = ''.concat(u).concat(a.options.contextSeparator).concat(s.context); c.push(g), d && (c.push(g + l), f && c.push(g + p)) } } for (;o = c.pop();)a.isValidLookup(t) || (r = o, t = a.getResource(n, e, o, s)) } })) }) } }), { res: t, usedKey: n, exactUsedKey: r, usedLng: i, usedNS: o } } }, { key: 'isValidLookup', value: function (e) { return !(void 0 === e || !this.options.returnNull && e === null || !this.options.returnEmptyString && e === '') } }, { key: 'getResource', value: function (e, t, n) { const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e, t, n, r) : this.resourceStore.getResource(e, t, n, r) } }], [{ key: 'hasDefaultValue', value: function (e) { const t = 'defaultValue'; for (const n in e) if (Object.prototype.hasOwnProperty.call(e, n) && t === n.substring(0, 12) && void 0 !== e[n]) return !0; return !1 } }]), n }(z)); function ue (e) { return e.charAt(0).toUpperCase() + e.slice(1) } const le = (function () { function e (t) { k(this, e), this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = M.create('languageUtils') } return O(e, [{ key: 'getScriptPartFromCode', value: function (e) { if (!e || e.indexOf('-') < 0) return null; const t = e.split('-'); return t.length === 2 ? null : (t.pop(), t[t.length - 1].toLowerCase() === 'x' ? null : this.formatLanguageCode(t.join('-'))) } }, { key: 'getLanguagePartFromCode', value: function (e) { if (!e || e.indexOf('-') < 0) return e; const t = e.split('-'); return this.formatLanguageCode(t[0]) } }, { key: 'formatLanguageCode', value: function (e) { if (typeof e === 'string' && e.indexOf('-') > -1) { const t = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab']; let n = e.split('-'); return this.options.lowerCaseLng ? n = n.map(function (e) { return e.toLowerCase() }) : n.length === 2 ? (n[0] = n[0].toLowerCase(), n[1] = n[1].toUpperCase(), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = ue(n[1].toLowerCase()))) : n.length === 3 && (n[0] = n[0].toLowerCase(), n[1].length === 2 && (n[1] = n[1].toUpperCase()), n[0] !== 'sgn' && n[2].length === 2 && (n[2] = n[2].toUpperCase()), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = ue(n[1].toLowerCase())), t.indexOf(n[2].toLowerCase()) > -1 && (n[2] = ue(n[2].toLowerCase()))), n.join('-') } return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e } }, { key: 'isSupportedCode', value: function (e) { return (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1 } }, { key: 'getBestMatchFromCodes', value: function (e) { let t; const n = this; return e ? (e.forEach(function (e) { if (!t) { const r = n.formatLanguageCode(e); n.options.supportedLngs && !n.isSupportedCode(r) || (t = r) } }), !t && this.options.supportedLngs && e.forEach(function (e) { if (!t) { const r = n.getLanguagePartFromCode(e); if (n.isSupportedCode(r)) return t = r; t = n.options.supportedLngs.find(function (e) { return e === r ? e : e.indexOf('-') < 0 && r.indexOf('-') < 0 ? void 0 : e.indexOf(r) === 0 ? e : void 0 }) } }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t) : null } }, { key: 'getFallbackCodes', value: function (e, t) { if (!e) return []; if (typeof e === 'function' && (e = e(t)), typeof e === 'string' && (e = [e]), Object.prototype.toString.apply(e) === '[object Array]') return e; if (!t) return e.default || []; let n = e[t]; return n || (n = e[this.getScriptPartFromCode(t)]), n || (n = e[this.formatLanguageCode(t)]), n || (n = e[this.getLanguagePartFromCode(t)]), n || (n = e.default), n || [] } }, { key: 'toResolveHierarchy', value: function (e, t) { const n = this; const r = this.getFallbackCodes(t || this.options.fallbackLng || [], e); const i = []; const o = function (e) { e && (n.isSupportedCode(e) ? i.push(e) : n.logger.warn('rejecting language code not found in supportedLngs: '.concat(e))) }; return typeof e === 'string' && e.indexOf('-') > -1 ? (this.options.load !== 'languageOnly' && o(this.formatLanguageCode(e)), this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly' && o(this.getScriptPartFromCode(e)), this.options.load !== 'currentOnly' && o(this.getLanguagePartFromCode(e))) : typeof e === 'string' && o(this.formatLanguageCode(e)), r.forEach(function (e) { i.indexOf(e) < 0 && o(n.formatLanguageCode(e)) }), i } }]), e }()); const de = [{ lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'tl', 'ti', 'tr', 'uz', 'wa'], nr: [1, 2], fc: 1 }, { lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kk', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'], nr: [1, 2], fc: 2 }, { lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'], nr: [1], fc: 3 }, { lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'], nr: [1, 2, 5], fc: 4 }, { lngs: ['ar'], nr: [0, 1, 2, 3, 11, 100], fc: 5 }, { lngs: ['cs', 'sk'], nr: [1, 2, 5], fc: 6 }, { lngs: ['csb', 'pl'], nr: [1, 2, 5], fc: 7 }, { lngs: ['cy'], nr: [1, 2, 3, 8], fc: 8 }, { lngs: ['fr'], nr: [1, 2], fc: 9 }, { lngs: ['ga'], nr: [1, 2, 3, 7, 11], fc: 10 }, { lngs: ['gd'], nr: [1, 2, 3, 20], fc: 11 }, { lngs: ['is'], nr: [1, 2], fc: 12 }, { lngs: ['jv'], nr: [0, 1], fc: 13 }, { lngs: ['kw'], nr: [1, 2, 3, 4], fc: 14 }, { lngs: ['lt'], nr: [1, 2, 10], fc: 15 }, { lngs: ['lv'], nr: [1, 2, 0], fc: 16 }, { lngs: ['mk'], nr: [1, 2], fc: 17 }, { lngs: ['mnk'], nr: [0, 1, 2], fc: 18 }, { lngs: ['mt'], nr: [1, 2, 11, 20], fc: 19 }, { lngs: ['or'], nr: [2, 1], fc: 2 }, { lngs: ['ro'], nr: [1, 2, 20], fc: 20 }, { lngs: ['sl'], nr: [5, 1, 2, 3], fc: 21 }, { lngs: ['he', 'iw'], nr: [1, 2, 20, 21], fc: 22 }]; const fe = { 1: function (e) { return Number(e > 1) }, 2: function (e) { return Number(e != 1) }, 3: function (e) { return 0 }, 4: function (e) { return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2) }, 5: function (e) { return Number(e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5) }, 6: function (e) { return Number(e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2) }, 7: function (e) { return Number(e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2) }, 8: function (e) { return Number(e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3) }, 9: function (e) { return Number(e >= 2) }, 10: function (e) { return Number(e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4) }, 11: function (e) { return Number(e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3) }, 12: function (e) { return Number(e % 10 != 1 || e % 100 == 11) }, 13: function (e) { return Number(e !== 0) }, 14: function (e) { return Number(e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3) }, 15: function (e) { return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2) }, 16: function (e) { return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2) }, 17: function (e) { return Number(e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1) }, 18: function (e) { return Number(e == 0 ? 0 : e == 1 ? 1 : 2) }, 19: function (e) { return Number(e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3) }, 20: function (e) { return Number(e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2) }, 21: function (e) { return Number(e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0) }, 22: function (e) { return Number(e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3) } }; const he = ['v1', 'v2', 'v3']; const pe = { zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5 }; const ge = (function () { function e (t) { let n; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; k(this, e), this.languageUtils = t, this.options = r, this.logger = M.create('pluralResolver'), this.options.compatibilityJSON && this.options.compatibilityJSON !== 'v4' || typeof Intl !== 'undefined' && Intl.PluralRules || (this.options.compatibilityJSON = 'v3', this.logger.error('Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.')), this.rules = (n = {}, de.forEach(function (e) { e.lngs.forEach(function (t) { n[t] = { numbers: e.nr, plurals: fe[e.fc] } }) }), n) } return O(e, [{ key: 'addRule', value: function (e, t) { this.rules[e] = t } }, { key: 'getRule', value: function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (this.shouldUseIntlApi()) try { return new Intl.PluralRules(e, { type: t.ordinal ? 'ordinal' : 'cardinal' }) } catch (e) { return } return this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)] } }, { key: 'needsPlural', value: function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = this.getRule(e, t); return this.shouldUseIntlApi() ? n && n.resolvedOptions().pluralCategories.length > 1 : n && n.numbers.length > 1 } }, { key: 'getPluralFormsOfKey', value: function (e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return this.getSuffixes(e, n).map(function (e) { return ''.concat(t).concat(e) }) } }, { key: 'getSuffixes', value: function (e) { const t = this; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = this.getRule(e, n); return r ? this.shouldUseIntlApi() ? r.resolvedOptions().pluralCategories.sort(function (e, t) { return pe[e] - pe[t] }).map(function (e) { return ''.concat(t.options.prepend).concat(e) }) : r.numbers.map(function (r) { return t.getSuffix(e, r, n) }) : [] } }, { key: 'getSuffix', value: function (e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const r = this.getRule(e, n); return r ? this.shouldUseIntlApi() ? ''.concat(this.options.prepend).concat(r.select(t)) : this.getSuffixRetroCompatible(r, t) : (this.logger.warn('no plural rule found for: '.concat(e)), '') } }, { key: 'getSuffixRetroCompatible', value: function (e, t) { const n = this; const r = e.noAbs ? e.plurals(t) : e.plurals(Math.abs(t)); let i = e.numbers[r]; this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 && (i === 2 ? i = 'plural' : i === 1 && (i = '')); const o = function () { return n.options.prepend && i.toString() ? n.options.prepend + i.toString() : i.toString() }; return this.options.compatibilityJSON === 'v1' ? i === 1 ? '' : typeof i === 'number' ? '_plural_'.concat(i.toString()) : o() : this.options.compatibilityJSON === 'v2' || this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 ? o() : this.options.prepend && r.toString() ? this.options.prepend + r.toString() : r.toString() } }, { key: 'shouldUseIntlApi', value: function () { return !he.includes(this.options.compatibilityJSON) } }]), e }()); function me (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function ye (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? me(Object(n), !0).forEach(function (t) { P(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : me(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function be (e, t, n) { const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : '.'; const i = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]; let o = (function (e, t, n) { const r = V(e, n); return void 0 !== r ? r : V(t, n) }(e, t, n)); return !o && i && typeof n === 'string' && void 0 === (o = X(e, n, r)) && (o = X(t, n, r)), o } const ve = (function () { function e () { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; k(this, e), this.logger = M.create('interpolator'), this.options = t, this.format = t.interpolation && t.interpolation.format || function (e) { return e }, this.init(t) } return O(e, [{ key: 'init', value: function () { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; e.interpolation || (e.interpolation = { escapeValue: !0 }); const t = e.interpolation; this.escape = void 0 !== t.escape ? t.escape : Y, this.escapeValue = void 0 === t.escapeValue || t.escapeValue, this.useRawValueToEscape = void 0 !== t.useRawValueToEscape && t.useRawValueToEscape, this.prefix = t.prefix ? $(t.prefix) : t.prefixEscaped || '{{', this.suffix = t.suffix ? $(t.suffix) : t.suffixEscaped || '}}', this.formatSeparator = t.formatSeparator ? t.formatSeparator : t.formatSeparator || ',', this.unescapePrefix = t.unescapeSuffix ? '' : t.unescapePrefix || '-', this.unescapeSuffix = this.unescapePrefix ? '' : t.unescapeSuffix || '', this.nestingPrefix = t.nestingPrefix ? $(t.nestingPrefix) : t.nestingPrefixEscaped || $('$t('), this.nestingSuffix = t.nestingSuffix ? $(t.nestingSuffix) : t.nestingSuffixEscaped || $(')'), this.nestingOptionsSeparator = t.nestingOptionsSeparator ? t.nestingOptionsSeparator : t.nestingOptionsSeparator || ',', this.maxReplaces = t.maxReplaces ? t.maxReplaces : 1e3, this.alwaysFormat = void 0 !== t.alwaysFormat && t.alwaysFormat, this.resetRegExp() } }, { key: 'reset', value: function () { this.options && this.init(this.options) } }, { key: 'resetRegExp', value: function () { const e = ''.concat(this.prefix, '(.+?)').concat(this.suffix); this.regexp = new RegExp(e, 'g'); const t = ''.concat(this.prefix).concat(this.unescapePrefix, '(.+?)').concat(this.unescapeSuffix).concat(this.suffix); this.regexpUnescape = new RegExp(t, 'g'); const n = ''.concat(this.nestingPrefix, '(.+?)').concat(this.nestingSuffix); this.nestingRegexp = new RegExp(n, 'g') } }, { key: 'interpolate', value: function (e, t, n, r) { let i; let o; let a; const s = this; const c = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}; function u (e) { return e.replace(/\$/g, '$$$$') } const l = function (e) { if (e.indexOf(s.formatSeparator) < 0) { const i = be(t, c, e, s.options.keySeparator, s.options.ignoreJSONStructure); return s.alwaysFormat ? s.format(i, void 0, n, ye(ye(ye({}, r), t), {}, { interpolationkey: e })) : i } const o = e.split(s.formatSeparator); const a = o.shift().trim(); const u = o.join(s.formatSeparator).trim(); return s.format(be(t, c, a, s.options.keySeparator, s.options.ignoreJSONStructure), u, n, ye(ye(ye({}, r), t), {}, { interpolationkey: a })) }; this.resetRegExp(); const d = r && r.missingInterpolationHandler || this.options.missingInterpolationHandler; const f = r && r.interpolation && void 0 !== r.interpolation.skipOnVariables ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables; return [{ regex: this.regexpUnescape, safeValue: function (e) { return u(e) } }, { regex: this.regexp, safeValue: function (e) { return s.escapeValue ? u(s.escape(e)) : u(e) } }].forEach(function (t) { for (a = 0; i = t.regex.exec(e);) { const n = i[1].trim(); if (void 0 === (o = l(n))) if (typeof d === 'function') { const c = d(e, i, r); o = typeof c === 'string' ? c : '' } else if (r && Object.prototype.hasOwnProperty.call(r, n))o = ''; else { if (f) { o = i[0]; continue }s.logger.warn('missed to pass in variable '.concat(n, ' for interpolating ').concat(e)), o = '' } else typeof o === 'string' || s.useRawValueToEscape || (o = H(o)); const u = t.safeValue(o); if (e = e.replace(i[0], u), f ? (t.regex.lastIndex += o.length, t.regex.lastIndex -= i[0].length) : t.regex.lastIndex = 0, ++a >= s.maxReplaces) break } }), e } }, { key: 'nest', value: function (e, t) { let n; let r; let i; const o = this; const a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; function s (e, t) { const n = this.nestingOptionsSeparator; if (e.indexOf(n) < 0) return e; const r = e.split(new RegExp(''.concat(n, '[ ]*{'))); let o = '{'.concat(r[1]); e = r[0]; const a = (o = this.interpolate(o, i)).match(/'/g); const s = o.match(/"/g); (a && a.length % 2 == 0 && !s || s.length % 2 != 0) && (o = o.replace(/'/g, '"')); try { i = JSON.parse(o), t && (i = ye(ye({}, t), i)) } catch (t) { return this.logger.warn('failed parsing options string in nesting for key '.concat(e), t), ''.concat(e).concat(n).concat(o) } return delete i.defaultValue, e } for (;n = this.nestingRegexp.exec(e);) { let c = []; (i = (i = ye({}, a)).replace && typeof i.replace !== 'string' ? i.replace : i).applyPostProcessor = !1, delete i.defaultValue; let u = !1; if (n[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(n[1])) { const l = n[1].split(this.formatSeparator).map(function (e) { return e.trim() }); n[1] = l.shift(), c = l, u = !0 } if ((r = t(s.call(this, n[1].trim(), i), i)) && n[0] === e && typeof r !== 'string') return r; typeof r !== 'string' && (r = H(r)), r || (this.logger.warn('missed to resolve '.concat(n[1], ' for nesting ').concat(e)), r = ''), u && (r = c.reduce(function (e, t) { return o.format(e, t, a.lng, ye(ye({}, a), {}, { interpolationkey: n[1].trim() })) }, r.trim())), e = e.replace(n[0], r), this.regexp.lastIndex = 0 } return e } }]), e }()); function we (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function _e (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? we(Object(n), !0).forEach(function (t) { P(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : we(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function Ee (e) { const t = {}; return function (n, r, i) { const o = r + JSON.stringify(i); let a = t[o]; return a || (a = e(r, i), t[o] = a), a(n) } } const ke = (function () { function e () { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; k(this, e), this.logger = M.create('formatter'), this.options = t, this.formats = { number: Ee(function (e, t) { const n = new Intl.NumberFormat(e, _e({}, t)); return function (e) { return n.format(e) } }), currency: Ee(function (e, t) { const n = new Intl.NumberFormat(e, _e(_e({}, t), {}, { style: 'currency' })); return function (e) { return n.format(e) } }), datetime: Ee(function (e, t) { const n = new Intl.DateTimeFormat(e, _e({}, t)); return function (e) { return n.format(e) } }), relativetime: Ee(function (e, t) { const n = new Intl.RelativeTimeFormat(e, _e({}, t)); return function (e) { return n.format(e, t.range || 'day') } }), list: Ee(function (e, t) { const n = new Intl.ListFormat(e, _e({}, t)); return function (e) { return n.format(e) } }) }, this.init(t) } return O(e, [{ key: 'init', value: function (e) { const t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { interpolation: {} }).interpolation; this.formatSeparator = t.formatSeparator ? t.formatSeparator : t.formatSeparator || ',' } }, { key: 'add', value: function (e, t) { this.formats[e.toLowerCase().trim()] = t } }, { key: 'addCached', value: function (e, t) { this.formats[e.toLowerCase().trim()] = Ee(t) } }, { key: 'format', value: function (e, t, n) { const r = this; const i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const o = t.split(this.formatSeparator).reduce(function (e, t) { const o = (function (e) { let t = e.toLowerCase().trim(); const n = {}; if (e.indexOf('(') > -1) { const r = e.split('('); t = r[0].toLowerCase().trim(); const i = r[1].substring(0, r[1].length - 1); t === 'currency' && i.indexOf(':') < 0 ? n.currency || (n.currency = i.trim()) : t === 'relativetime' && i.indexOf(':') < 0 ? n.range || (n.range = i.trim()) : i.split(';').forEach(function (e) { if (e) { const t = B(e.split(':')); const r = t[0]; const i = t.slice(1).join(':').trim().replace(/^'+|'+$/g, ''); n[r.trim()] || (n[r.trim()] = i), i === 'false' && (n[r.trim()] = !1), i === 'true' && (n[r.trim()] = !0), isNaN(i) || (n[r.trim()] = parseInt(i, 10)) } }) } return { formatName: t, formatOptions: n } }(t)); const a = o.formatName; const s = o.formatOptions; if (r.formats[a]) { let c = e; try { const u = i && i.formatParams && i.formatParams[i.interpolationkey] || {}; const l = u.locale || u.lng || i.locale || i.lng || n; c = r.formats[a](e, l, _e(_e(_e({}, s), i), u)) } catch (e) { r.logger.warn(e) } return c } return r.logger.warn('there was no format function for '.concat(a)), e }, e); return o } }]), e }()); function Se (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function Ae (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? Se(Object(n), !0).forEach(function (t) { P(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Se(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function Oe (e) { const t = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0 } catch (e) { return !1 } }()); return function () { let n; const r = R(e); if (t) { const i = R(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return T(this, n) } } const xe = (function (e) { N(n, e); const t = Oe(n); function n (e, r, i) { let o; const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; return k(this, n), o = t.call(this), Z && z.call(x(o)), o.backend = e, o.store = r, o.services = i, o.languageUtils = i.languageUtils, o.options = a, o.logger = M.create('backendConnector'), o.waitingReads = [], o.maxParallelReads = a.maxParallelReads || 10, o.readingCalls = 0, o.maxRetries = a.maxRetries >= 0 ? a.maxRetries : 5, o.retryTimeout = a.retryTimeout >= 1 ? a.retryTimeout : 350, o.state = {}, o.queue = [], o.backend && o.backend.init && o.backend.init(i, a.backend, a), o } return O(n, [{ key: 'queueLoad', value: function (e, t, n, r) { const i = this; const o = {}; const a = {}; const s = {}; const c = {}; return e.forEach(function (e) { let r = !0; t.forEach(function (t) { const s = ''.concat(e, '|').concat(t); !n.reload && i.store.hasResourceBundle(e, t) ? i.state[s] = 2 : i.state[s] < 0 || (i.state[s] === 1 ? void 0 === a[s] && (a[s] = !0) : (i.state[s] = 1, r = !1, void 0 === a[s] && (a[s] = !0), void 0 === o[s] && (o[s] = !0), void 0 === c[t] && (c[t] = !0))) }), r || (s[e] = !0) }), (Object.keys(o).length || Object.keys(a).length) && this.queue.push({ pending: a, pendingCount: Object.keys(a).length, loaded: {}, errors: [], callback: r }), { toLoad: Object.keys(o), pending: Object.keys(a), toLoadLanguages: Object.keys(s), toLoadNamespaces: Object.keys(c) } } }, { key: 'loaded', value: function (e, t, n) { const r = e.split('|'); const i = r[0]; const o = r[1]; t && this.emit('failedLoading', i, o, t), n && this.store.addResourceBundle(i, o, n), this.state[e] = t ? -1 : 2; const a = {}; this.queue.forEach(function (n) { !(function (e, t, n, r) { const i = q(e, t, Object); const o = i.obj; const a = i.k; o[a] = o[a] || [], r && (o[a] = o[a].concat(n)), r || o[a].push(n) }(n.loaded, [i], o)), (function (e, t) { void 0 !== e.pending[t] && (delete e.pending[t], e.pendingCount--) }(n, e)), t && n.errors.push(t), n.pendingCount !== 0 || n.done || (Object.keys(n.loaded).forEach(function (e) { a[e] || (a[e] = {}); const t = n.loaded[e]; t.length && t.forEach(function (t) { void 0 === a[e][t] && (a[e][t] = !0) }) }), n.done = !0, n.errors.length ? n.callback(n.errors) : n.callback()) }), this.emit('loaded', a), this.queue = this.queue.filter(function (e) { return !e.done }) } }, { key: 'read', value: function (e, t, n) { const r = this; const i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0; const o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.retryTimeout; const a = arguments.length > 5 ? arguments[5] : void 0; if (!e.length) return a(null, {}); if (this.readingCalls >= this.maxParallelReads) this.waitingReads.push({ lng: e, ns: t, fcName: n, tried: i, wait: o, callback: a }); else { this.readingCalls++; const s = function (s, c) { if (r.readingCalls--, r.waitingReads.length > 0) { const u = r.waitingReads.shift(); r.read(u.lng, u.ns, u.fcName, u.tried, u.wait, u.callback) }s && c && i < r.maxRetries ? setTimeout(function () { r.read.call(r, e, t, n, i + 1, 2 * o, a) }, o) : a(s, c) }; const c = this.backend[n].bind(this.backend); if (c.length !== 2) return c(e, t, s); try { const u = c(e, t); u && typeof u.then === 'function' ? u.then(function (e) { return s(null, e) }).catch(s) : s(null, u) } catch (e) { s(e) } } } }, { key: 'prepareLoading', value: function (e, t) { const n = this; const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const i = arguments.length > 3 ? arguments[3] : void 0; if (!this.backend) return this.logger.warn('No backend was added via i18next.use. Will not load resources.'), i && i(); typeof e === 'string' && (e = this.languageUtils.toResolveHierarchy(e)), typeof t === 'string' && (t = [t]); const o = this.queueLoad(e, t, r, i); if (!o.toLoad.length) return o.pending.length || i(), null; o.toLoad.forEach(function (e) { n.loadOne(e) }) } }, { key: 'load', value: function (e, t, n) { this.prepareLoading(e, t, {}, n) } }, { key: 'reload', value: function (e, t, n) { this.prepareLoading(e, t, { reload: !0 }, n) } }, { key: 'loadOne', value: function (e) { const t = this; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ''; const r = e.split('|'); const i = r[0]; const o = r[1]; this.read(i, o, 'read', void 0, void 0, function (r, a) { r && t.logger.warn(''.concat(n, 'loading namespace ').concat(o, ' for language ').concat(i, ' failed'), r), !r && a && t.logger.log(''.concat(n, 'loaded namespace ').concat(o, ' for language ').concat(i), a), t.loaded(e, r, a) }) } }, { key: 'saveMissing', value: function (e, t, n, r, i) { const o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {}; const a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : function () {}; if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(t)) this.logger.warn('did not save key "'.concat(n, '" as the namespace "').concat(t, '" was not yet loaded'), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!'); else if (n != null && n !== '') { if (this.backend && this.backend.create) { const s = Ae(Ae({}, o), {}, { isUpdate: i }); const c = this.backend.create.bind(this.backend); if (c.length < 6) try { let u; (u = c.length === 5 ? c(e, t, n, r, s) : c(e, t, n, r)) && typeof u.then === 'function' ? u.then(function (e) { return a(null, e) }).catch(a) : a(null, u) } catch (e) { a(e) } else c(e, t, n, r, a, s) }e && e[0] && this.store.addResource(e[0], t, n, r) } } }]), n }(z)); function Ie () { return { debug: !1, initImmediate: !0, ns: ['translation'], defaultNS: ['translation'], fallbackLng: ['dev'], fallbackNS: !1, supportedLngs: !1, nonExplicitSupportedLngs: !1, load: 'all', preload: !1, simplifyPluralSuffix: !0, keySeparator: '.', nsSeparator: ':', pluralSeparator: '_', contextSeparator: '_', partialBundledLanguages: !1, saveMissing: !1, updateMissing: !1, saveMissingTo: 'fallback', saveMissingPlurals: !0, missingKeyHandler: !1, missingInterpolationHandler: !1, postProcess: !1, postProcessPassResolved: !1, returnNull: !0, returnEmptyString: !0, returnObjects: !1, joinArrays: !1, returnedObjectHandler: !1, parseMissingKeyHandler: !1, appendNamespaceToMissingKey: !1, appendNamespaceToCIMode: !1, overloadTranslationOptionHandler: function (e) { let t = {}; if (E(e[1]) === 'object' && (t = e[1]), typeof e[1] === 'string' && (t.defaultValue = e[1]), typeof e[2] === 'string' && (t.tDescription = e[2]), E(e[2]) === 'object' || E(e[3]) === 'object') { const n = e[3] || e[2]; Object.keys(n).forEach(function (e) { t[e] = n[e] }) } return t }, interpolation: { escapeValue: !0, format: function (e, t, n, r) { return e }, prefix: '{{', suffix: '}}', formatSeparator: ',', unescapePrefix: '-', nestingPrefix: '$t(', nestingSuffix: ')', nestingOptionsSeparator: ',', maxReplaces: 1e3, skipOnVariables: !0 } } } function Ne (e) { return typeof e.ns === 'string' && (e.ns = [e.ns]), typeof e.fallbackLng === 'string' && (e.fallbackLng = [e.fallbackLng]), typeof e.fallbackNS === 'string' && (e.fallbackNS = [e.fallbackNS]), e.supportedLngs && e.supportedLngs.indexOf('cimode') < 0 && (e.supportedLngs = e.supportedLngs.concat(['cimode'])), e } function Te (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function Re (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? Te(Object(n), !0).forEach(function (t) { P(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Te(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function Pe (e) { const t = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0 } catch (e) { return !1 } }()); return function () { let n; const r = R(e); if (t) { const i = R(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return T(this, n) } } function Ce () {} const Be = (function (e) { N(n, e); const t = Pe(n); function n () { let e; let r; const i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const o = arguments.length > 1 ? arguments[1] : void 0; if (k(this, n), e = t.call(this), Z && z.call(x(e)), e.options = Ne(i), e.services = {}, e.logger = M, e.modules = { external: [] }, r = x(e), Object.getOwnPropertyNames(Object.getPrototypeOf(r)).forEach(function (e) { typeof r[e] === 'function' && (r[e] = r[e].bind(r)) }), o && !e.isInitialized && !i.isClone) { if (!e.options.initImmediate) return e.init(i, o), T(e, x(e)); setTimeout(function () { e.init(i, o) }, 0) } return e } return O(n, [{ key: 'init', value: function () { const e = this; let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; let n = arguments.length > 1 ? arguments[1] : void 0; typeof t === 'function' && (n = t, t = {}), !t.defaultNS && !1 !== t.defaultNS && t.ns && (typeof t.ns === 'string' ? t.defaultNS = t.ns : t.ns.indexOf('translation') < 0 && (t.defaultNS = t.ns[0])); const r = Ie(); function i (e) { return e ? typeof e === 'function' ? new e() : e : null } if (this.options = Re(Re(Re({}, r), this.options), Ne(t)), this.options.compatibilityAPI !== 'v1' && (this.options.interpolation = Re(Re({}, r.interpolation), this.options.interpolation)), void 0 !== t.keySeparator && (this.options.userDefinedKeySeparator = t.keySeparator), void 0 !== t.nsSeparator && (this.options.userDefinedNsSeparator = t.nsSeparator), !this.options.isClone) { let o; this.modules.logger ? M.init(i(this.modules.logger), this.options) : M.init(null, this.options), this.modules.formatter ? o = this.modules.formatter : typeof Intl !== 'undefined' && (o = ke); const a = new le(this.options); this.store = new ne(this.options.resources, this.options); const s = this.services; s.logger = M, s.resourceStore = this.store, s.languageUtils = a, s.pluralResolver = new ge(a, { prepend: this.options.pluralSeparator, compatibilityJSON: this.options.compatibilityJSON, simplifyPluralSuffix: this.options.simplifyPluralSuffix }), !o || this.options.interpolation.format && this.options.interpolation.format !== r.interpolation.format || (s.formatter = i(o), s.formatter.init(s, this.options), this.options.interpolation.format = s.formatter.format.bind(s.formatter)), s.interpolator = new ve(this.options), s.utils = { hasLoadedNamespace: this.hasLoadedNamespace.bind(this) }, s.backendConnector = new xe(i(this.modules.backend), s.resourceStore, s, this.options), s.backendConnector.on('*', function (t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; e.emit.apply(e, [t].concat(r)) }), this.modules.languageDetector && (s.languageDetector = i(this.modules.languageDetector), s.languageDetector.init && s.languageDetector.init(s, this.options.detection, this.options)), this.modules.i18nFormat && (s.i18nFormat = i(this.modules.i18nFormat), s.i18nFormat.init && s.i18nFormat.init(this)), this.translator = new ce(this.services, this.options), this.translator.on('*', function (t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; e.emit.apply(e, [t].concat(r)) }), this.modules.external.forEach(function (t) { t.init && t.init(e) }) } if (this.format = this.options.interpolation.format, n || (n = Ce), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) { const c = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng); c.length > 0 && c[0] !== 'dev' && (this.options.lng = c[0]) } this.services.languageDetector || this.options.lng || this.logger.warn('init: no languageDetector is used and no lng is defined'); ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'].forEach(function (t) { e[t] = function () { let n; return (n = e.store)[t].apply(n, arguments) } }); ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'].forEach(function (t) { e[t] = function () { let n; return (n = e.store)[t].apply(n, arguments), e } }); const u = F(); const l = function () { const t = function (t, r) { e.isInitialized && !e.initializedStoreOnce && e.logger.warn('init: i18next is already initialized. You should call init just once!'), e.isInitialized = !0, e.options.isClone || e.logger.log('initialized', e.options), e.emit('initialized', e.options), u.resolve(r), n(t, r) }; if (e.languages && e.options.compatibilityAPI !== 'v1' && !e.isInitialized) return t(null, e.t.bind(e)); e.changeLanguage(e.options.lng, t) }; return this.options.resources || !this.options.initImmediate ? l() : setTimeout(l, 0), u } }, { key: 'loadResources', value: function (e) { const t = this; let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ce; const r = typeof e === 'string' ? e : this.language; if (typeof e === 'function' && (n = e), !this.options.resources || this.options.partialBundledLanguages) { if (r && r.toLowerCase() === 'cimode') return n(); const i = []; const o = function (e) { e && t.services.languageUtils.toResolveHierarchy(e).forEach(function (e) { i.indexOf(e) < 0 && i.push(e) }) }; if (r)o(r); else this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(function (e) { return o(e) }); this.options.preload && this.options.preload.forEach(function (e) { return o(e) }), this.services.backendConnector.load(i, this.options.ns, function (e) { e || t.resolvedLanguage || !t.language || t.setResolvedLanguage(t.language), n(e) }) } else n(null) } }, { key: 'reloadResources', value: function (e, t, n) { const r = F(); return e || (e = this.languages), t || (t = this.options.ns), n || (n = Ce), this.services.backendConnector.reload(e, t, function (e) { r.resolve(), n(e) }), r } }, { key: 'use', value: function (e) { if (!e) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()'); if (!e.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()'); return e.type === 'backend' && (this.modules.backend = e), (e.type === 'logger' || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === 'languageDetector' && (this.modules.languageDetector = e), e.type === 'i18nFormat' && (this.modules.i18nFormat = e), e.type === 'postProcessor' && re.addPostProcessor(e), e.type === 'formatter' && (this.modules.formatter = e), e.type === '3rdParty' && this.modules.external.push(e), this } }, { key: 'setResolvedLanguage', value: function (e) { if (e && this.languages && !(['cimode', 'dev'].indexOf(e) > -1)) for (let t = 0; t < this.languages.length; t++) { const n = this.languages[t]; if (!(['cimode', 'dev'].indexOf(n) > -1) && this.store.hasLanguageSomeTranslations(n)) { this.resolvedLanguage = n; break } } } }, { key: 'changeLanguage', value: function (e, t) { const n = this; this.isLanguageChangingTo = e; const r = F(); this.emit('languageChanging', e); const i = function (e) { n.language = e, n.languages = n.services.languageUtils.toResolveHierarchy(e), n.resolvedLanguage = void 0, n.setResolvedLanguage(e) }; const o = function (o) { e || o || !n.services.languageDetector || (o = []); const a = typeof o === 'string' ? o : n.services.languageUtils.getBestMatchFromCodes(o); a && (n.language || i(a), n.translator.language || n.translator.changeLanguage(a), n.services.languageDetector && n.services.languageDetector.cacheUserLanguage && n.services.languageDetector.cacheUserLanguage(a)), n.loadResources(a, function (e) { !(function (e, o) { o ? (i(o), n.translator.changeLanguage(o), n.isLanguageChangingTo = void 0, n.emit('languageChanged', o), n.logger.log('languageChanged', o)) : n.isLanguageChangingTo = void 0, r.resolve(function () { return n.t.apply(n, arguments) }), t && t(e, function () { return n.t.apply(n, arguments) }) }(e, a)) }) }; return e || !this.services.languageDetector || this.services.languageDetector.async ? !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(o) : this.services.languageDetector.detect(o) : o(e) : o(this.services.languageDetector.detect()), r } }, { key: 'getFixedT', value: function (e, t, n) { const r = this; const i = function e (t, i) { let o; if (E(i) !== 'object') { for (var a = arguments.length, s = new Array(a > 2 ? a - 2 : 0), c = 2; c < a; c++)s[c - 2] = arguments[c]; o = r.options.overloadTranslationOptionHandler([t, i].concat(s)) } else o = Re({}, i); o.lng = o.lng || e.lng, o.lngs = o.lngs || e.lngs, o.ns = o.ns || e.ns, o.keyPrefix = o.keyPrefix || n || e.keyPrefix; let u; const l = r.options.keySeparator || '.'; return u = o.keyPrefix && Array.isArray(t) ? t.map(function (e) { return ''.concat(o.keyPrefix).concat(l).concat(e) }) : o.keyPrefix ? ''.concat(o.keyPrefix).concat(l).concat(t) : t, r.t(u, o) }; return typeof e === 'string' ? i.lng = e : i.lngs = e, i.ns = t, i.keyPrefix = n, i } }, { key: 't', value: function () { let e; return this.translator && (e = this.translator).translate.apply(e, arguments) } }, { key: 'exists', value: function () { let e; return this.translator && (e = this.translator).exists.apply(e, arguments) } }, { key: 'setDefaultNamespace', value: function (e) { this.options.defaultNS = e } }, { key: 'hasLoadedNamespace', value: function (e) { const t = this; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!this.isInitialized) return this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages), !1; if (!this.languages || !this.languages.length) return this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages), !1; const r = n.lng || this.resolvedLanguage || this.languages[0]; const i = !!this.options && this.options.fallbackLng; const o = this.languages[this.languages.length - 1]; if (r.toLowerCase() === 'cimode') return !0; const a = function (e, n) { const r = t.services.backendConnector.state[''.concat(e, '|').concat(n)]; return r === -1 || r === 2 }; if (n.precheck) { const s = n.precheck(this, a); if (void 0 !== s) return s } return !!this.hasResourceBundle(r, e) || (!(this.services.backendConnector.backend && (!this.options.resources || this.options.partialBundledLanguages)) || !(!a(r, e) || i && !a(o, e))) } }, { key: 'loadNamespaces', value: function (e, t) { const n = this; const r = F(); return this.options.ns ? (typeof e === 'string' && (e = [e]), e.forEach(function (e) { n.options.ns.indexOf(e) < 0 && n.options.ns.push(e) }), this.loadResources(function (e) { r.resolve(), t && t(e) }), r) : (t && t(), Promise.resolve()) } }, { key: 'loadLanguages', value: function (e, t) { const n = F(); typeof e === 'string' && (e = [e]); const r = this.options.preload || []; const i = e.filter(function (e) { return r.indexOf(e) < 0 }); return i.length ? (this.options.preload = r.concat(i), this.loadResources(function (e) { n.resolve(), t && t(e) }), n) : (t && t(), Promise.resolve()) } }, { key: 'dir', value: function (e) { if (e || (e = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !e) return 'rtl'; const t = this.services && this.services.languageUtils || new le(Ie()); return ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'].indexOf(t.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr' } }, { key: 'cloneInstance', value: function () { const e = this; const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ce; const i = Re(Re(Re({}, this.options), t), { isClone: !0 }); const o = new n(i); void 0 === t.debug && void 0 === t.prefix || (o.logger = o.logger.clone(t)); return ['store', 'services', 'language'].forEach(function (t) { o[t] = e[t] }), o.services = Re({}, this.services), o.services.utils = { hasLoadedNamespace: o.hasLoadedNamespace.bind(o) }, o.translator = new ce(o.services, o.options), o.translator.on('*', function (e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; o.emit.apply(o, [e].concat(n)) }), o.init(i, r), o.translator.options = o.options, o.translator.backendConnector.services.utils = { hasLoadedNamespace: o.hasLoadedNamespace.bind(o) }, o } }, { key: 'toJSON', value: function () { return { options: this.options, store: this.store, language: this.language, languages: this.languages, resolvedLanguage: this.resolvedLanguage } } }]), n }(z)); P(Be, 'createInstance', function () { return new Be(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 ? arguments[1] : void 0) }); const Le = Be.createInstance(); Le.createInstance = Be.createInstance; Le.createInstance, Le.dir, Le.init, Le.loadResources, Le.reloadResources, Le.use, Le.changeLanguage, Le.getFixedT, Le.t, Le.exists, Le.setDefaultNamespace, Le.hasLoadedNamespace, Le.loadNamespaces, Le.loadLanguages; function je (e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } const De = []; const Ue = De.forEach; const Me = De.slice; const ze = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/; const Fe = function (e, t, n, r) { const i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : { path: '/', sameSite: 'strict' }; n && (i.expires = new Date(), i.expires.setTime(i.expires.getTime() + 60 * n * 1e3)), r && (i.domain = r), document.cookie = (function (e, t, n) { const r = n || {}; r.path = r.path || '/'; const i = encodeURIComponent(t); let o = ''.concat(e, '=').concat(i); if (r.maxAge > 0) { const a = r.maxAge - 0; if (Number.isNaN(a)) throw new Error('maxAge should be a Number'); o += '; Max-Age='.concat(Math.floor(a)) } if (r.domain) { if (!ze.test(r.domain)) throw new TypeError('option domain is invalid'); o += '; Domain='.concat(r.domain) } if (r.path) { if (!ze.test(r.path)) throw new TypeError('option path is invalid'); o += '; Path='.concat(r.path) } if (r.expires) { if (typeof r.expires.toUTCString !== 'function') throw new TypeError('option expires is invalid'); o += '; Expires='.concat(r.expires.toUTCString()) } if (r.httpOnly && (o += '; HttpOnly'), r.secure && (o += '; Secure'), r.sameSite) switch (typeof r.sameSite === 'string' ? r.sameSite.toLowerCase() : r.sameSite) { case !0:o += '; SameSite=Strict'; break; case 'lax':o += '; SameSite=Lax'; break; case 'strict':o += '; SameSite=Strict'; break; case 'none':o += '; SameSite=None'; break; default:throw new TypeError('option sameSite is invalid') } return o }(e, encodeURIComponent(t), i)) }; const He = function (e) { for (let t = ''.concat(e, '='), n = document.cookie.split(';'), r = 0; r < n.length; r++) { for (var i = n[r]; i.charAt(0) === ' ';)i = i.substring(1, i.length); if (i.indexOf(t) === 0) return i.substring(t.length, i.length) } return null }; const qe = { name: 'cookie', lookup: function (e) { let t; if (e.lookupCookie && typeof document !== 'undefined') { const n = He(e.lookupCookie); n && (t = n) } return t }, cacheUserLanguage: function (e, t) { t.lookupCookie && typeof document !== 'undefined' && Fe(t.lookupCookie, e, t.cookieMinutes, t.cookieDomain, t.cookieOptions) } }; const Ke = { name: 'querystring', lookup: function (e) { let t; if (typeof window !== 'undefined') { let n = window.location.search; !window.location.search && window.location.hash && window.location.hash.indexOf('?') > -1 && (n = window.location.hash.substring(window.location.hash.indexOf('?'))); for (let r = n.substring(1).split('&'), i = 0; i < r.length; i++) { const o = r[i].indexOf('='); if (o > 0)r[i].substring(0, o) === e.lookupQuerystring && (t = r[i].substring(o + 1)) } } return t } }; let Ve = null; const We = function () { if (Ve !== null) return Ve; try { Ve = window !== 'undefined' && window.localStorage !== null; const e = 'i18next.translate.boo'; window.localStorage.setItem(e, 'foo'), window.localStorage.removeItem(e) } catch (e) { Ve = !1 } return Ve }; const $e = { name: 'localStorage', lookup: function (e) { let t; if (e.lookupLocalStorage && We()) { const n = window.localStorage.getItem(e.lookupLocalStorage); n && (t = n) } return t }, cacheUserLanguage: function (e, t) { t.lookupLocalStorage && We() && window.localStorage.setItem(t.lookupLocalStorage, e) } }; let Ge = null; const Ye = function () { if (Ge !== null) return Ge; try { Ge = window !== 'undefined' && window.sessionStorage !== null; const e = 'i18next.translate.boo'; window.sessionStorage.setItem(e, 'foo'), window.sessionStorage.removeItem(e) } catch (e) { Ge = !1 } return Ge }; const Ze = { name: 'sessionStorage', lookup: function (e) { let t; if (e.lookupSessionStorage && Ye()) { const n = window.sessionStorage.getItem(e.lookupSessionStorage); n && (t = n) } return t }, cacheUserLanguage: function (e, t) { t.lookupSessionStorage && Ye() && window.sessionStorage.setItem(t.lookupSessionStorage, e) } }; const Je = { name: 'navigator', lookup: function (e) { const t = []; if (typeof navigator !== 'undefined') { if (navigator.languages) for (let n = 0; n < navigator.languages.length; n++)t.push(navigator.languages[n]); navigator.userLanguage && t.push(navigator.userLanguage), navigator.language && t.push(navigator.language) } return t.length > 0 ? t : void 0 } }; const Xe = { name: 'htmlTag', lookup: function (e) { let t; const n = e.htmlTag || (typeof document !== 'undefined' ? document.documentElement : null); return n && typeof n.getAttribute === 'function' && (t = n.getAttribute('lang')), t } }; const Qe = { name: 'path', lookup: function (e) { let t; if (typeof window !== 'undefined') { const n = window.location.pathname.match(/\/([a-zA-Z-]*)/g); if (n instanceof Array) if (typeof e.lookupFromPathIndex === 'number') { if (typeof n[e.lookupFromPathIndex] !== 'string') return; t = n[e.lookupFromPathIndex].replace('/', '') } else t = n[0].replace('/', '') } return t } }; const et = { name: 'subdomain', lookup: function (e) { const t = typeof e.lookupFromSubdomainIndex === 'number' ? e.lookupFromSubdomainIndex + 1 : 1; const n = typeof window !== 'undefined' && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i); if (n) return n[t] } }; const tt = (function () { function e (t) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; !(function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') }(this, e)), this.type = 'languageDetector', this.detectors = {}, this.init(t, n) } let t, n, r; return t = e, n = [{ key: 'init', value: function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; this.services = e || { languageUtils: {} }, this.options = (function (e) { return Ue.call(Me.call(arguments, 1), function (t) { if (t) for (const n in t) void 0 === e[n] && (e[n] = t[n]) }), e }(t, this.options || {}, { order: ['querystring', 'cookie', 'localStorage', 'sessionStorage', 'navigator', 'htmlTag'], lookupQuerystring: 'lng', lookupCookie: 'i18next', lookupLocalStorage: 'i18nextLng', lookupSessionStorage: 'i18nextLng', caches: ['localStorage'], excludeCacheFor: ['cimode'], convertDetectedLanguage: function (e) { return e } })), typeof this.options.convertDetectedLanguage === 'string' && this.options.convertDetectedLanguage.indexOf('15897') > -1 && (this.options.convertDetectedLanguage = function (e) { return e.replace('-', '_') }), this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex), this.i18nOptions = n, this.addDetector(qe), this.addDetector(Ke), this.addDetector($e), this.addDetector(Ze), this.addDetector(Je), this.addDetector(Xe), this.addDetector(Qe), this.addDetector(et) } }, { key: 'addDetector', value: function (e) { this.detectors[e.name] = e } }, { key: 'detect', value: function (e) { const t = this; e || (e = this.options.order); let n = []; return e.forEach(function (e) { if (t.detectors[e]) { let r = t.detectors[e].lookup(t.options); r && typeof r === 'string' && (r = [r]), r && (n = n.concat(r)) } }), n = n.map(function (e) { return t.options.convertDetectedLanguage(e) }), this.services.languageUtils.getBestMatchFromCodes ? n : n.length > 0 ? n[0] : null } }, { key: 'cacheUserLanguage', value: function (e, t) { const n = this; t || (t = this.options.caches), t && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(e) > -1 || t.forEach(function (t) { n.detectors[t] && n.detectors[t].cacheUserLanguage(e, n.options) })) } }], n && je(t.prototype, n), r && je(t, r), Object.defineProperty(t, 'prototype', { writable: !1 }), e }()); tt.type = 'languageDetector'; a(1739); Object.create(null); function nt (e) { return nt = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }, nt(e) } function rt (e) { const t = (function (e, t) { if (nt(e) !== 'object' || e === null) return e; const n = e[Symbol.toPrimitive]; if (void 0 !== n) { const r = n.call(e, t || 'default'); if (nt(r) !== 'object') return r; throw new TypeError('@@toPrimitive must return a primitive value.') } return (t === 'string' ? String : Number)(e) }(e, 'string')); return nt(t) === 'symbol' ? t : String(t) } function it (e, t, n) { return (t = rt(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } const ot = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g; const at = { '&amp;': '&', '&#38;': '&', '&lt;': '<', '&#60;': '<', '&gt;': '>', '&#62;': '>', '&apos;': "'", '&#39;': "'", '&quot;': '"', '&#34;': '"', '&nbsp;': ' ', '&#160;': ' ', '&copy;': '', '&#169;': '', '&reg;': '', '&#174;': '', '&hellip;': '', '&#8230;': '', '&#x2F;': '/', '&#47;': '/' }; const st = function (e) { return at[e] }; function ct (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function ut (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? ct(Object(n), !0).forEach(function (t) { it(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ct(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } let lt = { bindI18n: 'languageChanged', bindI18nStore: '', transEmptyNodeValue: '', transSupportBasicHtmlNodes: !0, transWrapTextNodes: '', transKeepBasicHtmlNodesFor: ['br', 'strong', 'i', 'p'], useSuspense: !0, unescape: function (e) { return e.replace(ot, st) } }; function dt (e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, rt(r.key), r) } } const ft = { type: '3rdParty', init: function (e) { !(function () { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; lt = ut(ut({}, lt), e) }(e.options.react)), (function (e) { e }(e)) } }; (0, m.createContext)(), (function () { function e () { !(function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') }(this, e)), this.usedNamespaces = {} } let t, n, r; t = e, (n = [{ key: 'addUsedNamespaces', value: function (e) { const t = this; e.forEach(function (e) { t.usedNamespaces[e] || (t.usedNamespaces[e] = !0) }) } }, { key: 'getUsedNamespaces', value: function () { return Object.keys(this.usedNamespaces) } }]) && dt(t.prototype, n), r && dt(t, r), Object.defineProperty(t, 'prototype', { writable: !1 }) }()); const ht = JSON.parse('{"xk":{"welcome":{"set_password":{"title":"Nastavte/Nastavit heslo pro odemen tu","description":"Toto heslo je pouito pro zabezpeen vai penenky a pokytuje pstup k doplku prohlee. Ji neme bt resetovno a nijak nesouvis s heslem k vaemu Alby tu.","choose_password":{"label":"Zvolte heslo pro odemen:"},"confirm_password":{"label":"Ovte, e heslo je zadno sprvn:"},"errors":{"enter_password":"Prosm, zadejte heslo.","confirm_password":"Prosm potvrte sv heslo.","mismatched_password":"Hesla se neshoduj."}},"test_connection":{"ready":"Skvle, ve je pipraveno!","initializing":"Inicializace vaeho tu. Prosm ekejte, chvli to zabere...","connection_error":"Chyba spojen","review_connection_details":"Prosm pekontrolujte nastaven vaeho spojen.","connection_taking_long":"Pipojovn zabralo vce, ne bylo oekvno... Zadali jste daje o pipojen sprvn? Je v uzel dostupn?","contact_support":"Pokud potebujete pomoct, prosm kontaktujte support@getalby.com","actions":{"delete_edit_account":"Smate nevalidn et a zmny provete znovu"}},"title":"Vtejte v Alby"},"choose_connector":{"description":"Pipojte svou extern ligtning penenku nebo uzel","lnd":{"title":"LND","page":{"title":"Pipojt se ke svmu LND uzlu","description":"Potebujete URL svho uzlu a macaroon s oprvnnm pro ten a odesln (napklad admin.macaroon)"},"url":{"label":"REST API host a port","placeholder":"https://url-vaseho-uzlu:8080"},"macaroon":{"label":"Macaroon (v hexadecimlnm formtu)"},"drag_and_drop":"Pethnte svj macaroon zde nebo ho <0>vyhledejte</0>","errors":{"connection_failed":"Pipojen se nezdailo. Jsou vae daje pro LND zadny sprvn?"}},"lndhub_bluewallet":{"title":"Bluewallet","page":{"title":"Pipojit k BlueWallet","description":"V BlueWallet vyberte penenku, kterou chcete pipojit, otevete ji, kliknte na ..., kliknte na Exportovat/Zloha pro zobrazen QR kdu a tento kd naskenujte svou webkamerou."},"uri":{"label":"BlueWallet Export URI"},"errors":{"invalid_uri":"Nevalidn BlueWallet URI","connection_failed":"Pipojen se nezdailo. Je vae BlueWallet URI sprvn?"}},"lndhub_go":{"title":"LNDHub","page":{"title":"Pipojit k LNDHub","description":"Vlote svou LNDHub URI nebo naskenujte QR kd svou webkamerou."},"uri":{"label":"LNDHub Export URI"},"errors":{"invalid_uri":"Nevalidn LNDHub URI","connection_failed":"Pipojen se nezdailo. Je vae LNDHub URI zadna sprvn?"}},"lnbits":{"title":"LNbits","page":{"title":"Pipojen k <0>LNbits</0>","instructions":"V LNbits vyberte penenku, ke kter se chcete pipojit, otevete ji, zvolte Informace o API, zkoprujte administran kl. Vlote ho zde:"},"admin_key":{"label":"LNbits Administran kl","placeholder":"V 32-mstn administran kl"},"url":{"label":"LNbits URL"},"errors":{"connection_failed":"Pipojen se nezdailo. Zadali jste sprvnou URL a administran kl?"}},"eclair":{"title":"Eclair","page":{"title":"Pipojen k <0>Eclair</0>","instructions":"Potebujete svou Eclair URL a heslo."},"password":{"label":"Eclair heslo"},"url":{"label":"Eclair URL","placeholder":"http://localhost:8080"}},"citadel":{"title":"Citadel","page":{"title":"Pipojen k uzlu <0>Citadel</0>","instructions":"Aktuln nefunguje v ppad, e mte zapnutou dvoufaktorovou autentizaci (2FA)."},"password":{"label":"Heslo k Citadel"},"url":{"label":"Citadel URL","placeholder":"http://citadel.local"}},"umbrel":{"title":"Umbrel","page":{"title":"Pipojen k uzlu <0>Umbrel</0>","instructions":"V dashboardu Umbrell pejdte do <0>Pipojit pnenku (Connect Wallet)</0>. Vyberte volbu <0>lndconnect REST</0> a zkoprujte <0>lndconnect URL</0>. (V zvislosti na vaem nastaven mete vyut bu loklnho spojen nebo pipojen pes Tor.)"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://vas-uzel:8080?..."}},"mynode":{"title":"myNode","page":{"title":"Pipojen k <0>myNode</0>","instructions":"Na va domovsk strnce myNode kliknte na tlatko <0>Pnenka (Wallet)</0> sluby <0>lightning</0>.<1/> Dle zvolte <0>Provat penenku (Pair Wallet)</0> pod zlokou <0>Stav (Status)</0>. S dotznm vlote vae heslo.<1/> Z rozbalovac nabdky vyberte volbu provn. V zvislosti na vaem nastaven mete zvolit bu pipojen pes <0>lightning (REST + Local IP)</0> nebo <0>lightning (REST + Tor)</0>."},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://vas-uzel:8080?..."}},"start9":{"title":"Start9","page":{"title":"Pipojen k vaemu uzlu <0>Embassy</0>","instructions":"<0>Pozn.:</0> Aktuln podporujeme pouze LND, ale v budoucnu plnujeme pidvat podporu c-lightning!<1/>V dashboardu vaeho Embassy zvolte slubu <0>Lightning Network Daemon</0>.<1/>Vyberte zloku <0>Vlastnosti (Properties)</0>.<1/>Nsledn zkoprujte <0>LND Connect REST URL.</0>"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://vas-uzel:8080?..."}},"raspiblitz":{"title":"RaspiBlitz","page":{"title":"Pipojen k vaemu uzlu <0>RaspiBlitz</0>","instructions1":"Nsledujte tyto kroky:<1/> 1. <0>Pipojte se pes SSH</0> k vaemu <0>RaspiBlitz</0><1/>2. Vyberte <0>Pipojit aplikace a zobrazit pstupov daje (Connect Apps & Show Credentials)</0> ze seznamu<1/><0/>3. Vyberte <0>Pipojit Alby k tomuto uzlu</0><1/>4. Stisknte <0>OK</0>pro zobrazen detail pipojen<1/><1/>Zkoprujte <0>REST API</0> nebo <0>.onion</0> adresu pro pipojen pes Tor a vlote ji do vstupnho pole ne.","instructions2":"Zkoprujte (administran) <0>macaroon</0> do pole ne."},"rest_api_host":{"label":"REST API host","placeholder":"onion-adresa-vaseho-uzlu:port"}},"bitcoin_beach":{"title":"Bitcoin Beach Wallet","page":{"title":"Pipojen k <0>Bitcoin Beach Wallet</0>"}},"bitcoin_jungle":{"title":"Bitcoin Jungle Wallet","page":{"title":"Pipojen k <0>Bitcoin Jungle Wallet</0>"}},"galoy":{"phone_number":{"label":"Vlote sv telefonn slo"},"sms_code":{"label":"Vloe verifikan kd ze SMS"},"token":{"label":"Vloe svj JWT token","info":"Pihlen {{label}} je aktuln aktualizovno. Pokud jste pokroil uivatel, mete svj JWT token zskat pihlenm pes <0>Webovou penenku (wallet.mainnet.galoy.io)</0><1/><1/>JWT token vypad podobn jako: <2>eyJhbG...</2><1/><1/>"},"actions":{"login":"Pihlsit"},"errors":{"setup_failed":"Nastaven se nezdailo","missing_token":"JWT chyb, pihlen se nezdailo.","invalid_token":"Vloeno nevalidn JWT"}},"btcpay":{"title":"BTCPay Server","page":{"title":"Pipojen k vaemu uzlu BTCPay LND","instructions":"Pesute se do svho BTCPayServer a pihlate se jako administrtor. Bte do Nastaven serveru > Sluby > LND Rest - Vce informac. Nsledn zvolte \\"Zobrazit informace o QR kdu\\" a zkoprujte zobrazen data. Vlote je ne:"},"config":{"label":"Konfiguran data","placeholder":"config=https://vas-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Pipojen se nezdailo. Je BTCPay URL zadna sprvn a je pstupn?"}},"commando":{"title":"Core Lightning","page":{"title":"Pipojen k vaemu uzlu Core Lightning","instructions":"Ujistte se, e pouvte Core Lightning verze 0.12.0 (nebo novj), dle e vm b doplnk commando a v uzel je pstupn pes s lightning. Vytvote novou \\"runu\\" sputnm pkazu \'lightning-cli commando-rune\'."},"host":{"label":"Host"},"pubkey":{"label":"Veejn kl"},"rune":{"label":"Runa"},"port":{"label":"Port"},"proxy":{"label":"Websocket proxy"},"privKey":{"label":"Lokln privtn kl (automaticky generovan)"},"config":{"label":"Konfiguran data","placeholder":"config=https://vas-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Pipojen se nezdailo. Je v Core Lightning uzel online a se zapnutm doplkem commando?"}},"title":"Pipojte Lightning penenku","lnc":{"title":"LND s LNC","page":{"title":"Pipojit k vaemu LND uzlu","description":"Vytvote nov sezen v terminlu (litd) pro zskn nov provac frze a vlote ji zde"},"pairing_phrase":{"label":"Vae provac frze ","placeholder":"tajn frze"}},"kollider":{"description":"Pihlen k vaemu tu Kollider","title":"Kollider","errors":{"connection_failed":"Pipojen se nezdailo. Jste si jisti, e jste zadali daje k tu sprvn?"},"username":{"label":"Vlote vae uivatelsk jmno ke Kollider"},"currency":{"label":"Zvolte mnu vaeho tu"}}},"home":{"actions":{"send_satoshis":" Odeslat satoshi ","enable_now":"Povolit nyn"},"recent_transactions":"Nedvn transakce","allowance_view":{"recent_transactions":"Nedvn transakce","allowance":"Pspvek","sats_used":"pouit satoshi","no_transactions":"Prozatm dn transakce na <0>{{name}}</0>."},"default_view":{"recent_transactions":"Nedvn transakce","is_blocked_hint":"Alby je v souasnosti zakzan na {host}}","block_removed":"Povolen {{host}}. Prosm znovu natte webovou strnku."}},"accounts":{"title":"ty","actions":{"add_account":"Pidat et"},"account_view":{"remove":{"confirm":"Jste si jisti, e chcete odstranit et: {{name}}? \\nTato operace nelze vzt zpt. Pokud jste tento et pouvali k pihlaovan k webovm strnkam, mete k nim ztratit pstup.","title":"Odstranit tento et","subtitle":"Vechny propojen pspvky budou smazny. Bute si jisti, e akci chcete opravdu provst."},"nostr":{"errors":{"failed_to_load":"Nepodailo se nast Nostr kl. Zadali jste validn Nostr kl?"},"generate_keys":{"hint":"Mete vygenerovat nov nhodn generovan kl nebo derivovat kl ze svho tu (s vyuitm podepsan kanonick frze). <0>Dozvdt se vce </0>","screen_reader":"Vygenerovat nov Nostr kl pro v et","actions":{"random_keys":"Vygenerovat nhodn kl","derived_keys":"Derivovat kl z vaeho tu"},"title":"Vygenerujte nov Nostr kl"},"private_key":{"title":"Sprva vaeho kle","subtitle":"Vlote svj privtn kl nebo si vygenerujte nov. Pedtm, ne budete generovat nov kl, ujistte se, e mte svj kl zazalohovan. <0>Dozvdt se vce </0>","warning":"Prosm vlote jmno vaeho tu pro potvrzen smazn privtnho kle:","success":"Privtn kl byl spn zaifrovn a uloen.","successfully_removed":"Privtn kl byl odstrann.","label":"Privtn kl","failed_to_remove":"Zadan jmno tu se neshoduje, v star privtn kl byl obnoven."},"actions":{"generate":"Vygenerovat nov kl"},"hint":"je jednoduch oteven protokol, jeho snahou je vytvoit necenzurovateln sociln st. Nostr pracuje s kryptografickmi kli. Pro publikovn jakkoliv zpravy pes tento protokol, je vdy nutn zprvu podepsat svm klem a odeslat ji nkolika tzv. rel. Alby mete pout ke sprv svho Nostr kle. Vtina Nostr aplikac vm pak umon jednoduch pouit kle pmo z doplku Alby.","title":"Nostr","public_key":{"label":"Veejn kl"}},"actions":{"remove_account":"Odstranit et","export":"Export"},"export":{"screen_reader":"Exportovat detaily tu","title":"Exportovat et","export_uri":"LNDHub povovac URI","waiting":"ekn na data z LndHub...","your_ln_address":"Vae Lightning adresa:","scan_qr":"Importujte tuto penenku do Zeus nebo BlueWallet naskenovnm QR kdu."},"title1":"Informace o tu","title2":"Upravit et","name":{"title":"Jmno","placeholder":"Jmno tu"}}},"enable":{"title":"Pipojit","allow":"Povolit tto webov strnce:","request1":"dat povolen pro transakce","request2":"dat faktury a informace o lightning","block_and_ignore":"Blokovat a ignorovat {{host}}","block_added":"{{host}} byl pidn do listu blokovanch, prosm znovu natte strnku."},"unlock":{"unlock_to_continue":"Odemknout pro pokraovn","unlock_password":"Vae heslo pro odemen","help_contact":{"part1":"Potebujete pomoc? Kontaktujte","part2":"podporu Alby"},"unlock_error":{"help":"Data vaeho tu jsou ifrovna vam heslem pro odemen. Pokud sv heslo pro odemen zapomenete, budete muset resetovat a znovu vytvoit svj lightning et.","link":"Resetovat a vytvoit nov et"},"errors":{"invalid_password":"Nesprvn heslo"}},"settings":{"title":"Nastaven","browser_notifications":{"title":"Upozornn prohlee","subtitle":"Platebn notifikace a notifikace tkajc se autentizace."},"website_enhancements":{"title":"Vylepen webov strnky","subtitle":"Monosti tipovn pro Twitter, YouTube, apod."},"lnurl_auth":{"title":"LNURL-Auth","hint":"je obecn autentizan protokol. Ovuje uivatele pomoc digitlnch podpisu. Protkol nevyaduje dn dal identifikan daje jako jsou hesla, e-maily, uivatelsk jmna a podobn. S Alby mete pouvat sv lightning ty k bezpenmu pihlen k webovm strnkm. Abychom byli kompatibiln s jinmi penenkami, museli jsme udlat nkolik zmn, kter mete nakonfigurovat zde. <0>V idelnm ppad jsou vechny tyto monosti vypnut.</0> Pouvejte je pouze v ppad, e mte star ty.","legacy_lnurl_auth_202207":{"title":"Star verze LNURL-Auth","subtitle":"Generovn kle pro LNURL-auth se zmnilo (ervenec 2022). Alby nebylo kompatibiln s jinmi implementacemi. To bylo zmnno, ale nyn se pouvaj jin pihlaovac kle. Pokud jste dve pouvali LNURL-auth pro pihlaovn, mete stle zapnout star chovn. Tato volba bude v budoucnu odstranna. Ujistte se, e jste peli na nov typ pihlen."},"legacy_lnurl_auth":{"title":"Star verze podepisovn pro LNDhub aLNbits","subtitle":"Podepisovn zprv a pihlaovn pes LNDhub (napklad BlueWallet) a LNbits ty bylo zmnno (Bezen 2022). Pokud jste se pes tyto ty pihlaovali, mete stle zapnout podporu star pihlaovac metody. Tato volba bude v budoucnu odstranna, proto se ujistte, e jste peli na novou metodu pihlaovn."}},"camera_access":{"title":"Pstup kamery","subtitle":"Pro skenovn QR kd","allow":"Povolit pstup kamee","granted":"Oprvnn udleno"},"language":{"title":"Jazyk","subtitle":"Peklady jet nejsou stoprocentn hotov. <0>Pomote nm peloit Alby do vaeho jazyka!<0>"},"theme":{"title":"Tma","subtitle":"Pouvejte Alby v tmavm nebo svtlm mdu","options":{"dark":"Tmav","light":"Svtl","system":"Systm"}},"show_fiat":{"title":"Saty do fiatu","subtitle":"Vdy provdt smnu do vybran mny z vybran smnrny"},"currency":{"title":"Mna","subtitle":"Zobrazovat stky v tto mn"},"exchange":{"title":"Zdroj kurzu","subtitle":"Zdroj bitcoinovho smnnho kurzu"},"personal_data":{"title":"Osobn data","description":"Pjemci plateb mohou dat o dodaten data, kter se odelou spolu s plabou. Tato data nejsou s nikm sdlena bez vaeho souhlasu, vdy budete dotzn, zda si opravdu pejete tato data odeslat zrove s vai platbou."},"name":{"title":"Jmno","subtitle":"","placeholder":"Vlote sv jmno"},"email":{"title":"Email","subtitle":"","placeholder":"Vlote svou e-mailovou adresu"},"change_password":{"title":"Zmnit heslo pro odemen","subtitle":"","screen_reader":"Zmnit heslo pro odemen","choose_password":{"label":"Vlote nov heslo pro odemen:"},"confirm_password":{"label":"Potvrte nov heslo:"},"submit":{"label":"Zmnit"},"errors":{"enter_password":"Prosm vlote nov heslo pro odemen.","confirm_password":"Prosm potvrte sv heslo.","mismatched_password":"Hesla se neshoduj."},"success":"Zmna hesla probhla spn"},"nostr":{"title":"Nostr","hint":"je jednoduch oteven protokol, jeho snahou je vytvoit necenzurovateln sociln st. Nostr pracuje s kryptografickmi kli. Pro publikovn jakkoliv zpravy pes tento protokol, je vdy nutn zprvu podepsat svm klem a odeslat ji nkolika rel. Mete pout Alby ke sprv svho Nostr kle. Vtina Nostr aplikac vm pak umon jednoduch pouit kle pmo z doplku Alby.","private_key":{"title":"Privtn kl","subtitle":"Tato sekce je pesunuta na strnku s ty, protoe kle se tkaj t.","go_to":"Jt do sprvy t"}}},"send":{"title":"Odeslat","input":{"label":"Pjemce","hint":"Faktura, Lightning adresa nebo LNURL"}},"lnurlpay":{"amount":{"label":"stka"},"comment":{"label":"Koment"},"name":{"label":"Jmno"},"email":{"label":"Email"},"success":"spch, platba byla odeslna!"},"lnurlauth":{"title":"Autentizace","content_message":{"heading":"Chcete se pihlsit do"},"submit":"Pihlsit","success":"spn pihlen na {{name}}","errors":{"status":"Chyba: Stav autentizace nen v podku"}},"lnurlchannel":{"title":"dost o kanl","content_message":{"heading":"dost o kanl z uzlu"},"success":"dost o kanl odeslna spn na {{name}}"},"lnurlwithdraw":{"title":"Vbr","content_message":{"heading":"stka"},"amount":{"label":"stka"},"success":"dost o vber stky {{amount}} byla spn odeslna {{sender}}"},"receive":{"title":"Pijmout","actions":{"create_invoice":"Vytvoit fakturu"},"amount":{"label":"stka","placeholder":"stka v satoshi..."},"description":{"label":"Popisek","placeholder":"Nap. kdo tuto platbu odesl?"},"success":"Platba pijata!","payment":{"waiting":"ekn na platbu...","status":"Zkontrolovat stav platby"}},"publishers":{"publisher":{"allowance":{"title":"Pspvek","used_budget":"pouit satoshi"}},"title":"Vae  webov strnky","description":"Webov strnky, na kterch jste v minulosti pouili Alby","no_info":"Vypad to, e jste Alby jet na dn webov strnce nepouili.","discover":"Prozkoumat webov strnky"},"make_invoice":{"title":"Vytvoit fakturu","amount":{"label":"stka (v satoshi)"},"memo":{"label":"Poznmka"},"errors":{"amount_too_small":"stka je men ne minimum","amount_too_big":"stka pevyuje maximum"}},"confirm_sign_message":{"title":"Podepsat","content":"Tato webov strnka vs d o podpis:"},"confirm_keysend":{"title":"Schvlit platbu","success":"Platba odeslna! Preimage: {{preimage}}","payment_summary":{"description":"Platba odeslna na: {{destination}}"}},"keysend":{"title":"Odeslat","success":"Platba odeslna! Preimage: {{preimage}}","receiver":{"label":"Platba odeslna na"},"amount":{"label":"stka (v satoshi)"}},"confirm_payment":{"title":"Schvlit platbu","success":"Platba v hodnote {{amount}} byla spn!","actions":{"pay_now":"Zaplatit"}},"confirm_request_permission":{"title":"Schvlit dost","allow":"Dovolit tto strnce spustit:","always_allow":"Zapamatovat si m volby a nikdy se u neptat"},"nostr":{"title":"Nostr","allow":"Dovolit tto strnce:","block_and_ignore":"Zablokovat a ignorovat {{host}}","allow_sign":"Povolit {{host}} podepsn:","block_added":"{{host}} pidn do seznamu blokovanch, prosm znovu natte webovou strnku.","content":"Tato webov strnka vs d o podpis:"},"choose_path":{"other":{"title":"Jin penenky","description":"Pipojte svou existujc lightning penenku nebo svj uzel pomoc rznch konektor.","and_more":"a vce...","connect":"Pipojit"},"alby":{"title":"Alby","description":"Zaregistrujte se, nebo se pihlate ke svmu existujcmu Alby tu a zante vyuvat lightning platby."}},"alby":{"pre_connect":{"set_password":{"choose_password":{"label":"Heslo"},"confirm_password":{"label":"Potvrte heslo"},"errors":{"enter_password":"Prosm zadejte heslo.","confirm_password":"Prosm potvrte sv heslo.","mismatched_password":"Hesla se neshoduj."}}}},"discover":{"title":"Prozkoumejte ekosystm Lightningu ","description":"Webov strnky a aplikace, kde je mon Alby pouvat","list":{"trading":"Obchodovn","gaming":"Hran her","entertainment":"Zbava","shopping":"Nakupovn","nostr":"Nostr","miscellaneous":"Rzn","showcases":"Pklady uit"},"tips":{"title":"Vae Alby penenka je pipravena","description":"Pr tip ne zanete","top_up_wallet":{"title":" Dobt penenku","description":"Vytvote lightning fakturu, polete si bitcoiny a zante pouvat Alby v ekosystmu lightning"},"demo":{"description":"Objevte ve, co lze s Alby dlat, na na demo strnce","title":" Vyzkouejte demo Alby"}}}},"y0":{"password":"Heslo","advanced":"Pokroil","success":"spch","error":"Chyba","settings":"Nastaven","connected_sites":"","sats_one":"sat","sats_other":"sat","loading":"natn","amount":"stka","optional":"Voliten","feedback":"Zptn vazba","copied":"Zkoprovno!","description":"Popis","description_full":"Pln popis","success_message":"{{amount}}{{fiatAmount}} odeslna na {{destination}}","response":"Odezva","message":"Zprva","help":"Pomoc","actions":{"back":"Zpt","delete":"Smazat","edit":"Upravit","next":"Dal","open":"Otevt","cancel":"Zruit","confirm":"Potvrdit","continue":"Pokraovat","connect":"Pipojit","lock":"Uzamt","unlock":"Odemknout","send":"Odeslat","save":"Uloit","receive":"Pijmout","close":"Zavt","export":"Exportovat","remove":"Odstranit","copy":"Zkoprovat","copy_invoice":"","log_in":"Pihlsit se","receive_again":"Pijmout dal platbu","remember":"Zapamatovat moji volbu a nikdy se u neptat"},"errors":{"connection_failed":"Pipojen se nezdailo","payment_failed":"Platba se nezdaila"},"confirm_password":"Potvrte heslo","accounts":"ty","discover":"Objevovat"},"wx":{"allowance_menu":{"confirm_delete":"Jste si jisti, e chcete tuto webovou strnku smazat?","hint":"Tato akce vyresetuje v aktuln rozpoet","new_budget":{"label":"Nov rozpoet"},"enable_login":{"title":"Povolit pihlen k webovm strnkm","subtitle":"Automaticky pihlsit bez potvrzen, kdy to webov strnka vyd."},"edit_allowance":{"title":"Upravit pspvek","screen_reader":"Monosti pspvku"},"edit_permissions":"Upravit oprvnn"},"qrcode_scanner":{"title":"Skenovat QR kd","actions":{"start_scanning":"Zat skenovat","stop_scanning":"Zastavit skenovn"},"errors":{"allow_camera_access":"Prosm povolte pstup kamery ve svm nastaven."}},"transactionsTable":{"fee":"Poplatek","preimage":"Preimage","received":"Pijato","sent":"Odeslno","boostagram":{"sender":"Odeslatel","message":"Zprva","app":"Aplikace","podcast":"Podcast"},"open_location":"Otevt webovou strnku"},"confirm_or_cancel":{"only_trusted":"Spojit pouze se strnkami, kterm dvujete."},"budget_control":{"remember":{"label":"Zapamatovat a nastavit rozpoet","description":"Mete nastavit zstatek tak, aby nebylo poadovno potvrzen o platbch, dokud nebude vyerpn."},"budget":{"label":"Rozpoet"}},"toasts":{"connection_error":{"what_you_can_do":"Co mete dlat:","double_check":"Znovu pekontrolujte detaily spojen","if_ssl_errors":"a pokud vidte SSL chyby (napklad ERR_CERT_AUTHORITY_INVALID), kliknte na \\"pokroil\\" a pokraujte pijetm certifiktu.","visit_guides":"Navtivte nae nvody pro dal pomoc"},"login_failed":{"password_reset":"Zapomnli jste heslo? Kliknte zde"},"errors":{"invalid_credentials":"Chybn heslo. Prosm zkontrolujte sv heslo a emailovou adresu a zkuste to znovu."}},"account_menu":{"screen_reader":"Pepnout rozbalovac nabdku","title":"Zmnit et","options":{"account":{"add":"Pidat nov et","manage":"Spravovat ty"}}},"publishers_table":{"payments":"platby","used":"pouit"},"badge":{"label":{"active":"AKTIVN","auth":"PIHLEN"}}},"mk":{"lnd":{"lookupinvoice":"Vyhledat detaily o faktue.","getinfo":"Zskat informace o uzlu.","disconnectpeer":"Odpojit se od vzdlenho uzlu.","listpeers":"Zskat seznam vech aktuln aktivnch peer.","connectpeer":"Navzet spojen se vzdlenm uzlem.","listchannels":"Zskat popis vech otevench kanl.","estimatefee":"Odhadnout sazbu poplatku a celkov poplatky za transakci.","listinvoices":"Zskat seznam vech faktur.","channelbalance":"Zskat pehled o celkovch prostedcch nap vemi otevenmi kanly.","walletbalance":"Zskat celkov neutracen vstupy (UTXO) penenky.","getnetworkinfo":"Zskat zkladn statistiky o znmm grafu kanl.","openchannel":"Otevt nov kanl.","listpayments":"Zskat seznam vech odchozch plateb.","verifymessage":"Verifikovat podpis zprvy.","sendtoroute":"Provst platbu pes zadanou cestu.","addinvoice":"Vytvoit nov faktury.","routermc":"Pest vnitn kontroln stav.","getchaninfo":"Zskat oznmen st pro dan kanl.","getnodeinfo":"Zskat informace o kanlu pro dan uzel.","queryroutes":"Vyhledat mon cesty.","gettransactions":"Zskat seznam vech transakc tkajcch se dan penenky.","decodepayreq":"Dekdovat etzec dosti o platbu."},"commando":{"setchannel":"Konfigurace poplatk / rozsahu htlc oznamovanho pro kanl.","disconnect":"Uzavt existujc spojen s uzlem.","connect":"Navzat nov spojen s jinm uzlem.","bkpr-listbalances":"Seznam vech souasnch i minulch zstatk tu.","checkmessage":"Zkontrolovat, e byl podpis vygenerovn zadanm uzlem.","decode":"Dekdovat etzec bolt11/bolt12/runu.","decodepay":"Zkontrolovat a zparsovat etzec bolt11.","feerates":"Vrtit sazby poplatk, kter CLN pouije.","fundchannel":"Otevt platebn kanl s uzlem provedenm tzv. funding transakce.","getinfo":"Zskat souhrn o uzlu.","offer":"Vytvoit nabdku.","sendpay":"Odeslat platbu pes danou cestu.","listpeers":"Zobrazit uzly, kter jsou pipojeny nebo maj oteven kanl s tmto uzlem.","listsendpays":"Zsk stav vech sendpay pkaz.","listpays":"Zsk stav vech platebnch pkaz.","listtransactions":"Seznam transakc sledovanch v penence.","pay":"Odeslat platbu na BOLT11 fakturu.","keysend":"Odeslat platbu na jin uzel.","listinvoices":"Zskat status vech faktur.","listnodes":"Vypsat uzly, o kterch se uzel dozvdl prostednictvm gossip zprv.","listoffers":"Vypsat vechy nabdky nebo zskat konkrtn nabdku.","multifundchannel":"Otevt vce platebnch kanl s uzly provedenm jedn (funding) transakce.","signmessage":"Vytvoit podpis z tohoto uzlu.","getroute":"Najt nejlep cestu pro platbu na lightning uzel.","listfunds":"Vypsat seznam vech dostupnch prostedk.","listforwards":"Zobrazit seznam vech htlc, kter se uzel pokusil pedat dle.","invoice":"Vytvoit novou platebn fakturu."},"nostr":{"nip04encrypt":"Zaifrovat data.","getpublickey":"Pest svj veejn kl.","nip04decrypt":"Deifrovat data.","signmessage":"Podepsat zprvu klem."},"lnc":{"estimatefee":"Odhadnout sazbu poplatku a celkov poplatky za transakci.","lookupinvoice":"Vyhledat detaily o faktue.","queryroutes":"Vyhledat mon cesty.","verifymessage":"Verifikovat podpis zprvy.","sendtoroute":"Provst platbu pes zadanou cestu.","decodepayreq":"Dekdovat etzec dosti o platbu.","routermc":"Pest vnitn kontroln stav.","getinfo":"Zskat informace o uzlu.","walletbalance":"Zskat celkov neutracen vstupy (UTXO) penenky.","listpeers":"Zskat seznam vech aktuln aktivnch peer.","addinvoice":"Vytvoit nov faktury.","listchannels":"Zskat popis vech otevench kanl.","listinvoices":"Zskat seznam vech faktur.","channelbalance":"Zskat pehled o celkovch prostedcch nap vemi otevenmi kanly.","openchannel":"Otevt nov kanl.","disconnectpeer":"Odpojit se od vzdlenho uzlu.","getchaninfo":"Zskat oznmen st pro dan kanl.","getnetworkinfo":"Zskat zkladn statistiky o znmm grafu kanl.","getnodeinfo":"Zskat informace o kanlu pro dan uzel.","gettransactions":"Zskat seznam vech transakc tkajcch se dan penenky.","listpayments":"Zskat seznam vech odchozch plateb.","connectpeer":"Navzet spojen se vzdlenm uzlem."}}}'); const pt = JSON.parse('{"xk":{"welcome":{"title":"Velkommen til Alby","set_password":{"title":"Angiv en nglekode","description":"Dette kodeord bruges til at beskytte din wallet og giver adgang til browserudvidelsen. Det kan ikke nulstilles, og er ikke den samme som adgangskoden til din Alby-konto.","choose_password":{"label":"Vlg en nglekode:"},"confirm_password":{"label":"Lad os se, om du skrev det korrekt:"},"errors":{"enter_password":"Indtast en adgangskode.","confirm_password":"Bekrft din adgangskode.","mismatched_password":"Adgangskoderne er forskellige."}},"test_connection":{"ready":"Super, s er du klar!","initializing":"Forbereder din konto. Vent venligst, dette tager et jeblik...","connection_error":"Fejl p forbindelse","review_connection_details":"Kontroller dine forbindelsesoplysninger.","connection_taking_long":"Etablering af forbindelse gr lidt langsomt...Er dine oplysninger korrekte? Er der kontakt til din node?","contact_support":"Kontakt support@getalby.com hvis du behver hjlp","actions":{"delete_edit_account":"Slet ugyldig konto og rediger igen"}}},"choose_path":{"alby":{"title":"Alby","description":"Opret dig, eller brug din eksisterende Alby-konto til hurtigt at starte med at betale via lightning."},"other":{"title":"Andre wallets","description":"Opret forbindelse til din eksisterende wallet eller node, og vlg mellem flere forbindelser.","and_more":"med mere...","connect":"Opret forbindelse"}},"alby":{"pre_connect":{"set_password":{"choose_password":{"label":"Adgangskode"},"confirm_password":{"label":"Bekrft adgangskoden"},"errors":{"enter_password":"Indtast en adgangskode.","confirm_password":"Bekrft din adgangskode.","mismatched_password":"Adgangskoderne er forskellige."}}}},"choose_connector":{"title":"Opret forbindelse til Lightning-wallet","description":"Opret forbindelse til din eksterne Lightning-wallet eller node","lnd":{"title":"LND","page":{"title":"Opret forbindelse til din LND-node","description":"Du skal bruge din nodes URL og en macaroon med tilladelse til at lse og sende (fx admin.macaroon)"},"url":{"label":"REST API vrt og port","placeholder":"https://din-nodes-url:8080"},"macaroon":{"label":"Macaroon (HEX-format)"},"drag_and_drop":"Trk din macaroon herhen eller <0>find den</0>","errors":{"connection_failed":"Forbindelse kunne ikke oprettes. Er dine LND-oplysninger korrekte?"}},"lnc":{"title":"LND med LNC","page":{"title":"Opret forbindelse til din LND-node","description":"Start en ny session i terminal (litd) for at f en ny forbindelseskode, og skriv den her"},"pairing_phrase":{"label":"Din forbindelseskode ","placeholder":"hemmelig kode til sats-samlingen"}},"lndhub_bluewallet":{"title":"Bluewallet","page":{"title":"Opet forbindelse til Bluewallet","description":"Vlg den wallet du vil oprette forbindelse til i Bluewallet, bn den, klik p \\"...\\", klik p Export/Backup for at se QR-koden og afls den med dit webkamera."},"uri":{"label":"BlueWallet export URI"},"errors":{"invalid_uri":"Ugyldig BlueWallet URI","connection_failed":"Forbindelse kunne ikke oprettes. Er din BlueWallet URI korrekt?"}},"lndhub_go":{"title":"LNDHub","page":{"title":"Opret forbindelse til LNDHub","description":"Indst dine adgangsoplysninger til LNDHub her, eller afls QR-koden med dit webkamera."},"uri":{"label":"LNDHub export URI"},"errors":{"invalid_uri":"Ugyldig LNDHub URI","connection_failed":"Forbindelse kunne ikke oprettes. Er din LNDHub URI korrekt?"}},"lnbits":{"title":"LNbits","page":{"title":"Opret forbindelse til <0>LNbits</0>","instructions":"Vlg den wallet du vil oprette forbindelse til i LNbits, bn den, klik p API-oplysninger og kopier Admin-nglen. Indst den herunder:"},"admin_key":{"label":"LNbits Admin-ngle","placeholder":"Din admin-ngle med 32 tegn"},"url":{"label":"LNbits URL"},"errors":{"connection_failed":"Forbindelse kunne ikke oprettes. Er URL og admin-ngle korrekte?"}},"eclair":{"title":"Eclair","page":{"title":"Opret forbindelse til <0>Eclair</0>","instructions":"Du skal bruge din adgangskode og URL til Eclair."},"password":{"label":"Eclair adgangskode"},"url":{"label":"Eclair URL","placeholder":"http://localhost:8080"}},"citadel":{"title":"Citadel","page":{"title":"Opret forbindelse til <0>Citadel</0> node","instructions":"Dette virker i jeblikket ikke, hvis 2FA er slet til."},"password":{"label":"Citadel adgangskode"},"url":{"label":"Citadel URL","placeholder":"http://citadel.local"}},"umbrel":{"title":"Umbrel","page":{"title":"Opret forbindelse til <0>Umbrel</0> node","instructions":"Find <0>Connect Wallet</0> i din Umbrels indstillingsmenu. Vlg <0>lndconnect REST</0> og kopier <0>lndconnect URL</0>. (Afhngigt af din opstning kan du enten bruge den lokale forbindelse eller Tor-forbindelsen.)"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://dinnode:8080?..."}},"mynode":{"title":"myNode","page":{"title":"Opret forbindelse til <0>myNode</0>","instructions":"P din myNode-side klikker du p <0>Wallet</0> knappen til din <0>lightning</0> service.<1/> Klik s p knappen <0>Pair Wallet</0> under <0>Status</0> fanen. Skriv din adgangskode, nr du bliver spurgt.<1/> Vlg rullemenuen og vlg en koblingstype. Afhngigt af din opstning kan du enten bruge forbindelsen <0>lightning (REST + Lokal IP)</0> eller forbindelsen <0>lightning (REST + Tor)</0> ."},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://dinnode:8080?..."}},"start9":{"title":"Start9","page":{"title":"Opret forbindelse til din <0>Embassy</0> node","instructions":"<0>Note:</0> I jeblikket understtter vi kun LND, men vi vil fremover ogs tilfje support af c-lightning!<1/>I din Embassys indstillingsmenu klikker du p servicen <0>Lightning Network Daemon</0>.<1/>Vlg fanen <0>Properties</0>.<1/>Kopier s <0>LND Connect REST URL.</0>"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://dinnode:8080?..."}},"raspiblitz":{"title":"RaspiBlitz","page":{"title":"Opret forbindelse til din <0>RaspiBlitz</0> node","instructions1":"Du skal bruge din nodes onion-adresse og port samt en macaroon med tilladelse til at lse og sende (fx admin.macaroon).<1/><1/><0>SSH</0> ind til din <0>RaspiBlitz</0>.<1/>Udfr instruktionen <0>sudo cat /mnt/hdd/tor/lndrest/hostname</0>.<1/>Kopier og indst <0>.onion</0> adressen i nedenstende indtastningsfelt.<1/>Tilfj din <0>port</0> efter onion-adressen, standardporten er <0>:8080</0>.","instructions2":"Vlg <0>CONNECT</0>.<1/>Vlg <0>EXPORT</0>.<1/>Vlg <0>HEX</0>.<1/>Kopier <0>adminMacaroon</0>.<1/>St din macaroon ind i indtastningsfeltet nedenunder."},"rest_api_host":{"label":"REST API host","placeholder":"din-nodes-onion-adresse:port"}},"bitcoin_beach":{"title":"Bitcoin Beach Wallet","page":{"title":"Opret forbindelse til <0>Bitcoin Beach Wallet</0>"}},"bitcoin_jungle":{"title":"Bitcoin Jungle Wallet","page":{"title":"Opret forbindelse til <0>Bitcoin Jungle Wallet</0>"}},"galoy":{"phone_number":{"label":"Indtast dit telefonnummer"},"sms_code":{"label":"Indtast din SMS-bekrftelseskode"},"token":{"label":"Indtast din JWT-token","info":"Log ind med {{label}} bliver i jeblikketl opgraderet. Hvis du er en vet bruger, kan du f din JWT-token ved at logge ind via <0>Web Wallet (wallet.mainnet.galoy.io)</0><1/><1/>JWT ser sdan ud: <2>eyJhbG...</2><1/><1/>"},"actions":{"login":"Adgangsoplysninger"},"errors":{"setup_failed":"Opstning mislykkedes","missing_token":"JWT mangler, kunne ikke logge ind.","invalid_token":"ugyldig JWT givet"}},"kollider":{"title":"Kollider","description":"Log ind p din Kollider-konto","username":{"label":"Indtast dit Kollider-brugernavn"},"currency":{"label":"Vlg din kontovaluta"},"errors":{"connection_failed":"Forbindelsen kunne ikke oprettes. Er du sikker p at kontooplysningerne er korrekte?"}},"btcpay":{"title":"BTCPay Server","page":{"title":"Opret forbindelse til din BTCPay LND-node","instructions":"G til din BTCPayServer og log p som administrator. G til Server Settings > Services > LND Rest - See information. Klik s p \\"See QR Code information\\" og kopier QR-kodens data. Indst dem herunder:"},"config":{"label":"Konfigurationsoplysninger","placeholder":"config=https://din-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Forbindelsen kunne ikke oprettes. Er BTCPay-forbindelsens URL korrekt og tilgngelig?"}},"commando":{"title":"Core Lightning","page":{"title":"Opret forbindelse til din Core Lightning-node","instructions":"Srg for at have Core Lightning-versionen 0.12.0 eller nyere, at kommandomodulet krer og at din node kan tilgs p lightning-netvrket. Opret en rune ved at kre \'lightning-cli commando-rune\'."},"host":{"label":"Vrt"},"pubkey":{"label":"Offentlig ngle"},"rune":{"label":"Rune"},"port":{"label":"Port"},"proxy":{"label":"Websocket-proxy"},"privKey":{"label":"Lokal privat ngle (autogenereret)"},"config":{"label":"Konfigurationsdata","placeholder":"config=https://din-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Forbindelse kunne ikke oprettes. Er din Core Lightning-node online, og er kommandomodulet i brug?"}}},"home":{"actions":{"send_satoshis":" Send Satoshi ","enable_now":"Aktiver nu"},"recent_transactions":"Seneste transaktioner","allowance_view":{"recent_transactions":"Seneste transaktioner","allowance":"Pulje","sats_used":"brugte sats","no_transactions":"Endnu ingen transaktioner p <0>{{navn}}</0>."},"default_view":{"recent_transactions":"Seneste transaktioner","is_blocked_hint":"Alby er i jeblikket deaktiveret p {{vrt}}","block_removed":"{{vrt}} blev aktiveret. Indls hjemmesiden igen."}},"accounts":{"title":"Konti","account_view":{"title1":"Kontooplysninger","title2":"Rediger konto","name":{"title":"Navn","placeholder":"Kontonavn"},"export":{"title":"Eksporter konto","screen_reader":"Eksporter kontooplysninger","waiting":"venter p LndHub-data...","your_ln_address":"Din lightningadresse:","export_uri":"URI til LNDHub-adgangsoplysninger","scan_qr":"Importer denne wallet til Zeus eller BlueWallet ved at skanne QR-koden."},"nostr":{"title":"Nostr","hint":"er en enkel og ben protokol, der bruges til at skabe u-censorerbare sociale netvrk. Nostr anvender kryptografisk kode. Nr du publicerer noget, underskriver du det med din ngle, og sender det til flere netvrksreler. Du kan bruge Alby til opbevaring af din Nostr-ngle. Mange Nostr-applikationer vil derefter lade dig bruge nglen direkte fra Alby.","private_key":{"title":"Opbevar din ngle","subtitle":"Indst din private ngle eller generer en ny. Husk at tage en sikkerhedskopi af din private ngle, fr du genererer en ny. <0>Ls mere </0>","warning":"Dette vil slette din gamle private ngle. Er du sikker?","success":"Den private ngle blev krypteret & gemt.","successfully_removed":"Den private ngle blev fjernet.","label":"Privat ngle"},"public_key":{"label":"Offentlig ngle"},"generate_keys":{"title":"Generer en ny Nostr-ngle","screen_reader":"Generer en ny Nostr-ngle til din konto","hint":"Du kan generere en vilkrlig ngle eller f nglen fra kontooplysningerne (med et underskrevet standardudtryk). <0>Ls mere </0>","actions":{"random_keys":"Generer en vilkrlig ngle","derived_keys":"F en kontospecifik ngle"}},"actions":{"generate":"Generer en ny ngle"},"errors":{"failed_to_load":"Nostr-nglen kunne ikke anvendes. Er det en gyldig Nostr-ngle?"}},"remove":{"title":"Fjern denne konto","subtitle":"Alle de tilknyttede puljer bliver slettet. Du skal vre helt sikker.","confirm":"Er du sikker p, at du vil fjerne kontoen: {{navn}}?\\nDette kan ikke fortrydes. Hvis du brugte denne konto til at logge p hjemmesider, kan du miste adgangen til disse."},"actions":{"remove_account":"Fjern konto","export":"Eksporter"}},"actions":{"add_account":"Tilfj konto"}},"enable":{"title":"Opret forbindelse","allow":"Tillad denne hjemmeside at:","request1":"Anmod om godkendelse af transaktioner","request2":"Anmod om faktura- og lightningoplysninger","block_and_ignore":"Bloker og ignorer {{vrt}}","block_added":"Fjet {{vrt}} til blokeringslisten, indls hjemmesiden igen."},"unlock":{"unlock_to_continue":"Ls op for at fortstte","unlock_password":"Din nglekode","help_contact":{"part1":"Brug for hjlp? Kontakt","part2":"Albys support"},"unlock_error":{"help":"Dine kontooplysninger er krypteret med din nglekode. Hvis du er sikker p at du har glemt din nglekode, m du nulstille og tilfje din lightning konto igen.","link":"Nulstil nu, og tilfj en ny konto"},"errors":{"invalid_password":"Ugyldig adgangskode"}},"settings":{"title":"Indstillinger","browser_notifications":{"title":"Browsermeddelelser","subtitle":"Meddelelser om betaling og godkendelser."},"website_enhancements":{"title":"Ekstra hjemmesidefunktioner","subtitle":"Donationer p Twitter, YouTube, etc."},"lnurl_auth":{"title":"LNURL-Auth","hint":"er en generisk autentifikationsprotokol. Den autentificerer brugeren med digital signatur. Protokollen krver ikke andre autentifikationsoplysninger som fx adgangskode, e-mail, brugernavn eller lignende. Med Alby kan du bruge dine lightning-konti til at logge sikkert ind p hjemmesider. For at blive kompatible med andre wallets mtte vi ndre et par ting, som du kan konfigurere her. <0>Disse indstillinger skal helst sls fra.</0> Brug dem kun, hvis du har gamle konti.","legacy_lnurl_auth_202207":{"title":"Gamle LNURL-Auth","subtitle":"Generering af ngle med LNURL-auth er ndret (juli 2022). Alby var ikke kompatibel med andre implementeringer. Dette blev ndret, men nu bruges der andre ngler til at logge ind. Hvis du tidligere brugte LNURL-auth til at logge ind, kan du fortsat aktivere den gamle metode. Denne mulighed vil blive fjernet, husk at skifte til det nye log ind."},"legacy_lnurl_auth":{"title":"Forldet signatur til LNDhub and LNbits","subtitle":"Signatur og log ind med LNDhub (fx BlueWallet) og LNBits-konti er blevet ndret (marts 2022). Hvis du loggede ind med disse konti, kan du fortsat aktivere den gamle signatur-metode. Denne mulighed vil blive fjernet, husk at skifte til det nye log ind."}},"camera_access":{"title":"Adgang til kamera","subtitle":"Til at skanne QR-koder","allow":"Tillad adgang til kamera","granted":"Tilladelse givet"},"language":{"title":"Sprog","subtitle":"Oversttelsen er endnu ikke 100% frdig. <0>Hjlp os med at overstte Alby til dit sprog!</0>"},"theme":{"title":"Tema","subtitle":"Brug Alby med mrk eller lys indstilling","options":{"dark":"Mrk","light":"Lys","system":"System"}},"show_fiat":{"title":"Sats til fiat","subtitle":"Konverter altid til den valgte valuta fra den valgte brs"},"currency":{"title":"Valuta","subtitle":"Vis ogs belb i denne valuta"},"exchange":{"title":"Brs-kilde","subtitle":"Kilde til bitcoinkurser"},"personal_data":{"title":"Personoplysninger","description":"Betalingsmodtagere kan anmode om at yderligere oplysninger medsendes en betaling. Oplysningerne deles ikke med nogen uden dit samtykke, du bliver altid spurgt fr oplysningerne medsendes en betaling."},"name":{"title":"Navn","subtitle":"","placeholder":"Indtast dit navn"},"email":{"title":"E-mail","subtitle":"","placeholder":"Indtast din e-mailadresse"},"change_password":{"title":"ndring af nglekode","subtitle":"","screen_reader":"ndring af nglekode","choose_password":{"label":"Indtast en ny nglekode:"},"confirm_password":{"label":"Bekrft ny kode:"},"submit":{"label":"ndring"},"errors":{"enter_password":"Indtast en ny nglekode.","confirm_password":"Bekrft din kode.","mismatched_password":"Koderne er forskellige."},"success":"Koden blev ndret"},"nostr":{"title":"Nostr","hint":"er en enkel og ben protokol, der bruges til at skabe u-censorerbare sociale netvrk. Nostr anvender kryptografisk kode. Nr du publicerer noget, underskriver du det med din ngle, og sender det til flere netvrksreler. Du kan bruge Alby til opbevaring af din Nostr-ngle. Mange Nostr-applikationer vil derefter lade dig bruge nglen direkte fra Alby.","private_key":{"title":"Privat ngle","subtitle":"Dette afsnit blev flyttet til kontosiden, da ngler nu er kontospecifikke.","go_to":"G til konti"}}},"send":{"title":"Send","input":{"label":"Modtager","hint":"Faktura, lightningadresse eller LNURL"}},"lnurlpay":{"amount":{"label":"Belb"},"comment":{"label":"Kommentar"},"name":{"label":"Navn"},"email":{"label":"E-mail"},"success":"Hurra, betalingen er sendt!"},"lnurlauth":{"title":"Godkendelse","content_message":{"heading":"Vil du logge ind p"},"submit":"Log ind","success":"Logget ind p {{navn}}","errors":{"status":"Fejl: Auth-status er ikke ok"}},"lnurlchannel":{"title":"Anmodning om kanal","content_message":{"heading":"Anmod noden om en kanal"},"success":"Anmodning om kanal blev sendt til {{navn}}"},"lnurlwithdraw":{"title":"Hv","content_message":{"heading":"Belb"},"amount":{"label":"Belb"},"success":"Hveanmodning om {{belb}} blev sendt til {{afsender}}"},"receive":{"title":"Modtag","actions":{"create_invoice":"Generer faktura"},"amount":{"label":"Belb","placeholder":"Belb i Satoshi..."},"description":{"label":"Beskrivelse","placeholder":"Fx hvem sender denne betaling?"},"success":"Betaling modtaget!","payment":{"waiting":"venter p betaling...","status":"Tjek betalingsstatus"}},"discover":{"title":"Udforsk Lightnings  kosystem","description":"Hjemmesider og web-apps hvor Alby kan bruges","list":{"trading":"Handel","gaming":"Spil","entertainment":"Underholdning","shopping":"Indkb","miscellaneous":"Diverse","showcases":"Eksempler","nostr":"Nostr"},"tips":{"title":"Din Alby-wallet er klar","description":"Et par rd der fr dig p vingerne","top_up_wallet":{"title":" Fyld din wallet op","description":"Generer en lightning-faktura, send lidt bitcoin til dig selv og begynd at bruge Alby i lightnings kosystem"},"demo":{"title":" F en prvetur med Alby","description":"Se alle de ting, du kan med Alby p vores prsentationsside"}}},"publishers":{"title":"Dine  hjemmesider","description":"Hjemmesider, hvor du tidligere har brugt Alby","no_info":"Det ser ud til, at du endnu ikke har brugt Alby p nogen hjemmesider.","discover":"Opdag hjemmesider","publisher":{"allowance":{"title":"Pulje","used_budget":"sats brugt"}}},"make_invoice":{"title":"Generer faktura","amount":{"label":"Belb (Satoshi)"},"memo":{"label":"Besked"},"errors":{"amount_too_small":"Belb er under minimum","amount_too_big":"Belb overstiger maksimum"}},"confirm_sign_message":{"title":"Underskriv","content":"Denne hjemmeside beder dig underskrive:"},"confirm_keysend":{"title":"Godkend betaling","success":"Betaling sendt! Preimage: {{preimage}}","payment_summary":{"description":"Send betaling til: {{bestemmelsessted}}"}},"keysend":{"title":"Send","success":"Betaling sendt! Preimage: {{preimage}}","receiver":{"label":"Send betaling til"},"amount":{"label":"Belb (Satoshi)"}},"confirm_payment":{"title":"Godkend betaling","success":"Betaling af {{belb}} blev udfrt!","actions":{"pay_now":"Betal nu"}},"confirm_request_permission":{"title":"Godkend anmodning","allow":"Tillad denne hjemmeside at udfre:","always_allow":"Husk mit valg, og sprg ikke igen"},"nostr":{"title":"Nostr","allow":"Tillad denne hjemmeside at:","content":"Denne hjemmeside beder dig underskrive:","allow_sign":"Tillad {{vrt}} at underskrive:","block_and_ignore":"Bloker og ignorer {{vrt}}","block_added":"{{vrt}} blev fjet til blokeringslisten, indls hjemmesiden igen."}},"y0":{"password":"Adgangskode","confirm_password":"Bekrft adgangskode","advanced":"Avanceret","success":"Succes","error":"Fejl","settings":"Indstillinger","accounts":"Konti","discover":"Opdag","connected_sites":"","sats_one":"sat","sats_other":"sat","loading":"indlser","amount":"Belb","optional":"Valgfri","feedback":"Tilbagemelding","copied":"Kopieret!","description":"Beskrivelse","description_full":"Komplet beskrivelse","success_message":"{{belb}}{{fiatBelb}} sendt til {{bestemmelsessted}}","response":"Svar","message":"Besked","help":"Hjlp","actions":{"back":"Tilbage","delete":"Slet","edit":"Rediger","next":"Nste","open":"bn","cancel":"Annuller","confirm":"Bekrft","continue":"Fortst","connect":"Opret forbindelse","lock":"Ls","unlock":"Ls op","send":"Send","save":"Gem","receive":"Modtag","receive_again":"Modtag en ny betaling","close":"Luk","export":"Eksporter","remove":"Fjern","copy":"Kopier","copy_invoice":"","log_in":"Log ind","remember":"Husk mit valg, og sprg ikke igen"},"errors":{"connection_failed":"Forbindelse kunne ikke oprettes","payment_failed":"Betaling fejlede"}},"wx":{"allowance_menu":{"confirm_delete":"Er du sikker p, du vil slette denne hjemmeside?","hint":"Dette nulstiller det aktuelle budget","new_budget":{"label":"Nyt budget"},"enable_login":{"title":"Aktiver log ind til hjemmeside","subtitle":"Log ind automatisk uden bekrftelse efter anmodning fra hjemmesiden."},"edit_allowance":{"title":"Rediger pulje","screen_reader":"Indstillinger for pulje"},"edit_permissions":"Rediger tilladelser"},"qrcode_scanner":{"title":"Skan QR-kode","actions":{"start_scanning":"Start med at skanne","stop_scanning":"Stop med at skanne"},"errors":{"allow_camera_access":"Giv adgang til kameraet i indstillingsvinduet."}},"transactionsTable":{"fee":"Betaling","preimage":"Pr-visning","received":"Modtaget","sent":"Sendt","boostagram":{"sender":"Afsender","message":"Meddelelse","app":"App","podcast":"Podcast"},"open_location":"bn hjemmeside"},"confirm_or_cancel":{"only_trusted":"Opret kun forbindelse til sider, du har tillid til."},"budget_control":{"remember":{"label":"Husk og fastlg et budget","description":"Du kan angive et belb, s du ikke behver bekrfte betalinger indtil det er opbrugt."},"budget":{"label":"Budget"}},"toasts":{"connection_error":{"what_you_can_do":"Dette kan du gre:","double_check":"Dobbelttjek dine forbindelsesoplysninger","if_ssl_errors":"og hvis der er SSL-fejl (fx RR_CERT_AUTHORITY_INVALID), s klik p \\"avanceret\\" og fortst med at acceptere certifikatet.","visit_guides":"Find yderligere hjlp i vores vejledninger"},"login_failed":{"password_reset":"Glemt din adgangskode? Klik her"},"errors":{"invalid_credentials":"Ugyldig adgangskode. Kontroller din adgangskode og e-mailadresse, og prv igen."}},"account_menu":{"screen_reader":"Skift drop-down","title":"Skift konto","options":{"account":{"add":"Tilfj en ny konto","manage":"Administrer konti"}}},"publishers_table":{"payments":"betalinger","used":"brugt"},"badge":{"label":{"active":"AKTIV","auth":"LOG IND"}}},"mk":{"nostr":{"getpublickey":"Ls din offentlige ngle.","nip04encrypt":"Krypter data.","nip04decrypt":"De-krypter data.","signmessage":"Underskriv meddelelse med din ngle."},"commando":{"bkpr-listbalances":"Liste over alle nuvrende og tidligere kontosaldi.","checkmessage":"Verificer, at signaturen blev genereret af en bestemt node.","connect":"Opret en ny forbindelse til en anden node.","decode":"Afkod en bolt11/bolt12/rune-streng.","decodepay":"Tjek og parse en bolt11-streng.","disconnect":"Luk en eksisterende forbindelse til en peer.","feerates":"Vis de betalingstakster CLN vil anvende.","fundchannel":"bn en betalingskanal til en peer ved at sende en betalingstransaktion.","getinfo":"F nodens ngleoplysninger.","getroute":"Find den bedste betalingsrute til en lightning-node.","invoice":"Opret en betalingsforventning.","keysend":"Send en betaling til en anden node.","listforwards":"Vis alle de htlc, der er forsgt sendt.","listfunds":"Vis alle tilgngelige midler.","listinvoices":"F status p alle faktura.","listnodes":"Vis de noder, som noden har kendskab til via gossip-beskeder.","listoffers":"Vis alle tilbud eller f et specifikt tilbud.","listpays":"Giver status for alle betalingsinstruktioner.","listpeers":"Vis noder, der er forbundne med eller har bne kanaler til denne node.","listsendpays":"Giver status for alle sendpay-instruktioner.","listtransactions":"Viser transaktioner, der er gemt i din wallet.","multifundchannel":"bn flere betalingskanaler til noder ved at sende en enkelt betalingstransaktion.","offer":"Opret et tilbud.","pay":"Send en betaling til en BOLT11-faktura.","sendpay":"Send en betaling via en rute.","setchannel":"Konfigurer den betaling/ det htlc-interval, der annonceres for kanalen.","signmessage":"Lav en signatur fra denne node."},"lnd":{"getinfo":"Hent node-oplysningerne.","listchannels":"F en beskrivelse af alle bne kanaler.","listinvoices":"Hent en oversigt over alle faktura.","channelbalance":"Hent en rapport over samlede midler i alle bne kanaler.","walletbalance":"Hent summen af ubrugte output i denne wallet.","openchannel":"bn en ny kanal.","connectpeer":"Opret forbindelse til en peer p nettet.","disconnectpeer":"Afbryd forbindelsen til en peer p nettet.","estimatefee":"Beregn betalingstakst og samlet betaling for en transaktion.","getchaninfo":"Hent netvrksannonceringen for den givne kanal.","getnetworkinfo":"Hent basisoplysningerne for det kendte kanalsystem.","getnodeinfo":"Hent oplysninger om en nodes kanaler.","gettransactions":"Hent en liste over alle transaktioner, der er relevante for denne wallet.","listpayments":"Hent en liste over udgende betalinger.","listpeers":"Hent en liste over alle aktive peers.","lookupinvoice":"Se faktura-oplysningerne.","queryroutes":"Foresprg om en mulig rute.","verifymessage":"Verificer en signatur over en meddelelse.","sendtoroute":"Foretag en betaling via den angivne rute.","decodepayreq":"Afkod en betalingsanmodnings-streng.","routermc":"Afls tilstanden for den interne mission control.","addinvoice":"Opret nye faktura."},"lnc":{"getinfo":"Hent oplysninger om noden.","listchannels":"Hent en beskrivelse af alle bne kanaler.","listinvoices":"Hent en liste over alle faktura.","channelbalance":"Hent en rapport over samtlige midler i alle bne kanaler.","walletbalance":"Hent summen af ubrugte output i denne wallet.","openchannel":"bn en ny kanal.","connectpeer":"Opret forbindelse til en peer p nettet.","disconnectpeer":"Afbryd forbindelsen til en peer p nettet.","estimatefee":"Beregn betalingstaksten og samlet betaling for en transaktion.","getchaninfo":"Hent netvrksannonceringen for den givne kanal.","getnetworkinfo":"Hent basisoplysningerne for det kendte kanalsystem.","getnodeinfo":"Hent oplysninger om en nodes kanaler.","gettransactions":"Hent en liste over alle transaktioner, der er relevante for denne wallet.","listpayments":"Hent en liste over alle udgende betalinger.","listpeers":"Hent en liste over alle de peers, der er aktive nu.","lookupinvoice":"Se faktura-oplysningerne.","queryroutes":"Foresprg om en mulig rute.","verifymessage":"Verificer en signatur over en meddelelse.","sendtoroute":"Foretag en betaling via den angivne rute.","decodepayreq":"Afkod en betalingsanmodnings-streng.","routermc":"Afls tilstanden for den interne mission control.","addinvoice":"Opret nye faktura."}}}'); const gt = JSON.parse('{"xk":{"welcome":{"title":"Welcome to Alby","set_password":{"title":"Set an unlock passcode","description":"This passcode will allow you to unlock Alby on this device. It cannot be recovered, but may be changed later.","choose_password":{"label":"Choose an unlock passcode:"},"confirm_password":{"label":"Let\'s confirm you typed it correct:"},"errors":{"enter_password":"Please enter a passcode.","confirm_password":"Please confirm your passcode.","mismatched_password":"Passcodes don\'t match."}},"test_connection":{"ready":"Awesome, you\'re ready to go!","initializing":"Initializing your account. Please wait, this can take a minute...","connection_error":"Connection Error","review_connection_details":"Please review your connection details.","connection_taking_long":"Trying to connect takes longer than expected... Are your details correct? Is your node reachable?","contact_support":"If you need help please contact support@getalby.com","actions":{"delete_edit_account":"Delete invalid account and edit again"}},"pin_extension":{"title":"Pin your Alby extension","description":"You\'re almost there. To use Alby conveniently, remember to pin your extension to the browser toolbar:","explanation":"1. Click on <0/> in the top right corner of your browser<1/>2. Find Alby and click to pin it to the toolbar<1/>3. That\'s it. To access Alby just click on the <2/> icon","next_btn":"Start buzzin\' {{icon}} with Alby"}},"choose_path":{"alby":{"title":"Alby Account","description":"Sign up or use your existing Alby Account to get started with lightning payments in no time.","connect":"Connect with Alby"},"other":{"title":"Other Wallets","description":"Connect to your existing lightning wallet or node and choose from various connectors.","and_more":"& more...","connect":"Connect"}},"alby":{"pre_connect":{"set_password":{"choose_password":{"label":"Password"},"confirm_password":{"label":"Confirm Password"},"errors":{"enter_password":"Please enter a password.","confirm_password":"Please confirm your password.","mismatched_password":"Passwords don\'t match."}}}},"choose_connector":{"title":"Connect Lightning Wallet","description":"Connect to your external lightning wallet or node","lnd":{"title":"LND","page":{"title":"Connect to your LND node","description":"You need your node URL and a macaroon with read and send permissions (e.g. admin.macaroon)"},"url":{"label":"REST API host and port","placeholder":"https://your-node-url:8080"},"macaroon":{"label":"Macaroon (HEX format)"},"drag_and_drop":"Drag and drop your macaroon here or <0>browse</0>","errors":{"connection_failed":"Connection failed. Are your LND credentials correct?"}},"umbrel_lightning_node":{"title":"Lightning Node"},"lnc":{"title":"Lightning Terminal (LNC)","page":{"title":"Connect to your LND node","description":"1. Open Lightning Terminal and choose <0>Lightning Node Connect</0> from the sidebar.<1/> 2. Click <0>Create a new session</0><1/>3. Label the session, choose desired permissions and submit<1/>4. <0>Copy pairing phrase</0> and paste it below."},"pairing_phrase":{"label":"Your pairing phrase ","placeholder":"secret stack sats phrase"}},"lndhub_bluewallet":{"title":"Bluewallet","page":{"title":"Connect to BlueWallet","description":"In BlueWallet, choose the wallet you want to connect, open it, click on \\"...\\", click on Export/Backup to display the QR code and scan it with your webcam."},"uri":{"label":"BlueWallet Export URI"},"errors":{"invalid_uri":"Invalid BlueWallet URI","connection_failed":"Connection failed. Is your BlueWallet URI correct?"}},"lndhub_go":{"title":"LNDHub","page":{"title":"Connect to LNDHub","description":"Input your LNDHub credential URI here or scan the QR code with your webcam."},"uri":{"label":"LNDHub Export URI"},"errors":{"invalid_uri":"Invalid LNDHub URI","connection_failed":"Connection failed. Is your LNDHub URI correct?"}},"lnbits":{"title":"LNbits","page":{"title":"Connect to <0>LNbits</0>","instructions":"In LNbits, choose the wallet you want to connect, open it, click on API Info and copy the Admin Key. Paste it below:"},"admin_key":{"label":"LNbits Admin Key","placeholder":"Your 32 digit admin key"},"url":{"label":"LNbits URL"},"errors":{"connection_failed":"Connection failed. Do you have the correct URL and Admin Key?"}},"eclair":{"title":"Eclair","page":{"title":"Connect to <0>Eclair</0>","instructions":"You need your Eclair URL and password."},"password":{"label":"Eclair Password"},"url":{"label":"Eclair URL","placeholder":"http://localhost:8080"}},"citadel":{"title":"Citadel","page":{"title":"Connect to <0>Citadel</0> node","instructions":"This currently doesn\'t work if 2FA is enabled."},"password":{"label":"Citadel Password"},"url":{"label":"Citadel URL","placeholder":"http://citadel.local"}},"umbrel":{"title":"Umbrel","page":{"title":"Connect to <0>Umbrel</0> node","instructions":"1. In your Lightning Node dashboard go to <0>Connect wallet</0><1/>2. Select <0>REST (Tor)</0> or <0>REST (Local Network)</0> mode<1/>3. Copy the <0>lndconnect URL</0> and paste it below"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://yournode:8080?..."}},"mynode":{"title":"myNode","page":{"title":"Connect to <0>myNode</0>","instructions":"On your myNode homepage click on the <0>Wallet</0> button for your <0>lightning</0> service.<1/> Now click on the <0>Pair Wallet</0> button under the <0>Status</0> tab. Enter your password when prompted.<1/> Select the dropdown menu and choose a pairing option. Depending on your setup you can either use the <0>lightning (REST + Local IP)</0> connection or the <0>lightning (REST + Tor)</0> connection."},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://yournode:8080?..."}},"start9":{"title":"Start9","page":{"title":"Connect to your <0>Start9 Server</0>","instructions":"On your Embassy dashboard click on the <0>Lightning Network Daemon</0> service.<1/>Select the <0>Properties</0> tab.<1/>Now copy the <0>LND Connect REST URL.</0>"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://yournode:8080?..."}},"raspiblitz":{"title":"RaspiBlitz","page":{"title":"Connect to your <0>RaspiBlitz</0> node","instructions1":"Follow these steps:<1/> 1. <0>SSH</0> into your <0>Raspiblitz</0><1/>2. Select <0>Connect Apps & Show Credentials</0> from the list<1/><0/>3. Choose <0>Connect Alby to this node</0><1/>4. Press <0>OK</0> to display the connection credentials<1/><1/>Copy and paste the <0>REST API host</0> or the <0>.onion</0> address to connect through Tor into the input below.","instructions2":"Copy the (admin) <0>macaroon</0> into the input below."},"rest_api_host":{"label":"REST API host","placeholder":"your-node-onion-address:port"}},"bitcoin_beach":{"title":"Bitcoin Beach Wallet","page":{"title":"Connect to <0>Bitcoin Beach Wallet</0>"}},"bitcoin_jungle":{"title":"Bitcoin Jungle Wallet","page":{"title":"Connect to <0>Bitcoin Jungle Wallet</0>"}},"galoy":{"phone_number":{"label":"Enter your phone number"},"sms_code":{"label":"Enter your SMS verification code"},"token":{"label":"Enter your Access token","info":"The {{label}} integration with Alby is in alpha and only recommended for advanced users.<br><br>You can grab your Access token by going into the mobile app, clicking on the settings icon, and then tapping 3 times on the build number to open the developer menu.<br><br>The access token can be copied from here.<br><br>"},"actions":{"login":"Login"},"errors":{"setup_failed":"Setup failed","missing_token":"Access token missing, couldn\'t log in.","invalid_token":"invalid Access token passed"}},"kollider":{"title":"Kollider","description":"Login to your Kollider account","warning":" Please make sure you store your credentials securely in a password manager. Without these credentials your account will not be recoverable.","choose_path":{"title":"Connect to your Kollider Wallet","description":"Login or sign up for a new Kollider account and connect to Alby.","create_new":"Sign up"},"create":{"title":"Create your Kollider account and connect to Alby","description":"Create a new Kollider account to send, receive and trade Bitcoin."},"login":{"title":"Connect to your Kollider account"},"username":{"label":"Username"},"currency":{"label":"Select your currency account"},"errors":{"connection_failed":"Connection failed. Are you sure the account data is correct?","user_already_exists":"Username already exists","registration_limit_exceeded":"Registration limit exceeded, try after sometime."}},"btcpay":{"title":"BTCPay Server","page":{"title":"Connect to your BTCPay LND node","instructions":"Navigate to your BTCPayServer and log in as an admin. Go to Server Settings > Services > LND Rest - See information. Then Click \\"See QR Code information\\" and copy the QR Code data. Paste it below:"},"config":{"label":"Config data","placeholder":"config=https://your-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Connection failed. Is the BTCPay connection URL correct and accessible?"}},"commando":{"title":"Core Lightning","page":{"title":"Connect to your Core Lightning node","instructions":"Make sure you have Core Lightning version 0.12.0 or newer, the commando plugin is running and your node is accessible over the lightning network. Create a rune by running \'lightning-cli commando-rune\'."},"host":{"label":"Host"},"pubkey":{"label":"Public key"},"rune":{"label":"Rune"},"port":{"label":"Port"},"proxy":{"label":"Websocket proxy"},"privKey":{"label":"Local private key (autogenerated)"},"config":{"label":"Config data","placeholder":"config=https://your-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Connection failed. Is your Core Lightning node online and using the commando plugin?"}}},"distributions":{"title":"Connect to {{name}}","description":"Choose which {{name}} app you would like to connect with","umbrel":{"name":"Umbrel"},"citadel":{"name":"Citadel"},"btcpay":{"name":"BTCPay"},"raspiblitz":{"name":"Raspiblitz"},"mynode":{"name":"myNode"},"start9":{"name":"Start9"}},"home":{"actions":{"send_satoshis":" Send Satoshis ","enable_now":"Enable Now"},"recent_transactions":"Recent Transactions","allowance_view":{"recent_transactions":"Recent Transactions","allowance":"Allowance","sats_used":"sats used","no_transactions":"No transactions on <0>{{name}}</0> yet."},"default_view":{"recent_transactions":"Recent Transactions","is_blocked_hint":"Alby is currently disabled on {{host}}","block_removed":"Enabled {{host}}. Please reload the website.","no_outgoing_transactions":"No outgoing transactions for this account yet.","no_incoming_transactions":"No incoming transactions for this account yet.","all_transactions_link":"See all transactions"}},"accounts":{"title":"Accounts","account_view":{"title1":"Account Information","title2":"Account","name":{"title":"Display Name","placeholder":"Account Display Name"},"export":{"title":"Connect your mobile wallet","description":"Allows you to connect and use this account on mobile wallets like <0>Blue Wallet</0> and <0>Zeus</0>.","screen_reader":"Export account details","waiting":"waiting for LndHub data...","your_ln_address":"Your Lightning Address:","export_uri":"LNDHub Credentials URI","scan_qr":"Import this wallet into Zeus or BlueWallet by scanning the QRCode."},"mnemonic":{"title":" Key Management","saved":"Master Key encrypted & saved successfully.","existing_nostr_key_notice":" This account already has a nostr private key set and will not be derived from this Master Key. You can manage your Nostr key from your account settings.","generate":{"title":"Generate new Master Key","description":"Master Key allows you to interact with various protocols such as: Nostr, base layer of Bitcoin or LNURL-Auth.","button":"Generate Master Key","confirm":"I\'ve backed up the recovery phrase to my Master Key in a private and secure place.","error_confirm":"Please confirm that you have backed up the recovery phrase."},"backup":{"title":"Back up your recovery phrase","save":"Save Master Key","button":"View recovery phrase","warning":" Don\'t forget to back up your recovery phrase! Not backing it up might result in permanently losing access to your Master Key, Nostr identity or assets you manage with this key.","description":"Write down the recovery phrase to be able to restore your Master Key on a new device or in case you lose access to your account.","items":{"recovery_phrase":"You can always access your Master Key by using it\'s recovery phrase.","words":"Recovery phrase is set of 12 words that works like a password, however it can\'t be changed or reset in case it\'s lost.","storage":"Make sure to write it down somewhere safe and private!"},"protocols":{"nostr":"Nostr"}},"import":{"title":"Import your Master Key","description":"Use the recovery phrase to import your Master Key into Alby.","button":"Import Master Key"},"inputs":{"title":"Recovery Phrase"},"lnurl":{"title":"Login with Lightning","use_mnemonic":"Use Master Key for logging into lightning-powered apps (LNURL Auth)"}},"bitcoin":{"network":{"title":"Bitcoin Network","subtitle":"Choose network to derive addresses and decode transactions","options":{"bitcoin":"Mainnet","testnet":"Testnet","regtest":"Regtest"}}},"nostr":{"title":"Nostr","hint":"is a simple and open protocol that aims to create censorship-resistant social networks. Nostr works with cryptographic keys. To publish something you sign it with your key and send it to multiple relays. You can use Alby to manage your Nostr key. Many Nostr applications will then allow you to simply use the key from the Alby extension.","settings":{"label":"Nostr Settings","title":"Nostr Settings","description":"Derive Nostr keys from your Master Key or import your existing private key by pasting it in the \\"Nostr Private Key\\" field.","imported_key_warning":" You\'re currently using an imported or randomly generated Nostr key. Your Nostr private key cannot be restored by your recovery phrase, so remember to back up your Nostr private key separately.","can_restore":" Nostr key derived from your Master Key","derive":"Derive from Master Key","remove":"Remove current keys","no_secret_key":" You don\'t have a Master Key yet. <0>Click here</0></div> to create your Master Key and derive your Nostr keys."},"setup":{"title":"Setup your Nostr keys","description":"Choose If you\'d like to create a new Nostr account (a pair of private and public keys) or import an existing one.","description2":"Every Nostr account created in Alby comes with a <0>Recovery Phrase</0>  a set of 12 words that always allow you to regain access to your Nostr private keys.","new":{"label":"Create a new Nostr account","description":"Generate a Master Key with a pair of new Nostr keys."},"import":{"label":"Import a Nostr account","description":"Use an existing Nostr private key or derive it from your Master Key","title":"How would you like to import your Nostr account?","private_key":{"label":"Use Nostr private key","description":"Paste your Nostr private key to import it to Alby"},"recovery_phrase":{"label":"Use recovery phrase","description":"Use Master key recovery phrase to import your Nostr keys"}},"new_to_nostr":"New to Nostr? <0>Learn more</0>"},"private_key":{"title":"Manage your Nostr private key","subtitle":"Paste your nostr private key or generate a new one. <0>Learn more </0>","warning":"Please enter the name of the account to confirm the deletion of your nostr private key:","success":"Nostr private key encrypted & saved successfully.","failed_to_remove":"The entered account name didn\'t match, your old Nostr private key has been restored.","successfully_removed":"Nostr private key removed successfully.","label":"Nostr Private Key"},"public_key":{"label":"Nostr Public Key"},"generate_keys":{"title":"Generate a new Nostr key","screen_reader":"Generate a new Nostr key for your account","hint":"You can generate a random key or a derive key from this account details (using a signed canonical phrase). <0>Learn more </0>","actions":{"random_keys":"Generate a random key","derived_keys":"Derive a key from account"}},"actions":{"generate":"Generate a new key"},"errors":{"failed_to_load":"Failed to load the Nostr key. Is it a valid Nostr key?"}},"remove":{"title":"Remove This Account","subtitle":"Removes all allowances, payment data and keys associated with this account.","confirm":"Please enter the name of the account to confirm the deletion of your account.\\n\\n  All associated keys (Master Key, Nostr, etc) will be deleted if you continue. Please make sure you have backed them up, there is no other way to restore them.","error":"The entered account name didn\'t match."},"remove_secretkey":{"title":"Remove Master Key","subtitle":"Removes the Master Key from this account.","confirm":"Please enter the name of the account to confirm the deletion of your Master Key.","success":"Successfully removed the Master Key."},"actions":{"remove_account":"Remove account","remove_secretkey":"Remove Master Key","export":"Export"}},"actions":{"add_account":"Add account"}},"enable":{"title":"Connect","allow":"Allow this website to:","request1":"Request approval for transactions","request2":"Request invoices and lightning information","block_and_ignore":"Block and ignore {{host}}","block_added":"Added {{host}} to the blocklist, please reload the website."},"unlock":{"unlock_to_continue":"Unlock to continue","unlock_password":"Your unlock passcode","help_contact":{"part1":"Need help? Contact","part2":"Alby Support"},"unlock_error":{"help":"Your account data is encrypted with your unlock passcode. If you really forgot your unlock passcode you have to reset and add your lightning account again.","link":"Reset now and add a new account"},"errors":{"invalid_password":"Invalid passcode"}},"settings":{"title":"Settings","browser_notifications":{"title":"Browser notifications","subtitle":"Payment and authentication related notifications."},"website_enhancements":{"title":"Website enhancements","subtitle":"Tipping enhancements for Twitter, YouTube, etc."},"lnurl_auth":{"title":"LNURL-Auth","hint":"is a generic authentication protocol. It authenticates the user using digital signatures. The protocol does not require any other identifying information such as passwords, emails, usernames, or similar. With Alby you can use your lightning accounts to securely login to websites. To be compatible with other wallets we had to make a few changes that you can configure here. <0>Ideally all those options are OFF.</0> Use them only if you have old accounts.","legacy_lnurl_auth_202207":{"title":"Legacy LNURL-Auth","subtitle":"The key generation for LNURL-auth has changed (July 2022). Alby was not compatible with other implementations. This was changed, but now different login keys are used. If you used LNURL-auth to login before you can still enable the old method. This option will be removed later, make sure to switch to the new login."},"legacy_lnurl_auth":{"title":"Legacy signing for LNDhub and LNbits","subtitle":"Message signing and login with LNDhub (e.g. BlueWallet) and LNbits accounts has been changed (March 2022). If you logged in with these accounts you can still enable the old signing method. This option will be removed later, make sure to switch to the new login."}},"camera_access":{"title":"Camera access","subtitle":"For scanning QR codes","allow":"Allow camera access","granted":"Permission granted"},"language":{"title":"Language","subtitle":"Translations are not 100% finished yet. <0>Help us translate Alby into your language!</0>"},"theme":{"title":"Theme","subtitle":"Use Alby in dark or light mode","options":{"dark":"Dark","light":"Light","system":"System"}},"show_fiat":{"title":"Sats to Fiat","subtitle":"Always convert into selected currency from selected exchange"},"currency":{"title":"Currency","subtitle":"Show the amounts additionally in this currency"},"exchange":{"title":"Exchange Source","subtitle":"Source of bitcoin exchange rates"},"personal_data":{"title":"Personal data","description":"Payees can request for additional data to be sent with a payment. This data is not shared with anyone without your consent, you will always be prompted before this data is sent along with a payment."},"name":{"title":"Name","subtitle":"","placeholder":"Enter your name"},"email":{"title":"Email","subtitle":"","placeholder":"Enter your email address"},"change_password":{"title":"Change unlock passcode","subtitle":"","screen_reader":"Change unlock passcode","choose_password":{"label":"Enter a new unlock passcode:"},"confirm_password":{"label":"Confirm new passcode:"},"submit":{"label":"Change"},"errors":{"enter_password":"Please enter a new unlock passcode.","confirm_password":"Please confirm your passcode.","mismatched_password":"Passcodes don\'t match."},"success":"Passcode changed successfully"},"nostr":{"title":"Nostr","hint":"is a simple and open protocol that aims to create censorship-resistant social networks. Nostr works with cryptographic keys. To publish something you sign it with your key and send it to multiple relays. You can use Alby to manage your Nostr key. Many Nostr applications will then allow you to simply use the key from the Alby extension.","private_key":{"title":"Private key","subtitle":"This section is moved to accounts page as keys are account specific now.","go_to":"Go To Accounts"}}},"send":{"title":"Send","input":{"label":"Recipient","hint":"Invoice, Lightning Address or LNURL"}},"lnurlpay":{"amount":{"label":"Amount"},"comment":{"label":"Comment"},"name":{"label":"Name"},"email":{"label":"Email"},"success":"Success, payment sent!"},"lnurlauth":{"title":"Authentication","content_message":{"heading":"Do you want to log in to"},"submit":"Login","success":"Login successful on {{name}}","errors":{"status":"Error: Auth status is not ok"}},"lnurlchannel":{"title":"Channel Request","content_message":{"heading":"Request a channel from the node"},"success":"Channel request sent successfully to {{name}}"},"lnurlwithdraw":{"title":"Withdraw","content_message":{"heading":"Amount"},"amount":{"label":"Amount"},"success":"Withdraw request of {{amount}} sent successfully to {{sender}}"},"lnurlredeem":{"title":"Redeem bitcoin","input":{"label":"LNURL-withdraw code","placeholder":"LNURL..."},"actions":{"withdraw":"Withdraw"},"errors":{"invalid_withdraw_request":"Invalid LNURL withdraw request","invalid_lnurl":"Invalid LNURL"}},"receive":{"title":"Receive","actions":{"create_invoice":"Create Invoice","copy_lightning_address":"Copy Lightning Address"},"amount":{"label":"Amount","placeholder":"Amount in Satoshi..."},"description":{"label":"Description","placeholder":"For e.g. who is sending this payment?"},"success":"Payment received!","payment":{"waiting":"waiting for payment...","status":"Check payment status"},"redeem_lnurl":"Redeem LNURL","receive_via_bitcoin_address":"Receive via bitcoin address"},"on_chain":{"title":"Receive via bitcoin address","instructions1":"To receive bitcoin via a bitcoin address, login to your <0>Alby Account</0> on getalby.com","instructions2":"You can find your bitcoin address on the <0>Receive</0> page.","go":"Go to your Alby account "},"scan_qrcode":{"title":"Waiting to scan"},"discover":{"title":"Explore the Lightning  Ecosystem","description":"Websites and webapps where you can use Alby","list":{"trading":"Trading","gaming":"Gaming","entertainment":"Entertainment","shopping":"Shopping","miscellaneous":"Miscellaneous","showcases":"Showcases","nostr":"Nostr","nodeManagement":"Node Management"},"tips":{"title":"Your Alby wallet is ready","description":"A few tips to get you started buzzin\'","top_up_wallet":{"title":"Buy Bitcoin","description":"Need a top up?\\nWe got you!"},"demo":{"title":"Alby Demo","description":"Discover Alby\'s features\\non our demo website"},"mnemonic":{"title":"Nostr","description":"Planning to use Nostr?\\nGenerate your keys now."}}},"publishers":{"title":"Your  Websites","description":"Websites where you have used Alby before","no_info":"It looks like you haven\'t used Alby in any websites yet.","discover":"Discover Websites","publisher":{"allowance":{"title":"Allowance","used_budget":"sats used"}}},"make_invoice":{"title":"Create Invoice","amount":{"label":"Amount (Satoshi)"},"memo":{"label":"Memo"},"errors":{"amount_too_small":"Amount is less than minimum","amount_too_big":"Amount exceeds maximum"}},"confirm_sign_message":{"title":"Sign","content":"This website asks you to sign:"},"confirm_get_address":{"title":"Get Address","heading":"This website asks you to read:","content":"Your Bitcoin receive address"},"confirm_keysend":{"title":"Approve Payment","success":"Payment sent! Preimage: {{preimage}}","payment_summary":{"description":"Send payment to: {{destination}}"}},"keysend":{"title":"Send","success":"Payment sent! Preimage: {{preimage}}","receiver":{"label":"Send payment to"},"amount":{"label":"Amount (Satoshi)"}},"confirm_payment":{"title":"Approve Payment","success":"Payment of {{amount}} successful!","actions":{"pay_now":"Pay now"}},"confirm_request_permission":{"title":"Approve Request","allow":"Allow this website to execute:","always_allow":"Remember my choice and don\'t ask again"},"confirm_add_account":{"title":"Add account","content":"This website wants to add an account ({{connector}}):","tor_info":"In order to connect through the TOR network you need to first install the Alby companion app:"},"nostr":{"title":"Nostr","allow":"Allow this website to:","content":"This website asks you to sign:","allow_sign":"Allow {{host}} to sign:","allow_sign_event":"Allow {{host}} to sign a {{kind}}:","view_details":"View details","hide_details":"Hide details","no_content":"(No content)","block_and_ignore":"Block and ignore {{host}}","block_added":"Added {{host}} to the blocklist, please reload the website.","kinds":{"0":"metadata","1":"short text note","2":"recommend relay","3":"contacts","4":"encrypted direct messages","5":"event deletion","7":"reaction","8":"badge award","40":"channel creation","41":"channel metadata","42":"channel message","43":"channel hide message","44":"channel mute user","1984":"reporting","9734":"zap request","9735":"zap","10002":"relay list metadata","22242":"client authentication","24133":"nostr connect","30008":"profile badges","30009":"badge definition","30023":"long-form content","30078":"application-specific data","unknown":"nostr event of kind {{kind}}"}},"transactions":{"title":"Transactions","description":{"outgoing":"Outgoing transactions for this account","incoming":"Incoming transactions for this account"},"list_empty":"No transactions available yet."}},"y0":{"password":"Password","confirm_password":"Confirm Password","advanced":"Advanced","success":"Success","error":"Error","settings":"Settings","accounts":"Accounts","discover":"Discover","connected_sites":"Connected Sites","wallet":"Wallet","sats_one":"sat","sats_other":"sats","loading":"loading","amount":"Amount","optional":"Optional","feedback":"Feedback","copied":"Copied!","pasted":"Pasted!","description":"Description","description_full":"Full Description","success_message":"{{amount}}{{fiatAmount}} sent to {{destination}}","response":"Response","message":"Message","help":"Help","balance":"Balance","or":"or","actions":{"back":"Back","delete":"Delete","edit":"Edit","next":"Next","open":"Open","cancel":"Cancel","confirm":"Confirm","continue":"Continue","connect":"Connect","lock":"Lock","unlock":"Unlock","send":"Send","save":"Save","import":"Import","receive":"Receive","receive_again":"Receive another payment","transactions":"Transactions","close":"Close","export":"Export","remove":"Remove","copy":"Copy","copy_clipboard":"Copy to clipboard","paste":"Paste","paste_clipboard":"Paste from clipboard","copy_invoice":"Copy Invoice","log_in":"Log in","remember":"Remember my choice and don\'t ask again","more":"More","download":"Download"},"connectors":{"lnd":"LND","nativelnd":"LND (over Tor)","lndhub":"LNDHub","nativelndhub":"LNDHub (over Tor)","lnbits":"LNBits","nativelnbits":"LNBits (over Tor)","galoy":"Galoy","eclair":"Eclair","citadel":"Citadel","nativecitadel":"Citadel (over Tor)","commando":"Commando"},"errors":{"connection_failed":"Connection failed","payment_failed":"Payment Failed"},"range":{"between":"between {{min}} and {{max}}","lessThanOrEqual":" {{max}}","greaterOrEqual":" {{min}}"}},"wx":{"allowance_menu":{"confirm_delete":"Are you sure you want to delete this website?","hint":"This will reset the current budget","new_budget":{"label":"New budget"},"enable_login":{"title":"Enable website login","subtitle":"Automatically log in without confirmation when the website requests."},"edit_allowance":{"title":"Edit Preferences","screen_reader":"Allowance Options"},"edit_permissions":"Edit Permissions"},"qrcode_scanner":{"title":"Scan QR Code","actions":{"start_scanning":"Start scanning","stop_scanning":"Stop scanning"},"errors":{"allow_camera_access":"Please allow camera access in the settings screen."}},"transactionsTable":{"fee":"Fee","preimage":"Preimage","received":"Received","sent":"Sent","boostagram":{"sender":"Sender","message":"Message","app":"App","podcast":"Podcast"},"open_location":"Open website"},"transaction_list":{"tabs":{"outgoing":"Outgoing","incoming":"Incoming"}},"confirm_or_cancel":{"only_trusted":"Only connect with sites you trust."},"budget_control":{"remember":{"label":"Remember and set a budget","description":"You may set a balance to not be asked for confirmation on payments until it is exhausted."},"budget":{"label":"Budget"}},"companion_download_info":{"heading":"How do you want to connect to the TOR network?","download":"Download","companion":{"title":"Companion App","description":"Lightweight app that connects your browser to the TOR network."},"tor_native":{"title":"TOR (native)","description":"Select this option if this browser is already connected to the TOR network."}},"toasts":{"connection_error":{"what_you_can_do":"Here is what you can do:","double_check":"Double check your connection details","if_ssl_errors":"and if there are SSL errors (e.g. ERR_CERT_AUTHORITY_INVALID), click \\"advanced\\" and proceed to accept the certificate.","visit_guides":"Visit our guides for more help"},"login_failed":{"password_reset":"Forgot your password? Click here"},"errors":{"invalid_credentials":"Invalid password. Please review your password and email address and try again."}},"account_menu":{"screen_reader":"Toggle Dropdown","title":"Switch account","options":{"account":{"add":"Add a new account","manage":"Manage accounts","account_settings":"Account settings","go_to_web_wallet":"Manage your web account"}}},"publishers_table":{"payments":"payments","used":"used"},"badge":{"label":{"active":"ACTIVE","auth":"LOGIN","imported":"IMPORTED"}}},"mk":{"nostr":{"getpublickey":"Read your public key.","nip04encrypt":"Encrypt data.","nip04decrypt":"Decrypt data.","signmessage":"Sign message with your key."},"commando":{"bkpr-listbalances":"List of all current and historical account balances.","checkmessage":"Verify that the signature was generated by a given node.","connect":"Establish a new connection with another node.","decode":"Decode a bolt11/bolt12/rune string.","decodepay":"Check and parse a bolt11 string.","disconnect":"Close an existing connection to a peer.","feerates":"Return the feerates that CLN will use.","fundchannel":"Open a payment channel with a peer by committing a funding transaction.","getinfo":"Get the summary of the node.","getroute":"Find the best route for the payment to a lightning node.","invoice":"Create the expectation of a payment.","keysend":"Send a payment to another node.","listforwards":"List all htlcs that have been attempted to be forwarded.","listfunds":"List all funds available.","listinvoices":"Get the status of all invoices.","listnodes":"List nodes the node has learned about via gossip messages.","listoffers":"List all offers or get a specific offer.","listpays":"Gets the status of all pay commands.","listpeers":"List nodes that are connected or have open channels with this node.","listsendpays":"Gets the status of all sendpay commands.","listtransactions":"List transactions tracked in the wallet.","multifundchannel":"Open multiple payment channels with nodes by committing a single funding transaction.","offer":"Create an offer.","pay":"Send a payment to a BOLT11 invoice.","sendpay":"Send a payment via a route.","setchannel":"Configure fees / htlc range advertized for a channel.","signmessage":"Create a signature from this node."},"lnd":{"getinfo":"Get the node information.","listchannels":"Get a description of all the open channels.","listinvoices":"Get a list of all invoices.","channelbalance":"Get a report on the total funds across all open channels.","walletbalance":"Get the total unspent outputs of the wallet.","openchannel":"Open a new channel.","connectpeer":"Establish a connection to a remote peer.","disconnectpeer":"Disconnect from a remote peer.","estimatefee":"Estimate the fee rate and total fees for a transaction.","getchaninfo":"Get the network announcement for the given channel.","getnetworkinfo":"Get basic stats about the known channel graph.","getnodeinfo":"Get the channel information for a node.","gettransactions":"Get a list of all transactions relevant to the wallet.","listpayments":"Get a list of all outgoing payments.","listpeers":"Get a list all currently active peers.","lookupinvoice":"Look up invoice details.","queryroutes":"Query for a possible route.","verifymessage":"Verify a signature over a msg.","sendtoroute":"Make a payment via the specified route.","decodepayreq":"Decode a payment request string.","routermc":"Read the internal mission control state.","addinvoice":"Create new invoices.","addholdinvoice":"Create new HODL invoices.","settleinvoice":"Settle an accepted invoice."},"lnc":{"getinfo":"Get the node information.","listchannels":"Get a description of all the open channels.","listinvoices":"Get a list of all invoices.","channelbalance":"Get a report on the total funds across all open channels.","walletbalance":"Get the total unspent outputs of the wallet.","openchannel":"Open a new channel.","connectpeer":"Establish a connection to a remote peer.","disconnectpeer":"Disconnect from a remote peer.","estimatefee":"Estimate the fee rate and total fees for a transaction.","getchaninfo":"Get the network announcement for the given channel.","getnetworkinfo":"Get basic stats about the known channel graph.","getnodeinfo":"Get the channel information for a node.","gettransactions":"Get a list of all transactions relevant to the wallet.","listpayments":"Get a list of all outgoing payments.","listpeers":"Get a list all currently active peers.","lookupinvoice":"Look up invoice details.","queryroutes":"Query for a possible route.","verifymessage":"Verify a signature over a msg.","sendtoroute":"Make a payment via the specified route.","decodepayreq":"Decode a payment request string.","routermc":"Read the internal mission control state.","addinvoice":"Create new invoices.","addholdinvoice":"Create new HODL invoices.","settleinvoice":"Settle an accepted invoice."}}}'); const mt = JSON.parse('{"xk":{"welcome":{"set_password":{"title":"Establecer un cdigo de desbloqueo","description":"Este cdigo te permitir desbloquear Alby en este dispositivo. No se puede recuperar, pero se puede cambiar ms tarde.","choose_password":{"label":"Elige un cdigo de desbloqueo:"},"confirm_password":{"label":"Confirme que lo escribi correctamente:"},"errors":{"enter_password":"Por favor, introduce un cdigo de acceso.","confirm_password":"Por favor, confirma tu cdigo de acceso.","mismatched_password":"Los cdigos no coinciden."}},"test_connection":{"ready":"Genial, ests listo para comenzar!","initializing":"Accediendo a su cuenta. Por favor, espere, esto puede tardar un minuto...","connection_error":"Error de Conexin","review_connection_details":"Revise los detalles de su conexin.","connection_taking_long":"Conectarse est llevando ms tiempo de lo esperado... Sus datos son correctos? Se puede acceder a su nodo?","contact_support":"Si necesita ayuda, pngase en contacto con support@getalby.com","actions":{"delete_edit_account":"Eliminar una cuenta no vlida y volver a editarla"}},"title":"Bienvenido a Alby","pin_extension":{"title":"Fija tu extensin Alby","description":"Ya casi lo has conseguido. Para utilizar Alby cmodamente, recuerda anclar tu extensin a la barra de herramientas del navegador:","explanation":"1. Haz clic en <0/> en la esquina superior derecha de tu navegador<1/>2. Busca Alby y haz clic para anclarlo a la barra de herramientas<1/>3. Eso es todo. Para acceder a Alby slo tienes que hacer clic en el icono <2/>","next_btn":"Empieza a hablar {{icon}} con Alby"}},"choose_connector":{"description":"Conecta tu billetera lightning externa o nodo","lnd":{"title":"LND","page":{"title":"Conecta a tu nodo LND","description":"Necesita la URL de su nodo y una frase macarrn con permisos de lectura y envo (por ejemplo, admin.macaroon)"},"url":{"label":"Host y puerto de la API REST","placeholder":"https://url-de-su-nodo:8080"},"macaroon":{"label":"Frase macarrn (formato HEX)"},"drag_and_drop":"Arrastra y suelta tu frase macarrn aqu o <0>navegar</0>","errors":{"connection_failed":"Error de conexin. Son correctas sus credenciales de LND?"}},"lnbits":{"title":"Cuenta LNbits","page":{"instructions":"En LNbits, elija la billetera que desea conectar, brala, haga clic en Informacin de API y copie la clave de administrador. Pgalo a continuacin:","title":"Conctese a <0>LNbits</0>"},"admin_key":{"label":"Clave de Administrador de LNbits","placeholder":"Su clave de administrador de 32 dgitos"},"url":{"label":"URL de LNbits"},"errors":{"connection_failed":"La conexin fall. Tiene la URL y la clave de administrador correctas?"}},"eclair":{"title":"Cuenta de Eclair","password":{"label":"Contrasea de Eclair"},"page":{"instructions":"Necesitas la URL y la contreasea de Eclair.","title":"Conectar a Eclair"},"url":{"label":"URL de Eclair","placeholder":"http://localhost:8080"}},"citadel":{"title":"Cuenta de Citadel","password":{"label":"Contrasea de Citadel"},"url":{"label":"URL de Citadel","placeholder":"http://citadel.local"},"page":{"title":"Conectar a nodo Citadel","instructions":"Esto actualmente no funciona si el 2FA est activado."}},"umbrel":{"title":"Cuenta de Umbrel","page":{"title":"Conectar a Umbrel","instructions":"1. En tu Lightning Node dashboard ve a <0>Connect wallet</0><1/>2. Selecciona <0>REST (Tor)</0> o <0>REST (Local Network)</0> mode<1/>3. Copia la <0>lndconnect URL</0> y pgala a continuacin"},"rest_url":{"placeholder":"lndconnect://sunodo:8080?...","label":"URL de REST de lndconnect"}},"mynode":{"title":"MiNodo","page":{"title":"Conecta <0>miNodo</0>","instructions":"En tu pgina myNode pulsa el botn <0>Billetera</0> para tu servicio <0>lightning</0>.<1/> Ahora pulsa el botn <0>Emparejar Billetera</0> bajo la pestaa <0>Estado</0>. Escribe tu contrasea cuando se indique.<1/> Selecciona el men desplegable y elige una opcin de emparejamiento. Dependiendo de tu configuracin puedes usar la conexin <0>lightning (REST + IP Local)</0> o la conexin <0>lightning (REST + TOR)</0>."},"rest_url":{"label":"URL de REST de lndconnect","placeholder":"lndconnect://sunodo:8080?..."}},"start9":{"title":"Cuenta Start9","page":{"title":"Conctate a tu <0>Start9 Server</0>","instructions":"En tu panel de Embassy, haz clic en el servicio <0>Lightning Network Daemon</0>.<1/>Selecciona la pestaa <0>Propiedades</0>.<1/>Ahora copia la URL REST de <0>LND Connect. </0>"},"rest_url":{"label":"URL REST conectalnd","placeholder":"lndconnect://sunodo:8080?..."}},"raspiblitz":{"title":"Cuenta RaspiBlitz","page":{"title":"Conecta tu nodo <0>RaspiBlitz</0>","instructions2":"Copie el (admin) <0>macaroon</0> en la entrada de abajo.","instructions1":"Siga estos pasos:<1/> 1. <0>SSH</0> en su <0>Raspiblitz</0><1/>2. Seleccione <0>Conectar aplicaciones y mostrar credenciales</0> de la lista<1/><0/>3. Elija <0>Conectar Alby a este nodo</0><1/>4. Pulsa <0>Aceptar</0> para mostrar las credenciales de conexin<1/><1/>Copia y pega el <0>host API REST</0> o la direccin <0>.onion</0> para conectarte a travs de Tor en la entrada de abajo."},"rest_api_host":{"label":"Host de la API REST","placeholder":"tu-nodo-direccion onion:puerto"}},"bitcoin_beach":{"title":"Billetera de Bitcoin Beach","page":{"title":"Conecta a <0>La cartera Bitcoin Beach</0>"}},"bitcoin_jungle":{"title":"Billetera de Bitcoin Jungle","page":{"title":"Conecta a <0>La cartera Bitcoin Jungle</0>"}},"btcpay":{"title":"Servidor BTCPay","page":{"title":"Conctese a su nodo BTCPay LND","instructions":"Navegue a su servidor BTCPay e inicie sesin como administrador. Vaya a Configuracin del servidor > Servicios > LND Rest-Ver informacin. Luego haga clic en\\" Ver informacin del cdigo QR \\" y copie los datos del Cdigo QR. Pegar a continuacin:"},"config":{"label":"Datos de configuracin","placeholder":"config=https://su-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"La conexin fall. Es la URL de conexin de BTCPay correcta y accesible?"}},"lndhub_bluewallet":{"title":"Bluewallet","page":{"title":"Conecta a BlueWallet","description":"En BlueWallet, elija el monedero que desea conectar, bralo, haga clic en \\"...\\", haga clic en Exportar/Copia de seguridad para mostrar el cdigo QR y escanelo con su cmara web."},"uri":{"label":"URI de Exportacin BlueWallet"},"errors":{"invalid_uri":"URI de BlueWallet invlido","connection_failed":"Error de conexin. Es correcto el URI de BlueWallet?"}},"lndhub_go":{"title":"LNDHub","page":{"title":"Conecta LNDHub","description":"Ingrese su URI de credencial de LNDHub aqu o escanee el cdigo QR con su cmara web."},"uri":{"label":"URI de exportacin de LNDHub"},"errors":{"invalid_uri":"LN Dhubri No vlido","connection_failed":"La conexin fall. Es correcto el URI de LNDHub?"}},"kollider":{"description":"Inicie sesin en su cuenta Kollider","username":{"label":"Nombre de usuario"},"errors":{"connection_failed":"La conexin fall. Te aseguraste de que los datos de la cuenta son correctos?","user_already_exists":"El nombre de usuario ya existe","registration_limit_exceeded":"Lmite de registro excedido, intntalo ms tarde."},"title":"Kollider","currency":{"label":"Seleccione su cuenta de divisas"},"choose_path":{"description":"Inicia sesin o regstrate para obtener una nueva cuenta de Kollider y conctate a Alby.","title":"Conctate a t monedero Kollider","create_new":"Regstrate"},"create":{"title":"Crea t cuenta Kollider y conctate a Alby","description":"Crea una nueva cuenta Kollider para enviar, recibir e intercambiar Bitcoin."},"login":{"title":"Conctate a t cuenta Kollider"},"warning":" Asegrate de almacenar tus credenciales de forma segura en un administrador de contraseas. Sin estas credenciales, t cuenta no ser recuperable."},"commando":{"pubkey":{"label":"Clave Pblica"},"port":{"label":"Puerto"},"privKey":{"label":"Clave privada local (autogenerada)"},"config":{"label":"Datos de Configuracin","placeholder":"config=https://su-btc-pay.org/lnd-config/212121/lnd.config"},"host":{"label":"Host"},"page":{"title":"Conctese a su nodo Core Lightning","instructions":"Asegrese de tener Core Lightning versin 0.12.0 o posterior, el complemento de comando se est ejecutando y se puede acceder a su nodo a travs de Lightning Network. Cree una runa ejecutando \'lightning-cli commando-rune\'."},"title":"Core Lightning","errors":{"connection_failed":"La conexin fall. Est su nodo Core Lightning en lnea y usando el plugin de comando?"},"rune":{"label":"Rune"},"proxy":{"label":"Proxy de socket web"}},"galoy":{"errors":{"setup_failed":"Fall la configuracin","missing_token":"Falta JWT, no se pudo iniciar sesin.","invalid_token":"JWT invlido aprobado"},"phone_number":{"label":"Ingrese su nmero telefnico"},"sms_code":{"label":"Ingrese su cdigo de verificacin de SMS"},"token":{"label":"Ingresa tu token de JWT","info":"El inicio de sesin de {{label}} se est actualizando actualmente. Si es un usuario avanzado, puede obtener su token JWT iniciando sesin a travs de <0>Web Wallet (wallet.mainnet.galoy.io)</0><1/><1/>El JWT se ve as: < 2>eyJhbG...</2><1/><1/>"},"actions":{"login":"Ingresar"}},"lnc":{"page":{"title":"Conecta tu nodo LND","description":"1. Abra tu Lightning Terminal y selecciona <0>Lightning Node Connect</0> en la barra lateral.<1/> 2. Haz clic en <0>Crear una nueva sesin</0><1/>3. Etiqueta la sesin, luego elige el permiso que deseas y enva<1/>4. <0>Copia la frase de emparejamiento</0> y pgala a continuacin."},"title":"Lightning Terminal (LNC)","pairing_phrase":{"label":"Tu frase vinculada. ","placeholder":"frase de pila secreta de sats"}},"title":"Conecta la Billetera Lightning","umbrel_lightning_node":{"title":"Lightning Node"}},"home":{"actions":{"send_satoshis":" Enviar Satoshis ","enable_now":"Habilitar ahora"},"recent_transactions":"Transacciones Recientes","allowance_view":{"recent_transactions":"Transacciones Recientes","allowance":"Subsidio","sats_used":"sats utilizados","no_transactions":"No hay transacciones en <0>{{name}}</0> todava."},"default_view":{"recent_transactions":"Transacciones Recientes","is_blocked_hint":"Alby est actualmente deshabilitado en {{host}}","block_removed":"{{host}} habilitado. Vuelva a cargar el sitio web.","no_outgoing_transactions":"An no hay transacciones salientes para esta cuenta.","no_incoming_transactions":"An no hay transacciones entrantes para esta cuenta.","all_transactions_link":"Ver todas las transacciones"}},"accounts":{"title":"Cuentas","actions":{"add_account":"Agregar Cuenta"},"account_view":{"nostr":{"errors":{"failed_to_load":"No se pudo cargar la clave Nostr. Es una clave Nostr vlida?"},"private_key":{"success":"Clave privada cifrada y guardada con xito.","successfully_removed":"Clave privada eliminada con xito.","label":"Clave Privada","title":"Administra tu clave","subtitle":"Pega tu clave privada o genera una nueva. <0>Ms informacin \\"</0>","warning":"Introduzca el nombre de la cuenta para confirmar la eliminacin de la clave privada:","failed_to_remove":"El nombre de cuenta introducido no coincide, tu antiguo privado ha sido restaurado."},"public_key":{"label":"Clave Pblica"},"generate_keys":{"title":"Generar una nueva clave de Nostr","screen_reader":"Genere una nueva clave Nostr para su cuenta","actions":{"random_keys":"Genera una clave aleatoria","derived_keys":"Derivar una clave de la cuenta"},"hint":"Puede generar una clave aleatoria o una clave derivada a partir de los detalles de esta cuenta (usando una frase cannica firmada). <0>Aprenda Ms </0>"},"actions":{"generate":"Generar una nueva clave"},"title":"Nostr","hint":"es un protocolo simple y abierto que tiene como objetivo crear redes sociales resistentes a la censura. Nostr trabaja con claves criptogrficas. Para publicar algo, lo firma con su clave y lo enva a mltiples relevos. Puede usar Alby para administrar su clave Nostr. Muchas aplicaciones de Nostr le permitirn simplemente usar la clave de la extensin Alby."},"remove":{"title":"Eliminar Esta Cuenta","confirm":"Est seguro de que desea eliminar la cuenta: {{name}}?\\nEsto no se puede deshacer. Si us esta cuenta para iniciar sesin en sitios web, es posible que pierda el acceso a ellos.","subtitle":"Se eliminarn todos los enlaces vinculados. Por favor, asegrese de querer hacerlo."},"title1":"Informacin de la Cuenta","title2":"Editar Cuenta","name":{"title":"Nombre","placeholder":"Nombre de la Cuenta"},"export":{"title":"Exportar Cuenta","screen_reader":"Exportar los detalles de la cuenta","your_ln_address":"Tu Direccin Lightning:","scan_qr":"Importe esta billetera a Zeus o BlueWallet escaneando el cdigo QR.","waiting":"esperando datos de LndHub...","export_uri":"URI de credenciales de LNDHub"},"actions":{"remove_account":"Eliminar cuenta","export":"Exportar"}}},"enable":{"allow":"Permitir que este sitio web:","request1":"Solicitar aprobacin de transacciones","request2":"Solicitar facturas e informacin sobre Lightning","block_and_ignore":"Bloquear e ignorar {{host}}","title":"Conectar","block_added":"Se agreg {{host}} a la lista de bloqueados, vuelva a cargar la pgina."},"unlock":{"unlock_to_continue":"Desbloquear para continuar","help_contact":{"part1":"Necesita ayuda? Contacto","part2":"Soporte de Alby"},"unlock_error":{"help":"Los datos de tu cuenta estn encriptados con tu cdigo de desbloqueo. Si realmente olvidaste tu cdigo de desbloqueo, tienes que restablecer y aadir tu cuenta lightning de nuevo.","link":"Restablecer ahora y agregar una nueva cuenta"},"unlock_password":"Tu cdigo de desbloqueo","errors":{"invalid_password":"Contrasea no vlida"}},"settings":{"title":"Configuracin","website_enhancements":{"title":"Mejoras del sitio web","subtitle":"Mejoras de propinas para Twitter, YouTube, etc."},"lnurl_auth":{"title":"Autenticacin-LNURL","hint":"es un protocolo genrico de autenticacin. Autentica al usuario utilizando firmas digitales. El protocolo no requiere ninguna otra informacin de identificacin como contraseas, correos electrnicos, nombres de usuario o similares. Con Alby puedes utilizar tus cuentas relmpago para iniciar sesin en sitios web de forma segura. Para ser compatible con otros monederos hemos tenido que hacer algunos cambios que puedes configurar aqu. <0>Idealmente todas esas opciones estn en OFF.</0> salas slo si tienes cuentas antiguas.","legacy_lnurl_auth_202207":{"title":"Autenticacin-LNURL Legada","subtitle":"La generacin de claves para la autenticacin-LNURL ha cambiado (en julio de 2022). Alby no era compatible con otras implementaciones. Esto se cambi, pero ahora se utilizan diferentes claves de inicio de sesin. Si us autenticacin-LNURL para iniciar sesin antes, an puede habilitar el mtodo anterior. Esta opcin se eliminar ms adelante, asegrese de cambiar al nuevo inicio de sesin."},"legacy_lnurl_auth":{"title":"Firma heredada (Legacy) para LNDhub y LNbits","subtitle":"Se ha cambiado la firma de mensajes y el inicio de sesin con cuentas LNDhub (por ejemplo, BlueWallet) y LNbits (marzo de 2022). Si inici sesin con estas cuentas, an puede habilitar el mtodo de firma anterior. Esta opcin se eliminar ms adelante, asegrese de cambiar al nuevo inicio de sesin."}},"camera_access":{"title":"Acceso a la cmara","subtitle":"Para escanear cdigos QR","allow":"Permitir el acceso a la cmara","granted":"Permiso concedido"},"language":{"title":"Idioma","subtitle":"Alby se vuelve internacional! aydanos a traducir Alby en tu idioma"},"theme":{"title":"Tema","subtitle":"Utilice Alby en modo oscuro o claro","options":{"light":"Claro","dark":"Oscuro","system":"Sistema"}},"show_fiat":{"title":"Sats a Fiat","subtitle":"Convierta siempre a la moneda seleccionada desde el intercambio seleccionado"},"currency":{"title":"Moneda","subtitle":"Mostrar los importes adicionalmente en esta moneda"},"exchange":{"title":"Fuente del Intercambio","subtitle":"Fuente del tipo de cambio de Bitcoin"},"personal_data":{"title":"Datos personales","description":"Los beneficiarios pueden solicitar que se enven datos adicionales con un pago. Estos datos no se comparten con nadie sin su consentimiento, siempre se le solicitar antes de que se enven estos datos junto con un pago."},"name":{"title":"Nombre","subtitle":"","placeholder":"Introduzca su nombre"},"email":{"title":"Correo electrnico","subtitle":"","placeholder":"Introduzca su direccin de correo electrnico"},"change_password":{"title":"Cambiar la Contrasea","subtitle":"","screen_reader":"Cambiar la Contrasea","choose_password":{"label":"Introduzca una nueva contrasea:"},"confirm_password":{"label":"Confirmar nueva contrasea:"},"errors":{"enter_password":"Por favor, introduzca una contrasea.","confirm_password":"Por favor, confirme su contrasea.","mismatched_password":"Las contraseas no coinciden."},"success":"La contrasea se cambi correctamente","submit":{"label":"Cambiar"}},"browser_notifications":{"title":"Notificaciones del navegador","subtitle":"Notificaciones relacionadas con pagos y autenticacin."},"nostr":{"private_key":{"title":"Clave Privada","subtitle":"Esta seccin se ha movido a la pgina de cuentas ya que las claves ahora son especficas de la cuenta.","go_to":"Ir a Cuentas"},"title":"Nostr","hint":"es un protocolo simple y abierto que tiene como objetivo crear redes sociales resistentes a la censura. Nostr trabaja con claves criptogrficas. Para publicar algo, lo firma con su clave y lo enva a mltiples relevos. Puede usar Alby para administrar su clave Nostr. Muchas aplicaciones de Nostr le permitirn simplemente usar la clave de la extensin Alby."}},"send":{"title":"Enviar","input":{"label":"Destinatario","hint":"Factura, Direccin Lightning o LNURL"}},"lnurlpay":{"amount":{"label":"Cantidad"},"comment":{"label":"Comentario"},"name":{"label":"Nombre"},"email":{"label":"Email"},"success":"Pago enviado con xito!"},"receive":{"title":"Recibir","actions":{"create_invoice":"Crear Factura"},"amount":{"label":"Cantidad","placeholder":"Cantidad en Satoshi..."},"description":{"label":"Descripcin","placeholder":"Por ej. Quin est enviando este pago?"},"success":"Pago recibido!","payment":{"waiting":"Esperando el pago...","status":"Consultar estado de pago"}},"publishers":{"publisher":{"allowance":{"title":"Tolerancia","used_budget":"sats utilizados"}},"description":"Sitios web donde has usado Alby anteriormente","discover":"Descubre Sitios Web","title":"Tus  Sitios Web","no_info":"Parece que todava no has usado Alby en ningn sitio web."},"make_invoice":{"title":"Crear Factura","amount":{"label":"Cantidad (Satoshi)"},"memo":{"label":"Memorndum"},"errors":{"amount_too_small":"La cantidad es inferior al mnimo","amount_too_big":"La cantidad excede el mximo"}},"confirm_sign_message":{"title":"Firmar","content":"Este sitio web te pide que firmes:"},"confirm_keysend":{"title":"Aprobar Pago","success":"Pago enviado! Preimagen: {{preimage}}","payment_summary":{"description":"Enviar pago a: {{destination}}"}},"confirm_payment":{"title":"Aprobar Pago","success":"Pago de {{amount}} exitoso!!","actions":{"pay_now":"Pagar Ahora"}},"lnurlauth":{"title":"Autenticacin","content_message":{"heading":"Quieres iniciar sesin en"},"submit":"Acceder","success":"Inicio de sesin exitoso en {{name}}","errors":{"status":"Error: El estado de autenticacin no es correcto"}},"lnurlchannel":{"content_message":{"heading":"Solicitar un canal desde el nodo"},"success":"Solicitud de canal enviada con xito a {{name}}","title":"Solicitud de Canal"},"lnurlwithdraw":{"title":"Retirar","content_message":{"heading":"Cantidad"},"amount":{"label":"Cantidad"},"success":"Solicitud de retiro de {{amount}} enviada con xito a {{sender}}"},"choose_path":{"alby":{"title":"Cuenta de Alby","description":"Regstrate o usa t cuenta de Alby existente para empezar a realizar pagos relmpago en un abrir y cerrar de ojos."},"other":{"title":"Otras Billeteras","and_more":"Y ms...","connect":"Conectar","description":"Conecta con tu billetera lightning existente o nodo y elige entre varios conectores."}},"nostr":{"title":"Nostr","allow":"Permitir que este sitio web:","content":"Este sitio web te solicita firmar:","allow_sign":"Permitir que {{host}} firme:","block_and_ignore":"Bloquear e ignorar {{host}}","block_added":"Se agreg {{host}} a la lista de bloqueados, vuelva a cargar el sitio web.","allow_sign_event":"Permitir que {{host}} firme un {{kind}}:","view_details":"Ms informacin","hide_details":"Ocultar los detalles","no_content":"(Sin contenido)","kinds":{"0":"metadatos","1":"nota corta de texto","2":"Recomendar un rel","3":"contactos","4":"mensajes directos cifrados","5":"borrado de eventos","7":"reaccin","8":"concesin de distintivo","40":"creacin del canal","41":"metadatos del canal","42":"mensaje del canal","43":"ocultar mensaje del canal","44":"silenciar a un usuario del canal","1984":"reportando","9734":"solicitud de eliminacin","9735":"borrar","10002":"metadatos de la lista de rels","22242":"autenticacin del cliente","24133":"conectarse a nostr","30008":"distintivos del perfil","30009":"definicin del distintivo","30023":"contenidos largos","30078":"datos especficos de la aplicacin","unknown":"nostr evento del tipo {{kind}}"}},"discover":{"title":"Explora el Ecosistema  Lightning","description":"Sitios web y aplicaciones web donde puede usar Alby","tips":{"top_up_wallet":{"title":" Recarga tu billetera","description":"Cree una factura lightning, envese algunos bitcoins y comience a usar Alby en el ecosistema lightning"},"title":"Tu billetera Alby est lista","description":"Algunos consejos para que empieces a zumbar ","demo":{"title":" Prueba la versin Demo de Alby","description":"Descubra todo lo que puede hacer con Alby en nuestro sitio web de demostraciones"}},"list":{"entertainment":"Entretenimiento","shopping":"Compras","miscellaneous":"Varios","showcases":"Vitrinas","nostr":"Nostr","trading":"Comerciar","gaming":"Juegos","nodeManagement":"Gestin de nodos"}},"confirm_request_permission":{"title":"Aprobar solicitud","always_allow":"Recordar mi eleccin y no volver a preguntar","allow":"Permitir que este sitio web ejecute:"},"alby":{"pre_connect":{"set_password":{"choose_password":{"label":"Contrasea"},"confirm_password":{"label":"Confirmar Contrasea"},"errors":{"enter_password":"Por favor introduzca una contrasea.","confirm_password":"Por favor, confirme su contrasea.","mismatched_password":"Las contraseas no coinciden."}}}},"keysend":{"title":"Enviar","success":"Pago enviado! Preimagen: {{preimage}}","receiver":{"label":"Enviar pago a"},"amount":{"label":"Cantidad (Satoshi)"}},"transactions":{"title":"Transacciones","list_empty":"Todava no hay transacciones disponibles."},"distributions":{"umbrel":{"name":"Umbrel"},"start9":{"name":"Start9"},"raspiblitz":{"name":"Raspiblitz"},"mynode":{"name":"myNode"},"title":"Conectarse a {{name}}","description":"Elige la aplicacin {{name}} con la que deseas conectarse","citadel":{"name":"Citadel"},"btcpay":{"name":"BTCPay"}}},"y0":{"password":"Contrasea","success":"Exitoso","error":"Error","settings":"Ajustes","connected_sites":"Sitios conectados","sats_one":"sat","sats_other":"sats","loading":"cargando","amount":"Cantidad","optional":"Opcional","feedback":"Retroalimentacin","copied":"Copiada!","actions":{"delete":"Borrar","edit":"Editar","next":"Siguiente","cancel":"Cancelar","confirm":"Confirmar","continue":"Continuar","connect":"Conectar","lock":"Bloquear","unlock":"Desbloquear","send":"Enviar","save":"Guardar","receive":"Recibir","close":"Cerrar","export":"Exportar","remove":"Quitar","copy":"Copiar","copy_invoice":"","open":"Abrir","back":"Volver","receive_again":"Recibir otro pago","log_in":"Iniciar Sesin","remember":"Recordar mi eleccin y no preguntar nuevamente","transactions":"Transacciones","more":"Ms"},"errors":{"connection_failed":"Error de conexin","payment_failed":"Pago Fallido"},"description":"Descripcin","confirm_password":"Confirmar Contrasea","success_message":"{{amount}}{{fiatAmount}} enviados a {{destination}}","message":"Mensaje","description_full":"Descripcin Completa","advanced":"Avanzado","accounts":"Cuentas","discover":"Descubrir","response":"Respuesta","help":"Ayuda","range":{"between":"entre el {{min}} y el {{max}}","lessThanOrEqual":" {{max}}","greaterOrEqual":" {{min}}"},"balance":"Balance"},"wx":{"allowance_menu":{"confirm_delete":"Est seguro de que desea eliminar este sitio web?","hint":"Esto restablecer el presupuesto actual","new_budget":{"label":"Nuevo presupuesto"},"edit_allowance":{"title":"Editar Asignacin","screen_reader":"Opciones de Asignacin"},"enable_login":{"title":"Habilitar inicio de sesin en el sitio web","subtitle":"Iniciar sesin automticamente sin confirmacin cuando el sitio web lo solicite."},"edit_permissions":"Editar Permisos"},"qrcode_scanner":{"title":"Escanear el Cdigo QR","actions":{"start_scanning":"Comenzar a escanear","stop_scanning":"Detener el escaneo"},"errors":{"allow_camera_access":"Permita el acceso a la cmara en la pantalla de configuracin."}},"transactionsTable":{"fee":"Comisin","preimage":"Preimagen","received":"Recibido","sent":"Enviado","boostagram":{"sender":"Remitente","message":"Mensaje","app":"Aplicacin","podcast":"Podcasts"},"open_location":"Abrir sitio web"},"confirm_or_cancel":{"only_trusted":"Conctese solo con sitios en los que confe."},"budget_control":{"remember":{"label":"Recuerda y establece un presupuesto","description":"Puede establecer un saldo para que no se le solicite confirmacin de los pagos hasta que se agote."},"budget":{"label":"Presupuesto"}},"toasts":{"connection_error":{"what_you_can_do":"Esto es lo que puedes hacer:","visit_guides":"Visita nuestras guas para obtener ms ayuda","double_check":"Verifique los detalles de su conexin","if_ssl_errors":"y si hay errores SSL (por ejemplo, ERR_CERT_AUTHORITY_INVALID), haga clic en \\"avanzado\\" y proceda a aceptar el certificado."},"errors":{"invalid_credentials":"Contrasea no vlida. Por favor, revise su contrasea y direccin de correo electrnico e intntelo de nuevo."},"login_failed":{"password_reset":"Olvid su contrasea? Haga clic aqu"}},"account_menu":{"title":"Cambiar de cuenta","options":{"account":{"add":"Agregar una nueva cuenta","manage":"Administrar cuentas","account_settings":"Configuraciones de la cuenta","go_to_web_wallet":"Administra tu cuenta de Alby"}},"screen_reader":"Alternar men desplegable"},"publishers_table":{"used":"usado","payments":"pagos"},"badge":{"label":{"active":"ACTIVO","auth":"INICIAR SESIN"}},"companion_download_info":{"download":"Descargar","companion":{"title":"Aplicacin complementaria","description":"Aplicacin ligera que conecta tu navegador a la red TOR."},"tor_native":{"title":"TOR (nativa)","description":"Seleccione esta opcin si este navegador ya est conectado a la red TOR."},"heading":"Cmo quieres conectarte a la red TOR?"}},"mk":{"commando":{"getinfo":"Obtenga el resumen del nodo.","bkpr-listbalances":"Lista de todos los saldos actuales e histricos de la cuenta.","checkmessage":"Verifique que la firma fue generada por un nodo dado.","connect":"Establecer una nueva conexin con otro nodo.","keysend":"Enviar un pago a otro nodo.","offer":"Crear una oferta.","sendpay":"Enviar un pago a travs de una ruta.","signmessage":"Crear una firma a partir de este nodo.","fundchannel":"Abra un canal de pago con un par al realizar una transaccin de financiacin.","listfunds":"Listar todos los fondos disponibles.","getroute":"Encontrar la mejor ruta para el pago a un nodo lightning.","invoice":"Crear la expectativa de un pago.","listpays":"Obtener el estado de todos los comandos de pago.","listpeers":"Listar los nodos que estn conectados o que tienen canales abiertos con este nodo.","listtransactions":"Listar las transacciones rastreadas en la billetera.","pay":"Enve un pago a una factura BOLT11.","listinvoices":"Obtener el estado de todas las facturas.","listoffers":"Enumerar todas las ofertas u obtener una oferta especfica.","multifundchannel":"Abra mltiples canales de pago con nodos al realizar una sola transaccin de financiacin.","disconnect":"Cerrar una conexin existente con un par.","decode":"Decodifica una cadena bolt11/bolt12/rune.","decodepay":"Comprobar y analizar una cadena bolt11.","listforwards":"Enumere todos los htlc que se han intentado reenviar.","setchannel":"Configurar tarifas/rango htlc anunciado para un canal.","listnodes":"Enumere los nodos sobre los que el nodo ha aprendido a travs de mensajes gossip.","listsendpays":"Obtiene el estado de todos los comandos sendpay.","feerates":"Devuelve las tarifas que utilizar CLN."},"nostr":{"signmessage":"Firma el mensaje con tu clave.","getpublickey":"Leer tu clave pblica.","nip04encrypt":"Cifrar datos.","nip04decrypt":"Descifrar datos."},"lnd":{"queryroutes":"Consultar una posible ruta.","openchannel":"Abrir un nuevo canal.","getnetworkinfo":"Obtener estadsticas bsicas sobre el grfico de canales conocidos.","getnodeinfo":"Obtener la informacin del canal para un nodo.","gettransactions":"Obtener una lista de todas las transacciones relevantes para la billetera.","getchaninfo":"Obtener el anuncio de la red para el canal dado.","listpeers":"Obtener una lista de todos los pares actualmente activos.","lookupinvoice":"Consultar los detalles de la factura.","listpayments":"Obtener una lista de todos los pagos salientes.","estimatefee":"Calcular la tasa de tarifa y las tarifas totales para una transaccin.","getinfo":"Obtener la informacin del nodo.","listchannels":"Obtener una descripcin de todos los canales abiertos.","listinvoices":"Obtener una lista de todas las facturas.","connectpeer":"Establecer una conexin con un par remoto.","disconnectpeer":"Desconectar de un par remoto.","addinvoice":"Crear nuevas facturas.","channelbalance":"Obtener un informe sobre los fondos totales en todos los canales abiertos.","walletbalance":"Obtener las salidas totales no gastadas de la billetera.","sendtoroute":"Realizar un pago a travs de la ruta especificada.","decodepayreq":"Decodificar una cadena de solicitud de pago.","verifymessage":"Verificar una firma sobre un mensaje.","routermc":"Lea el estado de control de la misin interna.","settleinvoice":"Pagar una factura aceptada.","addholdinvoice":"Crear nuevas facturas HODL."},"lnc":{"getinfo":"Obtener la informacin del nodo.","gettransactions":"Obtener una lista de todas las transacciones relevantes para la billetera.","getnodeinfo":"Obtener la informacin del canal para un nodo.","getnetworkinfo":"Obtener estadsticas bsicas sobre el grfico de canales conocidos.","listinvoices":"Obtener una lista de todas las facturas.","channelbalance":"Obtener un informe sobre los fondos totales en todos los canales abiertos.","walletbalance":"Obtener las salidas totales no gastadas de la billetera.","listpeers":"Obtener una lista de todos los pares actualmente activos.","lookupinvoice":"Consultar los detalles de la factura.","queryroutes":"Consultar una posible ruta.","sendtoroute":"Realizar un pago a travs de la ruta especificada.","openchannel":"Abrir un nuevo canal.","connectpeer":"Establezca una conexin con un par remoto.","disconnectpeer":"Desconectarse de un par remoto.","estimatefee":"Calcular la tasa de tarifa y las tarifas totales para una transaccin.","getchaninfo":"Obtener el anuncio de la red para el canal dado.","addinvoice":"Crear nuevas facturas.","listpayments":"Obtener una lista de todos los pagos salientes.","listchannels":"Obtener una descripcin de todos los canales abiertos.","decodepayreq":"Decodificar una cadena de solicitud de pago.","verifymessage":"Verificar una firma sobre un mensaje.","routermc":"Lea el estado de control de la misin interna.","addholdinvoice":"Crear nuevas facturas HODL.","settleinvoice":"Pagar una factura aceptada."}}}'); const yt = JSON.parse('{"xk":{"welcome":{"set_password":{"title":"Aseta lukituksen avaussalasana","description":"Lightning-tilisi tiedot on salattu turvallisesti salasanan avulla. l unohda tt salasanaa! Tarvitset sit avataksesi Alby-laajennuksen lukituksen (tss selaimessa)","choose_password":{"label":"Valitse lukituksen avaamissalasana:"},"confirm_password":{"label":"Vahvistetaan, ett kirjoitit sen oikein:"},"errors":{"enter_password":"Syt salasana.","confirm_password":"Vahvista salasanasi.","mismatched_password":"Salasanat eivt tsm."}},"test_connection":{"ready":"Mahtavaa, olet valmis menemn!","initializing":"Tilin alustaminen. Odota, tm voi kest hetken...","connection_error":"Yhteysvirhe","review_connection_details":"Ole hyv ja tarkista yhteystietosi.","connection_taking_long":"Yhteyden muodostaminen kest odotettua kauemmin... Ovatko tietosi oikein? Onko solmusi tavoitettavissa?","contact_support":"Jos tarvitset apua, ota yhteytt osoitteeseen support@getalby.com","actions":{"delete_edit_account":"Poista virheellinen tili ja muokkaa uudelleen"}}},"choose_connector":{"description":"Sinun tytyy ensin muodostaa yhteys Lightning-lompakkoon, jotta voit olla vuorovaikutuksessa suosikkisivustojesi kanssa, jotka hyvksyvt Bitcoin Lightning -maksut!","lnd":{"title":"LND","page":{"title":"Yhdist LND-solmuusi","description":"Tarvitset solmusi URL-osoitteen ja macaroonin, jolla on luku- ja lhetysoikeudet (esim. admin.macaroon)"},"url":{"label":"REST API:n kone ja portti","placeholder":"https://sinun-solmusi-url:8080"},"macaroon":{"label":"Macaroon (HEX-muoto)"},"drag_and_drop":"Ved ja pudota makaroonisi tnne tai <0>selaa</0>","errors":{"connection_failed":"Yhteys eponnistui. Ovatko LND-tunnuksesi oikein?"}},"lndhub_bluewallet":{"title":"Sinilompakko","page":{"title":"Yhdist sinilompakkoosi","description":"Valitse sinilompakossa lompakko, jonka haluat yhdist, avaa se, napsauta \\"...\\", napsauta Vie/Varmuuskopioi nyttksesi QR-koodin ja skannaa se webbikamerallasi."},"uri":{"label":"Sinilompakon vienti-URI"},"errors":{"invalid_uri":"Virheellinen sinilompakon URI","connection_failed":"Yhteys eponnistui. Onko sinilompakon URI oikein?"}},"lndhub_go":{"title":"LNDHub","page":{"title":"Yhdist LNDHubiin","description":"Syt LNDHub-tunnuksesi URI tst tai skannaa QR-koodi webbikamerallasi."},"uri":{"label":"LNDHubin vienti-URI"},"errors":{"invalid_uri":"Virheellinen LNDHubin URI","connection_failed":"Yhteys eponnistui. Onko LNDHubin URI oikein?"}},"lnbits":{"title":"LNbits","page":{"title":"Yhdist <0>LNbits</0>:een","instructions":"Valitse LNbitsiss lompakko, johon haluat yhdist, avaa se, napsauta API-tiedot ja kopioi jrjestelmnvalvojan avain. Liit se alle:"},"admin_key":{"label":"LNbitsin jrjestelmnvalvojan avain","placeholder":"32-numeroinen jrjestelmnvalvojan avaimesi"},"url":{"label":"LNbitsin URL-osoite"},"errors":{"connection_failed":"Yhteys eponnistui. Onko sinulla oikea URL-osoite ja jrjestelmnvalvojan avain?"}},"eclair":{"title":"Eclair","page":{"title":"Yhdist <0>Eclairiin</0>","instructions":"Tarvitset Eclairin URL-osoitteen ja salasanan."},"password":{"label":"Eclair-salasana"},"url":{"label":"Eclairin URL-osoite","placeholder":"http://localhost:8080"}},"citadel":{"title":"Citadel","page":{"title":"Yhdist <0>Citadel</0> solmuun","instructions":"Tm ei tll hetkell toimi, jos 2FA on kytss."},"password":{"label":"Citadel-salasana"},"url":{"label":"Citadelin URL-osoite","placeholder":"http://citadel.local"}},"umbrel":{"title":"Umbrel","page":{"title":"Yhdist <0>Umbrel</0>-solmuun","instructions":"Siirry Umbrelin kojelaudassa kohtaan <0>Yhdist lompakkoon</0>. Valitse <0>lndconnect REST</0> ja kopioi <0>lndconnect URL-osoite</0>. (Asetuksistasi riippuen voit kytt joko paikallista yhteytt tai Tor-yhteytt)"},"rest_url":{"label":"lndconnect -REST URL-osoite","placeholder":"lndconnect://solmusi:8080?..."}},"mynode":{"title":"myNode","page":{"title":"Yhteys <0>myNode</0>:een","instructions":"Napsauta myNode-etusivullasi <0>Lompakko</0>-painiketta <0>Lightning</0>-palvelun kohdalla.<1/> Napsauta nyt <0>Muodosta parilompakko</0>-painiketta <0>Tila</0>-vlilehden alla. Syt salasanasi, kun sit pyydetn.<1/> Valitse pudotusvalikosta pariliitntvaihtoehto. Asetuksestasi riippuen voit kytt joko <0>Lightning (REST + paikallinen IP-osoite)</0> -yhteytt tai <0>Lightning (REST + Tor)</0> -yhteytt."},"rest_url":{"label":"lndconnect -REST URL-osoite","placeholder":"lndconnect://solmusi:8080?..."}},"start9":{"title":"Start9","page":{"title":"Yhdist <0>Embassy</0>-solmuun","instructions":"<0>Huomautus:</0> Tll hetkell tuemme vain LND:t, mutta lismme c-lightning-tuen tulevaisuudessa!<1/>Klikkaa Embassy-kojelaudallasi <0>Lightning Network Daemon</0> -palvelua.<1/>Valitse <0>Ominaisuudet</0>-vlilehti.<1/>Kopioi nyt <0>LND Yhdist -REST URL-osoite.</0>"},"rest_url":{"label":"lndconnect -REST URL-osoite","placeholder":"lndconnect://solmusi:8080?..."}},"raspiblitz":{"title":"RaspiBlitz","page":{"title":"Yhdist <0>RaspiBlitz</0>solmuusi","instructions1":"Tarvitset solmusi sipuliosoitteen, portin ja makaroonin, jolla on luku- ja lhetysoikeudet (esim. admin.makaroon). <1/><1/><0>SSH</0> sisn <0>RaspiBlitz</0>. <1/>Aja komento <0>sudo cat /mnt/hdd/tor/lndrest/hostname</0>.<1/>Kopioi ja liit <0>.onion</0> osoite alla olevaan sytteeseen.<1/>Lis <0>portti</0> sipilin osoitteen pern, oletusportti on <0>:8080</0>.","instructions2":"Valitse <0>Yhdist</0>. <1/>Valitse <0>Vie</0>. <1/>Valitse <0>HEX</0>. <1/>Kopioi <0>adminMacaroon</0>. <1/>Liit macaroon alla olevaan sytteeseen."},"rest_api_host":{"label":"REST API -kone","placeholder":"solmusi-sipuli-osoite:portti"}},"bitcoin_beach":{"title":"Bitcoin Beach -lompakko","page":{"title":"Yhdist <0>Bitcoin Beach -lompakkoon</0>"}},"bitcoin_jungle":{"title":"Bitcoin Jungle - lompakko","page":{"title":"Yhdist <0>Bitcoin Jungle -lompakkoon</0>"}},"galoy":{"phone_number":{"label":"Syt puhelinnumerosi"},"sms_code":{"label":"Syt tekstiviestivahvistuskoodisi"},"token":{"label":"Syt JWT-tunnuksesi","info":"Kirjautumistunnusta {{label}} pivitetn parhaillaan. Jos olet kokenut kyttj, voit napata JWT-tunnuksesi kirjautumalla sisn <0>Verkkolompakon (wallet.mainnet.galoy.io) kautta</0><1/><1/>JWT nytt tlt: < 2>eyJhbG...</2><1/><1/>"},"actions":{"login":"Kirjaudu sisn"},"errors":{"setup_failed":"Mritys eponnistui","missing_token":"JWT puuttuu, sisnkirjautuminen ei onnistunut.","invalid_token":"virheellinen JWT vlitetty"}},"btcpay":{"title":"BTCPay-palvelin","page":{"title":"Yhdist BTCPay LND -solmuusi","instructions":"Siirry BTCPayServerillesi ja kirjaudu sisn jrjestelmnvalvojana. Siirry kohtaan Palvelinasetukset > Palvelut > LND Rest - Katso tiedot. Napsauta sitten \\"Katso QR-koodin tiedot\\" ja kopioi QR-koodin tiedot. Liit se alle:"},"config":{"label":"Konfigurointitiedot","placeholder":"config=https://your-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Yhteys eponnistui. Onko BTCPay-yhteyden URL-osoite oikea ja saatavilla?"}},"commando":{"title":"Core Lightning","page":{"title":"Yhdist Core Lightning -solmuusi","instructions":"Varmista, ett sinulla on Core Lightning -versio 0.12.0 tai uudempi, ett Commando-laajennus on kynniss ja ett solmuasi on kytettviss Lightning-verkon kautta. Luo riimu suorittamalla \\"lightning-cli commando-rune\\"."},"host":{"label":"Kone"},"pubkey":{"label":"Julkinen avain"},"rune":{"label":"Rune"},"port":{"label":"Portti"},"proxy":{"label":"Websocket-vlityspalvelin"},"privKey":{"label":"Paikallinen yksityinen avain (automaattisesti luotu)"},"config":{"label":"Asetustiedot","placeholder":"config=https://your-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Yhteys eponnistui. Onko Core Lightning -solmu verkossa ja kyttk Commando-laajennusta?"}}},"home":{"actions":{"send_satoshis":" Lhet Satoshis ","enable_now":"Ota nyt kyttn"},"recent_transactions":"Viimeaikaiset tapahtumat","allowance_view":{"recent_transactions":"Viimeaikaiset tapahtumat","allowance":"Korvaus","sats_used":"sats kytetty","no_transactions":"Ei viel tapahtumia <0>{{name}}</0>:lla."},"default_view":{"recent_transactions":"Viimeaikaiset tapahtumat","is_blocked_hint":"Alby on tll hetkell poissa kytst {{host}}:lla"}},"accounts":{"title":"Tilit","actions":{"add_account":"Lis tili"}},"enable":{"title":"Yhdist","allow":"Salli {{host}} thn:","request1":"Pyyd hyvksynt tapahtumille","request2":"Pyyd laskuja ja Lightning-tietoja","block_and_ignore":"Est ja jt huomioimatta {{host}}"},"unlock":{"unlock_to_continue":"Avaa lukitus jatkaaksesi","unlock_password":"Avaussalasanasi","help_contact":{"part1":"Tarvitsetko apua? Ottaa yhteytt","part2":"Albyn tuki"},"unlock_error":{"help":"Tilisi tiedot on salattu lukituksen avaussalasanallasi. Jos todella unohdit avaussalasanasi, sinun on nollattava ja listtv Lightning-tilisi uudelleen.","link":"Nollaa nyt ja lis uusi tili"},"errors":{"invalid_password":"Vr salasana"}},"settings":{"title":"Asetukset","browser_notifications":{"title":"Selaimen ilmoitukset","subtitle":"Maksuihin ja todentamiseen liittyvt ilmoitukset."},"website_enhancements":{"title":"Verkkosivuston parannukset","subtitle":"Vinkkien parannuksia Twitteriss, YouTubessa jne."},"lnurl_auth":{"title":"LNURL-Auth","hint":"on yleinen todennusprotokolla. Se tunnistaa kyttjn digitaalisten allekirjoitusten avulla. Protokolla ei vaadi muita tunnistetietoja, kuten salasanoja, shkposteja, kyttjtunnuksia tai vastaavia. Albyn avulla voit kytt Lightning-tilejsi kirjautuaksesi turvallisesti verkkosivustoille. Ollaksemme yhteensopiva muiden lompakoiden kanssa, meidn piti tehd muutamia muutoksia, jotka voit mritt tll. <0>Ihannetapauksessa kaikki nm vaihtoehdot ovat Pois plt.</0> Kyt niit vain, jos sinulla on vanhoja tilej.","legacy_lnurl_auth_202207":{"title":"Vanha LNURL-Auth","subtitle":"Avainten luonti LNURL-Authia varten on muuttunut (heinkuu 2022). Alby ei ollut yhteensopiva muiden toteutusten kanssa. Tt muutettiin, mutta nyt kytetn erilaisia kirjautumisavaimia. Jos kytit kirjautumiseen LNURL-Authia, ennen kuin voit silti ottaa vanhan menetelmn kyttn. Tm vaihtoehto poistetaan myhemmin, muista vaihtaa uuteen kirjautumistunnukseen."},"legacy_lnurl_auth":{"title":"Vanha allekirjoitus LNDhubille ja LNbitsille","subtitle":"Viestien allekirjoitus ja sisnkirjautuminen LNDhub- (esim. BlueWallet (sinilompakko)- ja LNbits-tilill on muutettu (maaliskuu 2022). Jos kirjauduit sisn nill tileill, voit silti ottaa vanhan allekirjoitustavan kyttn. Tm vaihtoehto poistetaan myhemmin, muista vaihtaa uuteen kirjautumistunnukseen."}},"camera_access":{"title":"Kameran kyttoikeus","subtitle":"QR-koodien skannaamiseen","allow":"Salli kameran kytt","granted":"Lupa mynnetty"},"language":{"title":"Kieli","subtitle":"Knnkset eivt ole viel 100 % valmiit. <0>Auta meit kntmn Alby kielellesi!</0>"},"theme":{"title":"Teema","subtitle":"Kyt Albya tumma- tai vaalea-tilassa","options":{"dark":"Tumma","light":"Vaalea","system":"Jrjestelm"}},"show_fiat":{"title":"Satista Fiatiin","subtitle":"Muunna aina valituksi valuutaksi valitusta valuutasta"},"currency":{"title":"Valuutta","subtitle":"Nyt summat lisksi tss valuutassa"},"exchange":{"title":"Valuuttalhde","subtitle":"Bitcoin-valuuttakurssien lhde"},"personal_data":{"title":"Henkilkohtaiset tiedot","description":"Maksunsaajat voivat pyyt listietojen lhettmist maksun yhteydess. Nit tietoja ei jaeta kenenkn kanssa ilman suostumustasi, saat aina kehotteen ennen tietojen lhettmist maksun yhteydess."},"name":{"title":"Nimi","placeholder":"Syt nimesi"},"email":{"title":"Shkposti","placeholder":"Syt shkpostiosoitteesi"},"change_password":{"title":"Vaihda lukituksen avaussalasana","screen_reader":"Vaihda lukituksen avaussalasana","choose_password":{"label":"Syt uusi lukituksen avaussalasana:"},"confirm_password":{"label":"Vahvista uusi salasana:"},"submit":{"label":"Vaihda"},"errors":{"enter_password":"Syt uusi lukituksen avaussalasana.","confirm_password":"Vahvista salasanasi.","mismatched_password":"Salasanat eivt tsm."},"success":"Salasana vaihdettu onnistuneesti"},"nostr":{"title":"Nostr","hint":"on yksinkertainen ja avoin protokolla, jonka tarkoituksena on luoda sensuurin kestvi sosiaalisia verkostoja. Nostr toimii kryptografisten avainten kanssa. Jos haluat julkaista jotain, allekirjoita se avaimellasi ja lhet se useille vlittjille. Voit kytt Alby Nostr-avaimen hallintaan. Monet Nostr-sovellukset sallivat sitten yksinkertaisesti kytt avainta Alby-laajennuksesta.","private_key":{"title":"Yksityinen avain","subtitle":"Avaimen luominen luo uuden avaimen nykyisen kyttmsi tilin perusteella. Varmista, ett varmuuskopioit tmn yksityisen avaimen."}}},"send":{"title":"Lhet","input":{"label":"Vastaanottaja","hint":"Lasku, Lightningin osoite tai LNURL"}},"lnurlpay":{"amount":{"label":"Mr"},"comment":{"label":"Kommentti"},"name":{"label":"Nimi"},"email":{"label":"Shkposti"},"success":"Onnistui, maksu lhetetty!"},"lnurlauth":{"title":"Todennus","content_message":{"heading":"Haluatko kirjautua sisn"},"submit":"Sisn kirjautuminen","success":"Sisn kirjautuminen onnistui {{name}}","errors":{"status":"Virhe: Todennustila ei ole kunnossa"}},"lnurlchannel":{"title":"Kanavapyynt","content_message":{"heading":"Pyyd kanava solmulta"},"success":"Kanavapyynt lhetetty onnistuneesti {{name}}:lle"},"lnurlwithdraw":{"title":"Peruuta","content_message":{"heading":"Mr"},"amount":{"label":"Mr"},"success":"{{amount}}:n peruutuspyynt lhetetty onnistuneesti {{sender}}:lle"},"receive":{"title":"Vastaanota","actions":{"create_invoice":"Luo lasku"},"amount":{"label":"Mr","placeholder":"Mr Satoshissa..."},"description":{"label":"Kuvaus","placeholder":"Esim. kuka lhett tmn maksun?"},"success":"Maksu vastaanotettu!","payment":{"waiting":"odotetaan maksua...","status":"Tarkista maksun tila"}},"publishers":{"publisher":{"allowance":{"title":"Korvaus","used_budget":"satia kytetty"}}},"make_invoice":{"title":"Luo lasku","amount":{"label":"Summa (Satoshi)"},"memo":{"label":"Muistio"},"errors":{"amount_too_small":"Mr on alle vhimmismrn","amount_too_big":"Mr ylitt enimmismrn"}},"confirm_sign_message":{"title":"Allekirjoita","content":"{{host}} pyyt sinua allekirjoittamaan:"},"confirm_keysend":{"title":"Hyvksy maksu","success":"Maksu lhetetty! esikuva: {{preimage}}","payment_summary":{"description":"Lhet maksu {{destination}}:een"}},"keysend":{"title":"Lhet","success":"Maksu lhetetty! esikuva: {{preimage}}","receiver":{"label":"Lhet maksu thn"},"amount":{"label":"Mr (Satoshi)"}},"confirm_payment":{"title":"Hyvksy maksu","success":"{{amount}}:n maksu onnistui!","actions":{"pay_now":"Maksa nyt"}},"confirm_request_permission":{"title":"Hyvksy pyynt","allow":"Salli {{host}}:","always_allow":"Salli aina {{metodi}} {{host}}:lla"},"nostr":{"title":"Nostr","allow":"Salli {{host}}:","block_and_ignore":"Est ja jt huomiotta {{host}}"}},"y0":{"password":"Salasana","advanced":"Edistynyt","success":"Menestys","error":"Virhe","settings":"Asetukset","sats_one":"sat","sats_other":"satia","loading":"ladataan","amount":"Summa","optional":"Valinnainen","feedback":"Palaute","copied":"Kopioitu!","description":"Kuvaus","description_full":"Tydellinen kuvaus","success_message":"{{amount}}{{{fiatAmount}} lhetetty {{destination}}:een","response":"Vastaus","message":"Viesti","help":"Apu","actions":{"back":"Takaisin","delete":"Poista","edit":"Muokkaa","next":"Seuraava","open":"Avaa","cancel":"Peru","confirm":"Vahvista","continue":"Jatka","connect":"Yhdist","lock":"Lukitse","unlock":"Avaa lukitus","send":"Lhet","save":"Tallenna","receive":"Vastaanota","close":"Sulje","export":"Vie","remove":"Poista","copy":"Kopioi"},"errors":{"connection_failed":"Yhteyden muodostaminen eponnistui","payment_failed":"Maksu ei onnistunut"}},"wx":{"allowance_menu":{"confirm_delete":"Haluatko varmasti poistaa tmn verkkosivuston?","hint":"Tm nollaa voimassa olevan budgetin","new_budget":{"label":"Uusi budjetti"},"enable_login":{"title":"Ota verkkosivustoon kirjautuminen kyttn","subtitle":"Automaattinen kirjautuminen ilman vahvistusta, kun verkkosivusto pyyt."},"edit_allowance":{"title":"Muokkaa korvausta","screen_reader":"Korvausvaihtoehdot"}},"qrcode_scanner":{"title":"Skannaa QR-koodi","actions":{"start_scanning":"Aloita skannaus","stop_scanning":"Lopeta skannaus"},"errors":{"allow_camera_access":"Salli kameran kyttoikeus asetusruudussa."}},"transactionsTable":{"fee":"Kustannus","preimage":"Esikuva","received":"Vastaanotettu","sent":"Lhetetty","boostagram":{"sender":"Lhettj","message":"Viesti","app":"Sovellus","podcast":"Podcast"}},"confirm_or_cancel":{"only_trusted":"Muodosta yhteys vain sellaisiin sivustoihin, joihin luotat."},"budget_control":{"remember":{"label":"Muista ja aseta budjetti","description":"Voit asettaa saldon niin, ett maksujen vahvistusta ei pyydet ennen kuin se on kytetty kokonaan."},"budget":{"label":"Budjetti"}},"toasts":{"connection_error":{"what_you_can_do":"Voit tehd nin:","double_check":"Tarkista yhteystiedot kahdesti","if_ssl_errors":"ja jos on SSL-virheit (esim. ERR_CERT_AUTHORITY_INVALID), valitse \\"edistynyt\\" ja jatka varmenteen hyvksymist.","visit_guides":"Lue oppaita saadaksesi lis apua"},"login_failed":{"password_reset":"Unohditko salasanasi? Klikkaa tst"},"errors":{"invalid_credentials":"Virheellinen salasana. Tarkista salasanasi ja shkpostiosoitteesi ja yrit uudelleen."}},"account_menu":{"screen_reader":"Vaihda pudotusvalikko","title":"Vaihda tili","options":{"account":{"add":"Lis uusi tili","manage":"Hallitse tilej"}}},"publishers_table":{"payments":"maksut","used":"kytetty"},"badge":{"label":{"active":"TOIMIVA"}}},"mk":{}}'); const bt = JSON.parse('{"xk":{"welcome":{"title":"Bienvenue sur Alby","set_password":{"title":"Dfinir un mot de passe de dverrouillage","description":"Ce mot de passe est utilis pour protger votre portefeuille et donner accs  l\'extension du navigateur. Il ne peut pas tre rinitialis et est distinct du mot de passe de votre compte Alby.","choose_password":{"label":"Choisissez un mot de passe de dverrouillage:"},"confirm_password":{"label":"Confirmons que vous l\'avez tap correctement:"},"errors":{"enter_password":"S\'il vous plait, entrez votre mot de passe.","confirm_password":"Veuillez confirmer votre mot de passe.","mismatched_password":"Les mots de passe entrs ne sont pas les mmes."}},"test_connection":{"ready":"Parfait, vous tes prt !","initializing":"Cration de votre compte. S\'il vous plait, veuillez patienter, ceci peut prendre une minute...","connection_error":"Erreur de connexion","review_connection_details":"Veuillez vrifier vos informations de connexion.","connection_taking_long":"Essayer de se connecter prend plus de temps que prvu... Vos informations sont-elles correctes? Votre nud est-il accessible?","contact_support":"Si vous avez besoin d\'aide, veuillez contacter support@getalby.com","actions":{"delete_edit_account":"Supprimer le compte invalide et modifier  nouveau"}}},"choose_path":{"alby":{"title":"Alby","description":"Inscrivez-vous ou utilisez votre compte Alby existant pour commencer  utiliser les paiements clair en un rien de temps."},"other":{"title":"Autres portefeuilles","description":"Connectez-vous  votre portefeuille ou nud Lightning et choisissez parmi diffrents connecteurs.","and_more":"& plus...","connect":"Connecter"}},"alby":{"pre_connect":{"set_password":{"choose_password":{"label":"Mot de passe"},"confirm_password":{"label":"Confirmez le mot de passe"},"errors":{"enter_password":"Veuillez entrer un mot de passe.","confirm_password":"Veuillez confirmer votre mot de passe.","mismatched_password":"Les mots de passe ne correspondent pas."}}}},"choose_connector":{"title":"Connecter le portefeuille Lightning","description":"Connectez-vous  votre portefeuille ou nud Lightning externe","lnd":{"title":"LND","page":{"title":"Connectez-vous  votre nud LND","description":"Vous avez besoin de l\'URL de votre nud et d\'un macaroon avec des autorisations de lecture et d\'envoi (par exemple, admin.macaroon )"},"url":{"label":"REST API host et port","placeholder":"https://url-de-votre-node:8080"},"macaroon":{"label":"Macaroon (format HEX )"},"drag_and_drop":"Faites glisser et dposez votre macaroon ici ou <0>naviguez</0>","errors":{"connection_failed":"La connexion a chou. Vos informations d\'identification LND sont-elles correctes?"}},"lnc":{"title":"LND avec LNC","page":{"title":"Connectez-vous  votre nud LND","description":"Crez une nouvelle session dans le terminal (litd) pour obtenir une nouvelle phrase d\'appariement et entrez-la ici"},"pairing_phrase":{"label":"Votre phrase d\'appariement ","placeholder":"phrase de sats de pile secrte"}},"lndhub_bluewallet":{"title":"Bluewallet","page":{"title":"Connectez-vous  BlueWallet","description":"Dans BlueWallet, choisissez le wallet que vous souhaitez connecter, ouvrez-le, cliquez sur \\"...\\", cliquez sur Export/Backup pour afficher le QR code et scannez-le avec votre webcam."},"uri":{"label":"URI d\'exportation BlueWallet"},"errors":{"invalid_uri":"URI BlueWallet non valide","connection_failed":"La connexion a chou. Votre URI BlueWallet est-il correct?"}},"lndhub_go":{"title":"LNDHub","page":{"title":"Connectez-vous  LNDHub","description":"Saisissez ici l\'URI de votre identifiant LNDHub ou scannez le code QR avec votre webcam."},"uri":{"label":"URI d\'exportation LNDHub"},"errors":{"invalid_uri":"","connection_failed":"La connexion a chou. Votre URI LNDHub est-elle correcte?"}},"lnbits":{"title":"LNbits","page":{"title":"Connectez-vous  <0>LNbits</0>","instructions":"Dans LNbits, choisissez le portefeuille que vous souhaitez connecter, ouvrez-le, cliquez sur API Info et copiez la cl d\'administration. Collez-le ci-dessous:"},"admin_key":{"label":"Cl d\'administration LNbits","placeholder":"Votre cl d\'administrateur  32 chiffres"},"url":{"label":"URL LNbits"},"errors":{"connection_failed":"La connexion a chou. Disposez-vous de l\'URL et de la cl d\'administration correctes?"}},"eclair":{"title":"Eclair","page":{"title":"Connectez-vous  <0>Eclair</0>","instructions":"Vous avez besoin de votre URL et de votre mot de passe Eclair."},"password":{"label":"Mot de passe Eclair"},"url":{"label":"URL de l\'clair","placeholder":"http://localhost:8080"}},"citadel":{"title":"Citadelle","page":{"title":"Connectez-vous au nud <0>Citadelle</0>","instructions":"Cela ne fonctionne pas actuellement si 2FA est activ."},"password":{"label":"Mot de passe Citadelle"},"url":{"label":"URL de la Citadelle","placeholder":"http://citadel.local"}},"umbrel":{"title":"Parapluie","page":{"title":"Connectez-vous au nud <0>Umbrel</0>","instructions":"Dans votre tableau de bord Umbrel, accdez  <0>Connect Wallet</0>. Slectionnez <0>lndconnect REST</0> et copiez l\'<0>URL lndconnect</0>. (Selon votre configuration, vous pouvez utiliser la connexion locale ou la connexion Tor.)"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://votrenode:8080?..."}},"mynode":{"title":"monNode","page":{"title":"Connectez-vous  <0>monNode</0>","instructions":"Sur votre page d\'accueil myNode, cliquez sur le bouton <0>Wallet</0> pour votre service <0>lightning</0>.<1/> Cliquez maintenant sur le bouton <0>Pair Wallet</0> sous le <0 Onglet >tat</0>. Saisissez votre mot de passe lorsque vous y tes invit.<1/> Slectionnez le menu droulant et choisissez une option de couplage. Selon votre configuration, vous pouvez soit utiliser la connexion <0>lightning (REST + Local IP)</0> ou la connexion <0>lightning (REST + Tor)</0>."},"rest_url":{"label":"URL REST lndconnect","placeholder":"lndconnect://votrenode:8080?..."}},"start9":{"title":"Start9","page":{"title":"Connectez-vous  votre nud <0>Embassy</0>","instructions":"<0>Remarque:</0> Actuellement, nous ne prenons en charge que LND, mais nous ajouterons la prise en charge de c-lightning  l\'avenir!<1/>Sur votre tableau de bord Embassy, cliquez sur le service <0>daemon du rseau Lightning</0>. <1/>Slectionnez l\'onglet <0>Properties</0>.<1/>Copiez maintenant l\'<0>URL REST LND Connect.</0>"},"rest_url":{"label":"URL REST lndconnect","placeholder":"lndconnect://votrenoeud:8080?..."}},"raspiblitz":{"title":"RaspiBlitz","page":{"title":"Connectez-vous  votre nud <0>RaspiBlitz</0>","instructions1":"Suivez ces tapes:<1/> 1. <0>SSH</0> dans votre <0>Raspiblitz</0><1/>2. Slectionnez <0>Connect Apps & Show Credentials</0> dans la liste<1/><0/>3. Choisissez <0>Connecter Alby  ce nud</0><1/>4. Appuyez sur <0>OK</0> pour afficher les identifiants de connexion<1/><1/>Copiez et collez l\'<0>hte API REST</0> ou l\'adresse <0>.onion</0> pour vous connecter via Tor dans l\'entre ci-dessous.","instructions2":"Copiez le <0>macaroon</0> (admin) dans l\'entre ci-dessous."},"rest_api_host":{"label":"Hte d\'API REST","placeholder":"adresse-de-votre-node-onion:port"}},"bitcoin_beach":{"title":"Portefeuille de plage Bitcoin","page":{"title":"Connectez-vous  <0>Bitcoin Beach Wallet</0>"}},"bitcoin_jungle":{"title":"Portefeuille Jungle Bitcoin","page":{"title":"Connectez-vous au <0>portefeuille Bitcoin Jungle</0>"}},"galoy":{"phone_number":{"label":"Entrez votre numro de tlphone"},"sms_code":{"label":"Entrez votre code de vrification par SMS"},"token":{"label":"Entrez votre jeton JWT","info":"La connexion {{label}} est en cours de mise  jour. Si vous tes un utilisateur avanc, vous pouvez rcuprer votre jeton JWT en vous connectant via le <0>Portefeuille Web (wallet.mainnet.galoy.io)</0><1/><1/>Le JWT ressemble: < 2>eyJhbG...</2><1/><1/>"},"actions":{"login":"Connexion"},"errors":{"setup_failed":"La configuration a chou","missing_token":"JWT manquant, impossible de se connecter.","invalid_token":"JWT invalide pass"}},"kollider":{"title":"Kollider","description":"Connectez-vous  votre compte Kollider","username":{"label":"Saisissez votre nom d\'utilisateur pour Kollider"},"currency":{"label":"Slectionnez votre compte en devise"},"errors":{"connection_failed":"La connexion a chou. tes-vous sr que les donnes du compte sont correctes?"}},"btcpay":{"title":"Serveur BTCPay","page":{"title":"Connectez-vous  votre nud BTCPay LND","instructions":"Accdez  votre BTCPayServer et connectez-vous en tant qu\'administrateur. Accdez  Paramtres du serveur > Services > LND Rest - Voir les informations. Cliquez ensuite sur \\"Voir les informations du code QR\\" et copiez les donnes du code QR. Collez-le ci-dessous:"},"config":{"label":"Donnes de configuration","placeholder":"config=https://votre-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"La connexion a chou. L\'URL de connexion BTCPay est-elle correcte et accessible ?"}},"commando":{"title":"Core Lightning","page":{"title":"Connectez-vous  votre nud Core Lightning","instructions":"Assurez-vous que vous disposez de Core Lightning version 0.12.0 ou plus rcente, que le plug-in commando est en cours d\'excution et que votre nud est accessible via le rseau Lightning. Crez une rune en excutant \'lightning-cli commando-rune\'."},"host":{"label":"Hte"},"pubkey":{"label":"Cl publique"},"rune":{"label":"Rune"},"port":{"label":"Port"},"proxy":{"label":"Proxy websocket"},"privKey":{"label":"Cl prive locale (gnre automatiquement)"},"config":{"label":"Donnes de configuration","placeholder":"config=https://votre-btc-payer.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"La connexion a chou. Votre nud Core Lightning est-il en ligne et utilise-t-il le plugin commando?"}}},"home":{"actions":{"send_satoshis":" Envoyez des Satoshis ","enable_now":"Activer maintenant"},"recent_transactions":"transactions rcentes","allowance_view":{"recent_transactions":"transactions rcentes","allowance":"Allocation","sats_used":"sats utiliss","no_transactions":"Aucune transaction sur <0>{{name}}</0> pour le moment."},"default_view":{"recent_transactions":"transactions rcentes","is_blocked_hint":"Alby est actuellement dsactiv sur {{host}}","block_removed":"{{hte}} activ. Veuillez recharger le site Web."}},"accounts":{"title":"Comptes","account_view":{"title1":"Information sur le compte","title2":"Modifier le compte","name":{"title":"Nom","placeholder":"Nom du compte"},"export":{"title":"Compte d\'exportation","screen_reader":"Exporter les dtails du compte","waiting":"en attente des donnes LndHub...","your_ln_address":"Votre adresse Lightning:","export_uri":"URI des identifiants LNDHub","scan_qr":"Importez ce portefeuille dans Zeus ou BlueWallet en scannant le QRCode."},"nostr":{"title":"Nostr","hint":"est un protocole simple et ouvert qui vise  crer des rseaux sociaux rsistants  la censure. Nostr fonctionne avec des cls cryptographiques. Pour publier quelque chose vous le signez avec votre cl et l\'envoyez  plusieurs relais. Vous pouvez utiliser Alby pour grer votre cl Nostr. De nombreuses applications Nostr vous permettront alors d\'utiliser simplement la cl de l\'extension Alby.","private_key":{"title":"Grez votre cl","subtitle":"Collez votre cl prive ou gnrez-en une nouvelle. Assurez-vous de sauvegarder votre cl prive avant d\'en gnrer une nouvelle. <0>En savoir plus</0>","warning":"Veuillez entrer le nom du compte pour confirmer la suppression de la cl prive:","success":"Cl prive crypte et enregistre avec succs.","successfully_removed":"Cl prive supprime avec succs.","label":"Cl prive","failed_to_remove":"Le nom de compte saisi ne correspondait pas, votre ancien compte priv a t restaur."},"public_key":{"label":"Cl publique"},"generate_keys":{"title":"Gnrer une nouvelle cl Nostr","screen_reader":"Gnrez une nouvelle cl Nostr pour votre compte","hint":"Vous pouvez gnrer une cl alatoire ou une cl drive  partir des dtails de ce compte (en utilisant une phrase canonique signe). <0>En savoir plus</0>","actions":{"random_keys":"Gnrer une cl alatoire","derived_keys":"Driver une cl du compte"}},"actions":{"generate":"Gnrer une nouvelle cl"},"errors":{"failed_to_load":"chec du chargement de la cl Nostr. Est-ce une cl Nostr valide?"}},"remove":{"title":"Supprimer ce compte","subtitle":"Tous les quotas lis seront supprims. S\'il vous plat soyez certain.","confirm":"Voulez-vous vraiment supprimer le compte: {{name}}?\\na ne peut pas tre annul. Si vous avez utilis ce compte pour vous connecter  des sites Web, vous risquez de perdre l\'accs  ceux-ci."},"actions":{"remove_account":"Supprimer le compte","export":"Exporter"}},"actions":{"add_account":"Ajouter un compte"}},"enable":{"title":"Connecter","allow":"Autoriser ce site Web :","request1":"Demander l\'approbation des transactions","request2":"Demander des factures et des informations sur la foudre","block_and_ignore":"Bloquer et ignorer {{host}}","block_added":"{{host}} a t ajout  la liste de blocage, veuillez recharger le site Web."},"unlock":{"unlock_to_continue":"Dverrouiller pour continuer","unlock_password":"Votre mot de passe de dverrouillage","help_contact":{"part1":"Besoin d\'aide? Contacter","part2":"Assistance Alby"},"unlock_error":{"help":"Les donnes de votre compte sont cryptes avec votre mot de passe de dverrouillage. Si vous avez vraiment oubli votre mot de passe de dverrouillage, vous devez rinitialiser et ajouter  nouveau votre compte Lightning.","link":"Rinitialisez maintenant et ajoutez un nouveau compte"},"errors":{"invalid_password":"Mot de passe incorrect"}},"settings":{"title":"Paramtres","browser_notifications":{"title":"Notifications du navigateur","subtitle":"Notifications lies au paiement et  l\'authentification."},"website_enhancements":{"title":"Amliorations du site Web","subtitle":"Amliorations des pourboires pour Twitter, YouTube, etc."},"lnurl_auth":{"title":"LNURL-Auth","hint":"est un protocole d\'authentification gnrique. Il authentifie l\'utilisateur  l\'aide de signatures numriques. Le protocole ne ncessite aucune autre information d\'identification telle que des mots de passe, des e-mails, des noms d\'utilisateur ou similaires. Avec Alby, vous pouvez utiliser vos comptes Lightning pour vous connecter en toute scurit aux sites Web. Pour tre compatible avec d\'autres portefeuilles, nous avons d apporter quelques modifications que vous pouvez configurer ici. <0>Idalement, toutes ces options sont dsactives.</0> Utilisez-les uniquement si vous avez d\'anciens comptes.","legacy_lnurl_auth_202207":{"title":"Hrit LNURL-Auth","subtitle":"La gnration de cl pour LNURL-auth a chang (juillet 2022). Alby n\'tait pas compatible avec d\'autres implmentations. Cela a t chang, mais maintenant diffrentes cls de connexion sont utilises. Si vous avez utilis LNURL-auth pour vous connecter auparavant, vous pouvez toujours activer l\'ancienne mthode. Cette option sera supprime plus tard, assurez-vous de passer  la nouvelle connexion."},"legacy_lnurl_auth":{"title":"Signature hrite pour LNDhub et LNbits","subtitle":"La signature des messages et la connexion avec LNDhub (par exemple BlueWallet) et les comptes LNbits ont t modifies (mars 2022). Si vous vous tes connect avec ces comptes, vous pouvez toujours activer l\'ancienne mthode de signature. Cette option sera supprime plus tard, assurez-vous de passer  la nouvelle connexion."}},"camera_access":{"title":"accs  la camra","subtitle":"Pour scanner les codes QR","allow":"Autoriser l\'accs  la camra","granted":"Permission accorde"},"language":{"title":"Langue","subtitle":"Les traductions ne sont pas encore termines  100 %. <0>Aidez-nous  traduire Alby dans votre langue!</0>"},"theme":{"title":"Thme","subtitle":"Utiliser Alby en mode sombre ou clair","options":{"dark":"Sombre","light":"Lumire","system":"Systme"}},"show_fiat":{"title":"Sat  Fiat","subtitle":"Toujours convertir dans la devise slectionne  partir de l\'change slectionn"},"currency":{"title":"Monnaie","subtitle":"Afficher les montants en plus dans cette devise"},"exchange":{"title":"Source d\'change","subtitle":"Source des taux de change Bitcoin"},"personal_data":{"title":"Donnes personnelles","description":"Les bnficiaires peuvent demander que des donnes supplmentaires soient envoyes avec un paiement. Ces donnes ne sont partages avec personne sans votre consentement, vous serez toujours invit avant que ces donnes ne soient envoyes avec un paiement."},"name":{"title":"Nom","subtitle":"","placeholder":"Entrez votre nom"},"email":{"title":"E-mail","subtitle":"","placeholder":"Entrez votre adresse email"},"change_password":{"title":"Changer le mot de passe de dverrouillage","subtitle":"","screen_reader":"Changer le mot de passe de dverrouillage","choose_password":{"label":"Saisissez un nouveau mot de passe de dverrouillage:"},"confirm_password":{"label":"Confirmer le nouveau mot de passe:"},"submit":{"label":"Changement"},"errors":{"enter_password":"Veuillez saisir un nouveau mot de passe de dverrouillage.","confirm_password":"Veuillez confirmer votre mot de passe.","mismatched_password":"Les mots de passe ne correspondent pas."},"success":"Le mot de passe a t chang avec succs"},"nostr":{"title":"Nostr","hint":"est un protocole simple et ouvert qui vise  crer des rseaux sociaux rsistants  la censure. Nostr fonctionne avec des cls cryptographiques. Pour publier quelque chose vous le signez avec votre cl et l\'envoyez  plusieurs relais. Vous pouvez utiliser Alby pour grer votre cl Nostr. De nombreuses applications Nostr vous permettront alors d\'utiliser simplement la cl de l\'extension Alby.","private_key":{"title":"Cl prive","subtitle":"Cette section est dplace vers la page des comptes car les cls sont dsormais spcifiques au compte.","go_to":"Aller aux comptes"}}},"send":{"title":"Envoyer","input":{"label":"Destinataire","hint":"Facture, adresse Lightning ou LNURL"}},"lnurlpay":{"amount":{"label":"Montant"},"comment":{"label":"Commentaire"},"name":{"label":"Nom"},"email":{"label":"E-mail"},"success":"Succs, paiement envoy!"},"lnurlauth":{"title":"Authentification","content_message":{"heading":"Voulez-vous vous connecter "},"submit":"Connexion","success":"Connexion russie sur {{name}}","errors":{"status":"Erreur: Le statut d\'authentification n\'est pas correct"}},"lnurlchannel":{"title":"Demande de chane","content_message":{"heading":"Demander un canal au nud"},"success":"La demande de chane a t envoye avec succs  {{name}}"},"lnurlwithdraw":{"title":"Retirer","content_message":{"heading":"Montant"},"amount":{"label":"Montant"},"success":"Demande de retrait de {{amount}} envoye avec succs  {{sender}}"},"receive":{"title":"Recevoir","actions":{"create_invoice":"Crer une facture"},"amount":{"label":"Montant","placeholder":"Montant en Satoshi..."},"description":{"label":"Description","placeholder":"Par ex. qui envoie ce paiement?"},"success":"Paiement reu!","payment":{"waiting":"en attente de paiement...","status":"Vrifier l\'tat du paiement"}},"discover":{"title":"Explorez l\'cosystme Lightning ","description":"Sites Web et applications Web o vous pouvez utiliser Alby","list":{"trading":"Commerce","gaming":"Jeux","entertainment":"Divertissement","shopping":"Achats","miscellaneous":"Divers","showcases":"Vitrines","nostr":"Nostr"},"tips":{"title":"Votre portefeuille Alby est prt","description":"Quelques conseils pour commencer  buzzer","top_up_wallet":{"title":" Rechargez votre portefeuille","description":"Crez une facture Lightning, envoyez-vous des bitcoins et commencez  utiliser Alby dans l\'cosystme Lightning"},"demo":{"title":" Essayez la dmo d\'Alby","description":"Dcouvrez tout ce que vous pouvez faire avec Alby sur notre site de dmonstration"}}},"publishers":{"title":"Vos sites ","description":"Sites Web sur lesquels vous avez dj utilis Alby","no_info":"Il semble que vous n\'ayez encore utilis Alby sur aucun site Web.","discover":"Dcouvrir des sites Web","publisher":{"allowance":{"title":"Allocation","used_budget":"sats utiliss"}}},"make_invoice":{"title":"Crer une facture","amount":{"label":"Montant (Satoshi)"},"memo":{"label":"Note"},"errors":{"amount_too_small":"Le montant est infrieur au minimum","amount_too_big":"Le montant dpasse le maximum"}},"confirm_sign_message":{"title":"Signe","content":"Ce site vous demande de signer :"},"confirm_keysend":{"title":"Approuver le paiement","success":"Paiement envoy! Primage: {{preimage}}","payment_summary":{"description":"Envoyez le paiement : {{destination}}"}},"keysend":{"title":"Envoyer","success":"Paiement envoy! Primage: {{preimage}}","receiver":{"label":"Envoyez le paiement "},"amount":{"label":"Montant (Satoshi)"}},"confirm_payment":{"title":"Approuver le paiement","success":"Paiement de {{amount}} russi!","actions":{"pay_now":"Payez maintenant"}},"confirm_request_permission":{"title":"Approuver la demande","allow":"Autoriser ce site Web  excuter:","always_allow":"Souviens-toi de mon choix et ne redemande plus"},"nostr":{"title":"Nostr","allow":"Autoriser ce site Web :","content":"Ce site vous demande de signer :","allow_sign":"Autoriser {{host}}  signer:","block_and_ignore":"Bloquer et ignorer {{host}}","block_added":"{{host}} a t ajout  la liste de blocage, veuillez recharger le site Web."}},"y0":{"password":"Mot de passe","confirm_password":"Confirmez le mot de passe","advanced":"Avanc","success":"Succs","error":"Erreur","settings":"Paramtres","accounts":"Comptes","discover":"Dcouvrir","connected_sites":"","sats_one":"sat","sats_other":"sats","loading":"chargement","amount":"Montant","optional":"Facultatif","feedback":"Retour","copied":"Copi!","description":"Description","description_full":"Description complte","success_message":"{{amount}}{{fiatAmount}} envoy  {{destination}}","response":"Rponse","message":"Message","help":"Aider","actions":{"back":"arrire","delete":"Supprimer","edit":"Modifier","next":"Suivant","open":"Ouvrir","cancel":"Annuler","confirm":"Confirmer","continue":"Continuer","connect":"Connecter","lock":"Verrouiller","unlock":"Dverrouiller","send":"Envoyer","save":"Sauvegarder","receive":"Recevoir","receive_again":"Recevoir un autre paiement","close":"Fermer","export":"Exporter","remove":"Retirer","copy":"Copie","copy_invoice":"","log_in":"Connexion","remember":"Souviens-toi de mon choix et ne redemande plus"},"errors":{"connection_failed":"La connexion a chou","payment_failed":"Paiement chou"},"range":{"lessThanOrEqual":" {{max}}","greaterOrEqual":" {{min}}","between":"entre {{min}} et {{max}}"}},"wx":{"allowance_menu":{"confirm_delete":"Voulez-vous vraiment supprimer ce site?","hint":"Cela rinitialisera le budget actuel","new_budget":{"label":"Nouveau budget"},"enable_login":{"title":"Activer la connexion au site Web","subtitle":"Connectez-vous automatiquement sans confirmation lorsque le site Web le demande."},"edit_allowance":{"title":"Modifier l\'allocation","screen_reader":"Options d\'allocation"},"edit_permissions":"Modifier les autorisations"},"qrcode_scanner":{"title":"Scanner le code QR","actions":{"start_scanning":"Lancer la numrisation","stop_scanning":"Arrter la numrisation"},"errors":{"allow_camera_access":"Veuillez autoriser l\'accs  la camra dans l\'cran des paramtres."}},"transactionsTable":{"fee":"Frais","preimage":"Primage","received":"Reu","sent":"Envoy","boostagram":{"sender":"Expditeur","message":"Message","app":"Application","podcast":"Podcast"},"open_location":"Ouvrir le site Web"},"confirm_or_cancel":{"only_trusted":"Connectez-vous uniquement aux sites auxquels vous faites confiance."},"budget_control":{"remember":{"label":"Rappelez-vous et tablissez un budget","description":"Vous pouvez dfinir un solde pour ne pas tre invit  confirmer les paiements tant qu\'il n\'est pas puis."},"budget":{"label":"Budget"}},"toasts":{"connection_error":{"what_you_can_do":"Voici ce que vous pouvez faire:","double_check":"Vrifiez vos informations de connexion","if_ssl_errors":"et s\'il y a des erreurs SSL (par exemple ERR_CERT_AUTHORITY_INVALID), cliquez sur \\"avanc\\" et continuez  accepter le certificat.","visit_guides":"Consultez nos guides pour plus d\'aide"},"login_failed":{"password_reset":"Mot de passe oubli? Cliquez ici"},"errors":{"invalid_credentials":"Mot de passe incorrect. Veuillez vrifier votre mot de passe et votre adresse e-mail et ressayer."}},"account_menu":{"screen_reader":"Basculer la liste droulante","title":"Changer de compte","options":{"account":{"add":"Ajouter un nouveau compte","manage":"Grer les comptes"}}},"publishers_table":{"payments":"Paiements","used":"utilis"},"badge":{"label":{"active":"ACTIF","auth":"CONNEXION"}}},"mk":{"nostr":{"getpublickey":"Lisez votre cl publique.","nip04encrypt":"Crypter les donnes.","nip04decrypt":"Dchiffrer les donnes.","signmessage":"Signez le message avec votre cl."},"commando":{"bkpr-listbalances":"Liste de tous les soldes de compte actuels et historiques.","checkmessage":"Vrifiez que la signature a t gnre par un nud donn.","connect":"tablissez une nouvelle connexion avec un autre nud.","decode":"Dcode une chane bolt11/bolt12/ rune chane.","decodepay":"Vrifier et analyser une chane bolt11.","disconnect":"Fermez une connexion existante  un pair.","feerates":"Renvoie les frais que CLN utilisera.","fundchannel":"Ouvrez un canal de paiement avec un pair en engageant une transaction de financement.","getinfo":"Obtenez le rsum du nud.","getroute":"Trouvez le meilleur itinraire pour le paiement vers un nud Lightning.","invoice":"Crer l\'attente d\'un paiement.","keysend":"Envoyez un paiement  un autre nud.","listforwards":"Rpertorier tous les htlcs qui ont t tents d\'tre transfrs.","listfunds":"Dressez la liste de tous les fonds disponibles.","listinvoices":"Obtenez le statut de toutes les factures.","listnodes":"Listez les nuds dont le nud a eu connaissance via des messages de potins.","listoffers":"Listez toutes les offres ou obtenez une offre spcifique.","listpays":"Obtient le statut de toutes les commandes de paiement.","listpeers":"Rpertorier les nuds connects ou ayant des canaux ouverts avec ce nud.","listsendpays":"Obtient le statut de toutes les commandes sendpay.","listtransactions":"Rpertorier les transactions suivies dans le portefeuille.","multifundchannel":"Ouvrez plusieurs canaux de paiement avec des nuds en effectuant une seule transaction de financement.","offer":"Crer une offre.","pay":"Envoyez un paiement  une facture BOLT11.","sendpay":"Envoyer un paiement via un itinraire.","setchannel":"Configurez les frais / la gamme htlc annonce pour un canal.","signmessage":"Crez une signature  partir de ce nud."},"lnd":{"getinfo":"Obtenez les informations sur le nud.","listchannels":"Obtenez une description de tous les canaux ouverts.","listinvoices":"Obtenez une liste de toutes les factures.","channelbalance":"Obtenez un rapport sur le total des fonds sur tous les canaux ouverts.","walletbalance":"Obtenez le total des sorties non dpenses du portefeuille.","openchannel":"Ouvrez une nouvelle chane.","connectpeer":"tablissez une connexion  un pair distant.","disconnectpeer":"Dconnectez-vous d\'un pair distant.","estimatefee":"Estimez le taux de frais et les frais totaux pour une transaction.","getchaninfo":"Obtenez l\'annonce du rseau pour la chane donne.","getnetworkinfo":"Obtenez des statistiques de base sur le graphique des canaux connus.","getnodeinfo":"Obtenir les informations de canal pour un nud.","gettransactions":"Obtenez une liste de toutes les transactions pertinentes pour le portefeuille.","listpayments":"Obtenez une liste de tous les paiements sortants.","listpeers":"Obtenez une liste de tous les pairs actuellement actifs.","lookupinvoice":"Consulter les dtails de la facture.","queryroutes":"Requte pour un itinraire possible.","verifymessage":"Vrifier une signature sur un msg.","sendtoroute":"Effectuez un paiement via l\'itinraire spcifi.","decodepayreq":"Dcoder une chane de demande de paiement.","routermc":"Lire l\'tat du contrle de mission interne.","addinvoice":"Crer de nouvelles factures."},"lnc":{"getinfo":"Obtenez les informations sur le nud.","listchannels":"Obtenez une description de tous les canaux ouverts.","listinvoices":"Obtenez une liste de toutes les factures.","channelbalance":"Obtenez un rapport sur le total des fonds sur tous les canaux ouverts.","walletbalance":"Obtenez le total des sorties non dpenses du portefeuille.","openchannel":"Ouvrez une nouvelle chane.","connectpeer":"tablissez une connexion  un pair distant.","disconnectpeer":"Dconnectez-vous d\'un pair distant.","estimatefee":"Estimez le taux de frais et les frais totaux pour une transaction.","getchaninfo":"Obtenez l\'annonce du rseau pour la chane donne.","getnetworkinfo":"Obtenez des statistiques de base sur le graphique des canaux connus.","getnodeinfo":"Obtenir les informations de canal pour un nud.","gettransactions":"Obtenez une liste de toutes les transactions pertinentes pour le portefeuille.","listpayments":"Obtenez une liste de tous les paiements sortants.","listpeers":"Obtenez une liste de tous les pairs actuellement actifs.","lookupinvoice":"Consulter les dtails de la facture.","queryroutes":"Requte pour un itinraire possible.","verifymessage":"Vrifier une signature sur un msg.","sendtoroute":"Effectuez un paiement via l\'itinraire spcifi.","decodepayreq":"Dcoder une chane de demande de paiement.","routermc":"Lire l\'tat du contrle de mission interne.","addinvoice":"Crer de nouvelles factures."}}}'); const vt = JSON.parse('{"xk":{"welcome":{"set_password":{"title":"Imposta una password di sblocco","description":"Questa password serve a proteggere il tuo wallet e a fornirti l\'accesso all\'estensione del browser. Non pu essere reimpostata ed  differente dalla password dell\'account Alby.","choose_password":{"label":"Scegli una password di sblocco:"},"confirm_password":{"label":"Conferma di averla digitata correttamente:"},"errors":{"enter_password":"Per favore inserisci una password.","confirm_password":"Si prega di confermare la password.","mismatched_password":"Le password non corrispondono."}},"test_connection":{"ready":"Fantastico, sei pronto per partire!","initializing":"Stiamo inizializzando il tuo account. Per favore attendi, questa operazione potrebbe impiegare alcuni minuti","connection_error":"Errore di connessione","review_connection_details":"Controlla i dettagli della tua connessione.","connection_taking_long":"Il tentativo di connessione richiede pi tempo del previsto... I tuoi dati sono corretti? Il tuo nodo  raggiungibile?","contact_support":"Se hai bisogno di aiuto, contatta support@getalby.com","actions":{"delete_edit_account":"Elimina l\'account invalido e modificalo di nuovo"}},"title":"Benvenuto su Alby"},"choose_connector":{"description":"Connettiti al tuo wallet lightning esterno o al tuo nodo","lnd":{"title":"LND","page":{"title":"Connettiti al tuo nodo LND","description":"Sono necessari l\'URL del nodo e un macaroon con permessi di lettura e invio (ad esempio, admin.macaroon)"},"url":{"label":"Host e porta dell\'API REST","placeholder":"https://URL-del-tuo-nodo:8080"},"macaroon":{"label":"Macaroon (formato HEX)"},"drag_and_drop":"Trascina e rilascia il tuo macaroon qui o<0>sfoglia</0>","errors":{"connection_failed":"Connessione non riuscita. Le tue credenziali LND sono corrette?"}},"lndhub_bluewallet":{"title":"Bluewallet","page":{"title":"Connettiti a BlueWallet","description":"Nell\'app BlueWallet, scegli il portafoglio che vuoi connettere, aprilo, clicca su \\"...\\", clicca su Export/Backup per mostrare il codice QR e scansionalo con la tua webcam."},"uri":{"label":"URI di esportazione BlueWallet"},"errors":{"invalid_uri":"URI di BlueWallet non valido","connection_failed":"Connessione non riuscita. L\'URI BlueWallet  corretto?"}},"lndhub_go":{"title":"LNDHub","page":{"title":"Connettiti a LNDHub","description":"Inserisci qui l\'URI delle credenziali LNDHub o scansiona il codice QR con la tua webcam."},"uri":{"label":"URI di esportazione LNDHub"},"errors":{"invalid_uri":"URI LNDHub non valido","connection_failed":"Connessione non riuscita. L\'URI LNDHub  corretto?"}},"lnbits":{"title":"LNbits","page":{"title":"Connetti a <0>LNbits</0>","instructions":"In LNbits, scegli il portafoglio che vuoi connettere, aprilo, clicca su API Info e copia la Admin Key. Incollala qui di seguito:"},"admin_key":{"label":"LNbits Admin Key","placeholder":"La tua admin key a 32 cifre"},"url":{"label":"LNbits URL"},"errors":{"connection_failed":"Connessione non riuscita. L\'Admin Key e l\'URL sono corretti?"}},"eclair":{"title":"Eclair","page":{"title":"Connettiti a <0>Eclair</0>","instructions":"Hai bisogno della tua password e URL Eclair."},"password":{"label":"Password Eclair"},"url":{"label":"URL Eclair","placeholder":"http://localhost:8080"}},"citadel":{"title":"Citadel","page":{"title":"Collega un nodo <0>Citadel</0>","instructions":"Attualmente non funziona se  abilitata la 2FA."},"password":{"label":"Password Citadel"},"url":{"label":"URL Citadel","placeholder":"http://citadel.local"}},"umbrel":{"title":"Umbrel","page":{"title":"Collega un nodo <0>Umbrel</0>","instructions":"Nella dashboard di Umbrel vai su <0>Connect Wallet</0>. Seleziona <0>lndconnect REST</0> e copia il <0>lndconnect URL</0>. (In base al tuo setup puoi usare una connessione locale o una connessione via TOR)"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://tuonodo:8080?..."}},"mynode":{"title":"myNode","page":{"title":"Collegati a <0>myNode</0>","instructions":"Nella homepage di myNode clicca sul tasto <0>Wallet</0> per il servizio <0>Lightning</0>.<1/> Ora clicca sul tasto <0>Pair Wallet</0> sotto il tab <0>Status</0>. Inserisci la tua password quando richiesta.<1/> Seleziona il menu a tendina e scegli l\'opzione per effettuare l\'accoppiamento. In base al tuo setup puoi utilizzare la connessione <0>Lightning (REST + Local IP)</0> o quella <0>Lightning (REST + Tor)</0>."},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://tuonodo:8080?..."}},"start9":{"title":"Start9","page":{"title":"Collega il tuo nodo Embassy","instructions":"<0>Nota:</0> Al momento supportiamo solamente LND, aggiungeremo il supporto per c-lightning in futuro!<1/>Nella dashboard di Embassy clicca sul servizio <0>Lightning Network Daemon</0>.<1/>Seleziona il tab <0>Proprieta\'</0>.<1/>Adesso copia l\'<0>LND Connect REST URL.</0>"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://tuonodo:8080?..."}},"raspiblitz":{"title":"RaspiBlitz","page":{"title":"Collega il tuo nodo <0>RaspiBlitz</0>","instructions1":"Hai bisogno dell\'indirizzo onion, la porta e il macaroon con permessi di lettura e scrittura (e.g admin.macaroon) del tuo nodo..<1/><1/>Entra attraverso <0>SSH</0> nel tuo <0>RaspiBlitz</0>.<1/>Lancia il comando <0>sudo cat /mnt/hdd/tor/lndrest/hostname</0>.<1/>Copia e incolla l\'indirizzo <0>.onion</0> di seguito.<1/>Aggiungi la tua <0>porta</0> subito dopo l\'indirizzo onion, la porta di default e\' <0>:8080</0>.","instructions2":"Seleziona <0>CONNECT</0>.<1/>Seleziona <0>EXPORT</0>.<1/>Seleziona <0>HEX</0>.<1/>Copia l\'<0>adminMacaroon</0>.<1/>Incolla il macaroon di seguito."},"rest_api_host":{"label":"host REST API","placeholder":"indirizzo-onion-del-tuo-nodo:porta"}},"bitcoin_beach":{"title":"Bitcoin Beach Wallet","page":{"title":"Connetti il tuo <0>Bitcoin Beach Wallet</0>"}},"bitcoin_jungle":{"title":"Bitcoin Jungle Wallet","page":{"title":"Connetti a <0>Bitcoin Jungle Wallet</0>"}},"galoy":{"phone_number":{"label":"Inserisci il tuo numero di telefono"},"sms_code":{"label":"Inserisci il codice di verifica SMS"},"token":{"label":"Inserisci il tuo token JWT","info":"Il login {{label}}  attualmente in fase di aggiornamento. Se sei un utente avanzato puoi recuperare il tuo token JWT effettuando il login via il <0>Web Wallet (wallet.mainnet.galoy.io)</0><1/><1/>Il token JWT assomiglia a: <2>eyJhbG...</2><1/><1/>"},"actions":{"login":"Login"},"errors":{"setup_failed":"Setup non riuscito","missing_token":"JWT mancante, impossibile effettuare il login.","invalid_token":"passato JWT non valido"}},"btcpay":{"title":"BTCPay Server","page":{"title":"Connettiti al tuo nodo LND BTCPay","instructions":"Vai al tuo BTCPayServer e accedi come amministratore. Vai su Impostazioni server > Servizi > LND Rest - See information. Quindi fai clic su \\"Visualizza informazioni sul codice QR\\" e copia i dati del codice QR. Incollali qui sotto:"},"config":{"label":"Dati di configurazione","placeholder":"config=https://your-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Connessione fallita. L\'URL di connessione a BTCPay  corretto e accessibile?"}},"kollider":{"description":"Accedi al tuo account Kollider","username":{"label":"Inserisci il tuo username Kollider"},"currency":{"label":"Seleziona la valuta del tuo account"},"errors":{"connection_failed":"Connessione fallita. Sei sicuro che i dati dell\'account siano corretti?"},"title":"Kollider"},"commando":{"port":{"label":"Porta"},"proxy":{"label":"Websocket proxy"},"rune":{"label":"Rune"},"privKey":{"label":"Chiave privata locale (autogenerata)"},"title":"Core Lightning","page":{"title":"Connettiti al tuo nodo Core Lightning","instructions":"Assicurati di avere la versione 0.12.0 o pi recente di Core Lightning, che il plugin commando sia in esecuzione e che il tuo nodo sia accessibile sulla rete Lightning. Crea una rune eseguendo \'lightning-cli commando-rune\'."},"host":{"label":"Host"},"pubkey":{"label":"Chiave pubblica"},"config":{"label":"Dati di configurazione","placeholder":"config=https://your-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Connessione fallita. Il tuo nodo Core Lightning  online e sta usando il plugin Commando?"}},"title":"Connetti il Wallet Lightning","lnc":{"page":{"description":"Crea una nuova sessione nel terminale (litd) per ottenere una nuova frase di accoppiamento ed inseriscila qui","title":"Connettiti al tuo nodo LND"},"pairing_phrase":{"label":"La tua frase di accoppiamento ","placeholder":"frase segreta di stack sats"},"title":"LND con LNC"}},"home":{"actions":{"send_satoshis":" Invia Satoshis ","enable_now":"Attiva ora"},"recent_transactions":"Transazioni recenti","allowance_view":{"recent_transactions":"Transazioni recenti","allowance":"Margine","sats_used":"sats utilizzati","no_transactions":"Non ci sono ancora transazioni su <0>{{name}}</0>."},"default_view":{"recent_transactions":"Transazioni recenti","is_blocked_hint":"Alby  attualmente disabilitato su {{host}}","block_removed":"{{host}} abilitato. Si prega di ricaricare la pagina."}},"accounts":{"title":"Accounts","actions":{"add_account":"Aggiungi account"},"account_view":{"nostr":{"errors":{"failed_to_load":"Impossibile caricare la chiave Nostr.  una chiave Nostr valida?"},"title":"Nostr","private_key":{"title":"Gestisci la tua chiave","success":"Chiave privata criptata & salvata con successo.","successfully_removed":"Chiave privata rimossa con successo.","subtitle":"Incolla la tua chiave privata o generane una nuova. Assicurati di fare un backup della vostra chiave privata prima di generarne una nuova. <0>Per saperne di pi </0>","warning":"In questo modo si eliminer la vecchia chiave privata. Sei sicuro?","label":"Chiave Privata"},"actions":{"generate":"Genera una nuova chiave"},"hint":" un protocollo semplice e aperto che mira a creare social network resistenti alla censura. Nostr funziona con chiavi crittografiche. Per pubblicare qualcosa si firma con la propria chiave e la si invia a pi rel.  possibile utilizzare Alby per gestire la propria chiave Nostr. Molte applicazioni Nostr vi permetteranno poi di utilizzare semplicemente la chiave dall\'estensione Alby.","generate_keys":{"screen_reader":"Genera una nuova chiave Nostr per il tuo account","hint":"Puoi generare una chiave casuale o una chiave derivata dai dati dell\'account (utilizzando una frase canonica firmata). <0>Per saperne di pi </0>","actions":{"random_keys":"Genera una chiave casuale","derived_keys":"Deriva una chiave dall\'account"},"title":"Genera una nuova chiave Nostr"},"public_key":{"label":"Chiave Pubblica"}},"remove":{"confirm":"Sei sicuro di voler rimuovere il tuo accout: {{name}}?\\nNon  possibile annullare questa operazione. Se hai usato questo account per accedere a siti web, potresti perderne l\'accesso.","title":"Rimuovi Questo Account","subtitle":"Tutte i permessi collegati saranno cancellati. Si prega di esserne certi."},"actions":{"export":"Esporta","remove_account":"Rimuovi account"},"export":{"your_ln_address":"Il Tuo Indirizzo Lightning:","waiting":"in attesa dei dati da LndHub...","export_uri":"URI delle credenziali di LNDHub","scan_qr":"Importa questo wallet su Zeus o BlueWallet scansionando il QRCode.","title":"Esporta Account","screen_reader":"Esporta i dettagli dell\'account"},"title1":"Informazioni account","title2":"Modifica Account","name":{"title":"Nome","placeholder":"Nome Account"}}},"enable":{"title":"Connettiti","allow":"Consenti a questo sito di:","request1":"Richiedi l\'approvazione per le transazioni","request2":"Richiedi fatture e informazioni lightning","block_and_ignore":"Blocca e ignora {{host}}","block_added":"{{host}} aggiunto alla blocklist, si prega di ricaricare la pagina."},"unlock":{"unlock_to_continue":"Sblocca per continuare","unlock_password":"La tua password di sblocco","help_contact":{"part1":"Hai bisogno di aiuto? Contatta","part2":"Supporto Alby"},"unlock_error":{"help":"I dati del tuo account sono criptati con la password di sblocco. Se hai dimenticato la password di sblocco, devi ripristinare e aggiungere di nuovo il tuo account Lightning.","link":"Reimposta ora e aggiungi un nuovo account"},"errors":{"invalid_password":"Password non valida"}},"settings":{"title":"Impostazioni","browser_notifications":{"title":"Notifiche del browser","subtitle":"Notifiche relative ai pagamenti e all\'autenticazione."},"website_enhancements":{"title":"Miglioramenti del sito web","subtitle":"Miglioramenti per le mance su Twitter, YouTube, ecc."},"lnurl_auth":{"title":"LNURL-Auth","hint":" un protocollo di autenticazione generico. Autentica l\'utente utilizzando le firme digitali. Il protocollo non richiede altre informazioni di identificazione come password, e-mail, nomi utente o simili. Con Alby  possibile utilizzare i propri account lightning per accedere in modo sicuro ai siti web. Per essere compatibili con altri portafogli abbiamo dovuto apportare alcune modifiche che si possono configurare qui. <0>Idealmente tutte queste opzioni dovrebbero essere spente (OFF).</0> Usatele solo se avete vecchi account.","legacy_lnurl_auth_202207":{"title":"Legacy LNURL-Auth","subtitle":"La generazione di chiavi per LNURL-auth  cambiata (Luglio 2022). Alby non era compatibile con altre implementazioni. Abbiamo apportate delle modifiche, ma ora vengono utilizzate chiavi di accesso diverse. Se prima si utilizzava LNURL-auth per il login, si pu ancora attivare il vecchio metodo. Questa opzione sar rimossa in futuro; assicurarati di passare al nuovo login."},"legacy_lnurl_auth":{"title":"Firma tradizione per LNDhub e LNbits","subtitle":"La firma dei messaggi e il login con gli account LNDhub (ad esempio BlueWallet) e LNbits sono stati modificati (Marzo 2022). Se avete effettuato l\'accesso con questi account, potete ancora attivare il vecchio metodo di firma. Questa opzione sar rimossa in futuro; assicurati di passare al nuovo metodo di login."}},"camera_access":{"title":"Accesso alla telecamera","subtitle":"Per la scansione di codici QR","allow":"Consenti l\'accesso alla fotocamera","granted":"Autorizzazione concessa"},"language":{"title":"Lingua","subtitle":"Le traduzioni non sono ancora state completate al 100%. <0>Aiutaci a tradurre Alby nella tua lingua!</0>"},"theme":{"title":"Tema","subtitle":"Usa Alby in modalit scura o chiara","options":{"dark":"Scuro","light":"Chiaro","system":"Sistema"}},"show_fiat":{"title":"Da Sats a Fiat","subtitle":"Convertire sempre nella valuta selezionata rispetto all\'exchange selezionato"},"currency":{"title":"Valuta","subtitle":"Mostra gli importi anche in questa valuta"},"exchange":{"title":"Origine dell\'Exchange","subtitle":"Fonte dei tassi di cambio bitcoin"},"personal_data":{"title":"Dati personali","description":"I beneficiari possono richiedere l\'invio di dati aggiuntivi insieme al pagamento. Questi dati non vengono condivisi con nessuno senza il tuo consenso che ti verr sempre richiesto prima che questi dati vengano inviati insieme ad un pagamento."},"name":{"title":"Nome","subtitle":"","placeholder":"Inserisci il tuo nome"},"email":{"title":"Email","subtitle":"","placeholder":"Inserisci il tuo indirizzo email"},"change_password":{"title":"Cambia password di sblocco","subtitle":"","screen_reader":"Cambia password di sblocco","choose_password":{"label":"Inserire una nuova password di sblocco:"},"confirm_password":{"label":"Conferma nuova password:"},"submit":{"label":"Modifica"},"errors":{"enter_password":"Inserisci una nuova password di sblocco.","confirm_password":"Confermare la password.","mismatched_password":"Le password non corrispondono."},"success":"La password  stata modificata con successo"},"nostr":{"title":"Nostr","hint":" un protocollo semplice e aperto che mira a creare reti sociali resistenti alla censura. Nostr funziona con chiavi crittografiche. Per pubblicare qualcosa si firma con la propria chiave e la si invia a pi rel.  possibile utilizzare Alby per gestire la propria chiave Nostr. Molte applicazioni Nostr vi permetteranno poi di utilizzare semplicemente la chiave dall\'estensione Alby.","private_key":{"title":"Chiave privata","subtitle":"Questa sezione  stata spostata nella pagina degli account, poich le chiavi ora sono specifiche per l\'account.","go_to":"Vai Agli Account"}}},"send":{"title":"Invia","input":{"label":"Destinatario","hint":"Fattura, indirizzo Lightning o LNURL"}},"lnurlpay":{"amount":{"label":"Importo"},"comment":{"label":"Commento"},"name":{"label":"Nome"},"email":{"label":"Email"},"success":"Successo, pagamento inviato!"},"lnurlauth":{"title":"Autenticazione","content_message":{"heading":"Vuoi accedere a"},"submit":"Accedi","success":"Accesso riuscito su {{name}}","errors":{"status":"Errore: lo stato di autenticazione non  ok"}},"lnurlchannel":{"title":"Richiesta canale","content_message":{"heading":"Richiedi un canale dal nodo"},"success":"Richiesta di canale inviata correttamente a {{name}}"},"lnurlwithdraw":{"title":"Ritiro","content_message":{"heading":"Importo"},"amount":{"label":"Importo"},"success":"Richiesta di prelievo di {{amount}} inviata con successo a {{sender}}"},"receive":{"title":"Ricevi","actions":{"create_invoice":"Crea fattura"},"amount":{"label":"Importo","placeholder":"Importo in Satoshi..."},"description":{"label":"Descrizione","placeholder":"Ad esempio, chi sta inviando questo pagamento?"},"success":"Pagamento ricevuto!","payment":{"waiting":"in attesa del pagamento...","status":"Controlla lo stato del pagamento"}},"publishers":{"publisher":{"allowance":{"title":"Margine","used_budget":"sats utilizzati"}},"title":"I tuoi Siti ","description":"Siti dove hai gi usato Alby","no_info":"Sembra che non hai ancora usato Alby in nessun sito.","discover":"Scopri i Siti"},"make_invoice":{"title":"Crea fattura","amount":{"label":"Importo (Satoshi)"},"memo":{"label":"Memo"},"errors":{"amount_too_small":"L\'importo  inferiore al minimo","amount_too_big":"L\'importo supera il massimo"}},"confirm_sign_message":{"title":"Firma","content":"Questo sito ti chiede di firmare:"},"confirm_keysend":{"title":"Approva il pagamento","success":"Pagamento inviato! Preimmagine: {{preimage}}","payment_summary":{"description":"Invia il pagamento a: {{destination}}"}},"keysend":{"title":"Invia","success":"Pagamento inviato! Preimmagine: {{preimage}}","receiver":{"label":"Invia pagamento a"},"amount":{"label":"Importo (Satoshi)"}},"confirm_payment":{"title":"Approva il pagamento","success":"Pagamento di {{amount}} andato a buon fine!","actions":{"pay_now":"Paga ora"}},"nostr":{"title":"Nostr","allow":"Consenti a questo sito di:","block_and_ignore":"Blocca e ignora {{host}}","block_added":"{{host}} aggiunto alla blocklist, si prega di ricaricare la pagina.","content":"Questo sito chiede di firmare:","allow_sign":"Consenti a {{host}} di firmare:"},"alby":{"pre_connect":{"set_password":{"choose_password":{"label":"Password"},"confirm_password":{"label":"Conferma password"},"errors":{"enter_password":"Inserisci una password.","confirm_password":"Si prega di confermare la password.","mismatched_password":"Le password non corrispondono."}}}},"choose_path":{"alby":{"title":"Alby","description":"Registrati o utilizza il tuo account Alby per iniziare a pagare attraverso lightning in pochissimo tempo."},"other":{"title":"Altri Wallet","description":"Collegati al tuo portafoglio o nodo Lightning e scegli tra vari connettori.","and_more":"& altro...","connect":"Connettiti"}},"confirm_request_permission":{"always_allow":"Ricorda la mia scelta e non chiederlo pi","title":"Approva Richiesta","allow":"Consentire l\'esecuzione di questo sito:"},"discover":{"list":{"trading":"Trading","gaming":"Gaming","entertainment":"Intrattenimento","miscellaneous":"Altro","showcases":"Vetrine","nostr":"Nostr","shopping":"Shopping"},"tips":{"description":"Qualche suggerimento per iniziare a ronzare ","top_up_wallet":{"title":" Ricarica il tuo wallet","description":"Crea una fattura lightning, inviati qualche bitcoin e inizia ad usare Alby nell\'ecosistema lightning"},"demo":{"title":" Prova la Demo di Alby","description":"Scopri tutto quello che puoi fare con Alby sul nostro sito demo"},"title":"Il tuo wallet Alby  pronto"},"title":"Esplora l\'Ecosistema Lightning ","description":"Siti e webapp dove puoi usare Alby"}},"y0":{"password":"Password","success":"Successo","error":"Errore","settings":"Impostazioni","connected_sites":"","loading":"caricamento","amount":"Importo","optional":"Facoltativo","feedback":"Valutazione","copied":"Copiato!","description":"Descrizione","description_full":"Descrizione completa","message":"Messaggio","help":"Aiuto","actions":{"back":"Indietro","delete":"Elimina","edit":"Modifica","next":"Avanti","open":"Aprire","cancel":"Annulla","confirm":"Conferma","continue":"Continua","connect":"Connettiti","lock":"Blocca","unlock":"Sblocca","send":"Invia","save":"Salva","receive":"Ricevi","close":"Chiudi","export":"Esporta","remove":"Rimuovi","copy":"Copia","copy_invoice":"","log_in":"Log in","remember":"Ricorda la mia scelta e non chiederlo pi","receive_again":"Ricevi un altro pagamento"},"errors":{"connection_failed":"Connessione fallita","payment_failed":"Pagamento fallito"},"response":"Risposta","sats_one":"sat","sats_other":"sats","success_message":"{{amount}}{{fiatAmount}} inviati a {{destination}}","accounts":"Account","discover":"Scopri","confirm_password":"Conferma la Password","advanced":"Avanzate"},"wx":{"allowance_menu":{"confirm_delete":"Sei sicuro di voler eliminare questo sito web?","hint":"Questo azzerer il budget corrente","new_budget":{"label":"Nuovo budget"},"enable_login":{"title":"Abilita l\'accesso al sito web","subtitle":"Accedi automaticamente senza conferma quando il sito web lo richiede."},"edit_allowance":{"title":"Modifica tolleranza","screen_reader":"Opzioni di tolleranza"},"edit_permissions":"Modifica Permessi"},"qrcode_scanner":{"title":"Scansiona il codice QR","actions":{"start_scanning":"Avvia la scansione","stop_scanning":"Interrompi la scansione"},"errors":{"allow_camera_access":"Si prega di consentire l\'accesso alla fotocamera nella schermata delle impostazioni."}},"transactionsTable":{"fee":"Tassa","preimage":"Preimmagine","received":"Ricevuto","sent":"Inviato","boostagram":{"sender":"Mittente","message":"Messaggio","app":"App","podcast":"Podcast"},"open_location":"Apri il sito"},"confirm_or_cancel":{"only_trusted":"Connettiti solo con siti attendibili."},"budget_control":{"remember":{"label":"Imposta e ricorda un budget","description":" possibile impostare un saldo per il quale, fino ad esaurimento, possono non essere richieste conferme di pagamento."},"budget":{"label":"Budget"}},"toasts":{"connection_error":{"what_you_can_do":"Ecco cosa puoi fare:","double_check":"Ricontrolla i dettagli della tua connessione","if_ssl_errors":"e se ci sono errori SSL (ad esempio ERR_CERT_AUTHORITY_INVALID), clicca su \\"avanzato\\" e procedi all\'accettazione del certificato.","visit_guides":"Visita le nostre guide per ulteriore assistenza"},"login_failed":{"password_reset":"Hai dimenticato la password? Clicca qui"},"errors":{"invalid_credentials":"Password non valida. Controlla la password e l\'indirizzo e-mail e riprova."}},"account_menu":{"screen_reader":"Attiva/disattiva menu a tendina","title":"Cambia account","options":{"account":{"add":"Aggiungi un nuovo account","manage":"Gestisci gli account"}}},"publishers_table":{"payments":"pagamenti","used":"usati"},"badge":{"label":{"active":"ATTIVO","auth":"LOGIN"}}},"mk":{"commando":{"fundchannel":"Apri un canale di pagamento con un peer effettuando una transazione di invio fondi.","decodepay":"Controlla e analizza una stringa bolt11.","listpeers":"Elenca i nodi che sono connessi o hanno canali aperti con questo nodo.","getroute":"Trova il percorso migliore per il pagamento a un nodo lightning.","getinfo":"Ottieni il riepilogo del nodo.","listforwards":"Elenca tutti gli htlc di cui si  tentato l\'inoltro.","disconnect":"Chiudi una connessione esistente con un peer.","feerates":"Restituisci le feerate che CLN utilizzer.","invoice":"Crea l\'aspettativa di un pagamento.","listfunds":"Elenca tutti i fondi disponibili.","listinvoices":"Ottieni lo stato di tutte le fatture.","listnodes":"Elenca i nodi di cui il nodo  venuto a conoscenza tramite i messaggi gossip.","listsendpays":"Visualizza lo stato di tutti i comandi sendpay.","listtransactions":"Elenca le transazioni tracciate nel wallet.","keysend":"Invia un pagamento a un altro nodo.","listoffers":"Elenca tutte le offerte o ottieni un\'offerta specifica.","listpays":"Visualizza lo stato di tutti i comandi di pagamento.","multifundchannel":"Apri canali di pagamento multipli con i nodi effettuando un\'unica transazione di invio fondi.","offer":"Crea un\'offerta.","pay":"Invia un pagamento a una fattura BOLT11.","sendpay":"Inviare un pagamento attraverso un percorso.","setchannel":"Configura le commissioni / il range di htlc richiesto per un canale.","signmessage":"Crea una firma da questo nodo.","connect":"Stabilisci una nuova connessione con un altro nodo.","decode":"Decodifica una stringa bolt11/bolt12/rune.","bkpr-listbalances":"Elenco di tutti i saldi correnti e storici dell\'account.","checkmessage":"Verifica che la firma sia stata generata da un determinato nodo."},"lnd":{"lookupinvoice":"Visualizza i dettagli della fattura.","decodepayreq":"Decodifica una stringa di richiesta di pagamento.","routermc":"Leggi lo stato di controllo interno della missione.","estimatefee":"Stima il tasso di commissione e le commissioni totali per una transazione.","queryroutes":"Interroga per una possibile rotta.","connectpeer":"Stabilisci una connessione ad un peer remoto.","disconnectpeer":"Disconnetti da un peer remoto.","listpeers":"Otteni un elenco di tutti i peer attualmente attivi.","verifymessage":"Verifica una firma di un messaggio.","addinvoice":"Crea nuove fatture.","openchannel":"Apri un nuovo canale.","getnodeinfo":"Ottieni le informazioni del canale per un nodo.","sendtoroute":"Effettua un pagamento attraverso la rotta specificata.","walletbalance":"Ottieni il totale degli output non spesi del wallet.","getchaninfo":"Ottieni l\'annuncio di rete per il dato canale.","getnetworkinfo":"Ottieni le statistiche di base riguardo il tracciato del canale conosciuto.","gettransactions":"Ottieni un elenco di tutte le transazioni rilevanti per il wallet.","listpayments":"Ottieni un elenco di tutti i pagamenti in uscita.","getinfo":"Ottieni le informazioni del nodo.","listchannels":"Ottieni una descrizione di tutti i canali aperti.","listinvoices":"Ottieni un elenco di tutte le fatture.","channelbalance":"Ottieni un report sui fondi totali in tutti i canali aperti."},"lnc":{"listchannels":"Otteni una descrizione di tutti i canali aperti.","getinfo":"Ottieni le informazioni sul nodo.","listinvoices":"Ottieni un elenco di tutte le fatture.","queryroutes":"Interroga per una possibile rotta.","listpeers":"Otteni un elenco di tutti i peer attualmente attivi.","routermc":"Leggi lo stato di controllo interno della missione.","connectpeer":"Stabilisci una connessione ad un peer remoto.","disconnectpeer":"Disconnetti da un peer remoto.","getchaninfo":"Ottieni l\'annuncio di rete per il dato canale.","channelbalance":"Ottieni un report sui fondi totali in tutti i canali aperti.","walletbalance":"Ottieni il totale degli output non spesi del wallet.","openchannel":"Apri un nuovo canale.","estimatefee":"Stima il tasso di commissione e le commissioni totali per una transazione.","lookupinvoice":"Visualizza i dettagli della fattura.","verifymessage":"Verifica una firma di un messaggio.","sendtoroute":"Effettua un pagamento attraverso la rotta specificata.","getnodeinfo":"Ottieni le informazioni del canale per un nodo.","gettransactions":"Ottieni un elenco di tutte le transazioni rilevanti per il wallet.","listpayments":"Ottieni un elenco di tutti i pagamenti in uscita.","decodepayreq":"Decodifica una stringa di richiesta di pagamento.","getnetworkinfo":"Ottieni le statistiche di base riguardo il tracciato del canale conosciuto.","addinvoice":"Crea nuove ricevute di pagamento."},"nostr":{"nip04decrypt":"Decripta i dati.","getpublickey":"Leggi la tua chiave pubblica.","nip04encrypt":"Cripta i dati.","signmessage":"Firma il messaggio con la tua chiave."}}}'); const wt = JSON.parse('{"xk":{"welcome":{"title":"Alby    ","set_password":{"title":"   ","description":"       .     .  alby      .","confirm_password":{"label":"        :"},"choose_password":{"label":" "},"errors":{"enter_password":"  .","confirm_password":"     - .","mismatched_password":"   ."}},"test_connection":{"ready":",     !","initializing":"    .   ,       ...","connection_error":"   ","review_connection_details":"     .","contact_support":"     support@getalby.com   ","connection_taking_long":"        ...     ?     ?   .","actions":{"delete_edit_account":"      "}}},"choose_path":{"alby":{"title":"Alby","description":"     ,       Alby  ."},"other":{"title":" ","description":"           .","and_more":"&  ...","connect":" "}},"alby":{"pre_connect":{"set_password":{"choose_password":{"label":""},"confirm_password":{"label":"   "},"errors":{"enter_password":"   .","confirm_password":"    .","mismatched_password":"  ."}}}},"choose_connector":{"title":"Connect Lightning Wallet","description":"       ","lnd":{"title":"LND","page":{"title":" LND   ","description":"   URL         (. .)"},"url":{"label":"REST API host and port","placeholder":"https://your-node-url:8080"},"macaroon":{"label":"Macaroon (HEX format)"},"drag_and_drop":" Macaroon     <0> browse</0>","errors":{"connection_failed":"  .  LND    ?"}},"lnc":{"title":"LND with LNC","page":{"title":" LND   ","description":"     (litd)           "},"pairing_phrase":{"label":"   ","placeholder":"   "}},"lndhub_bluewallet":{"title":"Bluewallet","page":{"title":"Connect to BlueWallet","description":",      ,  , \\"...\\"  , QR     /         ."},"uri":{"label":"BlueWallet Export URI"},"errors":{"invalid_uri":" BlueWallet URI","connection_failed":"  .   URI   ?"}},"lndhub_go":{"title":"LNDHub","page":{"title":"LNDHub   ","description":"          QR   ."},"uri":{"label":"LNDHub Export URI"},"errors":{"invalid_uri":" LNDHub URI","connection_failed":"  .  LNDHub URI   ?"}},"lnbits":{"title":"LNbits","page":{"title":"<0>LNbits</0>   ","instructions":"In LNbits, choose the wallet you want to connect, open it, click on API Info and copy the Admin Key. Paste it below:"},"admin_key":{"label":"LNbits Admin Key","placeholder":"Your 32 digit admin key"},"url":{"label":"LNbits URL"},"errors":{"connection_failed":"Connection failed. Do you have the correct URL and Admin Key?"}},"eclair":{"title":"Eclair","page":{"title":"<0>Eclair</0>   ","instructions":"You need your Eclair URL and password."},"password":{"label":"Eclair Password"},"url":{"label":"Eclair URL","placeholder":"http://localhost:8080"}},"citadel":{"title":"Citadel","page":{"title":"<0>Citadel</0> node   ","instructions":"This currently doesn\'t work if 2FA is enabled."},"password":{"label":"Citadel Password"},"url":{"label":"Citadel URL","placeholder":"http://citadel.local"}},"umbrel":{"title":"Umbrel","page":{"title":"<0>Umbrel</0> node   ","instructions":"In your Umbrel dashboard go to <0>Connect Wallet</0>. Select <0>lndconnect REST</0> and copy the <0>lndconnect URL</0>. (Depending on your setup you can either use the local connection or the Tor connection.)"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://yournode:8080?..."}},"mynode":{"title":"myNode","page":{"title":"<0>myNode</0>   ","instructions":"On your myNode homepage click on the <0>Wallet</0> button for your <0>lightning</0> service.<1/> Now click on the <0>Pair Wallet</0> button under the <0>Status</0> tab. Enter your password when prompted.<1/> Select the dropdown menu and choose a pairing option. Depending on your setup you can either use the <0>lightning (REST + Local IP)</0> connection or the <0>lightning (REST + Tor)</0> connection."},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://yournode:8080?..."}},"start9":{"title":"Start9","page":{"title":"your <0>Embassy</0> node   ","instructions":"<0>Note:</0> Currently we only support LND but we will be adding c-lightning support in the future!<1/>On your Embassy dashboard click on the <0>Lightning Network Daemon</0> service.<1/>Select the <0>Properties</0> tab.<1/>Now copy the <0>LND Connect REST URL.</0>"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://yournode:8080?..."}},"raspiblitz":{"title":"RaspiBlitz","page":{"title":"your <0>RaspiBlitz</0> node   ","instructions1":"   :<1/> 1. <0>SSH</0>  <0>Raspiblitz</0><1/>2.  <0>     </0> <1/><0/>3. <0>Alby     </0><1/>4 .     <0></0> <1/><1/>  <0>REST API </0>  <0>.onion</0>         .","instructions2":"  (admin) <0>macaroon</0>  ."},"rest_api_host":{"label":"REST API host","placeholder":"your-node-onion-address:port"}},"bitcoin_beach":{"title":"Bitcoin Beach Wallet","page":{"title":"<0>Bitcoin Beach Wallet   </0>"}},"bitcoin_jungle":{"title":"Bitcoin Jungle Wallet","page":{"title":"<0>Bitcoin Jungle Wallet   </0>"}},"galoy":{"phone_number":{"label":"    "},"sms_code":{"label":" SMS    "},"token":{"label":"JWT token  ","info":"The {{label}} login     .    ,  <0>  (wallet.mainnet.galoy.io)</0><1/><1/>JWT      JWT   : < 2>eyJhbG...</2><1/><1/>"},"actions":{"login":"Login"},"errors":{"setup_failed":"Setup ","missing_token":"JWT         .","invalid_token":" JWT  "}},"kollider":{"title":"Kollider","description":" Kollider    ","username":{"label":" Kollider username  "},"currency":{"label":"   "},"errors":{"connection_failed":"  .        ?"}},"btcpay":{"title":"BTCPay Server","page":{"title":"BTCPay LND node   ","instructions":" BTCPayServer     admin    .   >  > LND REST   -  .  \\"QR   \\"     QR    .    :"},"config":{"label":"Config data","placeholder":"config=https://your-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"  . BTCPay  URL     ?"}},"commando":{"title":"Core Lightning","page":{"title":" Core Lightning node   ","instructions":"Make sure you have Core Lightning version 0.12.0 or newer, the commando plugin is running and your node is accessible over the lightning network. Create a rune by running \'lightning-cli commando-rune\'."},"host":{"label":"Host"},"pubkey":{"label":"Public key"},"rune":{"label":"Rune"},"port":{"label":"Port"},"proxy":{"label":"Websocket proxy"},"privKey":{"label":"Local private key (autogenerated)"},"config":{"label":"Config data","placeholder":"config=https://your-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"  .   Lightning node     commando plugin  ?"}}},"home":{"actions":{"send_satoshis":"  Satoshis  ","enable_now":"  "},"recent_transactions":" ","allowance_view":{"recent_transactions":" ","allowance":"","sats_used":"sats ","no_transactions":" <0>{{name}}</0>    ."},"default_view":{"recent_transactions":" ","is_blocked_hint":"Alby  {{host}}   ","block_removed":"{{host}}  .    ."}},"accounts":{"title":"Accounts","account_view":{"title1":" ","title2":"  ","name":{"title":"","placeholder":" "},"export":{"title":" ","screen_reader":"  ","waiting":"   ...","your_ln_address":" Lightning Address:","export_uri":"LNDHub Credentials URI","scan_qr":"     Zeus  BlueWallet  ."},"nostr":{"title":"Nostr","hint":"        -     .     .             .   Nostr    Alby  .   Nostr   Alby exntension   .","private_key":{"title":"Manage your key","subtitle":"Paste your private key or generate a new one. <0>Learn more </0>","warning":" key        :","success":"       .","failed_to_remove":"     ,       .","successfully_removed":" key  .","label":"Private Key"},"public_key":{"label":"Public Key"},"generate_keys":{"title":" Nostr   ","screen_reader":"   Nostr   ","hint":"             (    ). <0>   </0>"},"actions":{"generate":"   "},"errors":{"failed_to_load":"Nostr    .   Nostr key  ?"}},"remove":{"title":"Remove this account","subtitle":"     .   .","confirm":"        : {{name}}? \\n     .             ."},"actions":{"remove_account":" "}},"actions":{"add_account":" "}},"enable":{"title":"","allow":"   :","request1":"   ","request2":"  Lightning   ","block_and_ignore":"{{host}}      ","block_added":" {{}} ,    ."},"unlock":{"unlock_to_continue":"   ","unlock_password":"  ","help_contact":{"part1":"  ?  ","part2":"Alby "},"unlock_error":{"help":"        .          Lightning      .","link":"      "},"errors":{"invalid_password":" "}},"settings":{"title":"","browser_notifications":{"title":" ","subtitle":"    ."},"website_enhancements":{"title":" ","subtitle":"Twitter, YouTube, .   ."},"lnurl_auth":{"title":"LNURL-Auth","hint":"    .       .  , ,         . Alby            .               . <0>:     .</0>        .","legacy_lnurl_auth_202207":{"title":"Legacy LNURL-Auth","subtitle":"The key generation for LNURL-auth has changed (July 2022). Alby was not compatible with other implementations. This was changed, but now different login keys are used. If you used LNURL-auth to login before you can still enable the old method. This option will be removed later, make sure to switch to the new login."},"legacy_lnurl_auth":{"title":"Legacy signing for LNDhub and LNbits","subtitle":"Message signing and login with LNDhub (e.g. BlueWallet) and LNbits accounts has been changed (March 2022). If you logged in with these accounts you can still enable the old signing method. This option will be removed later, make sure to switch to the new login."}},"camera_access":{"title":"Camera access","subtitle":"QR   ","allow":"   ","granted":" "},"language":{"title":"","subtitle":" 100%    . <0>  Alby      !</0>"},"theme":{"title":"Theme","subtitle":"Use Alby in dark or light mode","options":{"dark":"","light":"","system":""}},"show_fiat":{"title":"Sats to Fiat","subtitle":"      "},"currency":{"title":"","subtitle":"    "},"exchange":{"title":" ","subtitle":"   "},"personal_data":{"title":" ","description":"       .         ,         ."},"name":{"title":"","subtitle":"","placeholder":"   "},"email":{"title":"","subtitle":"","placeholder":"    "},"change_password":{"title":"  ","subtitle":"","screen_reader":"  ","choose_password":{"label":"   :"},"confirm_password":{"label":"   :"},"submit":{"label":""},"errors":{"enter_password":"    .","confirm_password":"    .","mismatched_password":"  ."},"success":"  "},"nostr":{"title":"Nostr","hint":"-           . Nostr    .              .     Alby   Nostr .  Nostr Application  Alby     .","private_key":{"title":" ","subtitle":"           .","go_to":" "}}},"send":{"title":"Send","input":{"label":"","hint":", Lightning address  LNURL"}},"lnurlpay":{"amount":{"label":""},"comment":{"label":""},"name":{"label":""},"email":{"label":""},"success":"  !"},"lnurlauth":{"title":"Authentication","content_message":{"heading":"     "},"submit":" ","success":"{{name}}    ","errors":{"status":":    "}},"lnurlchannel":{"title":" ","content_message":{"heading":"   "},"success":"{{name}}     "},"lnurlwithdraw":{"title":" ","content_message":{"heading":""},"amount":{"label":""},"success":"{{sender}}  {{amount}}     "},"receive":{"title":" ","actions":{"create_invoice":"  "},"amount":{"label":"","placeholder":" ..."},"description":{"label":"","placeholder":".     ?"},"success":" !","payment":{"waiting":"   ...","status":"  "}},"discover":{"title":" Lightning  Ecosystem  ","description":"      Alby  ","list":{"trading":"","gaming":"","entertainment":"","shopping":"","miscellaneous":"","showcases":"","nostr":"Nostr"},"tips":{"title":" Alby wallet  ","description":"    ","top_up_wallet":{"title":"      ","description":"Lightning   ,   Bitcoin   Lightning  Alby   "},"demo":{"title":"    ","description":"    Alby     .  "}}},"publishers":{"title":"  ","description":"    Alby  ","no_info":"       Alby  .","discover":" ","publisher":{"allowance":{"title":"","used_budget":"sats "}}},"make_invoice":{"title":"  ","amount":{"label":" (Satoshi)"},"memo":{"label":"Memo"},"errors":{"amount_too_small":"    ","amount_too_big":"  "}},"confirm_sign_message":{"title":"Sign","content":"     :"},"confirm_keysend":{"title":"  ","success":" ! Preimage: {{preimage}}","payment_summary":{"description":" : {{destination}}"}},"keysend":{"title":"","success":" ! preimage: {{preimage}}","amount":{"label":" (Satoshi)"}},"confirm_payment":{"title":"  ","success":"{{amount}}   !"},"confirm_request_permission":{"title":"  ","allow":"     :","always_allow":"       "},"nostr":{"title":"Nostr","allow":"   :","content":"     :","allow_sign":"{{host}}     :","allow_sign_event":"{{host}}  {{kind}}     :","view_details":" ","hide_details":" ","no_content":"(  )","block_and_ignore":"{{host}}      ","block_added":" {{}} ,    .","kinds":{"0":"metadata","1":"  ","2":"  ","3":"","4":"   ","5":" ","7":"","8":"badge ","40":" ","41":" metadata","42":" ","43":"  ","44":"  ","1984":"","9734":"zap ","9735":"zap","10002":"relay  metadata","22242":" ","24133":"nostr ","30008":"profile ","30009":" ","30023":"  ","30078":"- ","unknown":"nostr event of kind {{kind}}"}},"transactions":{"title":"","list_empty":"    ."}},"y0":{"password":"","confirm_password":"  ","advanced":"","success":"","settings":"","accounts":"","discover":"","connected_sites":"","sats_one":"sat","sats_other":"sats","loading":"  ","amount":"","optional":"","feedback":"","copied":" !","description":"","description_full":" ","success_message":"{{amount}}{{fiatAmount}} {{destination}}  ","response":"","message":"","help":"","actions":{"back":"","delete":"","edit":" ","next":"","open":"","confirm":" ","continue":" ","connect":"","lock":"","unlock":"","send":"","save":" ","receive":" ","receive_again":"   ","close":" ","export":"","remove":" ","copy":"","copy_invoice":"","log_in":" ","remember":"       "},"errors":{"connection_failed":" ","payment_failed":" "},"range":{"between":"{{min}}  {{max}} ","lessThanOrEqual":" {{max}}","greaterOrEqual":" {{min}}"}},"wx":{"allowance_menu":{"confirm_delete":"        ?","hint":"    ","new_budget":{"label":" "},"enable_login":{"title":"   ","subtitle":"          ."},"edit_allowance":{"title":"  ","screen_reader":" "},"edit_permissions":"  "},"qrcode_scanner":{"title":"QR   ","actions":{"start_scanning":"  ","stop_scanning":" "},"errors":{"allow_camera_access":"      ."}},"transactionsTable":{"fee":"","preimage":"","received":"","sent":"","open_location":" "},"confirm_or_cancel":{"only_trusted":"      ."},"budget_control":{"remember":{"label":"     ","description":"             ."},"budget":{"label":""}},"companion_download_info":{"heading":" TOR    ?","download":" ","companion":{"title":" ","description":"  TOR    ."},"tor_native":{"title":"TOR (native)","description":"   TOR      ."}},"toasts":{"connection_error":{"what_you_can_do":"      :","double_check":"    ","if_ssl_errors":" SSL   (. ERR_CERT_AUTHORITY_INVALID), \\"\\"        .","visit_guides":"     "},"login_failed":{"password_reset":"  ?   "},"errors":{"invalid_credentials":" .            ."}},"account_menu":{"screen_reader":" ","title":" ","options":{"account":{"add":"  ","manage":"  "}}}},"mk":{"nostr":{"getpublickey":"   .","nip04encrypt":" Encrypt .","nip04decrypt":" Decrypt .","signmessage":"    ."},"commando":{"bkpr-listbalances":"      .","checkmessage":"        .","connect":"     .","decode":"bolt11/bolt12/rune   .","decodepay":"bolt11 string    .","disconnect":"     .","feerates":"CLN   fee rates  .","fundchannel":"       .","getinfo":"  .","getroute":"Lightning      .","invoice":"   .","keysend":"   .","listforwards":"     htlcs   .","listfunds":"    .","listinvoices":"   .","listnodes":"      .","listoffers":"       .","listpays":"    .","listpeers":"         .","listsendpays":"     .","listtransactions":"     .","multifundchannel":"        .","offer":"  .","pay":"BOLT11   .","sendpay":"  .","setchannel":"    / htlc   .","signmessage":"    ."},"lnd":{"getinfo":"  .","listchannels":"    .","listinvoices":"   .","channelbalance":"      .","walletbalance":"      .","openchannel":"  .","connectpeer":"    .","disconnectpeer":"   .","getchaninfo":"    .","getnetworkinfo":"     .","getnodeinfo":"   .","gettransactions":"     .","listpayments":"    .","listpeers":"      .","lookupinvoice":"  .","queryroutes":"  .","verifymessage":"   .","sendtoroute":"   .","decodepayreq":"    .","routermc":"    .","addinvoice":"   .","addholdinvoice":" HODL   .","settleinvoice":"   ."},"lnc":{"getchaninfo":"    .","getnetworkinfo":"     .","getnodeinfo":"   .","gettransactions":"     .","listpayments":"    .","listpeers":"      .","lookupinvoice":"  .","queryroutes":"  .","verifymessage":"   .","sendtoroute":"   .","decodepayreq":"Payment request string  .","routermc":"    .","addinvoice":"   .","addholdinvoice":" HODL   .","settleinvoice":"   ."}}}'); const _t = JSON.parse('{"xk":{"welcome":{"title":"Witaj w Alby","set_password":{"title":"Ustaw haso blokady","description":"To haso zabezpiecza Twj portfel i umoliwia dostp do rozszerzenia przegldarki. Nie mona go zresetowa i jest odrbne od hasa do Twojego konta Alby.","choose_password":{"label":"Wybierz haso blokady:"},"confirm_password":{"label":"Potwierdmy, e wpisano poprawnie:"},"errors":{"enter_password":"Prosz wprowadzi haso.","confirm_password":"Prosz potwierdzi haso.","mismatched_password":"Hasa si nie zgadzaj."}},"test_connection":{"ready":"wietnie, wszystko gotowe!","initializing":"Tworzenie Twojego konta. Poczekaj prosz, to moe zaj chwil...","connection_error":"Bd poczenia","review_connection_details":"Sprawd prosz dane do poczenia.","connection_taking_long":"Prba poczenia trwa duej ni oczekiwano... Czy dane do poczenia s poprawne? Czy Twj wze jest osigalny?","contact_support":"Jeli potrzebujesz pomocy, skontaktuj si z support@getalby.com","actions":{"delete_edit_account":"Skasuj niepoprawne konto i wyedytuj ponownie"}}},"choose_path":{"alby":{"title":"Konto Alby","description":"Zarejestruj si lub uyj istniejcego konta Alby aby zacz z patnociami lightning w mgnieniu oka."},"other":{"title":"Inne portfele","description":"Pocz si z Twoim istniejcym portfelem lightning lub wzem i wybierz dostpne integracje.","and_more":"i wicej...","connect":"Pocz"}},"alby":{"pre_connect":{"set_password":{"choose_password":{"label":"Haso"},"confirm_password":{"label":"Potwierd haso"},"errors":{"enter_password":"Prosz wprowadzi haso.","confirm_password":"Prosz potwierdzi haso.","mismatched_password":"Hasa si nie zgadzaj."}}}},"choose_connector":{"title":"Podcz portfel Lightning","description":"Podcz swj zewntrzny portfel lightning lub wze","lnd":{"title":"LND","page":{"title":"Podcz si do swojego wza LND","description":"Potrzebujesz adresu URL Twojego wza i tzw. macaroon z uprawnieniami do odczytu i wysyania (np. admin.macaroon)"},"url":{"label":"Serwer i port RESTowego API","placeholder":"https://url-twojego-wezla:8080"},"macaroon":{"label":"Macaroon (format heksadecymalny)"},"drag_and_drop":"Przecignij i upu Twj macaroon tutaj lub <0>znajd plik</0>","errors":{"connection_failed":"Poczenie nie powiodo si. Czy Twoje dane uwierzytelniajce s poprawne?"}},"lnc":{"title":"LND z LNC","page":{"title":"Podcz si do swojego wza LND","description":"Stwrz now sesj w terminalu (litd) aby uzyska now fraz parowania i wpisz j tutaj"},"pairing_phrase":{"label":"Twoja fraza parujca ","placeholder":"tajna fraza stosu satsw"}},"lndhub_bluewallet":{"title":"Bluewallet","page":{"title":"Podcz do BlueWallet","description":"W BlueWallet wybierz portfel do ktrego chcesz si podczy, otwcz go, kliknij na \\"...\\", kliknij na Eksport/Kopia zapasowa, aby wywietli kod QR i zeskanuj go kamerk."},"uri":{"label":"Adres URI eksportu z BlueWallet"},"errors":{"invalid_uri":"Niepoprawny adres URI BlueWallet","connection_failed":"Poczenie si nie powiodo. Czy Twj adres URI BlueWallet jest poprawny?"}},"lndhub_go":{"title":"LNDHub","page":{"title":"Podcz si do LNDHub","description":"Wprowad tutaj swj identyfikator URI LNDHub lub zeskanuj kod QR za pomoc kamery internetowej."},"uri":{"label":"Adres LNDHub"},"errors":{"invalid_uri":"Niepoprawny LNDHub URI","connection_failed":"Poczenie nieudane. Czy URI LNDHub jest prawidowy?"}},"lnbits":{"title":"LNbits","page":{"title":"Podcz do <0>LNbits</0>","instructions":"W LNbits, wybierz portfel, do ktrego chcesz si podczy, otwrz go, kliknij na API Info i skopiuj klucz administratora. Wklej go poniej:"},"admin_key":{"label":"Klucz administratora LNbits","placeholder":"Twj 32-cyfrowy klucz administratora"},"url":{"label":"Adres URL LNbits"},"errors":{"connection_failed":"Poczenie nieudane. Czy masz poprawny adres URL i klucz administratora?"}},"eclair":{"title":"Eclair","page":{"title":"Podcz do <0>Eclair</0>","instructions":"Potrzebujesz adresu URL i hasa Twojego Eclair."},"password":{"label":"Haso do Eclair"},"url":{"label":"Adres URL do Eclair","placeholder":"http://localhost:8080"}},"citadel":{"title":"Citadel","page":{"title":"Podcz do wza <0>Citadel</0>","instructions":"Ta funkcja nie dziaa jeli 2FA jest wczone."},"password":{"label":"Haso Citadel"},"url":{"label":"Adres URL Citadel","placeholder":"http://citadel.local"}},"umbrel":{"title":"Umbrel","page":{"title":"Podcz do wza <0>Umbrel</0>","instructions":"Na stronie gwnej Umbrel id do <0>Connect Wallet</0>. Wybierz <0>ldconnect REST</0> i skopiuj <0>lndconnect URL</0>. (W zalenoci od ustawie moesz wybra poaczenie lokalne albo przez Tor.)"},"rest_url":{"label":"Adres lndconnect REST","placeholder":"lndconnect://twojwezel:8080?..."}},"mynode":{"title":"myNode","page":{"title":"Podcz do <0>myNode</0>","instructions":"Na stronie gwnej myNode kliknij na przycisk <0>Wallet</0> swojej usugi <0>lightning</0>.<1/>Teraz kliknij na przycisk <0>Pair Wallet</0> w sekcji <0>Status</0>. Wprowad haso.<1/> Wybierz z rozwijalnej listy opcj parowania. W zalenoci od ustawie moesz uy poczenia <0>lightning (REST + Local IP)</0> albo <0>lightning (REST + Tor)</0>."},"rest_url":{"label":"Adres lndconnect REST","placeholder":"lndconnect://twojwezel:8080?..."}},"start9":{"title":"Start9","page":{"title":"Podcz do wza <0>Embassy</0>","instructions":"<0>Uwaga:</0>Obecnie wspieramy tylko LND, ale zamierzamy doda obsug c-lightning w przyszoci!<1/>Na pulpicie twojego Embassy kliknij na usug <0>Lightning Network Daemon</0>.<1/>Wybierz zakadk <0>Properties</0>.<1/>Nastpnie skopiuj <0>LND Connect REST URL.</0>"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://twojnode:8080?..."}},"raspiblitz":{"title":"RaspiBlitz","page":{"title":"Podcz do wza <0>RaspiBlitz</0>","instructions1":"Wykonaj te kroki:<1/> 1. Uywajc <0>SSH</0> zaloguj si do swojego <0>Raspiblitz</0><1/>2. Wybierz z listy <0>Connect Apps & Show Credentials</0><1/><0/>3. Wybierz <0>Connect Alby to this node</0><1/>4. Nacinij <0>OK</0> aby wywietli dane uwierzytelniajce<1/><1/>Skopiuj i wklej adres <0>REST API host</0> lub <0>.onion</0> aby poczy si przez Tor do pola tekstowego poniej.","instructions2":"Skopiuj (admin) <0>macaroon</0> w pole poniej."},"rest_api_host":{"label":"Adres serwera REST API","placeholder":"adres-onion-twojego-wezla:port"}},"bitcoin_beach":{"title":"Portfel Bitcoin Beach","page":{"title":"Podcz do <0>Bitcoin Beach Wallet</0>"}},"bitcoin_jungle":{"title":"Portfel Bitcoin Jungle","page":{"title":"Podcz do <0>Portfela Bitcoin Jungle</0>"}},"galoy":{"phone_number":{"label":"Wprowad numer telefonu"},"sms_code":{"label":"Wprowad pod weryfikujcy SMS"},"token":{"label":"Wprowad swj token JWT","info":"Logowanie do {{label}} jest w trakcie aktualizacji. Jeli jeste zaawansowanym uytkownikiem, pobierz swj token JWT logujc si przez <0>Portfel webowy (wallet.mainnet.galoy.io)</0><1/><1/>Token JWT wyglda tak: <2>eyJhbG...</2><1/><1/>"},"actions":{"login":"Zaloguj"},"errors":{"setup_failed":"Konfiguracja nie powioda si","missing_token":"Brakuje tokenu JWT, logowanie nieudane.","invalid_token":"podano nieprawidowy token JWT"}},"kollider":{"title":"Kollider","description":"Zaloguj si do swojego konta Kollider","username":{"label":"Wprowad nazw uytkownika Kollider"},"currency":{"label":"Wybierz walut swojego konta"},"errors":{"connection_failed":"Poczenie nieudane. Czy na pewno podane dane s poprawne?"}},"btcpay":{"title":"BTCPay Server","page":{"title":"Podcz do wza LND na BTCPayServer","instructions":"Przejd do BTCPayServer i zaloguj si jako administrator. Id do Server Settings > Services > NDS Rest - See information. Nastpni kliknij \\"See QR Code information\\" i skopiuj dane kodu QR. Wklej poniej:"},"config":{"label":"Date konfiguracyjne","placeholder":"config=https://twoj-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Poczenie nieudane. Czy adres BTCPay jest poprawny i osigalny?"}},"commando":{"title":"Core Lightning","page":{"title":"Podcz do Twojego wza Core Lightning","instructions":"Upewnij si, e masz Core Lightning w wersji 0.12.0 lub nowszej, e plugin commando dziaa, a Twj wze jest dostpny w sieci lightning. Stwrz run komend \'lightning-cli commando-rune\'."},"host":{"label":"Serwer"},"pubkey":{"label":"Klucz publiczny"},"rune":{"label":"Runa"},"port":{"label":"Port"},"proxy":{"label":"Proxy websocket"},"privKey":{"label":"Lokalny klucz prywatny (generowany automatycznie)"},"config":{"label":"Konfiguracja","placeholder":"config=https://twoj-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Poczenie nieudane. Czy Twj wze Core Lightning jest online i korzysta z wtyczki commando?"}}},"home":{"actions":{"send_satoshis":" Wylij Satoshi ","enable_now":"Wcz teraz"},"recent_transactions":"Ostatnie transakcje","allowance_view":{"recent_transactions":"Ostatnie transakcje","allowance":"Limity","sats_used":"wydanych satoshi","no_transactions":"Jeszcze nie ma transakcji na koncie <0>{{name}}</0>."},"default_view":{"recent_transactions":"Ostatnie transakcje","is_blocked_hint":"Alby jest obecnie wyczone na {{host}}","block_removed":"Wczono {{host}}. Odwie stron."}},"accounts":{"title":"Konta","account_view":{"title1":"Informacje o koncie","title2":"Edytuj konto","name":{"title":"Nazwa","placeholder":"Nazwa konta"},"export":{"title":"Eksport konta","screen_reader":"Eksportuj dane konta","waiting":"oczekiwanie na dane LndHub...","your_ln_address":"Twj adres Lightning:","export_uri":"Adres LNDHub","scan_qr":"Zaimportuj ten portfel do Zeusa lub BlueWallet skanujc kod QR."},"nostr":{"title":"Nostr","hint":"jest prostym i otwartym protokoem majcym na celu stworzenie sieci spoecznociowych opornych na cenzur. Nostr dziaa przy uyciu kluczy kryptograficznych. Aby co opublikowa podpisujesz to swoim kluczem i wysyasz do kilku przekanikw. Moesz uy Alby aby zarzdza swoim kluczem Nostr. Nastpnie, rne aplikacje umoliwi Ci uywanie klucze z rozszerzenia Alby.","private_key":{"title":"Zarzdzaj swoim kluczem","subtitle":"Wklej swj klucz prywatny lub wygeneruj nowy. <0>Dowiedz si wicej </o>","warning":"Podaj prosz nazw konta aby potwierdzi usunicie prywatnego klucza:","success":"Klucz prywatny zosta zaszyfrowany i zapisany.","successfully_removed":"Klucz prywatny usunity.","label":"Klucz prywatny","failed_to_remove":"Wprowadzona nazwa konta si nie zgadza, zosta odtworzony Twj stary klucz prywatny."},"public_key":{"label":"Klucz publiczny"},"generate_keys":{"title":"Wygeneruj nowy klucz Nostr","screen_reader":"Wygeneruj nowy klucz Nostr ze swojego konta","hint":"Moesz wygenerowa losowy klucz lub wyprowadzi go z danych tego konta (uywajc podpisanej frazy kanonicznej). <0>Dowiedz si wicej </0>","actions":{"random_keys":"Wygeneruj losowy klucz","derived_keys":"Wyprowad klucz z danych konta"}},"actions":{"generate":"Generuj nowy klucz"},"errors":{"failed_to_load":"Nie udao si wadowa klucza Nostr. Czy to poprawny klucz?"}},"remove":{"title":"Usu konto","subtitle":"Wszystkie powizane limity zostan usunite. Prosz si upewni.","confirm":"Na pewno usun konto: {{name}}? \\nNie mona tego cofn. Jeli tego konta uyto do logowania do innych stron, moesz straci do nich dostp."},"actions":{"remove_account":"Usu konto","export":"Eksport"}},"actions":{"add_account":"Dodaj konto"}},"enable":{"title":"Pocz","allow":"Pozwl tej stronie na:","request1":"Popro o zatwierdzenie transakcji","request2":"Popro o faktury i informacje o sieci Lightning","block_and_ignore":"Zablokuj i ignoruj {{host}}","block_added":"Dodano {{host}} do listy zablokowanych, odwie stron."},"unlock":{"unlock_to_continue":"Odblokuj aby kontynuowa","unlock_password":"Twoje haso blokady","help_contact":{"part1":"Potrzebujesz pomocy? Skontaktuj si ze","part2":"zespoem wsparcia Alby"},"unlock_error":{"help":"Dane Twojego konta s zaszyfrowane Twoim hasem blokady. Jeli naprawd zapomnisz haso, to musisz zrobi reset i doda swoje konto Lightning ponownie.","link":"Zrb reset i dodaj nowe konto"},"errors":{"invalid_password":"Nieprawidowe haso"}},"settings":{"title":"Ustawienia","browser_notifications":{"title":"Powiadomienia w przegldarce","subtitle":"Powiadomienia zwizane z patnociami i uwierzytelnianiem."},"website_enhancements":{"title":"Rozszerzenia na stronach","subtitle":"Rozszerzenia napiwkw na Twitterze, YouTube, etc."},"lnurl_auth":{"title":"LNURL-Auth","hint":"jest generycznym protokoem uwierzytelniania. Powiadcza tosamo uytkownika za pomoc podpisw cyfrowych. Protok nie wyamga adnych danych identyfikujcych takich jak hasa, emaile, nazwy uytkownika, itp. Za pomoc Alby moesz uywa swoich kont Lightning aby bezpiecznie logowa si na stronach internetowych. Aby zapewni kompatybilno z innymi portfelami musielimy zrobi kilka modyfikacji, ktre moesz skonfigurowa tutaj. <0>Najlepiej gdy te opcje s WYCZONE.</0> Uywaj ich tylko gdy masz stare konta.","legacy_lnurl_auth_202207":{"title":"Stary (Legacy) LNURL-Auth","subtitle":"Generowanie kluczy dla LNURL-auth zmienio si (w lipcu 2022 r.) Alby nie byo kompatybilne z innymi implementacjami. To si zmienio, ale teraz uywane s inne klucze logowania. Jeli uywano wczeniej LNURL-auth do logowania, moesz nadal uywa starej metody. Ta opcja pniej bdzie usunita, wic pamitaj by przej na nowy login."},"legacy_lnurl_auth":{"title":"Stare podpisywanie dla LNDhub i LNbits","subtitle":"Podpisywanie wiadomoci i logowanie z kontami LNDhub (np. BlueWallet) i LNbits zmienio si (w marcu 2022 r.) Jeli logowano si z tymi kontami moesz nadal wczy stary sposb podpisywania. Ta opcja pniej bdzie usunita, wic pamitaj by przej na nowy login."}},"camera_access":{"title":"Dostp do kamery","subtitle":"W celu skanowania kodw QR","allow":"Zezwl na dostp do kamery","granted":"Uprawnienie przyznane"},"language":{"title":"Jzyk","subtitle":"Tumaczenia nie s jeszcze gotowe w 100%. <0>Pom nam tumaczy Alby na Twj jzyk!</0>"},"theme":{"title":"Motyw graficzny","subtitle":"Uywaj Alby w trybie ciemnym lub jasnym","options":{"dark":"Ciemny","light":"Jasny","system":"Tak jak system"}},"show_fiat":{"title":"Sats na Fiat","subtitle":"Zawsze konwertuj kwot na wybran walut wg kursu z wybranego rda"},"currency":{"title":"Waluta","subtitle":"Poka kwoty dodatkowo w tej walucie"},"exchange":{"title":"rdo kursu wymiany","subtitle":"rdo kursw wymiany bitcoina"},"personal_data":{"title":"Dane osobowe","description":"Odbiorcy patnoci mog poprosi o dodatkowe dane, ktre zostan przesane wraz z patnoci. Te dane nie s udostpniane nikomu bez Twojej zgody - zawsze bdziesz uprzedzany przed przesaniem dodatkowych informacji wraz z patnoci."},"name":{"title":"Imi","subtitle":"","placeholder":"Wprowad swoje imi"},"email":{"title":"Email","subtitle":"","placeholder":"Wprowad swj email"},"change_password":{"title":"Zmie haso blokady","subtitle":"","screen_reader":"Zmie haso blokady","choose_password":{"label":"Wprowad nowe haso blokady:"},"confirm_password":{"label":"Potwierd nowe haso blokady:"},"submit":{"label":"Zmie"},"errors":{"enter_password":"Wprowad nowe haso blokady.","confirm_password":"Potwierd swoje haso.","mismatched_password":"Hasa si nie zgadzaj."},"success":"Haso zmienione pomylnie"},"nostr":{"title":"Nostr","hint":"jest prostym i otwartym protokoem majcym na celu stworzenie sieci spoecznociowych opornych na cenzur. Nostr dziaa przy uyciu kluczy kryptograficznych. Aby co opublikowa podpisujesz to swoim kluczem i wysyasz do kilku przekanikw. Moesz uy Alby aby zarzdza swoim kluczem Nostr. Nastpnie, rne aplikacje umoliwi Ci uywanie klucze z rozszerzenia Alby.","private_key":{"title":"Klucz prywatny","subtitle":"Ta sekcja zostaa przeniesiona do strony z kontami, poniewa klucze s teraz zwizane z konkretnymi kontami.","go_to":"Przejd do kont"}}},"send":{"title":"Wylij","input":{"label":"Odbiorca","hint":"Faktura, adres Lightning lub LNURL"}},"lnurlpay":{"amount":{"label":"Kwota"},"comment":{"label":"Komentarz"},"name":{"label":"Imi"},"email":{"label":"Email"},"success":"Sukces! Patno wysana!"},"lnurlauth":{"title":"Uwierzytelnianie","content_message":{"heading":"Czy chcesz si zalogowa do"},"submit":"Zaloguj","success":"Logowanie do {{name}} pomylne","errors":{"status":"Bd: Status autentykacji nie jest ok"}},"lnurlchannel":{"title":"Proba o kana","content_message":{"heading":"Popro o kana od wza"},"success":"Proba o kana pomylnie wysana do {{name}}"},"lnurlwithdraw":{"title":"Wypata","content_message":{"heading":"Kwota"},"amount":{"label":"Kwota"},"success":"Proba wypaty w kwocie {{amount}} pomylnie wysana do {{sender}}"},"receive":{"title":"Przyjmij","actions":{"create_invoice":"Stwrz faktur"},"amount":{"label":"Kwota","placeholder":"Kwota w Satoshi..."},"description":{"label":"Opis","placeholder":"np. kto wysya t patno?"},"success":"Patno otrzymana!","payment":{"waiting":"oczekiwanie na patno...","status":"Sprawd status patnoci"}},"discover":{"title":"Eksploruj ekosystem Lightning ","description":"Strony i aplikacje webowe, na ktrych moesz uywa Alby","list":{"trading":"Handel","gaming":"Gry","entertainment":"Rozrywka","shopping":"Zakupy","miscellaneous":"Rne","showcases":"Prezentowane","nostr":"Nostr"},"tips":{"title":"Twj portfel Alby jest gotowy","description":"Oto klika wskazwek na start ","top_up_wallet":{"title":" Doaduj swj portfel","description":"Stwrz faktur Lightning, wylij sobie troch bitcoinw i zacznij korzysta z Alby w ekosystemie Lightning"},"demo":{"title":" Sprbuj demonstracyjnej wersji Alby","description":"Odkryj wszystkie moliwoci, jakie daje Alby na naszej stronie demonstracyjnej"}}},"publishers":{"title":"Twoje strony ","description":"Strony, na ktrych uyto wczeniej Alby","no_info":"Wyglda na to, e nie uyto Alby jeszcze na adnej stronie.","discover":"Odkryj strony","publisher":{"allowance":{"title":"Limity","used_budget":"uyto sats"}}},"make_invoice":{"title":"Stwrz faktur","amount":{"label":"Kwota (Satoshi)"},"memo":{"label":"Notatka"},"errors":{"amount_too_small":"Kwota jest mniejsza ni minimalna","amount_too_big":"Kwota przewysza maksymaln"}},"confirm_sign_message":{"title":"Podpisz","content":"Ta strona prosi Ci aby podpisywa:"},"confirm_keysend":{"title":"Zatwierd patno","success":"Patno wysana! Obraz pierwotny (preimage): {{preimage}}","payment_summary":{"description":"Wylij patno do: {{destination}}"}},"keysend":{"title":"Wylij","success":"Patno wysana! Preimage: {{preimage}}","receiver":{"label":"Wylij patno do"},"amount":{"label":"Kwota (Satoshi)"}},"confirm_payment":{"title":"Zatwierd patno","success":"Patno w kwocie {{amount}} pomylna!","actions":{"pay_now":"Zapa teraz"}},"confirm_request_permission":{"title":"Zatwierd prob","allow":"Pozwl tej stronie na wykonanie:","always_allow":"Pamitaj mj wybr i wicej nie pytaj"},"nostr":{"title":"Nostr","allow":"Pozwl tej stronie na:","content":"Ta strona prosi Ci aby podpisywa:","allow_sign":"Pozwl {{host}} na podpisywanie:","block_and_ignore":"Zablokuj i ignoruj {{host}}","block_added":"Dodano {{host}} do listy zablokowanych, odwie stron.","hide_details":"Ukryj szczegy","no_content":"(brak treci)","kinds":{"0":"metadane","1":"krtka wiadomo tekstowa","2":"rekomendacja przekanika","3":"kontakty","4":"zaszyfrowane wiadomoci prywatne","5":"usunicie zdarzenia","7":"reakcja","8":"nadanie odznaki","40":"utworzenie kanau","41":"metadane kanau","42":"wiadomo kanau","43":"ukrycie wiadomoci w kanale","44":"ignorowanie uytkownika w kanale","1984":"zgoszenie","9734":"proba o zap","9735":"zap","10002":"metadane listy przekanikw","22242":"uwierzytelnienie klienta","24133":"poczenie nostr","30008":"odznaki profile","30009":"definicja odznaki","30023":"tre dugiego formatu","30078":"dane specyficzne dla aplikacji","unknown":"zdarzenia nostr typu {{kind}}"},"allow_sign_event":"Pozwl {{host}} na podpisywanie {{kind}}:","view_details":"Poka szczegy"},"transactions":{"title":"Transakcje","list_empty":"Brak dostpnych transakcji."}},"y0":{"password":"Haso","confirm_password":"Potwierd haso","advanced":"Zaawansowane","success":"Sukces","error":"Bd","settings":"Ustawienia","accounts":"Konta","discover":"Odkrywaj","connected_sites":"","sats_one":"sat","sats_other":"sats","loading":"adowanie","amount":"Kwota","optional":"Opcjonalne","feedback":"Opinia","copied":"Skopiowano!","description":"Opis","description_full":"Peny opis","success_message":"{{amount}}{{fiatAmount}} wysano do {{destination}}","response":"Odpowied","message":"Wiadomo","help":"Pomoc","actions":{"back":"Wstecz","delete":"Skasuj","edit":"Edytuj","next":"Dalej","open":"Otwrz","cancel":"Anuluj","confirm":"Potwierd","continue":"Kontynuuj","connect":"Pocz","lock":"Zablokuj","unlock":"Odblokuj","send":"Wylij","save":"Zapisz","receive":"Przyjmij","receive_again":"Przyjmij kolejn patno","close":"Zamknij","export":"Eksport","remove":"Usu","copy":"Kopiuj","copy_invoice":"","log_in":"Zaloguj","remember":"Pamitaj mj wybr i wicej nie pytaj","transactions":"Transakcje"},"errors":{"connection_failed":"Poaczenie nieudane","payment_failed":"Patno nie powioda si"},"range":{"between":"pomidzy {{min}} a {{max}}","lessThanOrEqual":" {{max}}","greaterOrEqual":" {{min}}"}},"wx":{"allowance_menu":{"confirm_delete":"Na pewno usun t stron?","hint":"W ten sposb usuniesz obecny budet","new_budget":{"label":"Nowy budet"},"enable_login":{"title":"Wcz logowanie na stronie","subtitle":"Automatycznie loguj si bez potwierdzenia gdy strona o to poprosi."},"edit_allowance":{"title":"Edytuj preferencje","screen_reader":"Opcje limitu"},"edit_permissions":"Edytuj uprawnienia"},"qrcode_scanner":{"title":"Skanuj kod QR","actions":{"start_scanning":"Zacznij skanowanie","stop_scanning":"Zakocz skanowanie"},"errors":{"allow_camera_access":"Prosz pozwoli na dostp do kamery w ekranie ustawie."}},"transactionsTable":{"fee":"Opata","preimage":"Obraz pierwotny (preimage)","received":"Otrzymano","sent":"Wysano","boostagram":{"sender":"Nadawca","message":"Wiadomo","app":"Aplikacja","podcast":"Podcast"},"open_location":"Otwrz stron"},"confirm_or_cancel":{"only_trusted":"cz si tylko ze stronami, ktrym ufasz."},"budget_control":{"remember":{"label":"Zapamitaj i ustaw budet","description":"Moesz ustawi limit, do ktrego nie bdzie wymagane potwierdzenie patnoci, a do wyczerpania si rodkw."},"budget":{"label":"Budet"}},"toasts":{"connection_error":{"what_you_can_do":"Oto co moesz zrobi:","double_check":"Sprawd szczegy swojego poczenia","if_ssl_errors":"a jeli s bdy SSL (np. ERR_CERT_AUTHORITY_INVALID), kliknij \\"zaawansowane\\" i zaakceptuj certyfikat.","visit_guides":"Aby uzyska wicej pomocy zobacz nasze przewodniki"},"login_failed":{"password_reset":"Nie pamitasz hasa? Kliknij tutaj"},"errors":{"invalid_credentials":"Haso niepoprawne. Sprawd swoje haso i adres email i sprbuj ponownie."}},"account_menu":{"screen_reader":"Przecznik rozwijany","title":"Zmie konto","options":{"account":{"add":"Dodaj nowe konto","manage":"Zarzdzaj kontami"}}},"publishers_table":{"payments":"patnoci","used":"uyto"},"badge":{"label":{"active":"AKTYWNA","auth":"LOGOWANIE"}},"companion_download_info":{"heading":"Jak chcesz si poczy do sieci TOR?","companion":{"description":"Lekka aplikacja, ktra czy Twoj przegldark z sieci TOR.","title":"Aplikacja towarzyszca"},"download":"Pobierz","tor_native":{"title":"TOR (natywny)","description":"Wybierz t opcj jeli Twoja przegldarka ju jest podczona do sieci TOR."}}},"mk":{"nostr":{"getpublickey":"Czytanie Twojego klucza publicznego.","nip04encrypt":"Szyfrowanie danych.","nip04decrypt":"Deszyfrowanie danych.","signmessage":"Podpisywanie wiadomoci Twoim kluczem."},"commando":{"bkpr-listbalances":"Listowanie wszystkich biecych i historycznych sald konta.","checkmessage":"Weryfikowanie, ze podpis zosta zoony przez dany wze.","connect":"Ustanowienie nowego poczenia z innym wzem.","decode":"Dekodowane cig bolt11/bolt12/runy.","decodepay":"Sprawdzanie i przetwarzanie cigu bolt11.","disconnect":"Zamykanie biecego poczenie z peerem.","feerates":"Zwracanie stawek opat jakich CLN bdzie uywa.","fundchannel":"Otwieranie kanau patnoci z peerem poprzez dokonywanie transakcji fundujcej.","getinfo":"Pobieranie podsumowania o wle.","getroute":"Odnajdowanie najlepszej trasy patnoci do wza lightning.","invoice":"Tworzenie oczekiwania patnoci.","keysend":"Wysania patnoci do innego wza.","listforwards":"Listowania wszystkich HTLC, ktre prbowano przekaza.","listfunds":"Listowania wszystkich dostpnych rodkw.","listinvoices":"Pobierania statusu wszystkich faktur.","listnodes":"Listowania wzw, o ktrych dany wze dowiedzia si za pomoc komunikatw gossip.","listoffers":"Listowania wszystkich ofert lub pobierania konkretnej oferty.","listpays":"Pobierania statusu wszystkich polece patnoci.","listpeers":"Listowania wzw, ktre s poczone lub maj otwarte kanay z tym wzem.","listsendpays":"Pobierania statusu wszystkich polece sendpay.","listtransactions":"Listowania transakcji ledzonych w portfelu.","multifundchannel":"Otwierania wielu kanaw patnoci z wzami poprzez dokonywania pojedynczej transakcji fundujcej.","offer":"Tworzenie oferty.","pay":"Wysyanie patnoci na faktur BOLT11.","sendpay":"Wysyanie patnoci poprzez tras.","setchannel":"Konfigurowanie opat / zakresw HTLC ogaszanych dla kanau.","signmessage":"Tworzenie podpisu z tego wza."},"lnd":{"getinfo":"Pobieranie informacji o wle.","listchannels":"Pobieranie opisw wszystkich otwartych kanaw.","listinvoices":"Pobieranie listy wszystkich faktur.","channelbalance":"Pobieranie raportu o rodkach we wszystkich otwartych kanaach.","walletbalance":"Pobieranie cznej wartoci niewydanych wyj portfela.","openchannel":"Otwieranie nowego kanau.","connectpeer":"Ustanawianie poczenia ze zdalnym peerem.","disconnectpeer":"Rozczania si ze zdalnym peerem.","estimatefee":"Szacowanie stawki opaty oraz opat cakowitych transakcji.","getchaninfo":"Uzyskiwanie ogosze sieci dla danego kanau.","getnetworkinfo":"Pobieranie podstawowych statystyk o grafie znanych kanaw.","getnodeinfo":"Pobieranie informacji o kanaach wza.","gettransactions":"Pobieranie listy wszystkich transakcji dotyczcych portfela.","listpayments":"Pobieranie listy wszystkich wychodzcych patnoci.","listpeers":"Pobieranie listy wszystkich aktywnych peerw.","lookupinvoice":"Uzyskiwanie szczegowych informacji o fakturach.","queryroutes":"Zapytanie o moliw tras.","verifymessage":"Weryfikowanie podpisu dla wiadomoci.","sendtoroute":"Dokonywanie patnoci poprzez podan tras.","decodepayreq":"Dekodowanie cigu dania patnoci.","routermc":"Odczytanie wewntrznego stanu mission control.","addinvoice":"Tworzenie nowych faktur.","addholdinvoice":"Tworzenie nowych faktur typu HODL.","settleinvoice":"Rozliczenie przyjtej faktury."},"lnc":{"getinfo":"Pobieranie informacji o wle.","listchannels":"Pobieranie opisw wszystkich otwartych kanaw.","listinvoices":"Pobieranie listy wszystkich faktur.","channelbalance":"Pobieranie raportu o rodkach we wszystkich otwartych kanaach.","walletbalance":"Pobieranie cznej wartoci niewydanych wyj portfela.","openchannel":"Otwieranie nowego kanau.","connectpeer":"Ustanawianie poczenia ze zdalnym peerem.","disconnectpeer":"Rozczania si ze zdalnym peerem.","estimatefee":"Szacowanie stawki opaty oraz opat cakowitych transakcji.","getchaninfo":"Uzyskiwanie ogosze sieci dla danego kanau.","getnetworkinfo":"Pobieranie podstawowych statystyk o grafie znanych kanaw.","getnodeinfo":"Pobieranie informacji o kanaach wza.","gettransactions":"Pobieranie listy wszystkich transakcji dotyczcych portfela.","listpayments":"Pobieranie listy wszystkich wychodzcych patnoci.","listpeers":"Pobieranie listy wszystkich aktywnych peerw.","lookupinvoice":"Uzyskiwanie szczegowych informacji o fakturach.","queryroutes":"Zapytanie o moliw tras.","verifymessage":"Weryfikowanie podpisu dla wiadomoci.","sendtoroute":"Dokonywanie patnoci poprzez podan tras.","decodepayreq":"Dekodowanie cigu dania patnoci.","routermc":"Odczytanie wewntrznego stanu mission control.","addinvoice":"Tworzenie nowych faktur.","addholdinvoice":"Tworzenie nowych faktur typu HODL.","settleinvoice":"Rozliczenie przyjtej faktury."}}}'); const Et = JSON.parse('{"xk":{"welcome":{"set_password":{"title":"Definir uma senha de desbloqueio","description":"Essa senha  usada para proteger sua carteira e fornecer acesso  extenso do navegador neste dispositivo. No esquea essa senha pois no  possvel recuper-la. Obs. Essa senha  diferente da senha da conta da Alby e voc alter-la quando quiser.","choose_password":{"label":"Escolha uma senha de desbloqueio:"},"confirm_password":{"label":"Confirme se voc digitou corretamente:"},"errors":{"enter_password":"Insira uma senha.","confirm_password":"Confirme sua senha.","mismatched_password":"As senhas no correspondem."}},"test_connection":{"ready":"Perfeito, tudo configurado!","initializing":"Iniciando sua conta. Aguarde, pode demorar um pouco...","connection_error":"Erro de conexo","review_connection_details":"Revise os detalhes da conexo.","connection_taking_long":"A tentativa de conexo est demorando mais do que o esperado... Os dados esto corretos? O servidor est acessvel?","contact_support":"Se precisar de ajuda, entre em contato com support@getalby.com","actions":{"delete_edit_account":"Remover conta invlida e editar novamente"}},"title":"Bem-vindo  Alby","pin_extension":{"title":"Fixar extenso Alby","description":"Quase l. Para facilitar seu acesso a Alby , lembre-se de fixar a extenso Alby na barra de ferramentas do navegador:","explanation":"1. Clique em <0/> no canto superior direito do seu navegador<1/>2. Localize a Alby e clique no cone de fixao para fix-lo na barra de ferramentas do navegador<1/>3.  isso. Agora  s clicar no cone da Alby <2/>","next_btn":"Comece a usar a Alby {{icon}}"}},"choose_connector":{"description":"Escolha uma carteira ou servidor disponvel abaixo","lnd":{"title":"LND","page":{"title":"Conecte-se no servidor LND","description":"Voc precisa da URL do servidor e um macaroon com permisso de envio e leitura (ex. admin.macaroon)"},"url":{"label":"REST API host e porta","placeholder":"https://seu-servidor-url:8080"},"macaroon":{"label":"Macaroon (formato HEX)"},"drag_and_drop":"Arraste e solte o macaroon aqui ou clique em <0>procurar</0>","errors":{"connection_failed":"Falha na conexo. As credenciais LND esto corretas?"}},"lnbits":{"title":"LNbits","page":{"title":"Conecte-se na <0>LNbits</0>","instructions":"Na LNbits, escolha a carteira que voc deseja conectar, abra ela, clica em API Info a e copie a Chave Admin e cole abaixo:"},"admin_key":{"label":"Chave Admin LNbits","placeholder":"Sua chave admin de 32 dgitos"},"url":{"label":"URL LNbits"},"errors":{"connection_failed":"Falha na conexo. A URL e a chave Admin esto corretas?"}},"eclair":{"title":"Eclair","page":{"title":"Conecte-se no servidor <0>Eclair</0>","instructions":"Voc precisa da URL e senha da Eclair."},"url":{"label":"URL Eclair","placeholder":"http://localhost:8080"},"password":{"label":"Senha Eclair"}},"citadel":{"title":"Citadel","page":{"title":"Conecte-se no servidor <0>Citadel</0>","instructions":"No funciona se o 2FA estiver ativado."},"password":{"label":"Senha Citadel"},"url":{"label":"URL Citadel","placeholder":"http://citadel.local"}},"umbrel":{"title":"Umbrel","page":{"title":"Conecte-se no servidor <0>Umbrel</0>","instructions":"1. In your Lightning Node dashboard go to <0>Connect wallet</0><1/>2. Select <0>REST (Tor)</0> or <0>REST (Local Network)</0> mode<1/>3. Copy the <0>lndconnect URL</0> and paste it below"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://seuservidor:8080?..."}},"mynode":{"title":"myNode","page":{"title":"Conecte-se no servidor <0>myNode</0>","instructions":"No myNode clique em <0>Wallet</0> boto para seu servio <0>lightning</0>.<1/> Agora clique em <0>Pair Wallet</0> boto abaixo da tab <0>Status</0>. Insira sua senha quando solicitada.<1/> Selecione o menu suspenso e escolha uma opo de emparelhamento. Dependendo de sua configurao voc pode escolher <0>Conexo lightning (REST + Local IP)</0> ou conexo <0>lightning (REST + Tor)</0>."},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://seuservidor:8080?..."}},"start9":{"title":"Start9","page":{"title":"Conecte-se no seu servidor <0>Start9</0>","instructions":"<0>Note:</0> Atualmente somente a LND  suportada mas ns adicionaremos suporte para a c-lightning no futuro!<1/>No seu Embassy clique em service <0>Lightning Network Daemon</0>.<1/>Selecione a tab <0>Properties</0>.<1/>Agora copie o <0>LND Connect REST URL.</0>"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://seuservidor:8080?..."}},"raspiblitz":{"title":"RaspiBlitz","page":{"title":"Conecte-se seu servidor <0>RaspiBlitz</0>","instructions2":"Copie o (admin) <0>macaroon</0> no campo abaixo.","instructions1":"Siga esses passos<1/> 1. <0>SSH</0> na <0>Raspiblitz</0><1/>2. Selecione <0>Conectar apps & Mostrar credenciais</0> da lista<1/><0/>3. Escolher <0>Conectar Alby neste servidor</0><1/>4. Pressione <0>OK</0> para exibir as credenciais de conexo<1/><1/>Copie e cole o <0>REST API host</0> ou o <0>.onion</0> endereo para conectar -se atravs do TOR na entrada abaixo."},"rest_api_host":{"label":"REST API host","placeholder":"seu-endereo-servidor-onion:porta"}},"bitcoin_beach":{"title":"Carteira Bitcoin Beach","page":{"title":"Conecte-se na <0>Carteira Bitcoin Beach</0>"}},"bitcoin_jungle":{"title":"Carteira Bitcoin Jungle","page":{"title":"Conecte-se na <0>Carteira Bitcoin Jungle</0>"}},"btcpay":{"title":"Servidor BTCPay","page":{"title":"Conecte-se no servidor LND BTCPay","instructions":"Navegue at a BTCPayServer e acesse como administrador. V at Configuraes>Servios>LND Rest - Ver informao. Depois Clique \\"Ver Cdigo QR\\" e copie os dados do Cdigo QR. Cole os dados abaixo:"},"config":{"label":"Dados config","placeholder":"config=https://seu-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Falha na conexo. A URL de conexo do servidor BTCPay est correta e acessvel?"}},"galoy":{"phone_number":{"label":"Insira seu nmero de telefone"},"sms_code":{"label":"Insira o cdigo de verificao SMS"},"token":{"label":"Insira o token JWT"},"actions":{"login":"Login"},"errors":{"setup_failed":"Falha na configurao","missing_token":"JWT ausente, no foi possvel fazer login."}},"lndhub_bluewallet":{"title":"Bluewallet","page":{"title":"Conecte-se na BlueWallet","description":"Na BlueWallet, escolha a carteira que voc deseja conectar, abra ela, clique em \\"...\\", clique em Exportar/Backup para exibir o cdigo QR e leia o cdigo com sua webcam."},"uri":{"label":"Exportar URI BlueWallet"},"errors":{"invalid_uri":"URI BlueWallet invlida","connection_failed":"Falha na conexo. A URI BlueWallet est correta?"}},"lndhub_go":{"title":"LNDHub","page":{"title":"Conecte-se na LNDHub","description":"Insira sua credencial URI LNDHub aqui ou leia o cdigo QR com sua webcam."},"uri":{"label":"Exportar URI LNDHub"},"errors":{"invalid_uri":"URI LNDHub invlida","connection_failed":"Falha na conexo. A URI LNDHub est correta?"}},"commando":{"page":{"title":"Conecte-se no seu servidor Core Lightning","instructions":"Certifique-se de conectar em um servidor Core Lightning que esteja na verso 0.12.0 ou mais recente, o plugin commando instalado e rodando e o servidor acessvel na rede relmpago. Crie um rune executando o comando \'lightning-cli commando-rune\'."},"title":"Core Lightning","pubkey":{"label":"Chave pblica"},"rune":{"label":"Rune"},"port":{"label":"Porta"},"privKey":{"label":"Chave privada local (Gerada automaticamente)"},"config":{"label":"Dados config","placeholder":"config=https://seu-btc-pay.org/lnd-config/212121/lnd.config"},"proxy":{"label":"Websocket proxy"},"host":{"label":"Host"},"errors":{"connection_failed":"Falha na conexo. O servidor Core Lightning est online e usando o plugin comando?"}},"title":"Conectar Carteira Bitcoin","kollider":{"title":"Kollider","warning":" Certifique-se de armazenar suas credenciais com segurana em um gerenciador de senhas. Sem essas credenciais, no poderemos recuperar sua conta.","choose_path":{"create_new":"Criar conta Kollider","description":"Crie uma conta Kollider ou faa o login caso j possua uma conta.","title":"Conecte-se na sua carteira Kollider"},"create":{"title":"Crie sua conta na Kollider e conecte-se na Alby","description":"Crie uma nova conta Kollider para enviar, receber e negociar Bitcoin."},"login":{"title":"Conecte-se na sua conta Kollider"},"username":{"label":"Nome de usurio"},"errors":{"user_already_exists":"Esse nome de usurio j existe","connection_failed":"Falha na conexo. Voc tem certeza de que os dados da conta esto corretos?"},"currency":{"label":"Escolha a moeda da conta"}},"lnc":{"page":{"title":"Conecte-se no servidor LND usando LNC","description":"1. Open Lightning Terminal and choose <0>Lightning Node Connect</0> from the sidebar.<1/> 2. Click <0>Create a new session</0><1/>3. Label the session, choose desired permissions and submit<1/>4. <0>Copy pairing phrase</0> and paste it below."},"title":"Lightning Terminal (LNC)","pairing_phrase":{"label":"Frase de pareamento "}}},"home":{"actions":{"send_satoshis":" Enviar Satoshis ","enable_now":"Ativar"},"recent_transactions":"Transaes recentes","allowance_view":{"recent_transactions":"Transaes recentes","allowance":"Limite de gastos","sats_used":"sats usados","no_transactions":"Sem transaes em <0>{{name}}</0>."},"default_view":{"recent_transactions":"Transaes recentes","is_blocked_hint":"A Alby est desativada em {{host}}","block_removed":"{{host}} ativado. Por favor, recarregue o site.","no_outgoing_transactions":"Voc ainda no realizou transaes usando esta conta.","all_transactions_link":"Ver todas as transaes","no_incoming_transactions":"Voc ainda no recebeu transaes nesta conta."}},"accounts":{"title":"Minhas contas","actions":{"add_account":"Adicionar conta"},"account_view":{"export":{"title":"Exportar conta","your_ln_address":"Seu Endereo Relmpago:","screen_reader":"Exportar detalhes da conta","waiting":"aguardando dados LndHub...","export_uri":"Credenciais URI LNDHub","scan_qr":"Leia o cdigo QR para importar esta carteira na Zeus ou BlueWallet."},"nostr":{"title":"Nostr","private_key":{"title":"Gerenciar sua chave privada Nostr","successfully_removed":"Chave privada Nostr removida com sucesso.","label":"Chave privada Nostr","warning":"Digite o nome da conta para confirmar a excluso de sua chave privada Nostr:","subtitle":"Cole sua chave privada Nostr ou gere uma nova. <0>Saiba mais </0>","success":"Chave privada Nostr criptografada e salva com sucesso.","failed_to_remove":"O nome da conta inserido no est correto, sua chave privada Nostr antiga foi restaurada."},"public_key":{"label":"Chave pblica Nostr"},"hint":" um protocolo simples e aberto que visa criar redes sociais resistentes  censura. Os perfis na rede Nostr so chaves criptogrficas. Para publicar algo, voc assina com sua chave e a informao  enviada para servidores. Na Alby voc pode usar e gerenciar seu perfil em diferentes aplicaes que suportam esse recurso.","generate_keys":{"title":"Gerar uma nova chave Nostr","screen_reader":"Gere uma nova chave Nostr para sua conta","actions":{"random_keys":"Gerar uma chave aleatria","derived_keys":"Derivar uma chave da conta"},"hint":"Voc pode gerar uma chave aleatria ou uma chave derivada desta conta. <0>Saiba mais </0>"},"actions":{"generate":"Gerar uma nova chave"},"errors":{"failed_to_load":"Falha ao carregar a chave Nostr. Esta  uma chave Nostr vlida?"},"settings":{"label":"Configuraes Nostr","title":"Configuraes Nostr","derive":"Derive chaves Nostr de sua chave secreta","can_restore":" Chave Nostr derivada de sua chave secreta","description":"Derive chaves Nostr de sua chave secreta ou importe sua chave privada existente colando-a no campo \\"Chave privada Nostr\\".","no_secret_key":" Voc ainda no tem uma chave secreta. <0>Clique aqui</0></div> para criar sua chave secreta e derivar suas chaves nostr.","imported_key_warning":" No momento, voc est usando uma chave Nostr importada ou gerada aleatoriamente. Sua chave privada Nostr no pode ser restaurada por sua chave secreta, ento lembre-se de fazer o backup de sua chave privada Nostr."}},"remove":{"confirm":"Digite o nome da conta para confirmar a excluso.\\n\\n  Ao prosseguir com a excluso, todas as chaves associadas a esta conta (chave secreta, Nostr, etc) sero perdidas. Certifique-se de fazer o backup antes de continuar, caso precise restaurar a conta no futuro.","title":"Remover esta conta","error":"O nome da conta inserido no corresponde.","subtitle":"Remove todos os limites de gastos, dados de pagamento e chaves associados a esta conta."},"actions":{"remove_account":"Remover conta","export":"Exportar","remove_secretkey":"Remover chave secreta"},"name":{"title":"Nome","placeholder":"Nome da conta"},"title2":"Editar conta","title1":"Configuraes da conta","mnemonic":{"title":"Chave secreta","saved":"Chave secreta criptografada e salva com sucesso.","generate":{"title":"Gere sua chave secreta","button":"Gerar chave secreta","confirm":"Eu salvei minha chave secreta em um local privado e seguro","error_confirm":"Por favor, confirme que voc salvou sua chave secreta."},"backup":{"save":"Salvar chave secreta","button":"Fazer backup","protocols":{"nostr":"Nostr"},"title":"Backup de sua chave secreta","warning":" No se esquea de fazer o backup de sua chave secreta! No fazer o backup pode resultar na perda permanente do acesso  sua conta Nostr ou aos ativos que voc gerencia com esta chave."},"import":{"title":"Importar uma chave secreta","description":"Use uma chave secreta existente para recuperar suas chaves derivadas.","button":"Importar chave secreta"},"inputs":{"title":"Sua chave secreta"},"existing_nostr_key_notice":" Esta conta j possui uma chave privada nostr definida e no ser derivada desta chave secreta. Voc pode gerenciar sua chave nostr nas configuraes de sua conta.","lnurl":{"use_mnemonic":"Use a chave secreta para acessar aplicativos com tecnologia (LNURL Auth)","title":"Login Relmpago"}},"bitcoin":{"network":{"title":"Rede Bitcoin","options":{"bitcoin":"Rede principal","testnet":"Rede de testes","regtest":"Regtest"},"subtitle":"Escolha a rede para derivar endereos e decodificar transaes"}},"remove_secretkey":{"title":"Remover chave secreta","confirm":"Digite o nome da conta para confirmar a excluso de sua chave secreta.","success":"Chave secreta removida com sucesso.","subtitle":"Remove a chave secreta desta conta."}}},"enable":{"allow":"Permitir este site:","request1":"Solicitar aprovao para transaes","request2":"Gerar faturas e solicitar informaes do servidor","block_and_ignore":"Bloquear e ignorar {{host}}","title":"Conectar","block_added":"{{host}} adicionado na lista de bloqueio, por favor recarregue o site."},"unlock":{"unlock_to_continue":"Desbloqueie para continuar","unlock_password":"Sua senha de desbloqueio","help_contact":{"part1":"Precisa de ajuda?","part2":"Suporte Alby"},"unlock_error":{"help":"Os dados da sua conta so criptografados com sua senha de desbloqueio. Se voc realmente esqueceu sua senha de desbloqueio, ser necessrio redefinir e adicionar sua conta novamente.","link":"Redefinir e adicionar nova conta"},"errors":{"invalid_password":"Senha incorreta"}},"settings":{"title":"Configuraes","website_enhancements":{"title":"Pagamentos em redes sociais","subtitle":"Reconhece automaticamente Endereos Relmpago em perfis do Twitter, Youtube, etc, facilitando o envio de pagamentos."},"lnurl_auth":{"title":"LNURL-Auth","hint":" um protocolo de autenticao. Ele autentica o usurio usando assinaturas digitais. O protocolo no requer nenhuma outra informao de identificao, como senhas, e-mails, nomes de usurio... Com a Alby voc pode usar suas contas bitcoin para logar em sites com segurana. Para ser compatvel com outras carteiras, tivemos que fazer algumas alteraes que voc pode configurar aqui. Por padro essas opes esto DESLIGADAS. Use-as apenas se voc tiver contas antigas.","legacy_lnurl_auth_202207":{"title":"LNURL-Auth antigo","subtitle":"A gerao de chave para a LNURL-auth mudou em (julho de 2022). A Alby no era compatvel com outras implementaes. Isso foi corrigido, mas agora uma nova chave est sendo usada como padro. Se voc usou a LNURL-auth para logar em sites antes de julho de 2022, ainda poder fazer login habilitando o mtodo antigo. Esta opo ser removida posteriormente, certifique-se de alterar suas contas nos sites para usar o novo login."},"legacy_lnurl_auth":{"title":"Mtodo antigo de autenticao para LNDhub e LNbits","subtitle":"A assinatura de mensagens e o login com as contas LNDhub (por exemplo, BlueWallet) e LNbits foram alteradas em (maro de 2022). Se voc fez login com essas contas, ainda poder ativar o mtodo de assinatura antigo. Esta opo ser removida posteriormente, certifique-se de alterar suas contas nos sites para usar o novo login."}},"camera_access":{"title":"Acesso  cmera","subtitle":"Acesso para ler cdigos QR","allow":"Permitir acesso  cmera","granted":"Permisso concedida"},"language":{"title":"Idioma","subtitle":"As tradues ainda no esto 100% concludas. <0>Nos ajude a traduzir a Alby para o seu idioma!</0>"},"theme":{"title":"Tema","subtitle":"Use a Alby no modo escuro ou claro","options":{"dark":"Escuro","light":"Claro","system":"Sistema"}},"show_fiat":{"title":"Sats para Fiat","subtitle":"Exibe na Alby os valores em Sats e em uma moeda adicional de sua escolha"},"currency":{"title":"Moeda","subtitle":"Escolha a moeda adicional para exibir os valores na Alby"},"exchange":{"title":"Servio provedor de cotaes","subtitle":"Escolha o servio que fornecer as cotaes do bitcoin exibidas na Alby"},"personal_data":{"title":"Dados pessoais","description":"Alguns servios podem solicitar dados adicionais no pagamento. Esses dados no so compartilhados sem o seu consentimento e voc sempre ser informado com antecedncia sobre os dados a serem enviados."},"name":{"title":"Nome","subtitle":"","placeholder":"Insira seu nome"},"email":{"title":"E-mail","subtitle":"","placeholder":"Insira seu endereo de e-mail"},"change_password":{"title":"Alterar senha de desbloqueio","subtitle":"","screen_reader":"Alterar senha de desbloqueio","choose_password":{"label":"Insira uma nova senha de desbloqueio:"},"confirm_password":{"label":"Confirme a nova senha:"},"errors":{"enter_password":"Insira uma nova senha de desbloqueio.","mismatched_password":"As senhas no correspondem.","confirm_password":"Confirme a senha."},"submit":{"label":"Alterar"},"success":"Senha alterada com sucesso"},"browser_notifications":{"subtitle":"Exibe no navegador notificaes da Alby relacionadas a pagamentos e autenticao.","title":"Notificaes do navegador"},"nostr":{"title":"Nostr","private_key":{"subtitle":"Esta seo foi movida para a rea de contas, pois as chaves agora so especficas de cada conta.","title":"Chave privada","go_to":"Ir para contas"},"hint":" um protocolo simples e aberto que visa criar redes sociais resistentes  censura. Os perfis na rede Nostr so chaves criptogrficas. Para publicar algo, voc assina com sua chave e a informao  enviada para servidores. Na Alby voc pode usar e gerenciar seu perfil em diferentes aplicaes que suportam esse recurso."}},"send":{"title":"Enviar","input":{"label":"Destinatrio","hint":"Fatura, Endereo Relmpago ou LNURL"}},"lnurlpay":{"amount":{"label":"Quantia"},"comment":{"label":"Comentrio"},"name":{"label":"Nome"},"email":{"label":"E-mail"},"success":"Sucesso, pagamento enviado!"},"receive":{"title":"Receber","actions":{"create_invoice":"Gerar fatura","copy_lightning_address":"Copiar endereo relmpago"},"amount":{"label":"Quantia","placeholder":"Quantia em Satoshi..."},"description":{"label":"Descrio","placeholder":"Ex. Quem est enviando este pagamento?"},"success":"Pagamento recebido!","payment":{"waiting":"aguardando pagamento...","status":"Verificar status do pagamento"},"receive_via_bitcoin_address":"Receber via endereo bitcoin","redeem_lnurl":"Resgatar vale-satoshi"},"publishers":{"publisher":{"allowance":{"title":"Limite de gastos","used_budget":"sats usados"}},"title":"Sua lista de sites ","description":"Sites onde voc j usou a Alby","no_info":"Parece que voc ainda no usou a Alby em sites.","discover":"Descubra sites"},"make_invoice":{"title":"Gerar fatura","amount":{"label":"Quantia"},"memo":{"label":"Memo"},"errors":{"amount_too_small":"O valor  menor que o mnimo","amount_too_big":"O valor excede o mximo"}},"confirm_sign_message":{"title":"Assinar","content":"Este site solicita que voc assine:"},"confirm_keysend":{"title":"Aprovar pagamento","success":"Pagamento enviado! Pr-imagem: {{preimage}}","payment_summary":{"description":"Enviar pagamento para: {{destination}}"}},"confirm_payment":{"title":"Aprovar pagamento","success":"Pagamento de {{amount}} realizado com sucesso!","actions":{"pay_now":"Pague agora"}},"lnurlauth":{"content_message":{"heading":"Voc deseja logar em"},"success":"Login realizado com sucesso em {{name}}","errors":{"status":"Erro: O status de autenticao no est correto"},"submit":"Fazer login","title":"Autenticao"},"lnurlwithdraw":{"title":"Resgatar","content_message":{"heading":"Quantia"},"amount":{"label":"Quantia"},"success":"{{amount}} recebidos com sucesso de {{sender}}"},"lnurlchannel":{"success":"Solicitao de canal de pagamento enviada com sucesso para {{name}}","title":"Solicitar canal de pagamento","content_message":{"heading":"Solicitar canal de pagamento do servidor"}},"keysend":{"title":"Enviar","success":"Pagamento enviado! Pr-imagem: {{preimage}}","receiver":{"label":"Enviar pagamento para"},"amount":{"label":"Quantia (Satoshi)"}},"nostr":{"allow":"Permitir este site:","block_and_ignore":"Bloquear e ignorar {{host}}","title":"Nostr","content":"Este site solicita que voc assine:","block_added":"{{host}} adicionado na lista de bloqueio, por favor recarregue o site.","allow_sign":"Permitir {{host}} assinar:","view_details":"Ver detalhes","allow_sign_event":"Permitir {{host}} assinar {{kind}}:","hide_details":"Ocultar detalhes","kinds":{"0":"metadados","1":"nota de texto curta","3":"contatos","4":"mensagens diretas criptografadas","5":"excluso de evento","7":"reao","9735":"zap","unknown":"evento nostr do tipo {{kind}}"},"no_content":"(Sem contedo)"},"confirm_request_permission":{"title":"Aprovar solicitao","allow":"Permitir este site executar:","always_allow":"Lembrar minha escolha e no perguntar novamente"},"discover":{"title":"Explore o ecossistema ","description":"Sites onde voc pode usar a Alby","list":{"trading":"Negociao","gaming":"Jogos","entertainment":"Entretenimento","shopping":"Compras","miscellaneous":"Outros","nostr":"Nostr","nodeManagement":"Gerenciamento de servidor"},"tips":{"top_up_wallet":{"description":"Precisa adicionar fundos?\\nClique aqui!","title":"Comprar Bitcoin"},"demo":{"title":"Teste a Alby","description":"Descubra tudo o que voc pode fazer com a Alby\\nem nosso site de demonstrao"},"title":"Sua carteira Alby est pronta","description":"Algumas dicas para voc comear a usar a Alby ","mnemonic":{"description":"Planejando usar apps Nostr?\\nGere suas chaves agora.","title":"Nostr"}}},"choose_path":{"alby":{"description":"Crie uma conta Alby ou faa o login caso j possua uma conta conosco.","title":"Conta Alby","connect":"Conecte-se com a Alby"},"other":{"title":"Outras contas","and_more":"& mais...","description":"Conecte-se em sua carteira bitcoin ou em um dos vrios servidores de carteira disponveis.","connect":"Conectar"}},"alby":{"pre_connect":{"set_password":{"errors":{"enter_password":"Insira uma senha.","confirm_password":"Confirme sua senha.","mismatched_password":"As senhas no correspondem."},"confirm_password":{"label":"Confirmar senha"},"choose_password":{"label":"Senha"}}}},"transactions":{"title":"Transaes","description":{"outgoing":"Transaes enviadas usando esta conta","incoming":"Transaes recebidas nesta conta"},"list_empty":"Sem transaes."},"distributions":{"umbrel":{"name":"Umbrel"},"citadel":{"name":"Citadel"},"btcpay":{"name":"BTCPay"},"raspiblitz":{"name":"Raspiblitz"},"mynode":{"name":"myNode"},"start9":{"name":"Start9"},"description":"Escolha com qual aplicativo {{name}} voc gostaria de se conectar","title":"Conectar em {{name}}"},"confirm_add_account":{"content":"Este site deseja adicionar uma conta ({{connector}}):","title":"Adicionar conta","tor_info":"Para se conectar atravs da rede TOR, voc precisa primeiro instalar o aplicativo Alby companion:"},"on_chain":{"instructions1":"Para receber via endereo bitcoin, acesse sua <0>conta Alby</0> em getalby.com","go":"Ir para sua conta Alby na web ","title":"Receber via endereo bitcoin","instructions2":"Seu endereo bitcoin est na pgina <0>Receber</0>."},"confirm_get_address":{"title":"Obter endereo","heading":"Este site solicita ler:","content":"Seu endereo de recebimento Bitcoin"},"lnurlredeem":{"title":"Resgatar bitcoin","input":{"placeholder":"LNURL...","label":"Cdigo LNURL"},"actions":{"withdraw":"Resgatar"},"errors":{"invalid_withdraw_request":"Solicitao LNURL invlida","invalid_lnurl":"LNURL invlido"}},"scan_qrcode":{"title":"Aguardando leitura"}},"y0":{"password":"Senha","success":"Sucesso","error":"Erro","settings":"Configuraes","connected_sites":"Sites conectados","sats_one":"sat","sats_other":"sats","loading":"carregando","amount":"Quantia","optional":"Opcional","feedback":"Feedback","copied":"Copiado!","actions":{"delete":"Remover","edit":"Editar","next":"Prximo","open":"Abrir","cancel":"Cancelar","confirm":"Confirmar","continue":"Continuar","connect":"Conectar","lock":"Bloquear","unlock":"Desbloquear","send":"Enviar","save":"Salvar","receive":"Receber","close":"Fechar","export":"Exportar","remove":"Remover","copy":"Copiar","copy_invoice":"Copiar cdigo","back":"Voltar","log_in":"Fazer login","remember":"Lembrar minha escolha e no perguntar novamente","receive_again":"Receber outro pagamento","transactions":"Transaes","more":"Mais","import":"Importar","paste":"Colar","paste_clipboard":"Colar da rea de transferncia","download":"Baixar","copy_clipboard":"Copiar para rea de transferncia"},"errors":{"connection_failed":"Falha na conexo","payment_failed":"Pagamento falhou"},"description":"Descrio","description_full":"Descrio completa","message":"Mensagem","help":"Ajuda","response":"Resposta","success_message":"{{amount}}{{fiatAmount}} enviados para {{destination}}","advanced":"Avanado","discover":"Explorar","confirm_password":"Confirmar senha","accounts":"Minhas contas","range":{"between":"entre {{min}} e {{max}}","lessThanOrEqual":" {{max}}","greaterOrEqual":" {{min}}"},"balance":"Saldo disponvel","wallet":"Carteira","connectors":{"galoy":"Galoy","lndhub":"LNDHub","eclair":"Eclair","lnd":"LND","lnbits":"LNBits","nativelndhub":"LNDHub (usando Tor)","commando":"Commando","citadel":"Citadel","nativelnbits":"LNBits (usando Tor)","nativecitadel":"Citadel (usando Tor)","nativelnd":"LND (usando Tor)"},"pasted":"Colado!","or":"ou"},"wx":{"allowance_menu":{"confirm_delete":"Tem certeza de que deseja remover este site?","hint":"O limite atual ser redefinido","new_budget":{"label":"Novo limite"},"edit_allowance":{"title":"Editar preferncias","screen_reader":"Opes limite de gastos"},"enable_login":{"title":"Login Relmpago","subtitle":"O login  realizado de forma automtica, sem necessidade de confirmao."},"edit_permissions":"Permisses"},"qrcode_scanner":{"title":"Ler cdigo QR","actions":{"start_scanning":"Iniciar leitura","stop_scanning":"Parar leitura"},"errors":{"allow_camera_access":"Permita o acesso  cmera na tela configuraes."}},"transactionsTable":{"fee":"Taxa","preimage":"Pr-imagem","received":"Recebida","sent":"Enviada","boostagram":{"sender":"Enviado por","message":"Mensagem","app":"App","podcast":"Podcast"},"open_location":"Abrir link"},"confirm_or_cancel":{"only_trusted":"Conecte-se apenas nos sites em que voc confia."},"budget_control":{"remember":{"label":"Lembrar e definir um limite de gastos","description":"Voc pode definir um valor limite para pagamentos automticos (sem necessidade de confirmao)."},"budget":{"label":"Limite de gastos"}},"toasts":{"connection_error":{"what_you_can_do":"Aqui est o que voc pode fazer:","double_check":"Verifique novamente os detalhes de sua conexo","if_ssl_errors":"e se houver erros de SSL (por exemplo, ERR_CERT_AUTHORITY_INVALID), clique em \\"avanado\\" e prossiga para aceitar o certificado.","visit_guides":"Acesse nossos tutoriais para obter mais ajuda"},"login_failed":{"password_reset":"Esqueceu sua senha? Clique aqui"},"errors":{"invalid_credentials":"Senha incorreta. Verifique se sua senha e endereo de e-mail esto corretos e tente novamente."}},"account_menu":{"title":"Trocar conta","options":{"account":{"add":"Adicionar nova conta","manage":"Gerenciar contas","account_settings":"Configuraes da conta","go_to_web_wallet":"Acessar sua conta na web"}}},"publishers_table":{"payments":"pagamentos","used":"usados"},"badge":{"label":{"active":"LIMITE DE GASTOS","auth":"LOGIN RELMPAGO"}},"companion_download_info":{"tor_native":{"title":"TOR (nativo)","description":"Selecione esta opo se este navegador j estiver conectado  rede TOR."},"heading":"Como voc deseja se conectar  rede TOR?","download":"Baixar"},"transaction_list":{"tabs":{"outgoing":"Enviadas","incoming":"Recebidas"}}},"mk":{"nostr":{"getpublickey":"Ler sua chave pblica.","signmessage":"Assinar mensagem com sua chave.","nip04decrypt":"Descriptografar dados.","nip04encrypt":"Criptografar dados."},"lnc":{"openchannel":""}}}'); const kt = JSON.parse('{"xk":{"welcome":{"set_password":{"title":"Ange ett lsenord fr upplsning","description":"Detta lsenord lter dig lsa upp Alby p den hr enheten. Det kan inte terstllas, men kan ndras senare.","choose_password":{"label":"Vlj ett lsenord fr upplsning:"},"confirm_password":{"label":"Bekrfta att du skrivit in lsenordet korrekt:"},"errors":{"enter_password":"Skriv in ett lsenord.","confirm_password":"Bekrfta ditt lsenord.","mismatched_password":"Lsenorden verensstmmer inte."}},"test_connection":{"ready":"Fantastiskt, du r redo att brja!","initializing":"Initialiserar ditt konto. Vnta, det kan ta ngon minut...","connection_error":"Anslutningsfel","review_connection_details":"Se ver dina anslutningsinstllningar.","connection_taking_long":"Anslutningen tar lngre tid n frvntat... r instllningarna korrekta? r din nod nbar?","contact_support":"Om du behver hjlp, kontakta support@getalby.com","actions":{"delete_edit_account":"Radera ogiltigt konto och redigera igen"}},"title":"Vlkommen till Alby","pin_extension":{"title":"Fst din Alby extension","description":"Du r nstan dr. Fr att anvnda Alby bekvmt, kom ihg att fsta ditt tillgg till webblsarens verktygsflt:","explanation":"1. Klicka p <0/> i det vre hgra hrnet av din webblsare<1/>2. Hitta Alby och klicka fr att fsta den i verktygsfltet<1/>3. Det r allt. Fr att komma t Alby klickar du bara p ikonen <2/>","next_btn":"Brja surra {{icon}} med Alby"}},"choose_connector":{"description":"Anslut till din externa lightning-plnbok eller node","lnd":{"title":"LND","page":{"title":"Anslut din LND-nod","description":"Du behver URLen till din nod samt en macaroon med ls och skicka-rttigheter (t.ex. admin.macaroon)"},"url":{"label":"REST API vrd och port","placeholder":"https://your-node-url:8080"},"macaroon":{"label":"Macaroon (HEX-format)"},"drag_and_drop":"Drag och slpp din macaroon hr eller <0>blddra</0>","errors":{"connection_failed":"Koppling misslyckades. r dina LND-uppgifter korrekta?"}},"lndhub_bluewallet":{"title":"Bluewallet","page":{"title":"Anslut Bluewallet","description":"I Bluwallet, vlj den plnbok du vill koppla till, ppna den och klicka p \\"...\\", drefter Export/Backup fr att visa QR-koden och scanna den med webb-kameran."},"uri":{"label":"BlueWallet Export URI"},"errors":{"invalid_uri":"Ogiltig BlueWallet URI","connection_failed":"Anslutningen misslyckades. r din BlueWallet URI korrekt?"}},"lndhub_go":{"title":"LNDHub","page":{"title":"Koppla till LNDHub","description":"Fyll i dina LNDHub-uppgifter eller skanna QR-koden med din webbkamera."},"uri":{"label":"LNDHub Export URI"},"errors":{"invalid_uri":"Ogiltig LNDHub URI","connection_failed":"Koppling misslyckades. r din LNDHub URI korrekt?"}},"lnbits":{"title":"LNbits","page":{"title":"Anslut <0>LNbits</0>","instructions":"I LNBits, vlj den plnbok du vill ansluta, ppna den och klicka p API info och kopiera Admin-nyckeln. Klistra in nedan:"},"admin_key":{"label":"LNBits Admin-nyckel","placeholder":"Din 32-siffriga admin-nyckel"},"url":{"label":"LNbits URL"},"errors":{"connection_failed":"Anslutningen misslyckades. Har du korrekt URL och Admin-nyckel?"}},"eclair":{"title":"Eclair","page":{"title":"Anslut <0>Eclair</0>","instructions":"Du behver din Eclair URL och lsenord."},"password":{"label":"Eclair lsenord"},"url":{"label":"Eclair URL","placeholder":"http://localhost:8080"}},"citadel":{"title":"Citadel","page":{"title":"Anslut <0>Citadel</0>-nod","instructions":"Detta fungerar fr tillfllet inte om 2FA r aktiverat."},"password":{"label":"Citadel lsenord"},"url":{"label":"Citadel URL","placeholder":"http://citadel.local"}},"umbrel":{"title":"Umbrel","page":{"title":"Anslut <0>Umbrel</0>-nod","instructions":"1. G till <0>Anslut plnbok</0><1/>2 i din Lightning Node-instrumentpanel. Vlj lge <0>REST (Tor)</0> eller <0>REST (Lokalt ntverk)</0><1/>3. Kopiera <0>lndconnect URL</0> och klistra in den nedan"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://yournode:8080?..."}},"mynode":{"title":"myNode","page":{"title":"Anslut <0>myNode</0>","instructions":"P din myNode-hemsida, klicka p knappen <0>Wallet</0> som motsvarar din <0>Lightning</0>-tjnst. <1/> Klicka p knappen <0>Pair Wallet</0> under fliken <0>Status</0>. Fyll i ditt lsenord nr du blir tillfrgad.<1/> I droppmenym vlj kopplingsalternativ. Beroende p dina instllningar kan du antingen vlja <0>Lightning (REST + Local IP)</0> eller <0>Lightning (REST + Tor)</0>."},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://yournode:8080?..."}},"start9":{"title":"Start9","page":{"title":"Anslut till din <0>Start9 Server</0>","instructions":"P din Embassy instrumentpanel klickar du p tjnsten <0>Lightning Network Daemon</0>.<1/>Vlj fliken <0>Egenskaper</0>.<1/>Kopiera nu <0>LND Connect REST URL. </0>"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://yournode:8080?..."}},"raspiblitz":{"title":"RaspiBlitz","page":{"title":"Anslut din <0>RaspiBlitz</0>-nod","instructions1":"Flj dessa steg:<1/> 1. <0>SSH</0> till din <0>Raspiblitz</0><1/>2. Vlj <0>Anslut appar och visa inloggningsuppgifter</0> frn listan<1/><0/>3. Vlj <0>Anslut Alby till denna nod</0><1/>4. Tryck p <0>OK</0> fr att visa anslutningsuppgifterna<1/><1/>Kopiera och klistra in <0>REST API-vrden</0> eller <0>.onion</0>-adressen fr att ansluta genom Tor till ingngen nedan.","instructions2":"Kopiera (admin) <0>macaroon</0> till inmatningen nedan."},"rest_api_host":{"label":"REST API vrd","placeholder":"din-onion-nod-adress:port"}},"bitcoin_beach":{"title":"Bitcoin Beach plnbok","page":{"title":"Anslut <0>Bitcoin Beach Wallet</0>"}},"bitcoin_jungle":{"title":"Bitcoin Jungle Wallet","page":{"title":"Anslut en <0>Bitcoin Jungle Wallet</0>"}},"galoy":{"phone_number":{"label":"Fyll i ditt telefonnummer"},"sms_code":{"label":"Fyll i verifieringskoden du fick via SMS"},"token":{"label":"Fyll i din JWT-token","info":"Inloggning till {{label}} uppdateras. Om du r avancerad anvndare kan du hmta din JWT token genom att logga in via <0>Web Wallet (wallet.mainnet.galoy.io)</0><1/><1/> JWT ser ut som fljer: <2>eyJhbG...</2><1/><1/>"},"actions":{"login":"Logga in"},"errors":{"setup_failed":"Konfiguration misslyckades","missing_token":"JWT saknas, kunde inte logga in.","invalid_token":"ogiltig JWT godkndes"}},"btcpay":{"title":"BTCPay Server","page":{"title":"Anslut din BTCPay LND-nod","instructions":"Navigera till din BTCPayServer och logga in som administratr. G till Server Settings > Services > LND Rest - See information. Klicka p \\"See QR Code information\\" och kopiera QR-koddatan. Klistra in nedan:"},"config":{"label":"Konfigurationsdata","placeholder":"config=https://your-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Anslutning misslyckades. r URL till BTCPay-anslutningen korrekt och tillgnglig?"}},"kollider":{"title":"Kollider","currency":{"label":"Vlj ditt valutakonto"},"errors":{"connection_failed":"Anslutningen misslyckades. r du sker p att kontouppgifterna r korrekta?","user_already_exists":"Anvndarnamnet finns redan","registration_limit_exceeded":"Registreringsgrnsen har verskridits, frsk efter en stund."},"description":"Logga in p ditt Kollider-konto","username":{"label":"Anvndarnamn"},"warning":" Se till att du sparar dina uppgifter skert i en lsenordshanterare. Utan dessa inloggningsuppgifter kommer ditt konto inte att kunna terstllas.","choose_path":{"title":"Anslut till din Kollider Wallet","description":"Logga in eller registrera dig fr ett nytt Kollider-konto och anslut till Alby.","create_new":"Registrera"},"create":{"title":"Skapa ditt Kollider-konto och anslut till Alby","description":"Skapa ett nytt Kollider-konto fr att skicka, ta emot och handla Bitcoin."},"login":{"title":"Anslut till ditt Kollider-konto"}},"commando":{"port":{"label":"Port"},"title":"Core Lightning","proxy":{"label":"Websocket proxy"},"config":{"label":"Config data","placeholder":"config=https://your-btc-pay.org/lnd-config/212121/lnd.config"},"errors":{"connection_failed":"Anslutningen misslyckades. r din Core Lightning-nod online och anvnder kommandoplugin?"},"privKey":{"label":"Lokal privat nyckel (automatiskt genererad)"},"page":{"title":"Anslut till din Core Lightning node","instructions":"Skerstll att du har Core Lightning version 0.12.0 eller nyare, att kommando insticksprogrammet r aktivt samt att din node r nbar ver lightning-ntverket. Skapa en rune genom att kra \'lightning-cli commando-rune\'."},"pubkey":{"label":"Publik nyckel"},"rune":{"label":"Rune"},"host":{"label":"Hosta"}},"title":"Anslut Lightning Plnbok","lnc":{"pairing_phrase":{"placeholder":"hemlig stack sats fras","label":"Din parningsfras "},"title":"Lightning Terminal (LNC)","page":{"title":"Anslut till din LND node","description":"1. ppna Lightning Terminal och vlj <0>Lightning Node Connect</0> frn sidofltet.<1/> 2. Klicka p <0>Skapa en ny session</0><1/>3. Mrk sessionen, vlj nskade behrigheter och skicka in<1/>4. <0>Kopiera parningsfras</0> och klistra in den nedan."}},"umbrel_lightning_node":{"title":"Lightning Node"}},"home":{"actions":{"send_satoshis":" Skicka Satoshis ","enable_now":"Aktivera Nu"},"recent_transactions":"Senaste Transaktioner","allowance_view":{"recent_transactions":"Senaste Transaktioner","allowance":"Beloppsgrns","sats_used":"spenderade sats","no_transactions":"Inga transaktioner fr <0>{{name}}</0> nnu."},"default_view":{"recent_transactions":"Senaste Transaktioner","is_blocked_hint":"Alby r fr tillfllet avstngt hos {{host}}","block_removed":"Aktiverade {{host}}. Ladda om webbplatsen.","no_outgoing_transactions":"Inga utgende transaktioner fr detta konto nnu.","all_transactions_link":"Se alla transaktioner","no_incoming_transactions":"Inga inkommande transaktioner fr detta konto nnu."}},"accounts":{"title":"Konton","actions":{"add_account":"Lgg till konto"},"account_view":{"nostr":{"generate_keys":{"hint":"Du kan generera en slumpmssig nyckel eller f en nyckel frn denna kontoinformation (med en signerad kanonisk fras). <0>Ls mer </0>","screen_reader":"Skapa en ny Nostr-nyckel fr ditt konto","title":"Generera en ny Nostr nyckel","actions":{"random_keys":"Generera en slumpmssig nyckel","derived_keys":"F en nyckel frn kontot"}},"errors":{"failed_to_load":"Det gick inte att ladda Nostr-nyckeln. r det en giltig Nostr-nyckel?"},"private_key":{"title":"Hantera dina Nostr privata nyckel","successfully_removed":"Nostr privat nyckel har tagits bort.","label":"Nostr Privat Nyckel","warning":"Ange namnet p kontot fr att bekrfta raderingen av din nostr privata nyckel:","subtitle":"Klistra in din nostr privata nyckel eller skapa en ny. <0>Ls mer </0>","success":"Nostr privat nyckel krypterad och sparad.","failed_to_remove":"Det angivna kontonamnet matchade inte, din gamla Nostr privata nyckel har terstllts."},"public_key":{"label":"Nostr Publik Nyckel"},"actions":{"generate":"Generera en ny nyckel"},"title":"Nostr","hint":"r ett enkelt och ppet protokoll som syftar till att skapa ett censur beskyddat sociala ntverk. Nostr fungerar med kryptografiska nycklar. Fr att publicera ngot signerar du det med din nyckel och skickar det till flera reler. Du kan anvnda Alby fr att hantera din Nostr-nyckel. Mnga Nostr-applikationer lter dig d helt enkelt anvnda nyckeln frn Alby-tillgget.","settings":{"label":"Nostr Instllningar","title":"Nostr Instllningar","imported_key_warning":" Du anvnder fr nrvarande en importerad eller slumpmssigt genererad Nostr-nyckel. Din privata Nostr-nyckel kan inte terstllas av din hemliga nyckel, s kom ihg att skerhetskopiera din privata Nostr-nyckel.","derive":"F Nostr-nycklar frn din hemliga nyckel","can_restore":" Nostr-nyckel hmtad frn din hemliga nyckel","description":"Hmta Nostr-nycklar frn din hemliga nyckel eller importera din befintliga privata nyckel genom att klistra in den i fltet \\"Nostr privat nyckel\\".","no_secret_key":" Du har ingen hemlig nyckel n. <0>Klicka hr</0></div> fr att skapa din hemliga nyckel och hmta dina nostr-nycklar."}},"remove":{"title":"Ta bort detta konto","subtitle":"Tar bort alla traktamenten, betalningsdata och nycklar som r kopplade till detta konto.","confirm":"Ange namnet p kontot fr att bekrfta raderingen av ditt konto.\\n\\n  Alla associerade nycklar (hemlig nyckel, Nostr, etc) kommer att raderas om du fortstter. Se till att du har skerhetskopierat dem, det finns inget annat stt att terstlla dem.","error":"Det angivna kontonamnet matchade inte."},"title1":"Konto information","title2":"Redigera konto","name":{"title":"Visnings Namn","placeholder":"Konto visningsnamn"},"export":{"title":"Exportera konto","screen_reader":"Exportera konto detaljer","waiting":"vntar p LndHub-data...","your_ln_address":"Din Lightning Address:","export_uri":"LNDHub-inloggnings-URI","scan_qr":"Importera denna plnbok till Zeus eller BlueWallet genom att skanna QR-koden."},"actions":{"remove_account":"Ta bort kontot","export":"Exportera","remove_secretkey":"Ta bort hemlig nyckel"},"mnemonic":{"saved":"Hemlig nyckel krypterad och sparad framgngsrikt.","existing_nostr_key_notice":" Detta konto har redan en nostr privat nyckeluppsttning och kommer inte att hrledas frn denna hemliga nyckel. Du kan hantera din nostr-nyckel frn dina kontoinstllningar.","generate":{"title":"Generera din hemliga nyckel","button":"Generera hemlig nyckel","confirm":"Jag har skerhetskopierat mitt kontos hemliga nyckel p en privat och sker plats","error_confirm":"Bekrfta att du har skerhetskopierat din hemliga nyckel."},"backup":{"title":"Skerhetskopiera din hemliga nyckel","save":"Spara hemlig nyckel","button":"Skerhetskopiera hemlig nyckel","protocols":{"nostr":"Nostr"},"warning":" Glm inte att skerhetskopiera din hemliga nyckel! Att inte skerhetskopiera det kan resultera i att du permanent frlorar tkomst till din Nostr-identitet eller tillgngar som du hanterar med denna nyckel."},"import":{"title":"Importera en hemlig nyckel","description":"Anvnd en befintlig hemlig nyckel fr att terstlla dina hrledda nycklar.","button":"Importera hemlig nyckel"},"title":"Hemlig nyckel","inputs":{"title":"Din hemliga nyckel"},"lnurl":{"title":"Logga in med Lightning","use_mnemonic":"Anvnd hemlig nyckel fr att logga in i Lightning appar (LNURL Auth)"}},"bitcoin":{"network":{"title":"Bitcoin Ntverket","subtitle":"Vlj ntverk fr att hrleda adresser och avkoda transaktioner","options":{"bitcoin":"Mainnet","testnet":"Testnet","regtest":"Regtest"}}},"remove_secretkey":{"title":"Ta bort hemlig nyckel","subtitle":"Tar bort den hemliga nyckeln frn det hr kontot.","confirm":"Ange namnet p kontot fr att bekrfta raderingen av din hemliga nyckel.","success":"Den hemliga nyckeln har tagits bort."}}},"enable":{"title":"Anslut","allow":"Tillt den hr webbplatsen att:","request1":"Begr tilltelse fr transaktioner","request2":"Begr faktura och lightning-information","block_and_ignore":"Blockera och ignorera {{host}}","block_added":"Lade till {{host}} till blockeringslistan, ladda om webbplatsen."},"unlock":{"unlock_to_continue":"Ls upp fr att fortstta","unlock_password":"Ditt upplsningslsenord","help_contact":{"part1":"Behvver du hjlp? Kontakta","part2":"Alby Support"},"unlock_error":{"help":"Ditt konto r krypterat med ditt upplsningslsenord. Om du har glmt ditt upplsningslsenord behver du nollstlla och lgga till ditt Lightning-konto p nytt.","link":"Nollstll och skapa ett nytt konto"},"errors":{"invalid_password":"Ogiltigt lsenord"}},"settings":{"title":"Instllningar","browser_notifications":{"title":"Webblsarnotiser","subtitle":"Betalnings- och autentiseringsrelaterade notiser."},"website_enhancements":{"title":"Webbplatsfrbttringar","subtitle":"Dricks fr Twitter, YouTube, m.fl."},"lnurl_auth":{"title":"LNURL-Auth","hint":"r ett generiskt autentiseringsprotokoll. Detta autentiserar anvndarens digitala signaturer. Protokollet krver ingen ytterligare information ssom lsenord, e-post, anvndarnamn eller liknande. Med Alby kan du anvnd dina lightning-konton fr att logga in p webbplatser. Fr att vara kompatibla med andra plnbcker var vi tvungna att gra vissa frndringar som du kan konfigurera hr. <0>I bsta fall r alla instllningar AV.</0> Anvnd enbart om du har ldre konton.","legacy_lnurl_auth_202207":{"title":"ldre LNURL-Auth","subtitle":"Nyckelgenereringen fr LNURL-auth har ndrats (Juli 2022). Alby var inte kompatibelt med andra implementationer. Detta har ndrats och nu anvnds andra inloggningsnycklar. Om du tidigare anvnt LNURL-auth fr att logga in, kan du fortfarande aktivera denna metod. Denna mjlighet kommer frsvinna s se till att byta till det nya inloggningsfrfarandet."},"legacy_lnurl_auth":{"title":"ldre signeringsmetod fr LNDHub och LNbits","subtitle":"Meddelandesignering och inloggning med LNDhub (t.ex. BlueWallet) och LNbits-konton har ndrats (Mars 2022). Om du tidigare loggade in med dessa konton kan du fortfarande aktivera den ldre signeringsmetoden. Denna mjlighet kommer frsvinna s se till att byta till det nya inloggningsfrfarandet."}},"camera_access":{"title":"tkomst till kamera","subtitle":"Fr att skanna QR-koder","allow":"Tillt tkomst till kamera","granted":"tkomst beviljad"},"language":{"title":"Sprk","subtitle":"versttningarna r inte fullstndiga till 100%. <0>Hjlp oss att verstta Alby till ditt sprk!</0>"},"theme":{"title":"Tema","subtitle":"Anvnd Alby i mrkt eller ljust lge","options":{"dark":"Mrkt","light":"Ljust","system":"System"}},"show_fiat":{"title":"Sats till Fiat","subtitle":"Vxla alltid till denna valuta frn vald valutavxlare"},"currency":{"title":"Valuta","subtitle":"Visa belopp ven i denna valuta"},"exchange":{"title":"Klla fr vxlingskurs","subtitle":"Klla fr Bitcoin vxlingskurs"},"personal_data":{"title":"Personlig information","description":"Betalande kan be att f skicka ytterligare information tillsammans med en verfring. Denna information delas inte med ngon annan utan ditt samtycke. Du kommer alltid f frgan om denna information ska skickas tillsammmans med en verfring."},"name":{"title":"Namn","subtitle":"","placeholder":"Skriv ditt namn"},"email":{"title":"E-post","subtitle":"","placeholder":"Skriv in din e-postadress"},"change_password":{"title":"ndra upplsningslsenord","subtitle":"","screen_reader":"nda upplsningslsenord","choose_password":{"label":"Skriv in det nya upplsningslsenordet:"},"confirm_password":{"label":"Bekrfta nytt lsenord:"},"submit":{"label":"ndra"},"errors":{"enter_password":"Skriv in ett nytt upplsningslsenord.","confirm_password":"Bekrfta ditt lsenord.","mismatched_password":"Lsenorden verensstmmer inte."},"success":"Lsenordet har ndrats"},"nostr":{"title":"Nostr","hint":"r ett enkelt och ppet protokoll som syftar till att skapa sociala ntverk som r motstndskraftiga mot censur. Nostr anvnder kryptografiska nycklar. Fr att publicera ngot signerar du med dina nycklar som skickas till multipla reler. Du kan anvnda Alby fr att hantera din Nostr-nyckel. Flertalet Nostr-applikationer tillter dig att anvnda nyckeln med hjlp av Alby-tillgget.","private_key":{"title":"Privat nyckel","subtitle":"Det hr sektionen har flyttas till kontosidan eftersom nycklar r kontospecifika nu.","go_to":"G till Konton"}}},"send":{"title":"Skicka","input":{"label":"Mottagare","hint":"Faktura, Lightning-adress eller LNURL"}},"lnurlpay":{"amount":{"label":"Belopp"},"comment":{"label":"Kommentar"},"name":{"label":"Namn"},"email":{"label":"E-post"},"success":"Klart. Betalning skickad!"},"lnurlauth":{"title":"Autentisering","content_message":{"heading":"Vill du logga in till"},"submit":"Logga in","success":"Inloggad till {{name}}","errors":{"status":"Fel: Auth status r felaktig"}},"lnurlchannel":{"title":"Kanalbegran","content_message":{"heading":"Begr kanal frn nod"},"success":"Kanalbegran skickad till {{name}}"},"lnurlwithdraw":{"title":"terkalla","content_message":{"heading":"Belopp"},"amount":{"label":"Belopp"},"success":"terkallelse av begran om {{amount}} skickad till {{sender}}"},"receive":{"title":"Tag emot","actions":{"create_invoice":"Skapa Faktura","copy_lightning_address":"Kopiera Lightning adress"},"amount":{"label":"Belopp","placeholder":"Belopp i Satoshi..."},"description":{"label":"Beskrivning","placeholder":"T.ex. vem skickar denna betalning?"},"success":"Betalning mottagen!","payment":{"waiting":"vntar p betalning...","status":"Kontrollera betalningsstatus"},"receive_via_bitcoin_address":"Ta emot via bitcoin adress","redeem_lnurl":"Ls in LNURL"},"publishers":{"publisher":{"allowance":{"title":"Beloppsgrns","used_budget":"spenderade sats"}},"description":"Webbplatser dr du har anvnt Alby tidigare","discover":"Upptck webbplatser","no_info":"Det verkar som att du inte har anvnt Alby p ngra webbplatser n.","title":"Dina  webbsidor"},"make_invoice":{"title":"Skapa Faktura","amount":{"label":"Belopp (Satoshi)"},"memo":{"label":"PM"},"errors":{"amount_too_small":"Belopp understiger minimigrnsen","amount_too_big":"Belopp verstiger maximumgrnsen"}},"confirm_sign_message":{"title":"Signera","content":"Den hr webbplatsen ber dig att logga in:"},"confirm_keysend":{"title":"Godknn Betalning","success":"Betalning skickad! Frhandsvy: {{preimage}}","payment_summary":{"description":"Skicka betalning till: {{destination}}"}},"keysend":{"title":"Skicka","success":"Betalning skickad! Frhandsvy: {{preimage}}","receiver":{"label":"Skicka betalning till"},"amount":{"label":"Belopp (Satoshi)"}},"confirm_payment":{"title":"Godknn Betalning","success":"Betalning av {{amount}} genomfrd!","actions":{"pay_now":"Betala nu"}},"nostr":{"title":"Nostr","allow":"Tillt den hr webbplatsen att:","block_and_ignore":"Blockera och ignorera {{host}}","kinds":{"0":"metadata","1":"kort textanteckning","2":"rekommenderade rel","3":"kontakter","4":"krypterade direktmeddelanden","5":"radering av hndelse","7":"reaktion","8":"badge utmrkelse","40":"skapa kanal","41":"kanalens metadata","42":"kanal meddelande","43":"kanal gmda meddelande","44":"kanal tysta anvndare","1984":"anmla","9734":"zap frfrgan","9735":"zap","10002":"rel listans metadata","22242":"klient autentisering","24133":"nostr ansluta","30008":"profil badges","30009":"badge definition","30023":"lngformigt innehll","30078":"applikationsspecifika data","unknown":"nostr event av sort {{kind}}"},"view_details":"Visa detaljer","hide_details":"Gm detaljer","block_added":"Lade till {{host}} till blockeringslistan, ladda om webbplatsen.","allow_sign_event":"Tillt {{host}} att signera en {{kind}}:","no_content":"(Inget innehll)","allow_sign":"Tillt {{host}} att signera:","content":"Den hr webbplatsen ber dig att signera:"},"choose_path":{"alby":{"title":"Alby Konto","description":"Registrera dig eller anvnd ditt befintliga Alby-konto fr att komma igng med lightning betalningar p nolltid.","connect":"Anslut med Alby"},"other":{"title":"Annan Plnbok","connect":"Anslut","and_more":"& mer...","description":"Anslut till din befintliga lightning Plnbok eller Node och vlj frn olika kontakter."}},"alby":{"pre_connect":{"set_password":{"choose_password":{"label":"Lsenord"},"confirm_password":{"label":"Bekrfta Lsenord"},"errors":{"mismatched_password":"Lsenordet matchar inte.","enter_password":"Vnligen ange ett lsenord.","confirm_password":"Vnligen ange ditt lsenord."}}}},"discover":{"list":{"miscellaneous":"Diverse","gaming":"Spel","entertainment":"Underhllning","shopping":"Shoppa","showcases":"Vitriner","nostr":"Nostr","trading":"Handel","nodeManagement":"Nodhantering"},"tips":{"title":"Din Alby plnbok r redo","description":"Ngra tips fr att f igng dig\'","top_up_wallet":{"title":"Kp Bitcoin","description":"Behver du en pfyllning?\\nVi hjlper dig!"},"demo":{"title":"Alby Demo","description":"Upptck Albys funktioner\\np vr demowebbplats"},"mnemonic":{"title":"Nostr","description":"Planerar du att anvnda Nostr?\\nSkapa dina nycklar nu."}},"title":"Utforska Lightnings  Eco system","description":"Webbplatser och webbappar dr du kan anvnda Alby"},"confirm_request_permission":{"always_allow":"Kom ihg mitt val och frga inte igen","title":"Godknn begran","allow":"Tillt den hr webbplatsen att kra:"},"transactions":{"title":"Transaktion","list_empty":"Inga transaktioner tillgngliga nnu.","description":{"incoming":"Inkommande transaktioner fr detta konto","outgoing":"Utgende transaktioner fr detta konto"}},"distributions":{"title":"Anslut till {{namn}}","description":"Vlj vilket {{namn}} app du vill ansluta med","umbrel":{"name":"Umbrel"},"citadel":{"name":"Citadel"},"btcpay":{"name":"BTCPay"},"raspiblitz":{"name":"Raspiblitz"},"mynode":{"name":"myNode"},"start9":{"name":"Start9"}},"confirm_add_account":{"title":"Lgg till konto","content":"Den hr webbplatsen vill lgga till ett konto ({{connector}}):","tor_info":"Fr att kunna ansluta via TOR-ntverket mste du frst installera Alby kompanion appen:"},"on_chain":{"title":"Ta emot via bitcoin adress","instructions2":"Du hittar din bitcoin adress p <0>Ta emot</0> sidan.","go":"G till ditt Alby konto ","instructions1":"Fr att ta emot bitcoin via en bitcoin adress, logga in p ditt <0>Alby-konto</0> p getalby.com"},"confirm_get_address":{"title":"F adress","heading":"Den hr webbplatsen ber dig att lsa:","content":"Din Bitcoin-mottagningsadress"},"scan_qrcode":{"title":"Vntar p att skanna"},"lnurlredeem":{"input":{"placeholder":"LNURL...","label":"LNURL-uttagskod"},"errors":{"invalid_withdraw_request":"Ogiltig LNURL-utagningsbegran","invalid_lnurl":"Ogiltig LNURL"},"title":"Ls in bitcoin","actions":{"withdraw":"Ta ut"}}},"y0":{"password":"Lsenord","success":"Genomfrt","error":"Misslyckades","settings":"Instllningar","connected_sites":"Anslutna webbplatser","loading":"laddar","amount":"Belopp","optional":"Valfritt","feedback":"terkoppling","copied":"Kopierad!","description":"Beskrivning","description_full":"Fullstndig beskrivning","message":"Meddelande","help":"Hjlp","actions":{"back":"Tillbaka","delete":"Radera","edit":"Redigera","next":"Nsta","open":"ppna","cancel":"Avbryt","confirm":"Bekrfta","continue":"Fortstt","connect":"Anslut","lock":"Ls","unlock":"Ls upp","send":"Skicka","save":"Spara","receive":"Tag emot","close":"Stng","export":"Exportera","remove":"Tag bort","copy":"Kopiera","copy_invoice":"Kopiera faktura","transactions":"Transaktioner","receive_again":"Ta emot en ny betalning","remember":"Kom ihg mitt val och frga inte igen","log_in":"Logga in","more":"Mer","download":"Ladda ner","import":"Importera","copy_clipboard":"Kopiera till urklipp","paste":"Klistra in","paste_clipboard":"Klistra in frn urklipp"},"errors":{"connection_failed":"Anslutning misslyckades","payment_failed":"Betalning misslyckades"},"range":{"between":"mellan {{min}} och {{max}}","lessThanOrEqual":" {{max}}","greaterOrEqual":" {{min}}"},"sats_other":"sats","sats_one":"sat","advanced":"Avancerat","accounts":"Konton","discover":"Upptcka","success_message":"{{amount}}{{fiatAmount}} skickat till {{destination}}","response":"Svar","confirm_password":"Bekrfta Lsenord","balance":"Balans","wallet":"Plnbok","connectors":{"lnd":"LND","nativelnd":"LND (ver Tor)","nativelndhub":"LNDHub (ver Tor)","galoy":"Galoy","eclair":"Eclair","nativecitadel":"Citadel (ver Tor)","commando":"Commando","nativelnbits":"LNBits (ver Tor)","lndhub":"LNDHub","lnbits":"LNBits","citadel":"Citadel"},"or":"eller","pasted":"Klistrat in!"},"wx":{"allowance_menu":{"confirm_delete":"r du sker p att du vill radera webbplatsen?","hint":"Detta nollstller nuvarande budget","new_budget":{"label":"Ny budget"},"enable_login":{"title":"Aktivera webbplatsinloggning","subtitle":"Logga in automatiskt utan bekrftelse nr webbplatsen begr det."},"edit_allowance":{"title":"Redigera Instllningar","screen_reader":"Alternativ fr Beloppsgrns"},"edit_permissions":"Redigera behrigheter"},"qrcode_scanner":{"title":"Skanna QR-kod","actions":{"start_scanning":"Pbrja skanning","stop_scanning":"Avsluta skanning"},"errors":{"allow_camera_access":"Tillt kameratkomst under instllningar."}},"transactionsTable":{"fee":"Avgift","preimage":"Frhandsvy","received":"Mottaget","sent":"Skickat","boostagram":{"sender":"Avsndare","message":"Meddelande","app":"App","podcast":"Podcast"},"open_location":"ppna websida"},"confirm_or_cancel":{"only_trusted":"Anslut endast till tillfrlitliga webbplatser."},"budget_control":{"remember":{"label":"Kom ihg att ange en budget","description":"Du kan ange en beloppsgrns utan att behva bekrfta betalningar frrn grnsen r uppndd."},"budget":{"label":"Budget"}},"toasts":{"connection_error":{"what_you_can_do":"Du kan gra detta:","double_check":"Kontrollera dina anslutningsinstllningar","if_ssl_errors":"och om det frekommer SSL-fel (t.ex. ERR_CERT_AUTHORITY_INVALID), klicka p \\"advanced\\" och fortstt genom att godknna certifikatet.","visit_guides":"Besk vr guide fr ytterligare hjlp"},"login_failed":{"password_reset":"Glmt ditt lsenord? Klicka hr"},"errors":{"invalid_credentials":"Ogitligt lsenord. Kontrollera ditt lsenord, e-postadress och frsk igen."}},"account_menu":{"screen_reader":"ppna droppmeny","title":"Vxla konto","options":{"account":{"add":"Lgg till nytt konto","manage":"Hantera konton","account_settings":"Konto instllningar","go_to_web_wallet":"Hantera ditt webbkonto"}}},"publishers_table":{"payments":"betalningar","used":"utnyttjat"},"badge":{"label":{"active":"AKTIV","auth":"LOGGA IN","imported":"IMPORTERAD"}},"companion_download_info":{"heading":"Hur vill du ansluta till TOR-ntverket?","companion":{"title":"Companion App","description":"Lttviktsapp som ansluter din webblsare till TOR-ntverket."},"download":"Ladda ner","tor_native":{"title":"TOR (native)","description":"Vlj det hr alternativet om den hr webblsaren redan r ansluten till TOR-ntverket."}},"transaction_list":{"tabs":{"incoming":"Inkommande","outgoing":"Utgende"}}},"mk":{"nostr":{"nip04decrypt":"Dekryptera data.","getpublickey":"Ls din publika nyckel.","signmessage":"Skriv under meddelandet med din nyckel.","nip04encrypt":"Kryptera data."},"lnd":{"channelbalance":"F en rapport om de totala medlen ver alla ppna kanaler.","routermc":"Ls det interna uppdragskontroll lget.","getinfo":"F nod-informationen.","lookupinvoice":"Sl upp fakturainformation.","walletbalance":"F plnbokens totala outnyttjade uttag.","disconnectpeer":"Koppla frn en fjrr-ansluten peer.","getchaninfo":"F ntverksmeddelandet fr den givna kanalen.","listpeers":"F en lista ver alla fr nrvarande aktiva peers.","sendtoroute":"Gr en betalning via den angivna vgen.","getnodeinfo":"F kanalinformationen fr en nod.","gettransactions":"F en lista ver alla transaktioner som r relevanta fr plnboken.","listpayments":"F en lista ver alla utgende betalningar.","queryroutes":"Frga efter en mjlig rutt.","addholdinvoice":"Skapa nya HODL-fakturor.","settleinvoice":"Avgr en godknd faktura.","listchannels":"F en beskrivning av alla ppna kanaler.","listinvoices":"F en lista ver alla fakturor.","openchannel":"ppna en ny kanal.","connectpeer":"Upprtta en anslutning till en extern peer.","estimatefee":"Uppskatta avgiftssatsen och totala avgifter fr en transaktion.","getnetworkinfo":"F grundlggande statistik om det knda kanaldiagrammet.","verifymessage":"Verifiera en signatur ver ett meddelande.","decodepayreq":"Avkoda en strng fr betalningsbegran.","addinvoice":"Skapa nya fakturor."},"lnc":{"listinvoices":"F en lista ver alla fakturor.","walletbalance":"F plnbokens totala outnyttjade uttag.","openchannel":"ppna en ny kanal.","getchaninfo":"F ntverksmeddelandet fr den givna kanalen.","getnetworkinfo":"F grundlggande statistik om det knda kanaldiagrammet.","listchannels":"F en beskrivning av alla ppna kanaler.","estimatefee":"Uppskatta avgiftssatsen och totala avgifter fr en transaktion.","getinfo":"F nod-informationen.","channelbalance":"F en rapport om de totala medlen ver alla ppna kanaler.","disconnectpeer":"Koppla frn en fjrransluten peer.","getnodeinfo":"F kanalinformationen fr en nod.","gettransactions":"F en lista ver alla transaktioner som r relevanta fr plnboken.","lookupinvoice":"Se fakturainformation.","queryroutes":"Frga efter en mjlig rutt.","connectpeer":"Upprtta en anslutning till en extern peer.","listpayments":"F en lista ver alla utgende betalningar.","listpeers":"F en lista ver alla fr nrvarande aktiva peers.","decodepayreq":"Avkoda en strng fr betalningsbegran.","verifymessage":"Verifiera en signatur ver ett meddelande.","sendtoroute":"Gr en betalning via den angivna vgen.","routermc":"Ls det interna uppdragskontrolllget.","addinvoice":"Skapa nya fakturor.","addholdinvoice":"Skapa nya HODL-fakturor.","settleinvoice":"Avgr en godknd faktura."},"commando":{"invoice":"Skapa frvntningar p en betalning.","listpeers":"Lista noder som r anslutna eller har ppna kanaler med denna nod.","setchannel":"Konfigurera avgifter / htlc-intervall som annonseras fr en kanal.","offer":"Skapa ett erbjudande.","pay":"Skicka en betalning till en BOLT11-faktura.","decodepay":"Kontrollera och analysera en bolt11-strng.","decode":"Avkoda en bolt11/bolt12/rune-strng.","getinfo":"F sammanfattningen av noden.","multifundchannel":"ppna flera betalningskanaler med noder genom att utfra en enda finansieringstransaktion.","sendpay":"Skicka en betalning via en rutt.","signmessage":"Skapa en signatur frn denna nod.","bkpr-listbalances":"Lista ver alla aktuella och historiska kontosaldon.","disconnect":"Stng en befintlig anslutning till en peer.","feerates":"Returnera avgifterna som CLN kommer att anvnda.","listfunds":"Lista alla tillgngliga medel.","fundchannel":"ppna en betalningskanal med en peer genom att genomfra en finansieringstransaktion.","listnodes":"Lista noder som noden har lrt sig om via gossip-meddelanden.","listoffers":"Lista alla erbjudanden eller f ett specifikt erbjudande.","listpays":"Fr status fr alla betalkommandon.","listsendpays":"Fr status fr alla sendpay-kommandon.","listtransactions":"Lista transaktioner som spras i plnboken.","connect":"Upprtta en ny anslutning med en annan nod.","getroute":"Hitta den bsta vgen fr betalningen till en lightning-nod.","listinvoices":"F status p alla fakturor.","keysend":"Skicka en betalning till en annan nod.","checkmessage":"Verifiera att signaturen genererades av en given nod.","listforwards":"Lista alla htlcs som har frskt vidarebefordras."}}}'); const St = JSON.parse('{"xk":{"welcome":{"set_password":{"title":"","description":" Alby","choose_password":{"label":""},"confirm_password":{"label":""},"errors":{"enter_password":"","confirm_password":"","mismatched_password":""}},"test_connection":{"ready":"!","initializing":"","connection_error":"","review_connection_details":"","connection_taking_long":"","contact_support":"support@getalby.com","actions":{"delete_edit_account":""}},"title":"Alby","pin_extension":{"title":" Alby ","description":" Alby","next_btn":" Alby {{icon}}","explanation":"1.<0/><1/>2.Alby<1/>3.Alby<2/>"}},"choose_connector":{"lnd":{"errors":{"connection_failed":"LND"},"page":{"description":"URLmacaroonadmin.macaroon","title":"LND"},"url":{"label":"REST API","placeholder":"https://your-node-url:8080"},"macaroon":{"label":"Macaroon(HEX)"},"drag_and_drop":"macaroon<0></0>","title":"LND"},"bitcoin_jungle":{"page":{"title":"<0></0>"},"title":""},"eclair":{"url":{"label":"Eclair URL","placeholder":"http://localhost:8080"},"page":{"title":" <0>Eclair</0>","instructions":" Eclair URL "},"password":{"label":"Eclair"},"title":"Eclair"},"citadel":{"page":{"title":"<0>Citadel</0>","instructions":"2FA"},"password":{"label":"Citadel"},"url":{"label":"Citadel URL","placeholder":"http://citadel.local"},"title":"Citadel"},"galoy":{"token":{"label":"JWT","info":"{{label}}<0>wallet.mainnet.galoy.io</0><1/><1/>JWTJWT<2>eyJhbG...</2><1/><1/>"},"actions":{"login":""},"errors":{"setup_failed":"","missing_token":"JWT","invalid_token":"JWT"},"sms_code":{"label":""},"phone_number":{"label":""}},"btcpay":{"page":{"instructions":"BTCPayServer >  > LND Rest -  \\" \\"","title":"BTCPay LND"},"title":"BTCPay Server","errors":{"connection_failed":"BTCPayURL"},"config":{"label":"","placeholder":"config=http://your-btc-pay.org/lnd-config/212121/lnd.config"}},"bitcoin_beach":{"page":{"title":"<0></0>"},"title":""},"commando":{"config":{"placeholder":"config=https://your-btc-pay.org/lnd-config/212121/lnd.config","label":""},"errors":{"connection_failed":"Core Lightningcommando"},"title":"Core Lightning","page":{"title":"Core Lightning","instructions":"Core Lightning 0.12.0commando\'lightning-cli commando-rune\'rune"},"host":{"label":""},"pubkey":{"label":""},"rune":{"label":"Rune"},"proxy":{"label":"Websocket"},"port":{"label":""},"privKey":{"label":""}},"start9":{"page":{"instructions":" Embassy  <0>Lightning Network Daemon</0> <1/> <0>Properties</0> <1/> <0>LND Connect REST URL</0>","title":"<0>Start9 </0>"},"rest_url":{"placeholder":"lndconnect://yournode:8080?...","label":"lndconnect REST URL"},"title":"Start9"},"raspiblitz":{"page":{"instructions2":"admin<0>macaroon</0>","instructions1":"<1/> 1.<0>SSH</0><0>Raspiblitz</0><1/>2<0>Connect Apps & Show Credentials</0><1/><0/>3 <0>Connect Alby to this node</0><1/>4 <0>OK</0> <1/><1/><0>REST API </0> <0>.onion</0>  Tor ","title":"<0>RaspiBlitz</0>"},"rest_api_host":{"label":"REST API","placeholder":"your-node-onion-address:port"},"title":"RaspiBlitz"},"lndhub_bluewallet":{"title":"Bluewallet","page":{"title":"BlueWallet","description":"BlueWallet\\"...\\"/"},"uri":{"label":"BlueWalletURI"},"errors":{"invalid_uri":"BlueWallet URI","connection_failed":"BlueWallet URI"}},"lndhub_go":{"title":"LNDHub","page":{"title":"LNDHub","description":"LNDHubURI"},"errors":{"invalid_uri":"LNDHub URI","connection_failed":"LNDHub URI"},"uri":{"label":"LNDHubURI"}},"lnbits":{"url":{"label":"LNbits URL"},"errors":{"connection_failed":"URL"},"title":"LNbits","page":{"title":"<0>LNbits</0>","instructions":"LNbitsAPI"},"admin_key":{"label":"LNbits","placeholder":"32"}},"umbrel":{"page":{"title":"<0>Umbrel</0>","instructions":"1. Umbrel<0></0><1/>2. <0>REST (Tor)</0><0>REST </0><1/>3. <0>lndconnect URL</0>"},"title":"Umbrel","rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://yournode:8080?..."}},"description":"","mynode":{"title":"myNode","page":{"title":"<0>myNode</0>","instructions":"myNode<0>Lightning</0><0>Wallet</0><1/> <0>Status</0><0>Pair Wallet</0><1/><0>REST +IP</0><0>REST + Tor</0>"},"rest_url":{"label":"lndconnect REST URL","placeholder":"lndconnect://yournode:8080?..."}},"lnc":{"page":{"description":"1.  Lightning Terminal  <0>Lightning Node Connect</0> <1/> 2.  <0>Create a new session</0><1/>3. <1/>4. <0></0> ","title":"LND"},"title":"Lightning Terminal (LNC)","pairing_phrase":{"placeholder":"","label":" "}},"kollider":{"title":"Kollider","description":"Kollider","username":{"label":""},"currency":{"label":""},"errors":{"connection_failed":"","user_already_exists":"","registration_limit_exceeded":""},"choose_path":{"create_new":"","description":"KolliderAlby","title":"Kollider"},"create":{"title":"KolliderAlby","description":"Kollider"},"login":{"title":"Kollider"},"warning":" "},"title":"","umbrel_lightning_node":{"title":""}},"home":{"recent_transactions":"","allowance_view":{"recent_transactions":"","no_transactions":"<0>{{name}}</0>","sats_used":"","allowance":""},"default_view":{"is_blocked_hint":"Alby  {{host}} ","recent_transactions":"","block_removed":"{{host}}","all_transactions_link":"","no_incoming_transactions":"","no_outgoing_transactions":""},"actions":{"send_satoshis":"  ","enable_now":""}},"accounts":{"title":"","actions":{"add_account":""},"account_view":{"nostr":{"errors":{"failed_to_load":" Nostr  Nostr "},"title":"Nostr","public_key":{"label":"Nostr "},"generate_keys":{"screen_reader":"Nostr","actions":{"random_keys":"","derived_keys":""},"title":" Nostr ","hint":" <0>\\"</0>"},"actions":{"generate":""},"private_key":{"subtitle":" Nostr <0></0>","title":" Nostr ","warning":" Nostr ","success":"Nostr ","successfully_removed":"Nostr ","label":"Nostr ","failed_to_remove":" Nostr "},"hint":"Nostr  Alby  Nostr  Nostr  Alby ","settings":{"label":"Nostr ","title":"Nostr ","imported_key_warning":"  Nostr  NostrNostr","can_restore":" Nostr ","derive":" Nostr ","no_secret_key":"  <0></0></div> nostr ","description":" Nostr Nostr "}},"title1":"","export":{"export_uri":"LNDHubURI","scan_qr":"ZeusBlueWallet","title":"","screen_reader":"","waiting":"LndHub...","your_ln_address":""},"remove":{"title":"","subtitle":"","confirm":"\\n\\n Nostr  ","error":""},"actions":{"remove_account":"","export":"","remove_secretkey":""},"title2":"","name":{"title":"","placeholder":""},"bitcoin":{"network":{"title":"","options":{"bitcoin":"","testnet":"","regtest":"Regtest"},"subtitle":""}},"mnemonic":{"backup":{"button":"","warning":"  Nostr ","title":"","save":"","protocols":{"nostr":"Nostr"}},"existing_nostr_key_notice":"  nostr  nostr ","title":"","saved":"","generate":{"title":"","button":"","confirm":"","error_confirm":""},"import":{"title":"","description":"","button":""},"inputs":{"title":""},"lnurl":{"title":"","use_mnemonic":"LNURL Auth"}},"remove_secretkey":{"confirm":"","success":"","title":"","subtitle":""}}},"unlock":{"help_contact":{"part2":"Alby","part1":"? "},"unlock_to_continue":"","errors":{"invalid_password":""},"unlock_error":{"help":"","link":""},"unlock_password":""},"publishers":{"publisher":{"allowance":{"used_budget":"","title":""}},"description":"Alby","no_info":" Alby","discover":"","title":""},"settings":{"nostr":{"private_key":{"title":"","subtitle":"","go_to":""},"title":"Nostr","hint":" Nostr  Alby  Nostr  Nostr  Alby "},"lnurl_auth":{"title":"LNURL-","legacy_lnurl_auth":{"title":"LNDhub  LNbits ","subtitle":" LNDhub BlueWallet LNbits 20223"},"hint":" Alby <0></0>","legacy_lnurl_auth_202207":{"subtitle":"LNURL-20227AlbyLNURL-","title":" LNURL-"}},"browser_notifications":{"title":"","subtitle":""},"language":{"subtitle":"100% <0>Alby</0>","title":""},"name":{"title":"","placeholder":""},"change_password":{"screen_reader":"","errors":{"confirm_password":"","mismatched_password":"","enter_password":""},"choose_password":{"label":""},"success":"","title":"","confirm_password":{"label":""},"submit":{"label":""}},"title":"","theme":{"options":{"system":"","dark":"","light":""},"title":"","subtitle":" Alby"},"website_enhancements":{"subtitle":"TwitterYouTube","title":""},"camera_access":{"subtitle":"","allow":"","granted":"","title":""},"show_fiat":{"subtitle":"","title":""},"exchange":{"title":"","subtitle":""},"personal_data":{"title":"","description":""},"email":{"title":"","placeholder":""},"currency":{"title":"","subtitle":""}},"keysend":{"receiver":{"label":""},"success":"{{preimage}}","amount":{"label":"()"},"title":""},"enable":{"block_and_ignore":" {{host}}","title":"","allow":"","request2":"","request1":"","block_added":"{{host}}"},"send":{"input":{"hint":"LNURL","label":""},"title":""},"lnurlauth":{"submit":"","content_message":{"heading":""},"title":"","success":" {{name}}","errors":{"status":""}},"lnurlwithdraw":{"content_message":{"heading":""},"amount":{"label":""},"title":"","success":"{{sender}}{{amount}}"},"receive":{"actions":{"create_invoice":""},"amount":{"placeholder":"...","label":""},"description":{"label":"","placeholder":""},"success":"!","payment":{"waiting":"...","status":""},"title":"","receive_via_bitcoin_address":"","redeem_lnurl":" LNURL"},"make_invoice":{"memo":{"label":""},"errors":{"amount_too_small":"","amount_too_big":""},"title":"","amount":{"label":"()"}},"confirm_sign_message":{"content":":","title":""},"confirm_request_permission":{"allow":"","always_allow":"","title":""},"nostr":{"title":"Nostr","allow":":","block_and_ignore":" {{host}}","content":":","allow_sign":"{{host}}","block_added":"{{host}}","allow_sign_event":" {{host}}  {{kind}}","view_details":"","hide_details":"","no_content":"()","kinds":{"0":"","1":"","2":"","3":"","4":"","5":"","7":"","8":"","40":"","41":"","42":"","43":"","44":"","1984":"","9734":"","9735":"","10002":"","22242":"","24133":"nostr ","30008":"","30009":"","30023":"","30078":"","unknown":"nostr  {{kind}}"}},"lnurlpay":{"amount":{"label":""},"comment":{"label":""},"email":{"label":""},"success":"","name":{"label":""}},"confirm_payment":{"actions":{"pay_now":""},"title":"","success":"{{amount}}!"},"confirm_keysend":{"title":"","success":"! : {{preimage}}","payment_summary":{"description":" {{destination}}"}},"choose_path":{"other":{"title":"","description":"","and_more":"...","connect":""},"alby":{"description":"Alby","title":"Alby","connect":" Alby "}},"discover":{"list":{"trading":"","miscellaneous":"","shopping":"","entertainment":"","gaming":"","showcases":"","nostr":"Nostr","nodeManagement":""},"description":" Alby ","title":"","tips":{"top_up_wallet":{"title":"","description":"\\n"},"title":"Alby","description":"","demo":{"title":"Alby ","description":"\\n Alby "},"mnemonic":{"title":"Nostr","description":" Nostr\\n"}}},"alby":{"pre_connect":{"set_password":{"choose_password":{"label":""},"confirm_password":{"label":""},"errors":{"enter_password":"","confirm_password":"","mismatched_password":""}}}},"lnurlchannel":{"content_message":{"heading":""},"title":"","success":" {{name}}"},"transactions":{"list_empty":"","title":"","description":{"incoming":"","outgoing":""}},"distributions":{"title":" {{name}}","description":"{{name}}","citadel":{"name":"Citadel"},"btcpay":{"name":"BTCPay"},"raspiblitz":{"name":"Raspiblitz"},"mynode":{"name":"myNode"},"start9":{"name":"Start9"},"umbrel":{"name":"Umbrel"}},"confirm_add_account":{"title":"","content":"{{connector}}","tor_info":" TOR  Alby "},"on_chain":{"instructions1":" getalby.com  <0>Alby </0>","go":" Alby  ","title":"","instructions2":"<0></0>"},"confirm_get_address":{"title":"","content":"","heading":""},"lnurlredeem":{"title":"","actions":{"withdraw":""},"input":{"label":"LNURL-","placeholder":"LNURL..."},"errors":{"invalid_withdraw_request":" LNURL ","invalid_lnurl":" LNURL"}},"scan_qrcode":{"title":""}},"y0":{"actions":{"lock":"","receive":"","close":"","back":"","next":"","cancel":"","delete":"","edit":"","export":"","remove":"","continue":"","connect":"","unlock":"","send":"","save":"","open":"","confirm":"","copy":"","copy_invoice":"","log_in":"","receive_again":"","remember":"","transactions":"","more":"","download":"","import":"","copy_clipboard":"","paste":"","paste_clipboard":""},"errors":{"connection_failed":"","payment_failed":""},"feedback":"","success":"","description_full":"","password":"","settings":"","connected_sites":"","amount":"","optional":"","description":"","message":"","sats_one":"sat","sats_other":"","success_message":"{{amount}}{{fiatAmount}}{{destination}}","response":"","help":"","copied":"","error":"","loading":"","advanced":"","accounts":"","confirm_password":"","discover":"","range":{"between":" {{min}}  {{max}} ","lessThanOrEqual":" {{max}}","greaterOrEqual":" {{min}}"},"balance":"","wallet":"","connectors":{"lnd":"LND","nativelnd":"LND Tor","lndhub":"LNDHub","nativelndhub":"LNDHub Tor","lnbits":"LNBits","nativelnbits":"LNBits Tor","galoy":"Galoy","eclair":"Eclair","citadel":"Citadel","nativecitadel":"Citadel Tor","commando":"Commando"},"or":"","pasted":""},"wx":{"toasts":{"login_failed":{"password_reset":""},"errors":{"invalid_credentials":""},"connection_error":{"visit_guides":"","what_you_can_do":"","double_check":"","if_ssl_errors":"SSLERR_CERT_AUTHORITY_INVALID \\" \\""}},"account_menu":{"title":"","options":{"account":{"add":"","manage":"","account_settings":"","go_to_web_wallet":""}},"screen_reader":""},"allowance_menu":{"hint":"","confirm_delete":"","new_budget":{"label":""},"enable_login":{"title":"","subtitle":""},"edit_allowance":{"title":"","screen_reader":""},"edit_permissions":""},"transactionsTable":{"boostagram":{"podcast":"","message":"","app":"","sender":""},"received":"","sent":"","fee":"","preimage":"","open_location":""},"confirm_or_cancel":{"only_trusted":""},"budget_control":{"remember":{"label":"","description":""},"budget":{"label":""}},"qrcode_scanner":{"title":"","actions":{"stop_scanning":"","start_scanning":""},"errors":{"allow_camera_access":""}},"badge":{"label":{"active":"","auth":"","imported":""}},"publishers_table":{"used":"","payments":""},"companion_download_info":{"heading":" TOR ","download":"","tor_native":{"title":"TOR","description":" TOR "},"companion":{"title":"","description":" TOR "}},"transaction_list":{"tabs":{"incoming":"","outgoing":""}}},"mk":{"nostr":{"signmessage":"","nip04decrypt":"","nip04encrypt":"","getpublickey":""},"commando":{"bkpr-listbalances":"","checkmessage":"","decode":" bolt11/bolt12/rune ","connect":"","decodepay":" bolt11 ","disconnect":"","fundchannel":"","getroute":"","invoice":"","listforwards":" htlc","listfunds":"","listnodes":"","listpeers":"","listsendpays":" sendpay ","listtransactions":"","offer":"","multifundchannel":"","pay":" BOLT11 ","signmessage":"","keysend":"","listinvoices":"","getinfo":"","listoffers":"","setchannel":" / htlc ","sendpay":"","feerates":" CLN ","listpays":""},"lnc":{"getnodeinfo":"","gettransactions":"","listpeers":"","addinvoice":"","getinfo":"","listinvoices":"","walletbalance":"","connectpeer":"","disconnectpeer":"","estimatefee":"","getnetworkinfo":"","listpayments":"","lookupinvoice":"","listchannels":"","channelbalance":"","getchaninfo":"","openchannel":"","sendtoroute":"","routermc":"","queryroutes":"","verifymessage":"","decodepayreq":"","addholdinvoice":" HODL ","settleinvoice":""},"lnd":{"sendtoroute":"","queryroutes":"","verifymessage":"","lookupinvoice":"","listpeers":"","listinvoices":"","channelbalance":"","walletbalance":"","disconnectpeer":"","estimatefee":"","getchaninfo":"","getnetworkinfo":"","getnodeinfo":"","gettransactions":"","listpayments":"","decodepayreq":"","routermc":"","addinvoice":"","getinfo":"","listchannels":"","connectpeer":"","openchannel":"","addholdinvoice":" HODL ","settleinvoice":""}}}'); const At = { en: { translation: gt.xk, common: gt.y0, components: gt.wx, permissions: gt.mk }, cs: { translation: ht.xk, common: ht.y0, components: ht.wx, permissions: ht.mk }, da: { translation: pt.xk, common: pt.y0, components: pt.wx, permissions: pt.mk }, es: { translation: mt.xk, common: mt.y0, components: mt.wx, permissions: mt.mk }, fi: { translation: yt.xk, common: yt.y0, components: yt.wx, permissions: yt.mk }, fr: { translation: bt.xk, common: bt.y0, components: bt.wx, permissions: bt.mk }, it: { translation: vt.xk, common: vt.y0, components: vt.wx, permissions: vt.mk }, mr: { translation: wt.xk, common: wt.y0, components: wt.wx, permissions: wt.mk }, pl: { translation: _t.xk, common: _t.y0, components: _t.wx, permissions: _t.mk }, 'pt-BR': { translation: Et.xk, common: Et.y0, components: Et.wx, permissions: Et.mk }, sv: { translation: kt.xk, common: kt.y0, components: kt.wx, permissions: kt.mk }, 'zh-CN': { translation: St.xk, common: St.y0, components: St.wx, permissions: St.mk } }; Le.use(ft).use(tt).init({ fallbackLng: 'en', ns: ['translation', 'common', 'components', 'permissions'], defaultNS: 'translation', resources: At }); const Ot = Le; const xt = { browserNotifications: !0, websiteEnhancements: !0, legacyLnurlAuth: !1, isUsingLegacyLnurlAuthKey: !1, userName: '', userEmail: '', locale: Ot.resolvedLanguage ?? 'en', theme: 'system', showFiat: !0, currency: s.USD, exchange: 'alby', nostrEnabled: !1, closedTips: [] }; const It = 2n ** 256n; const Nt = It - 0x1000003d1n; const Tt = It - 0x14551231950b75fc4402da1732fc9bebfn; const Rt = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n; const Pt = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n; const Ct = { p: Nt, n: Tt, a: 0n, b: 7n, Gx: Rt, Gy: Pt }; const Bt = 32; const Lt = e => Kt(Kt(e * e) * e + Ct.b); const jt = (e = '') => { throw new Error(e) }; const Dt = e => typeof e === 'bigint'; const Ut = e => typeof e === 'string'; const Mt = e => Dt(e) && e > 0n && e < Nt; const zt = e => Dt(e) && e > 0n && e < Tt; const Ft = (e, t) => !(e instanceof Uint8Array) || typeof t === 'number' && t > 0 && e.length !== t ? jt('Uint8Array expected') : e; const Ht = e => new Uint8Array(e); const qt = (e, t) => Ft(Ut(e) ? Xt(e) : Ht(e), t); const Kt = (e, t = Nt) => { const n = e % t; return n >= 0n ? n : t + n }; const Vt = e => e instanceof $t ? e : jt('Point expected'); let Wt; class $t {constructor (e, t, n) { this.px = e, this.py = t, this.pz = n } static fromAffine (e) { return new $t(e.x, e.y, 1n) } static fromHex (e) { let t; const n = (e = qt(e))[0]; const r = e.subarray(1); const i = en(r, 0, Bt); const o = e.length; if (o === 33 && [2, 3].includes(n)) { Mt(i) || jt('Point hex invalid: x not FE'); let e = an(Lt(i)); (1 & n) == 1 !== ((1n & e) === 1n) && (e = Kt(-e)), t = new $t(i, e, 1n) } return o === 65 && n === 4 && (t = new $t(i, en(r, Bt, 2 * Bt), 1n)), t ? t.ok() : jt('Point is not on curve') } static fromPrivateKey (e) { return Gt.mul(sn(e)) } get x () { return this.aff().x } get y () { return this.aff().y }equals (e) { const { px: t, py: n, pz: r } = this; const { px: i, py: o, pz: a } = Vt(e); const s = Kt(t * a); const c = Kt(i * r); const u = Kt(n * a); const l = Kt(o * r); return s === c && u === l }negate () { return new $t(this.px, Kt(-this.py), this.pz) }double () { return this.add(this) }add (e) { const { px: t, py: n, pz: r } = this; const { px: i, py: o, pz: a } = Vt(e); const { a: s, b: c } = Ct; let u = 0n; let l = 0n; let d = 0n; const f = Kt(3n * c); let h = Kt(t * i); let p = Kt(n * o); let g = Kt(r * a); let m = Kt(t + n); let y = Kt(i + o); m = Kt(m * y), y = Kt(h + p), m = Kt(m - y), y = Kt(t + r); let b = Kt(i + a); return y = Kt(y * b), b = Kt(h + g), y = Kt(y - b), b = Kt(n + r), u = Kt(o + a), b = Kt(b * u), u = Kt(p + g), b = Kt(b - u), d = Kt(s * y), u = Kt(f * g), d = Kt(u + d), u = Kt(p - d), d = Kt(p + d), l = Kt(u * d), p = Kt(h + h), p = Kt(p + h), g = Kt(s * g), y = Kt(f * y), p = Kt(p + g), g = Kt(h - g), g = Kt(s * g), y = Kt(y + g), h = Kt(p * y), l = Kt(l + h), h = Kt(b * y), u = Kt(m * u), u = Kt(u - h), h = Kt(m * p), d = Kt(b * d), d = Kt(d + h), new $t(u, l, d) }mul (e, t = !0) { if (!t && e === 0n) return Yt; if (zt(e) || jt('invalid scalar'), this.equals(Gt)) return _n(e).p; let n = Yt; let r = Gt; for (let i = this; e > 0n; i = i.double(), e >>= 1n)1n & e ? n = n.add(i) : t && (r = r.add(i)); return n }mulAddQUns (e, t, n) { return this.mul(t, !1).add(e.mul(n, !1)).ok() }toAffine () { const { px: e, py: t, pz: n } = this; if (this.equals(Yt)) return { x: 0n, y: 0n }; if (n === 1n) return { x: e, y: t }; const r = on(n); return Kt(n * r) !== 1n && jt('invalid inverse'), { x: Kt(e * r), y: Kt(t * r) } }assertValidity () { const { x: e, y: t } = this.aff(); return Mt(e) && Mt(t) || jt('Point invalid: x or y'), Kt(t * t) === Lt(e) ? this : jt('Point invalid: not on curve') }multiply (e) { return this.mul(e) }aff () { return this.toAffine() }ok () { return this.assertValidity() }toHex (e = !0) { const { x: t, y: n } = this.aff(); return (e ? (1n & n) === 0n ? '02' : '03' : '04') + nn(t) + (e ? '' : nn(n)) }toRawBytes (e = !0) { return Xt(this.toHex(e)) }}$t.BASE = new $t(Rt, Pt, 1n), $t.ZERO = new $t(0n, 1n, 0n); const { BASE: Gt, ZERO: Yt } = $t; const Zt = (e, t) => e.toString(16).padStart(t, '0'); const Jt = e => Array.from(e).map(e => Zt(e, 2)).join(''); const Xt = e => { const t = e.length; (!Ut(e) || t % 2) && jt('hex invalid 1'); const n = Ht(t / 2); for (let t = 0; t < n.length; t++) { const r = 2 * t; const i = e.slice(r, r + 2); const o = Number.parseInt(i, 16); (Number.isNaN(o) || o < 0) && jt('hex invalid 2'), n[t] = o } return n }; const Qt = e => BigInt('0x' + (Jt(e) || '0')); const en = (e, t, n) => Qt(e.slice(t, n)); const tn = e => Dt(e) && e >= 0n && e < It ? Xt(Zt(e, 2 * Bt)) : jt('bigint expected'); const nn = e => Jt(tn(e)); const rn = (...e) => { const t = Ht(e.reduce((e, t) => e + Ft(t).length, 0)); let n = 0; return e.forEach(e => { t.set(e, n), n += e.length }), t }; const on = (e, t = Nt) => { (e === 0n || t <= 0n) && jt('no inverse n=' + e + ' mod=' + t); let n = Kt(e, t); let r = t; let i = 0n; let o = 1n; let a = 1n; let s = 0n; for (;n !== 0n;) { const e = r / n; const t = r % n; const c = i - a * e; const u = o - s * e; r = n, n = t, i = a, o = s, a = c, s = u } return r === 1n ? Kt(i, t) : jt('no inverse') }; const an = e => { let t = 1n; for (let n = e, r = (Nt + 1n) / 4n; r > 0n; r >>= 1n)1n & r && (t = t * n % Nt), n = n * n % Nt; return Kt(t * t) === e ? t : jt('sqrt invalid') }; const sn = e => (Dt(e) || (e = Qt(qt(e, Bt))), zt(e) ? e : jt('private key out of range')); const cn = e => e > Tt >> 1n; class un {constructor (e, t, n) { this.r = e, this.s = t, this.recovery = n, this.assertValidity() } static fromCompact (e) { return e = qt(e, 64), new un(en(e, 0, Bt), en(e, Bt, 2 * Bt)) }assertValidity () { return zt(this.r) && zt(this.s) ? this : jt() }addRecoveryBit (e) { return new un(this.r, this.s, e) }hasHighS () { return cn(this.s) }recoverPublicKey (e) { const { r: t, s: n, recovery: r } = this; [0, 1, 2, 3].includes(r) || jt('recovery id invalid'); const i = dn(qt(e, 32)); const o = r === 2 || r === 3 ? t + Tt : t; o >= Nt && jt('q.x invalid'); const a = (1 & r) == 0 ? '02' : '03'; const s = $t.fromHex(a + nn(o)); const c = on(o, Tt); const u = Kt(-i * c, Tt); const l = Kt(n * c, Tt); return Gt.mulAddQUns(s, u, l) }toCompactRawBytes () { return Xt(this.toCompactHex()) }toCompactHex () { return nn(this.r) + nn(this.s) }} const ln = e => { const t = 8 * e.length - 256; const n = Qt(e); return t > 0 ? n >> BigInt(t) : n }; const dn = e => Kt(ln(e), Tt); const fn = e => tn(e); const hn = () => typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0; let pn; const gn = { lowS: !0 }; function mn (e, t, n = gn) { ['der', 'recovered', 'canonical'].some(e => e in n) && jt('sign() legacy options not supported'); let { lowS: r } = n; r == null && (r = !0); const i = dn(qt(e)); const o = fn(i); const a = sn(t); const s = [fn(a), o]; let c = n.extraEntropy; if (c) { !0 === c && (c = wn.randomBytes(Bt)); const e = qt(c); e.length !== Bt && jt(), s.push(e) } const u = i; return { seed: rn(...s), k2sig: e => { const t = ln(e); if (!zt(t)) return; const n = on(t, Tt); const i = Gt.mul(t).aff(); const o = Kt(i.x, Tt); if (o === 0n) return; const s = Kt(n * Kt(u + Kt(a * o, Tt), Tt), Tt); if (s === 0n) return; let c = s; let l = (i.x === o ? 0 : 2) | Number(1n & i.y); return r && cn(s) && (c = Kt(-s, Tt), l ^= 1), new un(o, c, l) } } } function yn (e) { let t = Ht(Bt); let n = Ht(Bt); let r = 0; const i = () => { t.fill(1), n.fill(0), r = 0 }; const o = 'drbg: tried 1000 values'; if (e) { const e = (...e) => wn.hmacSha256Async(n, t, ...e); const a = async (r = Ht()) => { n = await e(Ht([0]), r), t = await e(), r.length !== 0 && (n = await e(Ht([1]), r), t = await e()) }; const s = async () => (r++ >= 1e3 && jt(o), t = await e(), t); return async (e, t) => { let n; for (i(), await a(e); !(n = t(await s()));) await a(); return i(), n } } { const e = (...e) => { const r = pn; return r || jt('etc.hmacSha256Sync not set'), r(n, t, ...e) }; const a = (r = Ht()) => { n = e(Ht([0]), r), t = e(), r.length !== 0 && (n = e(Ht([1]), r), t = e()) }; const s = () => (r++ >= 1e3 && jt(o), t = e(), t); return (e, t) => { let n; for (i(), a(e); !(n = t(s()));)a(); return i(), n } } } function bn (e, t, n = !0) { return $t.fromHex(t).mul(sn(e)).toRawBytes(n) } function vn (e) { e = qt(e); const t = Bt + 8; (e.length < t || e.length > 1024) && jt('expected proper params'); const n = Kt(Qt(e), Tt - 1n) + 1n; return tn(n) } const wn = { hexToBytes: Xt, bytesToHex: Jt, concatBytes: rn, bytesToNumberBE: Qt, numberToBytesBE: tn, mod: Kt, invert: on, hmacSha256Async: async (e, ...t) => { const n = hn(); if (!n) return jt('etc.hmacSha256Async not set'); const r = n.subtle; const i = await r.importKey('raw', e, { name: 'HMAC', hash: { name: 'SHA-256' } }, !1, ['sign']); return Ht(await r.sign('HMAC', i, rn(...t))) }, hmacSha256Sync: pn, hashToPrivateKey: vn, randomBytes: e => { const t = hn(); return t || jt('crypto.getRandomValues must be defined'), t.getRandomValues(Ht(e)) } }; Object.defineProperties(wn, { hmacSha256Sync: { configurable: !1, get: () => pn, set (e) { pn || (pn = e) } } }); const _n = e => { const t = Wt || (Wt = (() => { const e = []; let t = Gt; let n = t; for (let r = 0; r < 33; r++) { n = t, e.push(n); for (let r = 1; r < 128; r++)n = n.add(t), e.push(n); t = n.double() } return e })()); const n = (e, t) => { const n = t.negate(); return e ? n : t }; let r = Yt; let i = Gt; const o = BigInt(255); const a = BigInt(8); for (let s = 0; s < 33; s++) { const c = 128 * s; let u = Number(e & o); e >>= a, u > 128 && (u -= 256, e += 1n); const l = c; const d = c + Math.abs(u) - 1; const f = s % 2 != 0; const h = u < 0; u === 0 ? i = i.add(n(f, t[l])) : r = r.add(n(h, t[d])) } return { p: r, f: i } }; function En (e) { if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`) } function kn (e, ...t) { if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array'); if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`) } const Sn = { number: En, bool: function (e) { if (typeof e !== 'boolean') throw new Error(`Expected boolean, not ${e}`) }, bytes: kn, hash: function (e) { if (typeof e !== 'function' || typeof e.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor'); En(e.outputLen), En(e.blockLen) }, exists: function (e, t = !0) { if (e.destroyed) throw new Error('Hash instance has been destroyed'); if (t && e.finished) throw new Error('Hash#digest() has already been called') }, output: function (e, t) { kn(e); const n = t.outputLen; if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`) } }; const An = Sn; const On = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0; const xn = e => new DataView(e.buffer, e.byteOffset, e.byteLength); const In = (e, t) => e << 32 - t | e >>> t; if (!(new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)) throw new Error('Non little-endian hardware is not supported'); Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0')); function Nn (e) { if (typeof e === 'string' && (e = (function (e) { if (typeof e !== 'string') throw new TypeError('utf8ToBytes expected string, got ' + typeof e); return (new TextEncoder()).encode(e) }(e))), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`); return e } class Tn {clone () { return this._cloneInto() }} function Rn (e) { const t = t => e().update(Nn(t)).digest(); const n = e(); return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t } function Pn (e = 32) { if (On && typeof On.getRandomValues === 'function') return On.getRandomValues(new Uint8Array(e)); throw new Error('crypto.getRandomValues must be defined') } class Cn extends Tn {constructor (e, t, n, r) { super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = xn(this.buffer) }update (e) { An.exists(this); const { view: t, buffer: n, blockLen: r } = this; const i = (e = Nn(e)).length; for (let o = 0; o < i;) { const a = Math.min(r - this.pos, i - o); if (a !== r)n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === r && (this.process(t, 0), this.pos = 0); else { const t = xn(e); for (;r <= i - o; o += r) this.process(t, o) } } return this.length += e.length, this.roundClean(), this }digestInto (e) { An.exists(this), An.output(e, this), this.finished = !0; const { buffer: t, view: n, blockLen: r, isLE: i } = this; let { pos: o } = this; t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > r - o && (this.process(n, 0), o = 0); for (let e = o; e < r; e++)t[e] = 0; !(function (e, t, n, r) { if (typeof e.setBigUint64 === 'function') return e.setBigUint64(t, n, r); const i = BigInt(32); const o = BigInt(4294967295); const a = Number(n >> i & o); const s = Number(n & o); const c = r ? 4 : 0; const u = r ? 0 : 4; e.setUint32(t + c, a, r), e.setUint32(t + u, s, r) }(n, r - 8, BigInt(8 * this.length), i)), this.process(n, 0); const a = xn(e); const s = this.outputLen; if (s % 4) throw new Error('_sha2: outputLen should be aligned to 32bit'); const c = s / 4; const u = this.get(); if (c > u.length) throw new Error('_sha2: outputLen bigger than state'); for (let e = 0; e < c; e++)a.setUint32(4 * e, u[e], i) }digest () { const { buffer: e, outputLen: t } = this; this.digestInto(e); const n = e.slice(0, t); return this.destroy(), n }_cloneInto (e) { e || (e = new this.constructor()), e.set(...this.get()); const { blockLen: t, buffer: n, length: r, finished: i, destroyed: o, pos: a } = this; return e.length = r, e.pos = a, e.finished = i, e.destroyed = o, r % t && e.buffer.set(n), e }} const Bn = (e, t, n) => e & t ^ ~e & n; const Ln = (e, t, n) => e & t ^ e & n ^ t & n; const jn = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]); const Dn = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]); const Un = new Uint32Array(64); class Mn extends Cn {constructor () { super(64, 32, 8, !1), this.A = 0 | Dn[0], this.B = 0 | Dn[1], this.C = 0 | Dn[2], this.D = 0 | Dn[3], this.E = 0 | Dn[4], this.F = 0 | Dn[5], this.G = 0 | Dn[6], this.H = 0 | Dn[7] }get () { const { A: e, B: t, C: n, D: r, E: i, F: o, G: a, H: s } = this; return [e, t, n, r, i, o, a, s] }set (e, t, n, r, i, o, a, s) { this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | o, this.G = 0 | a, this.H = 0 | s }process (e, t) { for (let n = 0; n < 16; n++, t += 4)Un[n] = e.getUint32(t, !1); for (let e = 16; e < 64; e++) { const t = Un[e - 15]; const n = Un[e - 2]; const r = In(t, 7) ^ In(t, 18) ^ t >>> 3; const i = In(n, 17) ^ In(n, 19) ^ n >>> 10; Un[e] = i + Un[e - 7] + r + Un[e - 16] | 0 } let { A: n, B: r, C: i, D: o, E: a, F: s, G: c, H: u } = this; for (let e = 0; e < 64; e++) { const t = u + (In(a, 6) ^ In(a, 11) ^ In(a, 25)) + Bn(a, s, c) + jn[e] + Un[e] | 0; const l = (In(n, 2) ^ In(n, 13) ^ In(n, 22)) + Ln(n, r, i) | 0; u = c, c = s, s = a, a = o + t | 0, o = i, i = r, r = n, n = t + l | 0 }n = n + this.A | 0, r = r + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, s = s + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(n, r, i, o, a, s, c, u) }roundClean () { Un.fill(0) }destroy () { this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0) }} class zn extends Mn {constructor () { super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28 }} const Fn = Rn(() => new Mn()); const Hn = (Rn(() => new zn()), BigInt(0), BigInt(1)); const qn = BigInt(2); const Kn = e => e instanceof Uint8Array; const Vn = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0')); function Wn (e) { if (!Kn(e)) throw new Error('Uint8Array expected'); let t = ''; for (let n = 0; n < e.length; n++)t += Vn[e[n]]; return t } function $n (e) { if (typeof e !== 'string') throw new Error('hex string expected, got ' + typeof e); return BigInt(e === '' ? '0' : `0x${e}`) } function Gn (e) { if (typeof e !== 'string') throw new Error('hex string expected, got ' + typeof e); if (e.length % 2) throw new Error('hex string is invalid: unpadded ' + e.length); const t = new Uint8Array(e.length / 2); for (let n = 0; n < t.length; n++) { const r = 2 * n; const i = e.slice(r, r + 2); const o = Number.parseInt(i, 16); if (Number.isNaN(o) || o < 0) throw new Error('invalid byte sequence'); t[n] = o } return t } function Yn (e) { return $n(Wn(e)) } function Zn (e) { if (!Kn(e)) throw new Error('Uint8Array expected'); return $n(Wn(Uint8Array.from(e).reverse())) } const Jn = (e, t) => Gn(e.toString(16).padStart(2 * t, '0')); const Xn = (e, t) => Jn(e, t).reverse(); function Qn (e, t, n) { let r; if (typeof t === 'string') try { r = Gn(t) } catch (n) { throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${n}`) } else { if (!Kn(t)) throw new Error(`${e} must be hex string or Uint8Array`); r = Uint8Array.from(t) } const i = r.length; if (typeof n === 'number' && i !== n) throw new Error(`${e} expected ${n} bytes, got ${i}`); return r } function er (...e) { const t = new Uint8Array(e.reduce((e, t) => e + t.length, 0)); let n = 0; return e.forEach(e => { if (!Kn(e)) throw new Error('Uint8Array expected'); t.set(e, n), n += e.length }), t } function tr (e) { if (typeof e !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof e); return (new TextEncoder()).encode(e) } const nr = e => (qn << BigInt(e - 1)) - Hn; const rr = e => new Uint8Array(e); const ir = e => Uint8Array.from(e); function or (e, t, n) { if (typeof e !== 'number' || e < 2) throw new Error('hashLen must be a number'); if (typeof t !== 'number' || t < 2) throw new Error('qByteLen must be a number'); if (typeof n !== 'function') throw new Error('hmacFn must be a function'); let r = rr(e); let i = rr(e); let o = 0; const a = () => { r.fill(1), i.fill(0), o = 0 }; const s = (...e) => n(i, r, ...e); const c = (e = rr()) => { i = s(ir([0]), e), r = s(), e.length !== 0 && (i = s(ir([1]), e), r = s()) }; const u = () => { if (o++ >= 1e3) throw new Error('drbg: tried 1000 values'); let e = 0; const n = []; for (;e < t;) { r = s(); const t = r.slice(); n.push(t), e += r.length } return er(...n) }; return (e, t) => { let n; for (a(), c(e); !(n = t(u()));)c(); return a(), n } } const ar = { bigint: e => typeof e === 'bigint', function: e => typeof e === 'function', boolean: e => typeof e === 'boolean', string: e => typeof e === 'string', isSafeInteger: e => Number.isSafeInteger(e), array: e => Array.isArray(e), field: (e, t) => t.Fp.isValid(e), hash: e => typeof e === 'function' && Number.isSafeInteger(e.outputLen) }; function sr (e, t, n = {}) { const r = (t, n, r) => { const i = ar[n]; if (typeof i !== 'function') throw new Error(`Invalid validator "${n}", expected function`); const o = e[t]; if (!(r && void 0 === o || i(o, e))) throw new Error(`Invalid param ${String(t)}=${o} (${typeof o}), expected ${n}`) }; for (const [e, n] of Object.entries(t))r(e, n, !1); for (const [e, t] of Object.entries(n))r(e, t, !0); return e } const cr = BigInt(0); const ur = BigInt(1); const lr = BigInt(2); const dr = BigInt(3); const fr = BigInt(4); const hr = BigInt(5); const pr = BigInt(8); BigInt(9), BigInt(16); function gr (e, t) { const n = e % t; return n >= cr ? n : t + n } function mr (e, t, n) { if (n <= cr || t < cr) throw new Error('Expected power/modulo > 0'); if (n === ur) return cr; let r = ur; for (;t > cr;)t & ur && (r = r * e % n), e = e * e % n, t >>= ur; return r } function yr (e, t, n) { let r = e; for (;t-- > cr;)r *= r, r %= n; return r } function br (e, t) { if (e === cr || t <= cr) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`); let n = gr(e, t); let r = t; let i = cr; let o = ur; let a = ur; let s = cr; for (;n !== cr;) { const e = r / n; const t = r % n; const c = i - a * e; const u = o - s * e; r = n, n = t, i = a, o = s, a = c, s = u } if (r !== ur) throw new Error('invert: does not exist'); return gr(i, t) } function vr (e) { if (e % fr === dr) { const t = (e + ur) / fr; return function (e, n) { const r = e.pow(n, t); if (!e.eql(e.sqr(r), n)) throw new Error('Cannot find square root'); return r } } if (e % pr === hr) { const t = (e - hr) / pr; return function (e, n) { const r = e.mul(n, lr); const i = e.pow(r, t); const o = e.mul(n, i); const a = e.mul(e.mul(o, lr), i); const s = e.mul(o, e.sub(a, e.ONE)); if (!e.eql(e.sqr(s), n)) throw new Error('Cannot find square root'); return s } } return (function (e) { const t = (e - ur) / lr; let n, r, i; for (n = e - ur, r = 0; n % lr === cr; n /= lr, r++);for (i = lr; i < e && mr(i, t, e) !== e - ur; i++);if (r === 1) { const t = (e + ur) / fr; return function (e, n) { const r = e.pow(n, t); if (!e.eql(e.sqr(r), n)) throw new Error('Cannot find square root'); return r } } const o = (n + ur) / lr; return function (e, a) { if (e.pow(a, t) === e.neg(e.ONE)) throw new Error('Cannot find square root'); let s = r; let c = e.pow(e.mul(e.ONE, i), n); let u = e.pow(a, o); let l = e.pow(a, n); for (;!e.eql(l, e.ONE);) { if (e.eql(l, e.ZERO)) return e.ZERO; let t = 1; for (let n = e.sqr(l); t < s && !e.eql(n, e.ONE); t++)n = e.sqr(n); const n = e.pow(c, ur << BigInt(s - t - 1)); c = e.sqr(n), u = e.mul(u, n), l = e.mul(l, c), s = t } return u } }(e)) } const wr = ['create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr', 'eql', 'add', 'sub', 'mul', 'pow', 'div', 'addN', 'subN', 'mulN', 'sqrN']; function _r (e) { const t = wr.reduce((e, t) => (e[t] = 'function', e), { ORDER: 'bigint', MASK: 'bigint', BYTES: 'isSafeInteger', BITS: 'isSafeInteger' }); return sr(e, t) } function Er (e, t) { const n = void 0 !== t ? t : e.toString(2).length; return { nBitLength: n, nByteLength: Math.ceil(n / 8) } } const kr = BigInt(0); const Sr = BigInt(1); function Ar (e) { return _r(e.Fp), sr(e, { n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field' }, { nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger' }), Object.freeze({ ...Er(e.n, e.nBitLength), ...e }) } const { bytesToNumberBE: Or, hexToBytes: xr } = e; const Ir = { Err: class extends Error {constructor (e = '') { super(e) }}, _parseInt (e) { const { Err: t } = Ir; if (e.length < 2 || e[0] !== 2) throw new t('Invalid signature integer tag'); const n = e[1]; const r = e.subarray(2, n + 2); if (!n || r.length !== n) throw new t('Invalid signature integer: wrong length'); if (r[0] === 0 && r[1] <= 127) throw new t('Invalid signature integer: trailing length'); return { d: Or(r), l: e.subarray(n + 2) } }, toSig (e) { const { Err: t } = Ir; const n = typeof e === 'string' ? xr(e) : e; if (!(n instanceof Uint8Array)) throw new Error('ui8a expected'); const r = n.length; if (r < 2 || n[0] != 48) throw new t('Invalid signature tag'); if (n[1] !== r - 2) throw new t('Invalid signature: incorrect length'); const { d: i, l: o } = Ir._parseInt(n.subarray(2)); const { d: a, l: s } = Ir._parseInt(o); if (s.length) throw new t('Invalid signature: left bytes after parsing'); return { r: i, s: a } }, hexFromSig (e) { const t = e => Number.parseInt(e[0], 16) >= 8 ? '00' + e : e; const n = e => { const t = e.toString(16); return 1 & t.length ? `0${t}` : t }; const r = t(n(e.s)); const i = t(n(e.r)); const o = r.length / 2; const a = i.length / 2; const s = n(o); const c = n(a); return `30${n(a + o + 4)}02${c}${i}02${s}${r}` } }; const Nr = BigInt(0); const Tr = BigInt(1); function Rr (e) { const t = (function (e) { const t = Ar(e); sr(t, { a: 'field', b: 'field', fromBytes: 'function', toBytes: 'function' }, { allowedPrivateKeyLengths: 'array', wrapPrivateKey: 'boolean', isTorsionFree: 'function', clearCofactor: 'function', allowInfinityPoint: 'boolean' }); const { endo: n, Fp: r, a: i } = t; if (n) { if (!r.eql(i, r.ZERO)) throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0'); if (typeof n !== 'object' || typeof n.beta !== 'bigint' || typeof n.splitScalar !== 'function') throw new Error('Expected endomorphism with beta: bigint and splitScalar: function') } return Object.freeze({ ...t }) }(e)); const { Fp: n } = t; function r (e) { const { a: r, b: i } = t; const o = n.sqr(e); const a = n.mul(o, e); return n.add(n.add(a, n.mul(e, r)), i) } function i (e) { return typeof e === 'bigint' && Nr < e && e < t.n } function o (e) { if (!i(e)) throw new Error('Expected valid bigint: 0 < bigint < curve.n') } function a (e) { const { allowedPrivateKeyLengths: n, nByteLength: r, wrapPrivateKey: i, n: a } = t; if (n && typeof e !== 'bigint') { if (e instanceof Uint8Array && (e = Wn(e)), typeof e !== 'string' || !n.includes(e.length)) throw new Error('Invalid key'); e = e.padStart(2 * r, '0') } let s; try { s = typeof e === 'bigint' ? e : Yn(Qn('private key', e, r)) } catch (t) { throw new Error(`private key must be ${r} bytes, hex or bigint, not ${typeof e}`) } return i && (s = gr(s, a)), o(s), s } const s = new Map(); function c (e) { if (!(e instanceof u)) throw new Error('ProjectivePoint expected') } class u {constructor (e, t, r) { if (this.px = e, this.py = t, this.pz = r, e == null || !n.isValid(e)) throw new Error('x required'); if (t == null || !n.isValid(t)) throw new Error('y required'); if (r == null || !n.isValid(r)) throw new Error('z required') } static fromAffine (e) { const { x: t, y: r } = e || {}; if (!e || !n.isValid(t) || !n.isValid(r)) throw new Error('invalid affine point'); if (e instanceof u) throw new Error('projective point not allowed'); const i = e => n.eql(e, n.ZERO); return i(t) && i(r) ? u.ZERO : new u(t, r, n.ONE) } get x () { return this.toAffine().x } get y () { return this.toAffine().y } static normalizeZ (e) { const t = n.invertBatch(e.map(e => e.pz)); return e.map((e, n) => e.toAffine(t[n])).map(u.fromAffine) } static fromHex (e) { const n = u.fromAffine(t.fromBytes(Qn('pointHex', e))); return n.assertValidity(), n } static fromPrivateKey (e) { return u.BASE.multiply(a(e)) }_setWindowSize (e) { this._WINDOW_SIZE = e, s.delete(this) }assertValidity () { if (this.is0()) { if (t.allowInfinityPoint) return; throw new Error('bad point: ZERO') } const { x: e, y: i } = this.toAffine(); if (!n.isValid(e) || !n.isValid(i)) throw new Error('bad point: x or y not FE'); const o = n.sqr(i); const a = r(e); if (!n.eql(o, a)) throw new Error('bad point: equation left != right'); if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup') }hasEvenY () { const { y: e } = this.toAffine(); if (n.isOdd) return !n.isOdd(e); throw new Error("Field doesn't support isOdd") }equals (e) { c(e); const { px: t, py: r, pz: i } = this; const { px: o, py: a, pz: s } = e; const u = n.eql(n.mul(t, s), n.mul(o, i)); const l = n.eql(n.mul(r, s), n.mul(a, i)); return u && l }negate () { return new u(this.px, n.neg(this.py), this.pz) }double () { const { a: e, b: r } = t; const i = n.mul(r, 3n); const { px: o, py: a, pz: s } = this; let c = n.ZERO; let l = n.ZERO; let d = n.ZERO; let f = n.mul(o, o); const h = n.mul(a, a); let p = n.mul(s, s); let g = n.mul(o, a); return g = n.add(g, g), d = n.mul(o, s), d = n.add(d, d), c = n.mul(e, d), l = n.mul(i, p), l = n.add(c, l), c = n.sub(h, l), l = n.add(h, l), l = n.mul(c, l), c = n.mul(g, c), d = n.mul(i, d), p = n.mul(e, p), g = n.sub(f, p), g = n.mul(e, g), g = n.add(g, d), d = n.add(f, f), f = n.add(d, f), f = n.add(f, p), f = n.mul(f, g), l = n.add(l, f), p = n.mul(a, s), p = n.add(p, p), f = n.mul(p, g), c = n.sub(c, f), d = n.mul(p, h), d = n.add(d, d), d = n.add(d, d), new u(c, l, d) }add (e) { c(e); const { px: r, py: i, pz: o } = this; const { px: a, py: s, pz: l } = e; let d = n.ZERO; let f = n.ZERO; let h = n.ZERO; const p = t.a; const g = n.mul(t.b, 3n); let m = n.mul(r, a); let y = n.mul(i, s); let b = n.mul(o, l); let v = n.add(r, i); let w = n.add(a, s); v = n.mul(v, w), w = n.add(m, y), v = n.sub(v, w), w = n.add(r, o); let _ = n.add(a, l); return w = n.mul(w, _), _ = n.add(m, b), w = n.sub(w, _), _ = n.add(i, o), d = n.add(s, l), _ = n.mul(_, d), d = n.add(y, b), _ = n.sub(_, d), h = n.mul(p, w), d = n.mul(g, b), h = n.add(d, h), d = n.sub(y, h), h = n.add(y, h), f = n.mul(d, h), y = n.add(m, m), y = n.add(y, m), b = n.mul(p, b), w = n.mul(g, w), y = n.add(y, b), b = n.sub(m, b), b = n.mul(p, b), w = n.add(w, b), m = n.mul(y, w), f = n.add(f, m), m = n.mul(_, w), d = n.mul(v, d), d = n.sub(d, m), m = n.mul(v, y), h = n.mul(_, h), h = n.add(h, m), new u(d, f, h) }subtract (e) { return this.add(e.negate()) }is0 () { return this.equals(u.ZERO) }wNAF (e) { return d.wNAFCached(this, s, e, e => { const t = n.invertBatch(e.map(e => e.pz)); return e.map((e, n) => e.toAffine(t[n])).map(u.fromAffine) }) }multiplyUnsafe (e) { const r = u.ZERO; if (e === Nr) return r; if (o(e), e === Tr) return this; const { endo: i } = t; if (!i) return d.unsafeLadder(this, e); let { k1neg: a, k1: s, k2neg: c, k2: l } = i.splitScalar(e); let f = r; let h = r; let p = this; for (;s > Nr || l > Nr;)s & Tr && (f = f.add(p)), l & Tr && (h = h.add(p)), p = p.double(), s >>= Tr, l >>= Tr; return a && (f = f.negate()), c && (h = h.negate()), h = new u(n.mul(h.px, i.beta), h.py, h.pz), f.add(h) }multiply (e) { o(e); let r; let i; const a = e; const { endo: s } = t; if (s) { const { k1neg: e, k1: t, k2neg: o, k2: c } = s.splitScalar(a); let { p: l, f } = this.wNAF(t); let { p: h, f: p } = this.wNAF(c); l = d.constTimeNegate(e, l), h = d.constTimeNegate(o, h), h = new u(n.mul(h.px, s.beta), h.py, h.pz), r = l.add(h), i = f.add(p) } else { const { p: e, f: t } = this.wNAF(a); r = e, i = t } return u.normalizeZ([r, i])[0] }multiplyAndAddUnsafe (e, t, n) { const r = u.BASE; const i = (e, t) => t !== Nr && t !== Tr && e.equals(r) ? e.multiply(t) : e.multiplyUnsafe(t); const o = i(this, t).add(i(e, n)); return o.is0() ? void 0 : o }toAffine (e) { const { px: t, py: r, pz: i } = this; const o = this.is0(); e == null && (e = o ? n.ONE : n.inv(i)); const a = n.mul(t, e); const s = n.mul(r, e); const c = n.mul(i, e); if (o) return { x: n.ZERO, y: n.ZERO }; if (!n.eql(c, n.ONE)) throw new Error('invZ was invalid'); return { x: a, y: s } }isTorsionFree () { const { h: e, isTorsionFree: n } = t; if (e === Tr) return !0; if (n) return n(u, this); throw new Error('isTorsionFree() has not been declared for the elliptic curve') }clearCofactor () { const { h: e, clearCofactor: n } = t; return e === Tr ? this : n ? n(u, this) : this.multiplyUnsafe(t.h) }toRawBytes (e = !0) { return this.assertValidity(), t.toBytes(u, this, e) }toHex (e = !0) { return Wn(this.toRawBytes(e)) }}u.BASE = new u(t.Gx, t.Gy, n.ONE), u.ZERO = new u(n.ZERO, n.ONE, n.ZERO); const l = t.nBitLength; const d = (function (e, t) { const n = (e, t) => { const n = t.negate(); return e ? n : t }; const r = e => ({ windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1) }); return { constTimeNegate: n, unsafeLadder (t, n) { let r = e.ZERO; let i = t; for (;n > kr;)n & Sr && (r = r.add(i)), i = i.double(), n >>= Sr; return r }, precomputeWindow (e, t) { const { windows: n, windowSize: i } = r(t); const o = []; let a = e; let s = a; for (let e = 0; e < n; e++) { s = a, o.push(s); for (let e = 1; e < i; e++)s = s.add(a), o.push(s); a = s.double() } return o }, wNAF (t, i, o) { const { windows: a, windowSize: s } = r(t); let c = e.ZERO; let u = e.BASE; const l = BigInt(2 ** t - 1); const d = 2 ** t; const f = BigInt(t); for (let e = 0; e < a; e++) { const t = e * s; let r = Number(o & l); o >>= f, r > s && (r -= d, o += Sr); const a = t; const h = t + Math.abs(r) - 1; const p = e % 2 != 0; const g = r < 0; r === 0 ? u = u.add(n(p, i[a])) : c = c.add(n(g, i[h])) } return { p: c, f: u } }, wNAFCached (e, t, n, r) { const i = e._WINDOW_SIZE || 1; let o = t.get(e); return o || (o = this.precomputeWindow(e, i), i !== 1 && t.set(e, r(o))), this.wNAF(i, o, n) } } }(u, t.endo ? Math.ceil(l / 2) : l)); return { ProjectivePoint: u, normPrivateKeyToScalar: a, weierstrassEquation: r, isWithinCurveOrder: i } } function Pr (e) { const t = (function (e) { const t = Ar(e); return sr(t, { hash: 'hash', hmac: 'function', randomBytes: 'function' }, { bits2int: 'function', bits2int_modN: 'function', lowS: 'boolean' }), Object.freeze({ lowS: !0, ...t }) }(e)); const n = t.n; const r = t.Fp; const i = r.BYTES + 1; const o = 2 * r.BYTES + 1; function a (e) { return gr(e, n) } function s (e) { return br(e, n) } const { ProjectivePoint: c, normPrivateKeyToScalar: u, weierstrassEquation: l, isWithinCurveOrder: d } = Rr({ ...t, toBytes (e, t, n) { const i = t.toAffine(); const o = r.toBytes(i.x); const a = er; return n ? a(Uint8Array.from([t.hasEvenY() ? 2 : 3]), o) : a(Uint8Array.from([4]), o, r.toBytes(i.y)) }, fromBytes (e) { const t = e.length; const n = e[0]; const a = e.subarray(1); if (t !== i || n !== 2 && n !== 3) { if (t === o && n === 4) { return { x: r.fromBytes(a.subarray(0, r.BYTES)), y: r.fromBytes(a.subarray(r.BYTES, 2 * r.BYTES)) } } throw new Error(`Point of length ${t} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`) } { const e = Yn(a); if (!(Nr < (s = e) && s < r.ORDER)) throw new Error('Point is not on curve'); const t = l(e); let i = r.sqrt(t); return (1 & n) == 1 !== ((i & Tr) === Tr) && (i = r.neg(i)), { x: e, y: i } } let s } }); const f = e => Wn(Jn(e, t.nByteLength)); function h (e) { return e > n >> Tr } const p = (e, t, n) => Yn(e.slice(t, n)); class g {constructor (e, t, n) { this.r = e, this.s = t, this.recovery = n, this.assertValidity() } static fromCompact (e) { const n = t.nByteLength; return e = Qn('compactSignature', e, 2 * n), new g(p(e, 0, n), p(e, n, 2 * n)) } static fromDER (e) { const { r: t, s: n } = Ir.toSig(Qn('DER', e)); return new g(t, n) }assertValidity () { if (!d(this.r)) throw new Error('r must be 0 < r < CURVE.n'); if (!d(this.s)) throw new Error('s must be 0 < s < CURVE.n') }addRecoveryBit (e) { return new g(this.r, this.s, e) }recoverPublicKey (e) { const { r: n, s: i, recovery: o } = this; const u = v(Qn('msgHash', e)); if (o == null || ![0, 1, 2, 3].includes(o)) throw new Error('recovery id invalid'); const l = o === 2 || o === 3 ? n + t.n : n; if (l >= r.ORDER) throw new Error('recovery id 2 or 3 invalid'); const d = (1 & o) == 0 ? '02' : '03'; const h = c.fromHex(d + f(l)); const p = s(l); const g = a(-u * p); const m = a(i * p); const y = c.BASE.multiplyAndAddUnsafe(h, g, m); if (!y) throw new Error('point at infinify'); return y.assertValidity(), y }hasHighS () { return h(this.s) }normalizeS () { return this.hasHighS() ? new g(this.r, a(-this.s), this.recovery) : this }toDERRawBytes () { return Gn(this.toDERHex()) }toDERHex () { return Ir.hexFromSig({ r: this.r, s: this.s }) }toCompactRawBytes () { return Gn(this.toCompactHex()) }toCompactHex () { return f(this.r) + f(this.s) }} const m = { isValidPrivateKey (e) { try { return u(e), !0 } catch (e) { return !1 } }, normPrivateKeyToScalar: u, randomPrivateKey: () => { const e = (function (e, t, n = !1) { const r = (e = Qn('privateHash', e)).length; const i = Er(t).nByteLength + 8; if (i < 24 || r < i || r > 1024) throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${r}`); return gr(n ? Zn(e) : Yn(e), t - ur) + ur }(t.randomBytes(r.BYTES + 8), n)); return Jn(e, t.nByteLength) }, precompute: (e = 8, t = c.BASE) => (t._setWindowSize(e), t.multiply(BigInt(3)), t) }; function y (e) { const t = e instanceof Uint8Array; const n = typeof e === 'string'; const r = (t || n) && e.length; return t ? r === i || r === o : n ? r === 2 * i || r === 2 * o : e instanceof c } const b = t.bits2int || function (e) { const n = Yn(e); const r = 8 * e.length - t.nBitLength; return r > 0 ? n >> BigInt(r) : n }; const v = t.bits2int_modN || function (e) { return a(b(e)) }; const w = nr(t.nBitLength); function _ (e) { if (typeof e !== 'bigint') throw new Error('bigint expected'); if (!(Nr <= e && e < w)) throw new Error(`bigint expected < 2^${t.nBitLength}`); return Jn(e, t.nByteLength) } function E (e, n, i = k) { if (['recovered', 'canonical'].some(e => e in i)) throw new Error('sign() legacy options not supported'); const { hash: o, randomBytes: l } = t; let { lowS: f, prehash: p, extraEntropy: m } = i; f == null && (f = !0), e = Qn('msgHash', e), p && (e = Qn('prehashed msgHash', o(e))); const y = v(e); const w = u(n); const E = [_(w), _(y)]; if (m != null) { const e = !0 === m ? l(r.BYTES) : m; E.push(Qn('extraEntropy', e, r.BYTES)) } const S = er(...E); const A = y; return { seed: S, k2sig: function (e) { const t = b(e); if (!d(t)) return; const n = s(t); const r = c.BASE.multiply(t).toAffine(); const i = a(r.x); if (i === Nr) return; const o = a(n * a(A + i * w)); if (o === Nr) return; let u = (r.x === i ? 0 : 2) | Number(r.y & Tr); let l = o; return f && h(o) && (l = (function (e) { return h(e) ? a(-e) : e }(o)), u ^= 1), new g(i, l, u) } } } const k = { lowS: t.lowS, prehash: !1 }; const S = { lowS: t.lowS, prehash: !1 }; return c.BASE._setWindowSize(8), { CURVE: t, getPublicKey: function (e, t = !0) { return c.fromPrivateKey(e).toRawBytes(t) }, getSharedSecret: function (e, t, n = !0) { if (y(e)) throw new Error('first arg must be private key'); if (!y(t)) throw new Error('second arg must be public key'); return c.fromHex(t).multiply(u(e)).toRawBytes(n) }, sign: function (e, n, r = k) { const { seed: i, k2sig: o } = E(e, n, r); return or(t.hash.outputLen, t.nByteLength, t.hmac)(i, o) }, verify: function (e, n, r, i = S) { const o = e; if (n = Qn('msgHash', n), r = Qn('publicKey', r), 'strict' in i) throw new Error('options.strict was renamed to lowS'); const { lowS: u, prehash: l } = i; let d, f; try { if (typeof o === 'string' || o instanceof Uint8Array) try { d = g.fromDER(o) } catch (e) { if (!(e instanceof Ir.Err)) throw e; d = g.fromCompact(o) } else { if (typeof o !== 'object' || typeof o.r !== 'bigint' || typeof o.s !== 'bigint') throw new Error('PARSE'); { const { r: e, s: t } = o; d = new g(e, t) } }f = c.fromHex(r) } catch (e) { if (e.message === 'PARSE') throw new Error('signature must be Signature instance, Uint8Array or hex string'); return !1 } if (u && d.hasHighS()) return !1; l && (n = t.hash(n)); const { r: h, s: p } = d; const m = v(n); const y = s(p); const b = a(m * y); const w = a(h * y); const _ = c.BASE.multiplyAndAddUnsafe(f, b, w)?.toAffine(); return !!_ && a(_.x) === h }, ProjectivePoint: c, Signature: g, utils: m } } const Cr = Yn; function Br (e, t) { if (e < 0 || e >= 1 << 8 * t) throw new Error(`bad I2OSP call: value=${e} length=${t}`); const n = Array.from({ length: t }).fill(0); for (let r = t - 1; r >= 0; r--)n[r] = 255 & e, e >>>= 8; return new Uint8Array(n) } function Lr (e, t) { const n = new Uint8Array(e.length); for (let r = 0; r < e.length; r++)n[r] = e[r] ^ t[r]; return n } function jr (e) { if (!(e instanceof Uint8Array)) throw new Error('Uint8Array expected') } function Dr (e) { if (!Number.isSafeInteger(e)) throw new Error('number expected') } function Ur (e, t, n) { sr(n, { DST: 'string', p: 'bigint', m: 'isSafeInteger', k: 'isSafeInteger', hash: 'hash' }); const { p: r, k: i, m: o, hash: a, expand: s, DST: c } = n; jr(e), Dr(t); const u = (function (e) { if (e instanceof Uint8Array) return e; if (typeof e === 'string') return tr(e); throw new Error('DST must be Uint8Array or string') }(c)); const l = r.toString(2).length; const d = Math.ceil((l + i) / 8); const f = t * o * d; let h; if (s === 'xmd')h = (function (e, t, n, r) { jr(e), jr(t), Dr(n), t.length > 255 && (t = r(er(tr('H2C-OVERSIZE-DST-'), t))); const { outputLen: i, blockLen: o } = r; const a = Math.ceil(n / i); if (a > 255) throw new Error('Invalid xmd length'); const s = er(t, Br(t.length, 1)); const c = Br(0, o); const u = Br(n, 2); const l = new Array(a); const d = r(er(c, e, u, Br(0, 1), s)); l[0] = r(er(d, Br(1, 1), s)); for (let e = 1; e <= a; e++) { const t = [Lr(d, l[e - 1]), Br(e + 1, 1), s]; l[e] = r(er(...t)) } return er(...l).slice(0, n) }(e, u, f, a)); else if (s === 'xof')h = (function (e, t, n, r, i) { if (jr(e), jr(t), Dr(n), t.length > 255) { const e = Math.ceil(2 * r / 8); t = i.create({ dkLen: e }).update(tr('H2C-OVERSIZE-DST-')).update(t).digest() } if (n > 65535 || t.length > 255) throw new Error('expand_message_xof: invalid lenInBytes'); return i.create({ dkLen: n }).update(e).update(Br(n, 2)).update(t).update(Br(t.length, 1)).digest() }(e, u, f, i, a)); else { if (void 0 !== s) throw new Error('expand must be "xmd", "xof" or undefined'); h = e } const p = new Array(t); for (let e = 0; e < t; e++) { const t = new Array(o); for (let n = 0; n < o; n++) { const i = d * (n + e * o); const a = h.subarray(i, i + d); t[n] = gr(Cr(a), r) }p[e] = t } return p } class Mr extends Tn {constructor (e, t) { super(), this.finished = !1, this.destroyed = !1, An.hash(e); const n = Nn(t); if (this.iHash = e.create(), typeof this.iHash.update !== 'function') throw new TypeError('Expected instance of class which extends utils.Hash'); this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen; const r = this.blockLen; const i = new Uint8Array(r); i.set(n.length > r ? e.create().update(n).digest() : n); for (let e = 0; e < i.length; e++)i[e] ^= 54; this.iHash.update(i), this.oHash = e.create(); for (let e = 0; e < i.length; e++)i[e] ^= 106; this.oHash.update(i), i.fill(0) }update (e) { return An.exists(this), this.iHash.update(e), this }digestInto (e) { An.exists(this), An.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy() }digest () { const e = new Uint8Array(this.oHash.outputLen); return this.digestInto(e), e }_cloneInto (e) { e || (e = Object.create(Object.getPrototypeOf(this), {})); const { oHash: t, iHash: n, finished: r, destroyed: i, blockLen: o, outputLen: a } = this; return e.finished = r, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e }destroy () { this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy() }} const zr = (e, t, n) => new Mr(e, t).update(n).digest(); function Fr (e) { return { hash: e, hmac: (t, ...n) => zr(e, t, (function (...e) { if (!e.every(e => e instanceof Uint8Array)) throw new Error('Uint8Array list expected'); if (e.length === 1) return e[0]; const t = e.reduce((e, t) => e + t.length, 0); const n = new Uint8Array(t); for (let t = 0, r = 0; t < e.length; t++) { const i = e[t]; n.set(i, r), r += i.length } return n }(...n))), randomBytes: Pn } }zr.create = (e, t) => new Mr(e, t); const Hr = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'); const qr = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'); const Kr = BigInt(1); const Vr = BigInt(2); const Wr = (e, t) => (e + t / Vr) / t; function $r (e) { const t = Hr; const n = BigInt(3); const r = BigInt(6); const i = BigInt(11); const o = BigInt(22); const a = BigInt(23); const s = BigInt(44); const c = BigInt(88); const u = e * e * e % t; const l = u * u * e % t; const d = yr(l, n, t) * l % t; const f = yr(d, n, t) * l % t; const h = yr(f, Vr, t) * u % t; const p = yr(h, i, t) * h % t; const g = yr(p, o, t) * p % t; const m = yr(g, s, t) * g % t; const y = yr(m, c, t) * m % t; const b = yr(y, s, t) * g % t; const v = yr(b, n, t) * l % t; const w = yr(v, a, t) * p % t; const _ = yr(w, r, t) * u % t; const E = yr(_, Vr, t); if (!Gr.eql(Gr.sqr(E), e)) throw new Error('Cannot find square root'); return E } const Gr = (function (e, t, n = !1, r = {}) { if (e <= cr) throw new Error(`Expected Fp ORDER > 0, got ${e}`); const { nBitLength: i, nByteLength: o } = Er(e, t); if (o > 2048) throw new Error('Field lengths over 2048 bytes are not supported'); const a = vr(e); const s = Object.freeze({ ORDER: e, BITS: i, BYTES: o, MASK: nr(i), ZERO: cr, ONE: ur, create: t => gr(t, e), isValid: t => { if (typeof t !== 'bigint') throw new Error('Invalid field element: expected bigint, got ' + typeof t); return cr <= t && t < e }, is0: e => e === cr, isOdd: e => (e & ur) === ur, neg: t => gr(-t, e), eql: (e, t) => e === t, sqr: t => gr(t * t, e), add: (t, n) => gr(t + n, e), sub: (t, n) => gr(t - n, e), mul: (t, n) => gr(t * n, e), pow: (e, t) => (function (e, t, n) { if (n < cr) throw new Error('Expected power > 0'); if (n === cr) return e.ONE; if (n === ur) return t; let r = e.ONE; let i = t; for (;n > cr;)n & ur && (r = e.mul(r, i)), i = e.sqr(i), n >>= 1n; return r }(s, e, t)), div: (t, n) => gr(t * br(n, e), e), sqrN: e => e * e, addN: (e, t) => e + t, subN: (e, t) => e - t, mulN: (e, t) => e * t, inv: t => br(t, e), sqrt: r.sqrt || (e => a(s, e)), invertBatch: e => (function (e, t) { const n = new Array(t.length); const r = t.reduce((t, r, i) => e.is0(r) ? t : (n[i] = t, e.mul(t, r)), e.ONE); const i = e.inv(r); return t.reduceRight((t, r, i) => e.is0(r) ? t : (n[i] = e.mul(t, n[i]), e.mul(t, r)), i), n }(s, e)), cmov: (e, t, n) => n ? t : e, toBytes: e => n ? Xn(e, o) : Jn(e, o), fromBytes: e => { if (e.length !== o) throw new Error(`Fp.fromBytes: expected ${o}, got ${e.length}`); return n ? Zn(e) : Yn(e) } }); return Object.freeze(s) }(Hr, void 0, void 0, { sqrt: $r })); const Yr = (function (e, t) { const n = t => Pr({ ...e, ...Fr(t) }); return Object.freeze({ ...n(t), create: n }) }({ a: BigInt(0), b: BigInt(7), Fp: Gr, n: qr, Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'), Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'), h: BigInt(1), lowS: !0, endo: { beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'), splitScalar: e => { const t = qr; const n = BigInt('0x3086d221a7d46bcde86c90e49284eb15'); const r = -Kr * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'); const i = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'); const o = n; const a = BigInt('0x100000000000000000000000000000000'); const s = Wr(o * e, t); const c = Wr(-r * e, t); let u = gr(e - s * n - c * i, t); let l = gr(-s * r - c * o, t); const d = u > a; const f = l > a; if (d && (u = t - u), f && (l = t - l), u > a || l > a) throw new Error('splitScalar: Endomorphism failed, k=' + e); return { k1neg: d, k1: u, k2neg: f, k2: l } } } }, Fn)); const Zr = BigInt(0); const Jr = e => typeof e === 'bigint' && Zr < e && e < Hr; const Xr = e => typeof e === 'bigint' && Zr < e && e < qr; const Qr = {}; function ei (e, ...t) { let n = Qr[e]; if (void 0 === n) { const t = Fn(Uint8Array.from(e, e => e.charCodeAt(0))); n = er(t, t), Qr[e] = n } return Fn(er(n, ...t)) } const ti = e => e.toRawBytes(!0).slice(1); const ni = e => Jn(e, 32); const ri = e => gr(e, Hr); const ii = e => gr(e, qr); const oi = Yr.ProjectivePoint; const ai = (e, t, n) => oi.BASE.multiplyAndAddUnsafe(e, t, n); function si (e) { const t = Yr.utils.normPrivateKeyToScalar(e); const n = oi.fromPrivateKey(t); return { scalar: n.hasEvenY() ? t : ii(-t), bytes: ti(n) } } function ci (e) { if (!Jr(e)) throw new Error('bad x: need 0 < x < p'); const t = ri(e * e); let n = $r(ri(t * e + BigInt(7))); n % 2n !== 0n && (n = ri(-n)); const r = new oi(e, n, Kr); return r.assertValidity(), r } function ui (...e) { return ii(Yn(ei('BIP0340/challenge', ...e))) } function li (e, t, n) { const r = Qn('signature', e, 64); const i = Qn('message', t); const o = Qn('publicKey', n, 32); try { const e = ci(Yn(o)); const t = Yn(r.subarray(0, 32)); if (!Jr(t)) return !1; const n = Yn(r.subarray(32, 64)); if (!Xr(n)) return !1; const a = ui(ni(t), ti(e), i); const s = ai(e, n, ii(-a)); return !(!s || !s.hasEvenY() || s.toAffine().x !== t) } catch (e) { return !1 } } const di = { getPublicKey: function (e) { return si(e).bytes }, sign: function (e, t, n = Pn(32)) { const r = Qn('message', e); const { bytes: i, scalar: o } = si(t); const a = Qn('auxRand', n, 32); const s = ni(o ^ Yn(ei('BIP0340/aux', a))); const c = ei('BIP0340/nonce', s, i, r); const u = ii(Yn(c)); if (u === Zr) throw new Error('sign failed: k is zero'); const { bytes: l, scalar: d } = si(u); const f = ui(l, i, r); const h = new Uint8Array(64); if (h.set(l, 0), h.set(ni(ii(d + f * o)), 32), !li(h, r, i)) throw new Error('sign: Invalid signature produced'); return h }, verify: li, utils: { randomPrivateKey: Yr.utils.randomPrivateKey, lift_x: ci, pointToBytes: ti, numberToBytesBE: Jn, bytesToNumberBE: Yn, taggedHash: ei, mod: gr } }; const fi = (function (e, t) { const n = t.map(e => Array.from(e).reverse()); return (t, r) => { const [i, o, a, s] = n.map(n => n.reduce((n, r) => e.add(e.mul(n, t), r))); return t = e.div(i, o), r = e.mul(r, e.div(a, s)), { x: t, y: r } } }(Gr, [['0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7', '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581', '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262', '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'], ['0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b', '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14', '0x0000000000000000000000000000000000000000000000000000000000000001'], ['0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c', '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3', '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931', '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'], ['0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b', '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573', '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f', '0x0000000000000000000000000000000000000000000000000000000000000001']].map(e => e.map(e => BigInt(e))))); const hi = (function (e, t) { if (_r(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts'); const n = (function (e, t) { const n = e.ORDER; let r = 0n; for (let e = n - 1n; e % 2n === 0n; e /= 2n)r += 1n; const i = r; const o = (n - 1n) / 2n ** i; const a = (o - 1n) / 2n; const s = 2n ** i - 1n; const c = 2n ** (i - 1n); const u = e.pow(t, o); const l = e.pow(t, (o + 1n) / 2n); let d = (t, n) => { let r = u; let o = e.pow(n, s); let d = e.sqr(o); d = e.mul(d, n); let f = e.mul(t, d); f = e.pow(f, a), f = e.mul(f, o), o = e.mul(f, n), d = e.mul(f, t); let h = e.mul(d, o); f = e.pow(h, c); const p = e.eql(f, e.ONE); o = e.mul(d, l), f = e.mul(h, r), d = e.cmov(o, d, p), h = e.cmov(f, h, p); for (let t = i; t > 1; t--) { const n = 2n ** (t - 2n); let i = e.pow(h, n); const a = e.eql(i, e.ONE); o = e.mul(d, r), r = e.mul(r, r), i = e.mul(h, r), d = e.cmov(o, d, a), h = e.cmov(i, h, a) } return { isValid: p, value: d } }; if (e.ORDER % 4n === 3n) { const n = (e.ORDER - 3n) / 4n; const r = e.sqrt(e.neg(t)); d = (t, i) => { let o = e.sqr(i); const a = e.mul(t, i); o = e.mul(o, a); let s = e.pow(o, n); s = e.mul(s, a); const c = e.mul(s, r); const u = e.mul(e.sqr(s), i); const l = e.eql(u, t); return { isValid: l, value: e.cmov(c, s, l) } } } return d }(e, t.Z)); if (!e.isOdd) throw new Error('Fp.isOdd is not implemented!'); return r => { let i, o, a, s, c, u, l, d; i = e.sqr(r), i = e.mul(i, t.Z), o = e.sqr(i), o = e.add(o, i), a = e.add(o, e.ONE), a = e.mul(a, t.B), s = e.cmov(t.Z, e.neg(o), !e.eql(o, e.ZERO)), s = e.mul(s, t.A), o = e.sqr(a), u = e.sqr(s), c = e.mul(u, t.A), o = e.add(o, c), o = e.mul(o, a), u = e.mul(u, s), c = e.mul(u, t.B), o = e.add(o, c), l = e.mul(i, a); const { isValid: f, value: h } = n(o, u); d = e.mul(i, r), d = e.mul(d, h), l = e.cmov(l, a, f), d = e.cmov(d, h, f); const p = e.isOdd(r) === e.isOdd(d); return d = e.cmov(e.neg(d), d, p), l = e.div(l, s), { x: l, y: d } } }(Gr, { A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'), B: BigInt('1771'), Z: Gr.create(BigInt('-11')) })); const { hashToCurve: pi, encodeToCurve: gi } = (function (e, t, n) { if (typeof t !== 'function') throw new Error('mapToCurve() must be defined'); return { hashToCurve (r, i) { const o = Ur(r, 2, { ...n, DST: n.DST, ...i }); const a = e.fromAffine(t(o[0])); const s = e.fromAffine(t(o[1])); const c = a.add(s).clearCofactor(); return c.assertValidity(), c }, encodeToCurve (r, i) { const o = Ur(r, 1, { ...n, DST: n.encodeDST, ...i }); const a = e.fromAffine(t(o[0])).clearCofactor(); return a.assertValidity(), a } } }(Yr.ProjectivePoint, e => { const { x: t, y: n } = hi(Gr.create(e[0])); return fi(t, n) }, { DST: 'secp256k1_XMD:SHA-256_SSWU_RO_', encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_', p: Gr.ORDER, m: 1, k: 128, expand: 'xmd', hash: Fn })); function mi (e) { if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`) } function yi (e, ...t) { if (!(e instanceof Uint8Array)) throw new Error('Expected Uint8Array'); if (t.length > 0 && !t.includes(e.length)) throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`) } const bi = { number: mi, bool: function (e) { if (typeof e !== 'boolean') throw new Error(`Expected boolean, not ${e}`) }, bytes: yi, hash: function (e) { if (typeof e !== 'function' || typeof e.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor'); mi(e.outputLen), mi(e.blockLen) }, exists: function (e, t = !0) { if (e.destroyed) throw new Error('Hash instance has been destroyed'); if (t && e.finished) throw new Error('Hash#digest() has already been called') }, output: function (e, t) { yi(e); const n = t.outputLen; if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`) } }; const vi = bi; const wi = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0; const _i = e => e instanceof Uint8Array; const Ei = e => new DataView(e.buffer, e.byteOffset, e.byteLength); const ki = (e, t) => e << 32 - t | e >>> t; if (!(new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)) throw new Error('Non little-endian hardware is not supported'); const Si = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0')); function Ai (e) { if (typeof e !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof e); return new Uint8Array((new TextEncoder()).encode(e)) } function Oi (e) { if (typeof e === 'string' && (e = Ai(e)), !_i(e)) throw new Error('expected Uint8Array, got ' + typeof e); return e } function xi (...e) { const t = new Uint8Array(e.reduce((e, t) => e + t.length, 0)); let n = 0; return e.forEach(e => { if (!_i(e)) throw new Error('Uint8Array expected'); t.set(e, n), n += e.length }), t } class Ii {clone () { return this._cloneInto() }} const Ni = e => Object.prototype.toString.call(e) === '[object Object]' && e.constructor === Object; function Ti (e) { const t = t => e().update(Oi(t)).digest(); const n = e(); return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t } function Ri (e = 32) { if (wi && typeof wi.getRandomValues === 'function') return wi.getRandomValues(new Uint8Array(e)); throw new Error('crypto.getRandomValues must be defined') } class Pi extends Ii {constructor (e, t, n, r) { super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Ei(this.buffer) }update (e) { vi.exists(this); const { view: t, buffer: n, blockLen: r } = this; const i = (e = Oi(e)).length; for (let o = 0; o < i;) { const a = Math.min(r - this.pos, i - o); if (a !== r)n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === r && (this.process(t, 0), this.pos = 0); else { const t = Ei(e); for (;r <= i - o; o += r) this.process(t, o) } } return this.length += e.length, this.roundClean(), this }digestInto (e) { vi.exists(this), vi.output(e, this), this.finished = !0; const { buffer: t, view: n, blockLen: r, isLE: i } = this; let { pos: o } = this; t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > r - o && (this.process(n, 0), o = 0); for (let e = o; e < r; e++)t[e] = 0; !(function (e, t, n, r) { if (typeof e.setBigUint64 === 'function') return e.setBigUint64(t, n, r); const i = BigInt(32); const o = BigInt(4294967295); const a = Number(n >> i & o); const s = Number(n & o); const c = r ? 4 : 0; const u = r ? 0 : 4; e.setUint32(t + c, a, r), e.setUint32(t + u, s, r) }(n, r - 8, BigInt(8 * this.length), i)), this.process(n, 0); const a = Ei(e); const s = this.outputLen; if (s % 4) throw new Error('_sha2: outputLen should be aligned to 32bit'); const c = s / 4; const u = this.get(); if (c > u.length) throw new Error('_sha2: outputLen bigger than state'); for (let e = 0; e < c; e++)a.setUint32(4 * e, u[e], i) }digest () { const { buffer: e, outputLen: t } = this; this.digestInto(e); const n = e.slice(0, t); return this.destroy(), n }_cloneInto (e) { e || (e = new this.constructor()), e.set(...this.get()); const { blockLen: t, buffer: n, length: r, finished: i, destroyed: o, pos: a } = this; return e.length = r, e.pos = a, e.finished = i, e.destroyed = o, r % t && e.buffer.set(n), e }} const Ci = (e, t, n) => e & t ^ ~e & n; const Bi = (e, t, n) => e & t ^ e & n ^ t & n; const Li = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]); const ji = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]); const Di = new Uint32Array(64); class Ui extends Pi {constructor () { super(64, 32, 8, !1), this.A = 0 | ji[0], this.B = 0 | ji[1], this.C = 0 | ji[2], this.D = 0 | ji[3], this.E = 0 | ji[4], this.F = 0 | ji[5], this.G = 0 | ji[6], this.H = 0 | ji[7] }get () { const { A: e, B: t, C: n, D: r, E: i, F: o, G: a, H: s } = this; return [e, t, n, r, i, o, a, s] }set (e, t, n, r, i, o, a, s) { this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | o, this.G = 0 | a, this.H = 0 | s }process (e, t) { for (let n = 0; n < 16; n++, t += 4)Di[n] = e.getUint32(t, !1); for (let e = 16; e < 64; e++) { const t = Di[e - 15]; const n = Di[e - 2]; const r = ki(t, 7) ^ ki(t, 18) ^ t >>> 3; const i = ki(n, 17) ^ ki(n, 19) ^ n >>> 10; Di[e] = i + Di[e - 7] + r + Di[e - 16] | 0 } let { A: n, B: r, C: i, D: o, E: a, F: s, G: c, H: u } = this; for (let e = 0; e < 64; e++) { const t = u + (ki(a, 6) ^ ki(a, 11) ^ ki(a, 25)) + Ci(a, s, c) + Li[e] + Di[e] | 0; const l = (ki(n, 2) ^ ki(n, 13) ^ ki(n, 22)) + Bi(n, r, i) | 0; u = c, c = s, s = a, a = o + t | 0, o = i, i = r, r = n, n = t + l | 0 }n = n + this.A | 0, r = r + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, s = s + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(n, r, i, o, a, s, c, u) }roundClean () { Di.fill(0) }destroy () { this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0) }} class Mi extends Ui {constructor () { super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28 }} const zi = Ti(() => new Ui()); const Fi = (Ti(() => new Mi()), new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8])); const Hi = Uint8Array.from({ length: 16 }, (e, t) => t); const qi = Hi.map(e => (9 * e + 5) % 16); const Ki = [Hi]; const Vi = [qi]; for (let e = 0; e < 4; e++) for (const t of [Ki, Vi])t.push(t[e].map(e => Fi[e])); const Wi = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(e => new Uint8Array(e)); const $i = Ki.map((e, t) => e.map(e => Wi[t][e])); const Gi = Vi.map((e, t) => e.map(e => Wi[t][e])); const Yi = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]); const Zi = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]); const Ji = (e, t) => e << t | e >>> 32 - t; function Xi (e, t, n, r) { return e === 0 ? t ^ n ^ r : e === 1 ? t & n | ~t & r : e === 2 ? (t | ~n) ^ r : e === 3 ? t & r | n & ~r : t ^ (n | ~r) } const Qi = new Uint32Array(16); class eo extends Pi {constructor () { super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776 }get () { const { h0: e, h1: t, h2: n, h3: r, h4: i } = this; return [e, t, n, r, i] }set (e, t, n, r, i) { this.h0 = 0 | e, this.h1 = 0 | t, this.h2 = 0 | n, this.h3 = 0 | r, this.h4 = 0 | i }process (e, t) { for (let n = 0; n < 16; n++, t += 4)Qi[n] = e.getUint32(t, !0); let n = 0 | this.h0; let r = n; let i = 0 | this.h1; let o = i; let a = 0 | this.h2; let s = a; let c = 0 | this.h3; let u = c; let l = 0 | this.h4; let d = l; for (let e = 0; e < 5; e++) { const t = 4 - e; const f = Yi[e]; const h = Zi[e]; const p = Ki[e]; const g = Vi[e]; const m = $i[e]; const y = Gi[e]; for (let t = 0; t < 16; t++) { const r = Ji(n + Xi(e, i, a, c) + Qi[p[t]] + f, m[t]) + l | 0; n = l, l = c, c = 0 | Ji(a, 10), a = i, i = r } for (let e = 0; e < 16; e++) { const n = Ji(r + Xi(t, o, s, u) + Qi[g[e]] + h, y[e]) + d | 0; r = d, d = u, u = 0 | Ji(s, 10), s = o, o = n } } this.set(this.h1 + a + u | 0, this.h2 + c + d | 0, this.h3 + l + r | 0, this.h4 + n + o | 0, this.h0 + i + s | 0) }roundClean () { Qi.fill(0) }destroy () { this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0) }} const to = Ti(() => new eo()); function no (e) { if (!Number.isSafeInteger(e)) throw new Error(`Wrong integer: ${e}`) } function ro (...e) { const t = (e, t) => n => e(t(n)); const n = Array.from(e).reverse().reduce((e, n) => e ? t(e, n.encode) : n.encode, void 0); const r = e.reduce((e, n) => e ? t(e, n.decode) : n.decode, void 0); return { encode: n, decode: r } } function io (e) { return { encode: t => { if (!Array.isArray(t) || t.length && typeof t[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers'); return t.map(t => { if (no(t), t < 0 || t >= e.length) throw new Error(`Digit index outside alphabet: ${t} (alphabet: ${e.length})`); return e[t] }) }, decode: t => { if (!Array.isArray(t) || t.length && typeof t[0] !== 'string') throw new Error('alphabet.decode input should be array of strings'); return t.map(t => { if (typeof t !== 'string') throw new Error(`alphabet.decode: not string element=${t}`); const n = e.indexOf(t); if (n === -1) throw new Error(`Unknown letter: "${t}". Allowed: ${e}`); return n }) } } } function oo (e = '') { if (typeof e !== 'string') throw new Error('join separator should be string'); return { encode: t => { if (!Array.isArray(t) || t.length && typeof t[0] !== 'string') throw new Error('join.encode input should be array of strings'); for (const e of t) if (typeof e !== 'string') throw new Error(`join.encode: non-string input=${e}`); return t.join(e) }, decode: t => { if (typeof t !== 'string') throw new Error('join.decode input should be string'); return t.split(e) } } } function ao (e, t = '=') { if (no(e), typeof t !== 'string') throw new Error('padding chr should be string'); return { encode (n) { if (!Array.isArray(n) || n.length && typeof n[0] !== 'string') throw new Error('padding.encode input should be array of strings'); for (const e of n) if (typeof e !== 'string') throw new Error(`padding.encode: non-string input=${e}`); for (;n.length * e % 8;)n.push(t); return n }, decode (n) { if (!Array.isArray(n) || n.length && typeof n[0] !== 'string') throw new Error('padding.encode input should be array of strings'); for (const e of n) if (typeof e !== 'string') throw new Error(`padding.decode: non-string input=${e}`); let r = n.length; if (r * e % 8) throw new Error('Invalid padding: string should have whole number of bytes'); for (;r > 0 && n[r - 1] === t; r--) if (!((r - 1) * e % 8)) throw new Error('Invalid padding: string has too much padding'); return n.slice(0, r) } } } function so (e) { if (typeof e !== 'function') throw new Error('normalize fn should be function'); return { encode: e => e, decode: t => e(t) } } function co (e, t, n) { if (t < 2) throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`); if (n < 2) throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`); if (!Array.isArray(e)) throw new Error('convertRadix: data should be array'); if (!e.length) return []; let r = 0; const i = []; const o = Array.from(e); for (o.forEach(e => { if (no(e), e < 0 || e >= t) throw new Error(`Wrong integer: ${e}`) }); ;) { let e = 0; let a = !0; for (let i = r; i < o.length; i++) { const s = o[i]; const c = t * e + s; if (!Number.isSafeInteger(c) || t * e / t !== e || c - s != t * e) throw new Error('convertRadix: carry overflow'); if (e = c % n, o[i] = Math.floor(c / n), !Number.isSafeInteger(o[i]) || o[i] * n + e !== c) throw new Error('convertRadix: carry overflow'); a && (o[i] ? a = !1 : r = i) } if (i.push(e), a) break } for (let t = 0; t < e.length - 1 && e[t] === 0; t++)i.push(0); return i.reverse() } const uo = (e, t) => t ? uo(t, e % t) : e; const lo = (e, t) => e + (t - uo(e, t)); function fo (e, t, n, r) { if (!Array.isArray(e)) throw new Error('convertRadix2: data should be array'); if (t <= 0 || t > 32) throw new Error(`convertRadix2: wrong from=${t}`); if (n <= 0 || n > 32) throw new Error(`convertRadix2: wrong to=${n}`); if (lo(t, n) > 32) throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${lo(t, n)}`); let i = 0; let o = 0; const a = 2 ** n - 1; const s = []; for (const r of e) { if (no(r), r >= 2 ** t) throw new Error(`convertRadix2: invalid data word=${r} from=${t}`); if (i = i << t | r, o + t > 32) throw new Error(`convertRadix2: carry overflow pos=${o} from=${t}`); for (o += t; o >= n; o -= n)s.push((i >> o - n & a) >>> 0); i &= 2 ** o - 1 } if (i = i << n - o & a, !r && o >= t) throw new Error('Excess padding'); if (!r && i) throw new Error(`Non-zero padding: ${i}`); return r && o > 0 && s.push(i >>> 0), s } function ho (e) { return no(e), { encode: t => { if (!(t instanceof Uint8Array)) throw new Error('radix.encode input should be Uint8Array'); return co(Array.from(t), 256, e) }, decode: t => { if (!Array.isArray(t) || t.length && typeof t[0] !== 'number') throw new Error('radix.decode input should be array of strings'); return Uint8Array.from(co(t, e, 256)) } } } function po (e, t = !1) { if (no(e), e <= 0 || e > 32) throw new Error('radix2: bits should be in (0..32]'); if (lo(8, e) > 32 || lo(e, 8) > 32) throw new Error('radix2: carry overflow'); return { encode: n => { if (!(n instanceof Uint8Array)) throw new Error('radix2.encode input should be Uint8Array'); return fo(Array.from(n), 8, e, !t) }, decode: n => { if (!Array.isArray(n) || n.length && typeof n[0] !== 'number') throw new Error('radix2.decode input should be array of strings'); return Uint8Array.from(fo(n, e, 8, t)) } } } function go (e) { if (typeof e !== 'function') throw new Error('unsafeWrapper fn should be function'); return function (...t) { try { return e.apply(null, t) } catch (e) {} } } function mo (e, t) { if (no(e), typeof t !== 'function') throw new Error('checksum fn should be function'); return { encode (n) { if (!(n instanceof Uint8Array)) throw new Error('checksum.encode: input should be Uint8Array'); const r = t(n).slice(0, e); const i = new Uint8Array(n.length + e); return i.set(n), i.set(r, n.length), i }, decode (n) { if (!(n instanceof Uint8Array)) throw new Error('checksum.decode: input should be Uint8Array'); const r = n.slice(0, -e); const i = t(r).slice(0, e); const o = n.slice(-e); for (let t = 0; t < e; t++) if (i[t] !== o[t]) throw new Error('Invalid checksum'); return r } } } const yo = { alphabet: io, chain: ro, checksum: mo, radix: ho, radix2: po, join: oo, padding: ao }; const bo = (ro(po(4), io('0123456789ABCDEF'), oo('')), ro(po(5), io('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), ao(5), oo('')), ro(po(5), io('0123456789ABCDEFGHIJKLMNOPQRSTUV'), ao(5), oo('')), ro(po(5), io('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), oo(''), so(e => e.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))), ro(po(6), io('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), ao(6), oo(''))); const vo = (ro(po(6), io('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), ao(6), oo('')), e => ro(ho(58), io(e), oo(''))); const wo = vo('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'); const _o = (vo('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'), vo('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'), e => ro(mo(4, t => e(e(t))), wo)); const Eo = ro(io('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), oo('')); const ko = [996825010, 642813549, 513874426, 1027748829, 705979059]; function So (e) { const t = e >> 25; let n = (33554431 & e) << 5; for (let e = 0; e < ko.length; e++)(t >> e & 1) == 1 && (n ^= ko[e]); return n } function Ao (e, t, n = 1) { const r = e.length; let i = 1; for (let t = 0; t < r; t++) { const n = e.charCodeAt(t); if (n < 33 || n > 126) throw new Error(`Invalid prefix (${e})`); i = So(i) ^ n >> 5 }i = So(i); for (let t = 0; t < r; t++)i = So(i) ^ 31 & e.charCodeAt(t); for (const e of t)i = So(i) ^ e; for (let e = 0; e < 6; e++)i = So(i); return i ^= n, Eo.encode(fo([i % 2 ** 30], 30, 5, !1)) } function Oo (e) { const t = e === 'bech32' ? 1 : 734539939; const n = po(5); const r = n.decode; const i = n.encode; const o = go(r); function a (e, n = 90) { if (typeof e !== 'string') throw new Error('bech32.decode input should be string, not ' + typeof e); if (e.length < 8 || !1 !== n && e.length > n) throw new TypeError(`Wrong string length: ${e.length} (${e}). Expected (8..${n})`); const r = e.toLowerCase(); if (e !== r && e !== e.toUpperCase()) throw new Error('String must be lowercase or uppercase'); const i = (e = r).lastIndexOf('1'); if (i === 0 || i === -1) throw new Error('Letter "1" must be present between prefix and data only'); const o = e.slice(0, i); const a = e.slice(i + 1); if (a.length < 6) throw new Error('Data must be at least 6 characters long'); const s = Eo.decode(a).slice(0, -6); const c = Ao(o, s, t); if (!a.endsWith(c)) throw new Error(`Invalid checksum in ${e}: expected "${c}"`); return { prefix: o, words: s } } return { encode: function (e, n, r = 90) { if (typeof e !== 'string') throw new Error('bech32.encode prefix should be string, not ' + typeof e); if (!Array.isArray(n) || n.length && typeof n[0] !== 'number') throw new Error('bech32.encode words should be array of numbers, not ' + typeof n); const i = e.length + 7 + n.length; if (!1 !== r && i > r) throw new TypeError(`Length ${i} exceeds limit ${r}`); return `${e = e.toLowerCase()}1${Eo.encode(n)}${Ao(e, n, t)}` }, decode: a, decodeToBytes: function (e) { const { prefix: t, words: n } = a(e, !1); return { prefix: t, words: n, bytes: r(n) } }, decodeUnsafe: go(a), fromWords: r, fromWordsUnsafe: o, toWords: i } } const xo = Oo('bech32'); const Io = Oo('bech32m'); const No = { encode: e => (new TextDecoder()).decode(e), decode: e => (new TextEncoder()).encode(e) }; const To = ro(po(4), io('0123456789abcdef'), oo(''), so(e => { if (typeof e !== 'string' || e.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`); return e.toLowerCase() })); const Ro = new Uint8Array(); const Po = new Uint8Array([0]); function Co (e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1; return !0 } function Bo (...e) { if (e.length === 1) return e[0]; const t = e.reduce((e, t) => e + t.length, 0); const n = new Uint8Array(t); for (let t = 0, r = 0; t < e.length; t++) { const i = e[t]; n.set(i, r), r += i.length } return n } const Lo = e => e instanceof Uint8Array; class jo {constructor (e, t = [], n = []) { this.data = e, this.path = t, this.fieldPath = n, this.pos = 0, this.hasPtr = !1, this.bitBuf = 0, this.bitPos = 0 }err (e) { return new Error(`Reader(${this.fieldPath.join('/')}): ${e}`) }absBytes (e) { if (e > this.data.length) throw new Error('absBytes: Unexpected end of buffer'); return this.data.subarray(e) }bytes (e, t = !1) { if (this.bitPos) throw this.err('readBytes: bitPos not empty'); if (!Number.isFinite(e)) throw this.err(`readBytes: wrong length=${e}`); if (this.pos + e > this.data.length) throw this.err('readBytes: Unexpected end of buffer'); const n = this.data.subarray(this.pos, this.pos + e); return t || (this.pos += e), n }byte (e = !1) { if (this.bitPos) throw this.err('readByte: bitPos not empty'); return this.data[e ? this.pos : this.pos++] } get leftBytes () { return this.data.length - this.pos }isEnd () { return this.pos >= this.data.length && !this.bitPos }length (e) { let t; if (Ho(e) ? t = Number(e.decodeStream(this)) : typeof e === 'number' ? t = e : typeof e === 'string' && (t = Fo(this.path, e.split('/'))), typeof t === 'bigint' && (t = Number(t)), typeof t !== 'number') throw this.err(`Wrong length: ${t}`); return t }bits (e) { if (e > 32) throw this.err('BitReader: cannot read more than 32 bits in single call'); let t = 0; for (;e;) { this.bitPos || (this.bitBuf = this.data[this.pos++], this.bitPos = 8); const n = Math.min(e, this.bitPos); this.bitPos -= n, t = t << n | this.bitBuf >> this.bitPos & 2 ** n - 1, this.bitBuf &= 2 ** this.bitPos - 1, e -= n } return t >>> 0 }find (e, t = this.pos) { if (!Lo(e)) throw this.err(`find: needle is not bytes! ${e}`); if (this.bitPos) throw this.err('findByte: bitPos not empty'); if (!e.length) throw this.err('find: needle is empty'); for (let n = t; (n = this.data.indexOf(e[0], n)) !== -1; n++) { if (n === -1) return; if (this.data.length - n < e.length) return; if (Co(e, this.data.subarray(n, n + e.length))) return n } }finish () { if (!this.isEnd() && !this.hasPtr) throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${To.encode(this.data.slice(this.pos))}`) }fieldPathPush (e) { this.fieldPath.push(e) }fieldPathPop () { this.fieldPath.pop() }} class Do {constructor (e = [], t = []) { this.path = e, this.fieldPath = t, this.buffers = [], this.pos = 0, this.ptrs = [], this.bitBuf = 0, this.bitPos = 0 }err (e) { return new Error(`Writer(${this.fieldPath.join('/')}): ${e}`) }bytes (e) { if (this.bitPos) throw this.err('writeBytes: ends with non-empty bit buffer'); this.buffers.push(e), this.pos += e.length }byte (e) { if (this.bitPos) throw this.err('writeByte: ends with non-empty bit buffer'); this.buffers.push(new Uint8Array([e])), this.pos++ } get buffer () { if (this.bitPos) throw this.err('buffer: ends with non-empty bit buffer'); let e = Bo(...this.buffers); for (const t of this.ptrs) { const n = e.length; e = Bo(e, t.buffer); const r = t.ptr.encode(n); for (let n = 0; n < r.length; n++)e[t.pos + n] = r[n] } return e }length (e, t) { if (e === null) return; if (Ho(e)) return e.encodeStream(this, t); let n; if (typeof e === 'number' ? n = e : typeof e === 'string' && (n = Fo(this.path, e.split('/'))), typeof n === 'bigint' && (n = Number(n)), void 0 === n || n !== t) throw this.err(`Wrong length: ${n} len=${e} exp=${t}`) }bits (e, t) { if (t > 32) throw this.err('writeBits: cannot write more than 32 bits in single call'); if (e >= 2 ** t) throw this.err(`writeBits: value (${e}) >= 2**bits (${t})`); for (;t;) { const n = Math.min(t, 8 - this.bitPos); this.bitBuf = this.bitBuf << n | e >> t - n, this.bitPos += n, e &= 2 ** (t -= n) - 1, this.bitPos === 8 && (this.bitPos = 0, this.buffers.push(new Uint8Array([this.bitBuf])), this.pos++) } }fieldPathPush (e) { this.fieldPath.push(e) }fieldPathPop () { this.fieldPath.pop() }} const Uo = e => Uint8Array.from(e).reverse(); function Mo (e, t, n, r) { if (r) { const r = 2n ** (n - 1n); if (t < -r || t >= r) throw e.err('sInt: value out of bounds') } else if (t < 0n || t >= 2n ** n) throw e.err('uInt: value out of bounds') } function zo (e) { return { ...e, encode: t => { const n = new Do(); return e.encodeStream(n, t), n.buffer }, decode: t => { const n = new jo(t); const r = e.decodeStream(n); return n.finish(), r } } } function Fo (e, t) { e = Array.from(e); let n = 0; for (;n < t.length && t[n] === '..'; n++)e.pop(); let r = e.pop(); for (;n < t.length; n++) { if (!r || void 0 === r[t[n]]) return; r = r[t[n]] } return r } function Ho (e) { return typeof e.encode === 'function' && typeof e.encodeStream === 'function' && typeof e.decode === 'function' && typeof e.decodeStream === 'function' } const qo = { dict: function () { return { encode: e => { const t = {}; for (const [n, r] of e) { if (void 0 !== t[n]) throw new Error(`coders.dict: same key(${n}) appears twice in struct`); t[n] = r } return t }, decode: e => Object.entries(e) } }, number: { encode: e => { if (e > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error(`coders.number: element bigger than MAX_SAFE_INTEGER=${e}`); return Number(e) }, decode: e => BigInt(e) }, tsEnum: function (e) { return { encode: t => e[t], decode: t => e[t] } }, decimal: function (e) { const t = 10n ** BigInt(e); return { encode: t => { let n = (t < 0n ? -t : t).toString(10); let r = n.length - e; r < 0 && (n = n.padStart(n.length - r, '0'), r = 0); let i = n.length - 1; for (;i >= r && n[i] === '0'; i--);let [o, a] = [n.slice(0, r), n.slice(r, i + 1)]; return o || (o = '0'), t < 0n && (o = '-' + o), a ? `${o}.${a}` : o }, decode: n => { let r = !1; n.startsWith('-') && (r = !0, n = n.slice(1)); let i = n.indexOf('.'); i = i === -1 ? n.length : i; const [o, a] = [n.slice(0, i), n.slice(i + 1)]; const s = BigInt(o) * t; const c = Math.min(a.length, e); const u = s + BigInt(a.slice(0, c)) * 10n ** BigInt(e - c); return r ? -u : u } } }, match: function (e) { return { encode: t => { for (const n of e) { const e = n.encode(t); if (void 0 !== e) return e } throw new Error(`match/encode: cannot find match in ${t}`) }, decode: t => { for (const n of e) { const e = n.decode(t); if (void 0 !== e) return e } throw new Error(`match/decode: cannot find match in ${t}`) } } } }; const Ko = (e, t = !1, n = !1) => zo({ size: e, encodeStream: (r, i) => { if (typeof i !== 'number' && typeof i !== 'bigint') throw r.err(`bigint: invalid value: ${i}`); let o = BigInt(i); const a = BigInt(e); Mo(r, o, 8n * a, !!n); n && o < 0 && (o |= 2n ** (8n * a - 1n)); const s = []; for (let t = 0; t < e; t++)s.push(Number(255n & o)), o >>= 8n; const c = new Uint8Array(s).reverse(); r.bytes(t ? c.reverse() : c) }, decodeStream: r => { const i = BigInt(e); let o = r.bytes(e); t && (o = Uo(o)); const a = Uo(o); const s = 2n ** (8n * i - 1n); let c = 0n; for (let e = 0; e < a.length; e++)c |= BigInt(a[e]) << 8n * BigInt(e); return n && c & s && (c = (c ^ s) - s), Mo(r, c, 8n * i, !!n), c } }); const Vo = (Ko(32, !0), Ko(32, !1)); const Wo = (Ko(32, !0, !0), Ko(32, !1, !0), Ko(16, !0), Ko(16, !1), Ko(16, !0, !0), Ko(16, !1, !0), Ko(8, !0)); const $o = (Ko(8, !1), Ko(8, !0, !0)); const Go = (Ko(8, !1, !0), (e, t = !1, n = !1) => { if (e > 6) throw new Error('int supports size up to 6 bytes (48 bits), for other use bigint'); return na(Ko(e, t, n), qo.number) }); const Yo = Go(4, !0); const Zo = Go(4, !1); const Jo = Go(4, !0, !0); const Xo = (Go(4, !1, !0), Go(2, !0)); const Qo = (Go(2, !1), Go(2, !0, !0), Go(2, !1, !0), Go(1, !1)); const ea = (Go(1, !1, !0), zo({ size: 1, encodeStream: (e, t) => e.byte(t ? 1 : 0), decodeStream: e => { const t = e.byte(); if (t !== 0 && t !== 1) throw e.err(`bool: invalid value ${t}`); return t === 1 } }), (e, t = !1) => zo({ size: typeof e === 'number' ? e : void 0, encodeStream: (n, r) => { if (!Lo(r)) throw n.err(`bytes: invalid value ${r}`); Lo(e) || n.length(e, r.length), n.bytes(t ? Uo(r) : r), Lo(e) && n.bytes(e) }, decodeStream: n => { let r; if (Lo(e)) { const t = n.find(e); if (!t) throw n.err('bytes: cannot find terminator'); r = n.bytes(t - n.pos), n.bytes(e.length) } else r = n.bytes(e === null ? n.leftBytes : n.length(e)); return t ? Uo(r) : r } })); const ta = (e, t = !1) => { const n = ea(e, t); return zo({ size: n.size, encodeStream: (e, t) => n.encodeStream(e, No.decode(t)), decodeStream: e => No.encode(n.decodeStream(e)) }) }; ta(Po); function na (e, t) { if (!Ho(e)) throw new Error(`apply: invalid inner value ${e}`); return zo({ size: e.size, encodeStream: (n, r) => { let i; try { i = t.decode(r) } catch (e) { throw n.err('' + e) } return e.encodeStream(n, i) }, decodeStream: n => { const r = e.decodeStream(n); try { return t.encode(r) } catch (e) { throw n.err('' + e) } } }) } function ra (e, t) { if (!Ho(e)) throw new Error(`validate: invalid inner value ${e}`); return zo({ size: e.size, encodeStream: (n, r) => e.encodeStream(n, t(r)), decodeStream: n => t(e.decodeStream(n)) }) } function ia (e, t, n = !0) { if (!Ho(e)) throw new Error(`flagged: invalid inner value ${e}`); return zo({ size: e.size, encodeStream: (n, r) => e.encodeStream(n, t), decodeStream: r => { const i = e.decodeStream(r); if (n && typeof i !== 'object' && i !== t || Lo(t) && !Co(t, i)) throw r.err(`magic: invalid value: ${i} !== ${t}`) } }) } function oa (e) { let t = 0; for (const n of e) { if (!n.size) return; t += n.size } return t } function aa (e) { if (Array.isArray(e)) throw new Error('Packed.Struct: got array instead of object'); return zo({ size: oa(Object.values(e)), encodeStream: (t, n) => { if (typeof n !== 'object' || n === null) throw t.err(`struct: invalid value ${n}`); t.path.push(n); for (const r in e) { t.fieldPathPush(r), e[r].encodeStream(t, n[r]), t.fieldPathPop() }t.path.pop() }, decodeStream: t => { const n = {}; t.path.push(n); for (const r in e)t.fieldPathPush(r), n[r] = e[r].decodeStream(t), t.fieldPathPop(); return t.path.pop(), n } }) } function sa (e, t) { if (!Ho(t)) throw new Error(`array: invalid inner value ${t}`); return zo({ size: typeof e === 'number' && t.size ? e * t.size : void 0, encodeStream: (n, r) => { if (!Array.isArray(r)) throw n.err(`array: invalid value ${r}`); Lo(e) || n.length(e, r.length), n.path.push(r); for (let i = 0; i < r.length; i++) { n.fieldPathPush('' + i); const o = r[i]; const a = n.pos; if (t.encodeStream(n, o), Lo(e)) { if (e.length > n.pos - a) continue; const t = n.buffer.subarray(a, n.pos); if (Co(t.subarray(0, e.length), e)) throw n.err(`array: inner element encoding same as separator. elm=${o} data=${t}`) }n.fieldPathPop() }n.path.pop(), Lo(e) && n.bytes(e) }, decodeStream: n => { const r = []; if (e === null) { let e = 0; for (n.path.push(r); !(n.isEnd() || (n.fieldPathPush('' + e++), r.push(t.decodeStream(n)), n.fieldPathPop(), t.size && n.leftBytes < t.size)););n.path.pop() } else if (Lo(e)) { let i = 0; for (n.path.push(r); ;) { if (Co(n.bytes(e.length, !0), e)) { n.bytes(e.length); break }n.fieldPathPush('' + i++), r.push(t.decodeStream(n)), n.fieldPathPop() }n.path.pop() } else { n.fieldPathPush('arrayLen'); const i = n.length(e); n.fieldPathPop(), n.path.push(r); for (let e = 0; e < i; e++)n.fieldPathPush('' + e), r.push(t.decodeStream(n)), n.fieldPathPop(); n.path.pop() } return r } }) }ia(ea(0), Ro); const { ProjectivePoint: ca, sign: ua, getPublicKey: la } = Yr; const da = Yr.CURVE.n; const fa = (e, t) => void 0 === e ? t : e; const ha = Lo; const pa = e => to(zi(e)); const ga = (...e) => zi(zi(ma(...e))); const ma = Bo; const ya = _o(zi); function ba (e) { if (Array.isArray(e)) return e.map(e => ba(e)); if (e instanceof Uint8Array) return Uint8Array.from(e); if (['number', 'bigint', 'boolean', 'string', 'undefined'].includes(typeof e)) return e; if (e === null) return e; if (typeof e === 'object') return Object.fromEntries(Object.entries(e).map(([e, t]) => [e, ba(t)])); throw new Error(`cloneDeep: unknown type=${e} (${typeof e})`) } let va; function wa (e, t) { const n = e.length; if (t === va.ecdsa) { if (n === 32) throw new Error('Expected non-Schnorr key'); return ca.fromHex(e), e } if (t === va.schnorr) { if (n !== 32) throw new Error('Expected 32-byte Schnorr key'); return di.utils.lift_x(di.utils.bytesToNumberBE(e)), e } throw new Error('Unknown key type') } function _a (e, t) { try { return wa(e, t), !0 } catch (e) { return !1 } }!(function (e) { e[e.ecdsa = 0] = 'ecdsa', e[e.schnorr = 1] = 'schnorr' }(va || (va = {}))); const Ea = e => e.r < da / 2n; function ka (e, t) { const n = di.utils; const r = n.taggedHash('TapTweak', e, t); const i = n.bytesToNumberBE(r); if (i >= da) throw new Error('tweak higher than curve order'); return i } function Sa (e, t) { const n = di.utils; const r = ka(e, t); const i = n.lift_x(n.bytesToNumberBE(e)).add(ca.fromPrivateKey(r)); const o = i.hasEvenY() ? 0 : 1; return [n.pointToBytes(i), o] } const Aa = ra(ea(null), e => wa(e, va.ecdsa)); const Oa = ra(ea(32), e => wa(e, va.schnorr)); const xa = ra(ea(null), e => { if (e.length !== 64 && e.length !== 65) throw new Error('Schnorr signature should be 64 or 65 bytes long'); return e }); const Ia = { bech32: 'bc', pubKeyHash: 0, scriptHash: 5, wif: 128 }; const Na = 4294967295; const Ta = new Uint8Array(32); qo.decimal(8); function Ra (e, t) { if (!ha(e) || !ha(t)) throw new Error(`cmp: wrong type a=${typeof e} b=${typeof t}`); const n = Math.min(e.length, t.length); for (let r = 0; r < n; r++) if (e[r] != t[r]) return Math.sign(e[r] - t[r]); return Math.sign(e.length - t.length) } let Pa; !(function (e) { e[e.OP_0 = 0] = 'OP_0', e[e.PUSHDATA1 = 76] = 'PUSHDATA1', e[e.PUSHDATA2 = 77] = 'PUSHDATA2', e[e.PUSHDATA4 = 78] = 'PUSHDATA4', e[e['1NEGATE'] = 79] = '1NEGATE', e[e.RESERVED = 80] = 'RESERVED', e[e.OP_1 = 81] = 'OP_1', e[e.OP_2 = 82] = 'OP_2', e[e.OP_3 = 83] = 'OP_3', e[e.OP_4 = 84] = 'OP_4', e[e.OP_5 = 85] = 'OP_5', e[e.OP_6 = 86] = 'OP_6', e[e.OP_7 = 87] = 'OP_7', e[e.OP_8 = 88] = 'OP_8', e[e.OP_9 = 89] = 'OP_9', e[e.OP_10 = 90] = 'OP_10', e[e.OP_11 = 91] = 'OP_11', e[e.OP_12 = 92] = 'OP_12', e[e.OP_13 = 93] = 'OP_13', e[e.OP_14 = 94] = 'OP_14', e[e.OP_15 = 95] = 'OP_15', e[e.OP_16 = 96] = 'OP_16', e[e.NOP = 97] = 'NOP', e[e.VER = 98] = 'VER', e[e.IF = 99] = 'IF', e[e.NOTIF = 100] = 'NOTIF', e[e.VERIF = 101] = 'VERIF', e[e.VERNOTIF = 102] = 'VERNOTIF', e[e.ELSE = 103] = 'ELSE', e[e.ENDIF = 104] = 'ENDIF', e[e.VERIFY = 105] = 'VERIFY', e[e.RETURN = 106] = 'RETURN', e[e.TOALTSTACK = 107] = 'TOALTSTACK', e[e.FROMALTSTACK = 108] = 'FROMALTSTACK', e[e['2DROP'] = 109] = '2DROP', e[e['2DUP'] = 110] = '2DUP', e[e['3DUP'] = 111] = '3DUP', e[e['2OVER'] = 112] = '2OVER', e[e['2ROT'] = 113] = '2ROT', e[e['2SWAP'] = 114] = '2SWAP', e[e.IFDUP = 115] = 'IFDUP', e[e.DEPTH = 116] = 'DEPTH', e[e.DROP = 117] = 'DROP', e[e.DUP = 118] = 'DUP', e[e.NIP = 119] = 'NIP', e[e.OVER = 120] = 'OVER', e[e.PICK = 121] = 'PICK', e[e.ROLL = 122] = 'ROLL', e[e.ROT = 123] = 'ROT', e[e.SWAP = 124] = 'SWAP', e[e.TUCK = 125] = 'TUCK', e[e.CAT = 126] = 'CAT', e[e.SUBSTR = 127] = 'SUBSTR', e[e.LEFT = 128] = 'LEFT', e[e.RIGHT = 129] = 'RIGHT', e[e.SIZE = 130] = 'SIZE', e[e.INVERT = 131] = 'INVERT', e[e.AND = 132] = 'AND', e[e.OR = 133] = 'OR', e[e.XOR = 134] = 'XOR', e[e.EQUAL = 135] = 'EQUAL', e[e.EQUALVERIFY = 136] = 'EQUALVERIFY', e[e.RESERVED1 = 137] = 'RESERVED1', e[e.RESERVED2 = 138] = 'RESERVED2', e[e['1ADD'] = 139] = '1ADD', e[e['1SUB'] = 140] = '1SUB', e[e['2MUL'] = 141] = '2MUL', e[e['2DIV'] = 142] = '2DIV', e[e.NEGATE = 143] = 'NEGATE', e[e.ABS = 144] = 'ABS', e[e.NOT = 145] = 'NOT', e[e['0NOTEQUAL'] = 146] = '0NOTEQUAL', e[e.ADD = 147] = 'ADD', e[e.SUB = 148] = 'SUB', e[e.MUL = 149] = 'MUL', e[e.DIV = 150] = 'DIV', e[e.MOD = 151] = 'MOD', e[e.LSHIFT = 152] = 'LSHIFT', e[e.RSHIFT = 153] = 'RSHIFT', e[e.BOOLAND = 154] = 'BOOLAND', e[e.BOOLOR = 155] = 'BOOLOR', e[e.NUMEQUAL = 156] = 'NUMEQUAL', e[e.NUMEQUALVERIFY = 157] = 'NUMEQUALVERIFY', e[e.NUMNOTEQUAL = 158] = 'NUMNOTEQUAL', e[e.LESSTHAN = 159] = 'LESSTHAN', e[e.GREATERTHAN = 160] = 'GREATERTHAN', e[e.LESSTHANOREQUAL = 161] = 'LESSTHANOREQUAL', e[e.GREATERTHANOREQUAL = 162] = 'GREATERTHANOREQUAL', e[e.MIN = 163] = 'MIN', e[e.MAX = 164] = 'MAX', e[e.WITHIN = 165] = 'WITHIN', e[e.RIPEMD160 = 166] = 'RIPEMD160', e[e.SHA1 = 167] = 'SHA1', e[e.SHA256 = 168] = 'SHA256', e[e.HASH160 = 169] = 'HASH160', e[e.HASH256 = 170] = 'HASH256', e[e.CODESEPARATOR = 171] = 'CODESEPARATOR', e[e.CHECKSIG = 172] = 'CHECKSIG', e[e.CHECKSIGVERIFY = 173] = 'CHECKSIGVERIFY', e[e.CHECKMULTISIG = 174] = 'CHECKMULTISIG', e[e.CHECKMULTISIGVERIFY = 175] = 'CHECKMULTISIGVERIFY', e[e.NOP1 = 176] = 'NOP1', e[e.CHECKLOCKTIMEVERIFY = 177] = 'CHECKLOCKTIMEVERIFY', e[e.CHECKSEQUENCEVERIFY = 178] = 'CHECKSEQUENCEVERIFY', e[e.NOP4 = 179] = 'NOP4', e[e.NOP5 = 180] = 'NOP5', e[e.NOP6 = 181] = 'NOP6', e[e.NOP7 = 182] = 'NOP7', e[e.NOP8 = 183] = 'NOP8', e[e.NOP9 = 184] = 'NOP9', e[e.NOP10 = 185] = 'NOP10', e[e.CHECKSIGADD = 186] = 'CHECKSIGADD', e[e.INVALID = 255] = 'INVALID' }(Pa || (Pa = {}))); const Ca = zo({ encodeStream: (e, t) => { for (let n of t) { if (typeof n === 'string') { if (void 0 === Pa[n]) throw new Error(`Unknown opcode=${n}`); e.byte(Pa[n]); continue } if (typeof n === 'number') { if (n === 0) { e.byte(0); continue } if (n >= 1 && n <= 16) { e.byte(Pa.OP_1 - 1 + n); continue } } if (typeof n === 'number' && (n = Ba().encode(BigInt(n))), !ha(n)) throw new Error(`Wrong Script OP=${n} (${typeof n})`); const t = n.length; t < Pa.PUSHDATA1 ? e.byte(t) : t <= 255 ? (e.byte(Pa.PUSHDATA1), e.byte(t)) : t <= 65535 ? (e.byte(Pa.PUSHDATA2), e.bytes(Xo.encode(t))) : (e.byte(Pa.PUSHDATA4), e.bytes(Yo.encode(t))), e.bytes(n) } }, decodeStream: e => { const t = []; for (;!e.isEnd();) { const n = e.byte(); if (Pa.OP_0 < n && n <= Pa.PUSHDATA4) { let r; if (n < Pa.PUSHDATA1)r = n; else if (n === Pa.PUSHDATA1)r = Qo.decodeStream(e); else if (n === Pa.PUSHDATA2)r = Xo.decodeStream(e); else { if (n !== Pa.PUSHDATA4) throw new Error('Should be not possible'); r = Yo.decodeStream(e) }t.push(e.bytes(r)) } else if (n === 0)t.push(0); else if (Pa.OP_1 <= n && n <= Pa.OP_16)t.push(n - (Pa.OP_1 - 1)); else { const e = Pa[n]; if (void 0 === e) throw new Error(`Unknown opcode=${n.toString(16)}`); t.push(e) } } return t } }); function Ba (e = 6, t = !1) { return zo({ encodeStream: (e, t) => { if (t === 0n) return; const n = t < 0; const r = BigInt(t); const i = []; for (let e = n ? -r : r; e; e >>= 8n)i.push(Number(0xffn & e)); i[i.length - 1] >= 128 ? i.push(n ? 128 : 0) : n && (i[i.length - 1] |= 128), e.bytes(new Uint8Array(i)) }, decodeStream: n => { const r = n.leftBytes; if (r > e) throw new Error(`ScriptNum: number (${r}) bigger than limit=${e}`); if (r === 0) return 0n; if (t && (127 & n.data[r - 1]) == 0 && (r <= 1 || (128 & n.data[r - 2]) == 0)) throw new Error('Non-minimally encoded ScriptNum'); let i = 0; let o = 0n; for (let e = 0; e < r; ++e)i = n.byte(), o |= BigInt(i) << 8n * BigInt(e); return i >= 128 && (o &= 2n ** BigInt(8 * r) - 1n >> 1n, o = -o), o } }) } const La = { 253: [253, 2, 253n, 65535n], 254: [254, 4, 65536n, 4294967295n], 255: [255, 8, 4294967296n, 18446744073709551615n] }; const ja = zo({ encodeStream: (e, t) => { if (typeof t === 'number' && (t = BigInt(t)), t >= 0n && t <= 252n) return e.byte(Number(t)); for (const [n, r, i, o] of Object.values(La)) if (!(i > t || t > o)) { e.byte(n); for (let n = 0; n < r; n++)e.byte(Number(t >> 8n * BigInt(n) & 0xffn)); return } throw e.err(`VarInt too big: ${t}`) }, decodeStream: e => { const t = e.byte(); if (t <= 252) return BigInt(t); const [n, r, i] = La[t]; let o = 0n; for (let t = 0; t < r; t++)o |= BigInt(e.byte()) << 8n * BigInt(t); if (o < i) throw e.err(`Wrong CompactSize(${8 * r})`); return o } }); const Da = na(ja, qo.number); const Ua = e => sa(ja, e); const Ma = ea(ja); const za = aa({ txid: ea(32, !0), index: Yo, finalScriptSig: Ma, sequence: Yo }); const Fa = aa({ amount: Wo, script: Ma }); const Ha = { amount: 0xffffffffffffffffn, script: Ro }; const qa = sa(Da, Ma); const Ka = aa({ version: Jo, segwitFlag: ((e, t = !1) => zo({ size: e.length, encodeStream: (n, r) => { !!r !== t && n.bytes(e) }, decodeStream: n => { let r = n.leftBytes >= e.length; return r && (r = Co(n.bytes(e.length, !0), e), r && n.bytes(e.length)), r !== t } }))(new Uint8Array([0, 1])), inputs: Ua(za), outputs: Ua(Fa), witnesses: (function (e, t, n) { if (!Ho(t)) throw new Error(`flagged: invalid inner value ${t}`); return zo({ encodeStream: (r, i) => { typeof e === 'string' ? Fo(r.path, e.split('/')) ? t.encodeStream(r, i) : n && t.encodeStream(r, n) : (e.encodeStream(r, !!i), i ? t.encodeStream(r, i) : n && t.encodeStream(r, n)) }, decodeStream: r => { let i = !1; if (i = typeof e === 'string' ? Fo(r.path, e.split('/')) : e.decodeStream(r), i) return t.decodeStream(r); n && t.decodeStream(r) } }) }('segwitFlag', sa('inputs/length', qa))), lockTime: Yo }); const Va = ra(Ka, function (e) { if (e.segwitFlag && e.witnesses && !e.witnesses.length) throw new Error('Segwit flag with empty witnesses array'); return e }); function Wa (e) { const [t, n, r, i, o, a] = e; return { type: t, kc: n, vc: r, reqInc: i, allowInc: o, silentIgnore: a } } const $a = aa({ fingerprint: Zo, path: sa(null, Yo) }); const Ga = ra(aa({ version: Qo, internalKey: ea(32), merklePath: sa(null, ea(32)) }), e => { if (e.merklePath.length > 128) throw new Error('TaprootControlBlock: merklePath should be of length 0..128 (inclusive)'); return e }); const Ya = aa({ hashes: sa(Da, ea(32)), der: $a }); const Za = ea(78); const Ja = aa({ pubKey: Oa, leafHash: ea(32) }); const Xa = sa(null, aa({ depth: Qo, version: Qo, script: Ma })); const Qa = ea(null); const es = ea(20); const ts = ea(32); const ns = { unsignedTx: [0, !1, Va, [0], [0], !1], xpub: [1, Za, $a, [], [0, 2], !1], txVersion: [2, !1, Yo, [2], [2], !1], fallbackLocktime: [3, !1, Yo, [], [2], !1], inputCount: [4, !1, Da, [2], [2], !1], outputCount: [5, !1, Da, [2], [2], !1], txModifiable: [6, !1, Qo, [], [2], !1], version: [251, !1, Yo, [], [0, 2], !1], proprietary: [252, Qa, Qa, [], [0, 2], !1] }; const rs = { nonWitnessUtxo: [0, !1, Va, [], [0, 2], !1], witnessUtxo: [1, !1, Fa, [], [0, 2], !1], partialSig: [2, Aa, Qa, [], [0, 2], !1], sighashType: [3, !1, Yo, [], [0, 2], !1], redeemScript: [4, !1, Qa, [], [0, 2], !1], witnessScript: [5, !1, Qa, [], [0, 2], !1], bip32Derivation: [6, Aa, $a, [], [0, 2], !1], finalScriptSig: [7, !1, Qa, [], [0, 2], !1], finalScriptWitness: [8, !1, qa, [], [0, 2], !1], porCommitment: [9, !1, Qa, [], [0, 2], !1], ripemd160: [10, es, Qa, [], [0, 2], !1], sha256: [11, ts, Qa, [], [0, 2], !1], hash160: [12, es, Qa, [], [0, 2], !1], hash256: [13, ts, Qa, [], [0, 2], !1], txid: [14, !1, ts, [2], [2], !0], index: [15, !1, Yo, [2], [2], !0], sequence: [16, !1, Yo, [], [2], !0], requiredTimeLocktime: [17, !1, Yo, [], [2], !1], requiredHeightLocktime: [18, !1, Yo, [], [2], !1], tapKeySig: [19, !1, xa, [], [0, 2], !1], tapScriptSig: [20, Ja, xa, [], [0, 2], !1], tapLeafScript: [21, Ga, Qa, [], [0, 2], !1], tapBip32Derivation: [22, ts, Ya, [], [0, 2], !1], tapInternalKey: [23, !1, Oa, [], [0, 2], !1], tapMerkleRoot: [24, !1, ts, [], [0, 2], !1], proprietary: [252, Qa, Qa, [], [0, 2], !1] }; const is = ['txid', 'sequence', 'index', 'witnessUtxo', 'nonWitnessUtxo', 'finalScriptSig', 'finalScriptWitness', 'unknown']; const os = ['partialSig', 'finalScriptSig', 'finalScriptWitness', 'tapKeySig', 'tapScriptSig']; const as = { redeemScript: [0, !1, Qa, [], [0, 2], !1], witnessScript: [1, !1, Qa, [], [0, 2], !1], bip32Derivation: [2, Aa, $a, [], [0, 2], !1], amount: [3, !1, $o, [2], [2], !0], script: [4, !1, Qa, [2], [2], !0], tapInternalKey: [5, !1, Oa, [], [0, 2], !1], tapTree: [6, !1, Xa, [], [0, 2], !1], tapBip32Derivation: [7, Oa, Ya, [], [0, 2], !1], proprietary: [252, Qa, Qa, [], [0, 2], !1] }; const ss = []; const cs = sa(Po, aa({ key: (function (e, t) { if (!Ho(t)) throw new Error(`prefix: invalid inner value ${t}`); if (Lo(e)) throw new Error('prefix: len cannot be Uint8Array'); const n = ea(e); return zo({ size: typeof e === 'number' ? e : void 0, encodeStream: (e, r) => { const i = new Do(e.path, e.fieldPath); t.encodeStream(i, r), n.encodeStream(e, i.buffer) }, decodeStream: e => { const r = n.decodeStream(e); return t.decodeStream(new jo(r, e.path, e.fieldPath)) } }) }(Da, aa({ type: Da, key: ea(null) }))), value: ea(Da) })); aa({ type: Da, key: ea(null) }); function us (e) { const t = {}; for (const n in e) { const [r, i, o] = e[n]; t[r] = [n, i, o] } return zo({ encodeStream: (t, n) => { const r = []; for (const t in e) { const i = n[t]; if (void 0 === i) continue; const [o, a, s] = e[t]; if (a) { const e = i.map(([e, t]) => [a.encode(e), s.encode(t)]); e.sort((e, t) => Ra(e[0], t[0])); for (const [t, n] of e)r.push({ key: { key: t, type: o }, value: n }) } else r.push({ key: { type: o, key: Ro }, value: s.encode(i) }) } if (n.unknown) { n.unknown.sort((e, t) => Ra(e[0].key, t[0].key)); for (const [e, t] of n.unknown)r.push({ key: e, value: t }) }cs.encodeStream(t, r) }, decodeStream: e => { const n = cs.decodeStream(e); const r = {}; const i = {}; for (const e of n) { let n = 'unknown'; let o = e.key.key; let a = e.value; if (t[e.key.type]) { const [s, c, u] = t[e.key.type]; if (n = s, !c && o.length) throw new Error(`PSBT: Non-empty key for ${n} (key=${To.encode(o)} value=${To.encode(a)}`); if (o = c ? c.decode(o) : void 0, a = u.decode(a), !c) { if (r[n]) throw new Error(`PSBT: Same keys: ${n} (key=${o} value=${a})`); r[n] = a, i[n] = !0; continue } } else o = { type: e.key.type, key: e.key.key }; if (i[n]) throw new Error(`PSBT: Key type with empty key and no key=${n} val=${a}`); r[n] || (r[n] = []), r[n].push([o, a]) } return r } }) } function ls (e, t) { if (!Co(e.hash, zi(t))) throw new Error('checkScript: wsh wrong witnessScript hash'); const n = Ms.decode(t); if (n.type === 'tr' || n.type === 'tr_ns' || n.type === 'tr_ms') throw new Error(`checkScript: P2${n.type} cannot be wrapped in P2SH`); if (n.type === 'wpkh' || n.type === 'sh') throw new Error(`checkScript: P2${n.type} cannot be wrapped in P2WSH`) } function ds (e, t, n) { if (e) { const r = Ms.decode(e); if (r.type === 'tr_ns' || r.type === 'tr_ms' || r.type === 'ms' || r.type == 'pk') throw new Error(`checkScript: non-wrapped ${r.type}`); if (r.type === 'sh' && t) { if (!Co(r.hash, pa(t))) throw new Error('checkScript: sh wrong redeemScript hash'); const e = Ms.decode(t); if (e.type === 'tr' || e.type === 'tr_ns' || e.type === 'tr_ms') throw new Error(`checkScript: P2${e.type} cannot be wrapped in P2SH`); if (e.type === 'sh') throw new Error('checkScript: P2SH cannot be wrapped in P2SH') }r.type === 'wsh' && n && ls(r, n) } if (t) { const e = Ms.decode(t); e.type === 'wsh' && n && ls(e, n) } } const fs = ra(us(rs), e => { if (e.finalScriptWitness && !e.finalScriptWitness.length) throw new Error('validateInput: wmpty finalScriptWitness'); if (e.partialSig && !e.partialSig.length) throw new Error('Empty partialSig'); if (e.partialSig) for (const [t, n] of e.partialSig)wa(t, va.ecdsa); if (e.bip32Derivation) for (const [t, n] of e.bip32Derivation)wa(t, va.ecdsa); if (void 0 !== e.requiredTimeLocktime && e.requiredTimeLocktime < 5e8) throw new Error(`validateInput: wrong timeLocktime=${e.requiredTimeLocktime}`); if (void 0 !== e.requiredHeightLocktime && (e.requiredHeightLocktime <= 0 || e.requiredHeightLocktime >= 5e8)) throw new Error(`validateInput: wrong heighLocktime=${e.requiredHeightLocktime}`); if (e.nonWitnessUtxo && void 0 !== e.index) { const t = e.nonWitnessUtxo.outputs.length - 1; if (e.index > t) throw new Error(`validateInput: index(${e.index}) not in nonWitnessUtxo`); const n = e.nonWitnessUtxo.outputs[e.index]; if (e.witnessUtxo && (!Co(e.witnessUtxo.script, n.script) || e.witnessUtxo.amount !== n.amount)) throw new Error('validateInput: witnessUtxo different from nonWitnessUtxo') } if (e.tapLeafScript) for (const [t, n] of e.tapLeafScript) { if ((254 & t.version) !== n[n.length - 1]) throw new Error('validateInput: tapLeafScript version mimatch'); if (1 & n[n.length - 1]) throw new Error('validateInput: tapLeafScript version has parity bit!') } if (e.nonWitnessUtxo && e.index && e.txid) { if (e.nonWitnessUtxo.outputs.length - 1 < e.index) throw new Error('nonWitnessUtxo: incorect output index'); const t = Qs.fromRaw(Va.encode(e.nonWitnessUtxo)); const n = To.encode(e.txid); if (t.id !== n) throw new Error(`nonWitnessUtxo: wrong txid, exp=${n} got=${t.id}`) } return e }); const hs = ra(us(as), e => { if (e.bip32Derivation) for (const [t, n] of e.bip32Derivation)wa(t, va.ecdsa); return e }); const ps = ra(us(ns), e => { if ((e.version || 0) === 0) { if (!e.unsignedTx) throw new Error('PSBTv0: missing unsignedTx'); if (e.unsignedTx.segwitFlag || e.unsignedTx.witnesses) throw new Error('PSBTv0: witness in unsingedTx'); for (const t of e.unsignedTx.inputs) if (t.finalScriptSig && t.finalScriptSig.length) throw new Error('PSBTv0: input scriptSig found in unsignedTx') } return e }); const gs = aa({ magic: ia(ta(new Uint8Array([255])), 'psbt'), global: ps, inputs: sa('global/unsignedTx/inputs/length', fs), outputs: sa(null, hs) }); const ms = aa({ magic: ia(ta(new Uint8Array([255])), 'psbt'), global: ps, inputs: sa('global/inputCount', fs), outputs: sa('global/outputCount', hs) }); aa({ magic: ia(ta(new Uint8Array([255])), 'psbt'), items: sa(null, na(sa(Po, (function (e) { if (!Array.isArray(e)) throw new Error(`Packed.Tuple: got ${typeof e} instead of array`); return zo({ size: oa(e), encodeStream: (t, n) => { if (!Array.isArray(n)) throw t.err(`tuple: invalid value ${n}`); t.path.push(n); for (let r = 0; r < e.length; r++)t.fieldPathPush('' + r), e[r].encodeStream(t, n[r]), t.fieldPathPop(); t.path.pop() }, decodeStream: t => { const n = []; t.path.push(n); for (let r = 0; r < e.length; r++)t.fieldPathPush('' + r), n.push(e[r].decodeStream(t)), t.fieldPathPop(); return t.path.pop(), n } }) }([((e, t = !1, n = !1) => { const r = ea(e, t); return zo({ size: r.size, encodeStream: (e, t) => { if (n && !t.startsWith('0x')) throw new Error('hex(withZero=true).encode input should start with 0x'); const i = To.decode(n ? t.slice(2) : t); return r.encodeStream(e, i) }, decodeStream: e => (n ? '0x' : '') + To.encode(r.decodeStream(e)) }) })(Da), ea(ja)]))), qo.dict())) }); function ys (e, t, n) { for (const r in n) { if (r === 'unknown') continue; if (!t[r]) continue; const { allowInc: n } = Wa(t[r]); if (!n.includes(e)) throw new Error(`PSBTv${e}: field ${r} is not allowed`) } for (const r in t) { const { reqInc: i } = Wa(t[r]); if (i.includes(e) && void 0 === n[r]) throw new Error(`PSBTv${e}: missing required field ${r}`) } } function bs (e, t, n) { const r = {}; for (const i in n) { const o = i; if (o !== 'unknown') { if (!t[o]) continue; const { allowInc: n, silentIgnore: r } = Wa(t[o]); if (!n.includes(e)) { if (r) continue; throw new Error(`Failed to serialize in PSBTv${e}: ${o} but versions allows inclusion=${n}`) } }r[o] = n[o] } return r } function vs (e) { const t = e && e.global && e.global.version || 0; ys(t, ns, e.global); for (const n of e.inputs)ys(t, rs, n); for (const n of e.outputs)ys(t, as, n); const n = t ? e.global.inputCount : e.global.unsignedTx.inputs.length; if (e.inputs.length < n) throw new Error('Not enough inputs'); const r = e.inputs.slice(n); if (r.length > 1 || r.length && Object.keys(r[0]).length) throw new Error(`Unexpected inputs left in tx=${r}`); const i = t ? e.global.outputCount : e.global.unsignedTx.outputs.length; if (e.outputs.length < i) throw new Error('Not outputs inputs'); const o = e.outputs.slice(i); if (o.length > 1 || o.length && Object.keys(o[0]).length) throw new Error(`Unexpected outputs left in tx=${o}`); return e } function ws (e, t, n, r) { const i = { ...n, ...t }; for (const o in e) { const a = o; const [s, c, u] = e[a]; const l = r && !r.includes(o); if (void 0 === t[o] && o in t) { if (l) throw new Error(`Cannot remove signed field=${o}`); delete i[o] } else if (c) { const e = n && n[o] ? n[o] : []; let r = t[a]; if (r) { if (!Array.isArray(r)) throw new Error(`keyMap(${o}): KV pairs should be [k, v][]`); r = r.map(e => { if (e.length !== 2) throw new Error(`keyMap(${o}): KV pairs should be [k, v][]`); return [typeof e[0] === 'string' ? c.decode(To.decode(e[0])) : e[0], typeof e[1] === 'string' ? u.decode(To.decode(e[1])) : e[1]] }); const t = {}; const n = (e, n, r) => { if (void 0 === t[e]) return void (t[e] = [n, r]); const i = To.encode(u.encode(t[e][1])); const o = To.encode(u.encode(r)); if (i !== o) throw new Error(`keyMap(${a}): same key=${e} oldVal=${i} newVal=${o}`) }; for (const [t, r] of e) { n(To.encode(c.encode(t)), t, r) } for (const [e, i] of r) { const r = To.encode(c.encode(e)); if (void 0 === i) { if (l) throw new Error(`Cannot remove signed field=${a}/${e}`); delete t[r] } else n(r, e, i) }i[a] = Object.values(t) } } else if (typeof i[o] === 'string')i[o] = u.decode(To.decode(i[o])); else if (l && o in t && n && void 0 !== n[o] && !Co(u.encode(t[o]), u.encode(n[o]))) throw new Error(`Cannot change signed field=${o}`) } for (const t in i)e[t] || delete i[t]; return i } const _s = ra(gs, vs); const Es = ra(ms, vs); const ks = aa({ txid: ea(32, !0), index: Yo }); const Ss = { encode (e) { if (e.length === 2 && ha(e[0]) && _a(e[0], va.ecdsa) && e[1] === 'CHECKSIG') return { type: 'pk', pubkey: e[0] } }, decode: e => e.type === 'pk' ? [e.pubkey, 'CHECKSIG'] : void 0 }; const As = { encode (e) { if (e.length === 5 && e[0] === 'DUP' && e[1] === 'HASH160' && ha(e[2]) && e[3] === 'EQUALVERIFY' && e[4] === 'CHECKSIG') return { type: 'pkh', hash: e[2] } }, decode: e => e.type === 'pkh' ? ['DUP', 'HASH160', e.hash, 'EQUALVERIFY', 'CHECKSIG'] : void 0 }; const Os = { encode (e) { if (e.length === 3 && e[0] === 'HASH160' && ha(e[1]) && e[2] === 'EQUAL') return { type: 'sh', hash: e[1] } }, decode: e => e.type === 'sh' ? ['HASH160', e.hash, 'EQUAL'] : void 0 }; const xs = { encode (e) { if (e.length === 2 && e[0] === 0 && ha(e[1]) && e[1].length === 32) return { type: 'wsh', hash: e[1] } }, decode: e => e.type === 'wsh' ? [0, e.hash] : void 0 }; const Is = { encode (e) { if (e.length === 2 && e[0] === 0 && ha(e[1]) && e[1].length === 20) return { type: 'wpkh', hash: e[1] } }, decode: e => e.type === 'wpkh' ? [0, e.hash] : void 0 }; const Ns = { encode (e) { const t = e.length - 1; if (e[t] !== 'CHECKMULTISIG') return; const n = e[0]; const r = e[t - 1]; if (typeof n !== 'number' || typeof r !== 'number') return; const i = e.slice(1, -2); if (r === i.length) { for (const e of i) if (!ha(e)) return; return { type: 'ms', m: n, pubkeys: i } } }, decode: e => e.type === 'ms' ? [e.m, ...e.pubkeys, e.pubkeys.length, 'CHECKMULTISIG'] : void 0 }; const Ts = { encode (e) { if (e.length === 2 && e[0] === 1 && ha(e[1])) return { type: 'tr', pubkey: e[1] } }, decode: e => e.type === 'tr' ? [1, e.pubkey] : void 0 }; function Rs (e, t = !1) { if (!e) throw new Error('taprootHashTree: empty tree'); if (Array.isArray(e) && e.length === 1 && (e = e[0]), !Array.isArray(e)) { const { leafVersion: n, script: r, tapInternalKey: i } = e; if (e.tapLeafScript || e.tapMerkleRoot && !Co(e.tapMerkleRoot, Ro)) throw new Error('P2TR: tapRoot leafScript cannot have tree'); if (i && Co(i, Bs)) throw new Error('P2TR: tapRoot leafScript cannot have unspendble key'); const o = typeof r === 'string' ? To.decode(r) : r; if (!ha(o)) throw new Error(`checkScript: wrong script type=${o}`); return (function (e, t = !1) { const n = Ms.decode(e); if (!(n.type === 'unknown' && t || ['tr_ns', 'tr_ms'].includes(n.type))) throw new Error(`P2TR: invalid leaf script=${n.type}`) }(o, t)), { type: 'leaf', tapInternalKey: i, version: n, script: o, hash: Zs(o, n) } } if (e.length !== 2 && (e = (function (e) { const t = Array.from(e); for (;t.length >= 2;) { t.sort((e, t) => (t.weight || 1) - (e.weight || 1)); const e = t.pop(); const n = t.pop(); const r = (n?.weight || 1) + (e?.weight || 1); t.push({ weight: r, childs: [n?.childs || n, e?.childs || e] }) } const n = t[0]; return n?.childs || n }(e))), e.length !== 2) throw new Error('hashTree: non binary tree!'); const n = Rs(e[0], t); const r = Rs(e[1], t); let [i, o] = [n.hash, r.hash]; return Ra(o, i) === -1 && ([i, o] = [o, i]), { type: 'branch', left: n, right: r, hash: di.utils.taggedHash('TapBranch', i, o) } } function Ps (e, t = []) { if (!e) throw new Error('taprootAddPath: empty tree'); if (e.type === 'leaf') return { ...e, path: t }; if (e.type !== 'branch') throw new Error(`taprootAddPath: wrong type=${e}`); return { ...e, path: t, left: Ps(e.left, [e.right.hash, ...t]), right: Ps(e.right, [e.left.hash, ...t]) } } function Cs (e) { if (!e) throw new Error('taprootAddPath: empty tree'); if (e.type === 'leaf') return [e]; if (e.type !== 'branch') throw new Error(`taprootWalkTree: wrong type=${e}`); return [...Cs(e.left), ...Cs(e.right)] } const Bs = zi(ca.BASE.toRawBytes(!1)); function Ls (e, t, n = Ia, r = !1) { if (!e && !t) throw new Error('p2tr: should have pubKey or scriptTree (or both)'); const i = typeof e === 'string' ? To.decode(e) : e || Bs; if (!_a(i, va.schnorr)) throw new Error('p2tr: non-schnorr pubkey'); const o = t ? Ps(Rs(t, r)) : void 0; const a = o ? o.hash : void 0; const [s, c] = Sa(i, a || Ro); let u, l; o && (u = Cs(o).map(e => ({ ...e, controlBlock: Ga.encode({ version: (e.version || Ys) + c, internalKey: e.tapInternalKey || i, merklePath: e.path }) }))), u && (l = u.map(e => [Ga.decode(e.controlBlock), ma(e.script, new Uint8Array([e.version || Ys]))])); const d = { type: 'tr', script: Ms.encode({ type: 'tr', pubkey: s }), address: qs(n).encode({ type: 'tr', pubkey: s }), tweakedPubkey: s, tapInternalKey: i }; return u && (d.leaves = u), l && (d.tapLeafScript = l), a && (d.tapMerkleRoot = a), d } const js = { encode (e) { const t = e.length - 1; if (e[t] !== 'CHECKSIG') return; const n = []; for (let r = 0; r < t; r++) { const i = e[r]; if (1 & r) { if (i !== 'CHECKSIGVERIFY' || r === t - 1) return } else { if (!ha(i)) return; n.push(i) } } return { type: 'tr_ns', pubkeys: n } }, decode: e => { if (e.type !== 'tr_ns') return; const t = []; for (let n = 0; n < e.pubkeys.length - 1; n++)t.push(e.pubkeys[n], 'CHECKSIGVERIFY'); return t.push(e.pubkeys[e.pubkeys.length - 1], 'CHECKSIG'), t } }; const Ds = { encode (e) { const t = e.length - 1; if (e[t] !== 'NUMEQUAL' || e[1] !== 'CHECKSIG') return; const n = []; const r = (function (e, t = 4, n = !0) { if (typeof e === 'number') return e; if (ha(e)) try { const r = Ba(t, n).decode(e); if (r > Number.MAX_SAFE_INTEGER) return; return Number(r) } catch (e) { } }(e[t - 1])); if (typeof r === 'number') { for (let r = 0; r < t - 1; r++) { const t = e[r]; if (1 & r) { if (t !== (r === 1 ? 'CHECKSIG' : 'CHECKSIGADD')) throw new Error('OutScript.encode/tr_ms: wrong element') } else { if (!ha(t)) throw new Error('OutScript.encode/tr_ms: wrong key element'); n.push(t) } } return { type: 'tr_ms', pubkeys: n, m: r } } }, decode: e => { if (e.type !== 'tr_ms') return; const t = [e.pubkeys[0], 'CHECKSIG']; for (let n = 1; n < e.pubkeys.length; n++)t.push(e.pubkeys[n], 'CHECKSIGADD'); return t.push(e.m, 'NUMEQUAL'), t } }; const Us = [Ss, As, Os, xs, Is, Ns, Ts, js, Ds, { encode: e => ({ type: 'unknown', script: Ca.encode(e) }), decode: e => e.type === 'unknown' ? Ca.decode(e.script) : void 0 }]; const Ms = ra(na(Ca, qo.match(Us)), e => { if (e.type === 'pk' && !_a(e.pubkey, va.ecdsa)) throw new Error('OutScript/pk: wrong key'); if (!(e.type !== 'pkh' && e.type !== 'sh' && e.type !== 'wpkh' || ha(e.hash) && e.hash.length === 20)) throw new Error(`OutScript/${e.type}: wrong hash`); if (e.type === 'wsh' && (!ha(e.hash) || e.hash.length !== 32)) throw new Error('OutScript/wsh: wrong hash'); if (!(e.type !== 'tr' || ha(e.pubkey) && _a(e.pubkey, va.schnorr))) throw new Error('OutScript/tr: wrong taproot public key'); if ((e.type === 'ms' || e.type === 'tr_ns' || e.type === 'tr_ms') && !Array.isArray(e.pubkeys)) throw new Error('OutScript/multisig: wrong pubkeys array'); if (e.type === 'ms') { const t = e.pubkeys.length; for (const t of e.pubkeys) if (!_a(t, va.ecdsa)) throw new Error('OutScript/multisig: wrong pubkey'); if (e.m <= 0 || t > 16 || e.m > t) throw new Error('OutScript/multisig: invalid params') } if (e.type === 'tr_ns' || e.type === 'tr_ms') for (const t of e.pubkeys) if (!_a(t, va.schnorr)) throw new Error(`OutScript/${e.type}: wrong pubkey`); if (e.type === 'tr_ms') { const t = e.pubkeys.length; if (e.m <= 0 || t > 999 || e.m > t) throw new Error('OutScript/tr_ms: invalid params') } return e }); function zs (e, t) { if (t.length < 2 || t.length > 40) throw new Error('Witness: invalid length'); if (e > 16) throw new Error('Witness: invalid version'); if (e === 0 && t.length !== 20 && t.length !== 32) throw new Error('Witness: invalid length for version') } function Fs (e, t, n = Ia) { zs(e, t); const r = e === 0 ? xo : Io; return r.encode(n.bech32, [e].concat(r.toWords(t))) } function Hs (e, t) { return ya.encode(ma(Uint8Array.from(t), e)) } function qs (e = Ia) { return { encode (t) { const { type: n } = t; if (n === 'wpkh') return Fs(0, t.hash, e); if (n === 'wsh') return Fs(0, t.hash, e); if (n === 'tr') return Fs(1, t.pubkey, e); if (n === 'pkh') return Hs(t.hash, [e.pubKeyHash]); if (n === 'sh') return Hs(t.hash, [e.scriptHash]); throw new Error(`Unknown address type=${n}`) }, decode (t) { if (t.length < 14 || t.length > 74) throw new Error('Invalid address length'); if (e.bech32 && t.toLowerCase().startsWith(e.bech32)) { let n; try { if (n = xo.decode(t), n.words[0] !== 0) throw new Error(`bech32: wrong version=${n.words[0]}`) } catch (e) { if (n = Io.decode(t), n.words[0] === 0) throw new Error(`bech32m: wrong version=${n.words[0]}`) } if (n.prefix !== e.bech32) throw new Error(`wrong bech32 prefix=${n.prefix}`); const [r, ...i] = n.words; const o = xo.fromWords(i); if (zs(r, o), r === 0 && o.length === 32) return { type: 'wsh', hash: o }; if (r === 0 && o.length === 20) return { type: 'wpkh', hash: o }; if (r === 1 && o.length === 32) return { type: 'tr', pubkey: o }; throw new Error('Unkown witness program') } const n = wo.decode(t); if (n.length !== 25) throw new Error('Invalid base58 address'); if (n[0] === e.pubKeyHash) { const e = wo.decode(t); return { type: 'pkh', hash: e.slice(1, e.length - 4) } } if (n[0] === e.scriptHash) { const e = wo.decode(t); return { type: 'sh', hash: wo.decode(t).slice(1, e.length - 4) } } throw new Error(`Invalid address prefix=${n[0]}`) } } } let Ks; !(function (e) { e[e.DEFAULT = 0] = 'DEFAULT', e[e.ALL = 1] = 'ALL', e[e.NONE = 2] = 'NONE', e[e.SINGLE = 3] = 'SINGLE', e[e.ANYONECANPAY = 128] = 'ANYONECANPAY' }(Ks || (Ks = {}))); na(Yo, qo.tsEnum(Ks)); function Vs (e) { const t = 31 & e; return { isAny: !!(e & Ks.ANYONECANPAY), isNone: t === Ks.NONE, isSingle: t === Ks.SINGLE } } function Ws (e) { if (void 0 === e.txid || void 0 === e.index) throw new Error('Transaction/input: txid and index required'); return { txid: e.txid, index: e.index, sequence: fa(e.sequence, Na), finalScriptSig: fa(e.finalScriptSig, Ro) } } function $s (e) { for (const t in e) { const n = t; is.includes(n) || delete e[n] } } function Gs (e) { if (void 0 === e.script || void 0 === e.amount) throw new Error('Transaction/output: script and amount required'); return { script: e.script, amount: e.amount } } const Ys = 192; const Zs = (e, t = Ys) => di.utils.taggedHash('TapLeaf', new Uint8Array([t]), Ma.encode(e)); function Js (e, t, n, r = Ro) { return Co(n, t) && (e = (function (e, t = new Uint8Array()) { const n = di.utils; const r = n.bytesToNumberBE(e); const i = ca.fromPrivateKey(r); const o = i.hasEvenY() ? r : n.mod(-r, da); const a = ka(n.pointToBytes(i), t); return n.numberToBytesBE(n.mod(o + a, da), 32) }(e, r)), t = di.getPublicKey(e)), { privKey: e, pubKey: t } } function Xs (e) { if (t = e, Object.prototype.toString.call(t) !== '[object Object]' || t.constructor !== Object) throw new Error(`Wrong object type for transaction options: ${e}`); let t; const n = { ...e, version: fa(e.version, 2), lockTime: fa(e.lockTime, 0), PSBTVersion: fa(e.PSBTVersion, 0) }; if (![-1, 0, 1, 2].includes(n.version)) throw new Error(`Unknown version: ${n.version}`); if (typeof n.lockTime !== 'number') throw new Error('Transaction lock time should be number'); if (Yo.encode(n.lockTime), n.PSBTVersion !== 0 && n.PSBTVersion !== 2) throw new Error(`Unknown PSBT version ${n.PSBTVersion}`); for (const e of ['allowUnknowOutput', 'allowUnknowInput', 'disableScriptCheck', 'bip174jsCompat', 'allowLegacyWitnessUtxo', 'lowR']) { const t = n[e]; if (void 0 !== t && typeof t !== 'boolean') throw new Error(`Transation options wrong type: ${e}=${t} (${typeof t})`) } return Object.freeze(n) } class Qs {constructor (e = {}) { this.global = {}, this.inputs = [], this.outputs = []; const t = this.opts = Xs(e); t.lockTime !== 0 && (this.global.fallbackLocktime = t.lockTime), this.global.txVersion = t.version } static fromRaw (e, t = {}) { const n = Va.decode(e); const r = new Qs({ ...t, version: n.version, lockTime: n.lockTime }); for (const e of n.outputs)r.addOutput(e); if (r.outputs = n.outputs, r.inputs = n.inputs, n.witnesses) for (let e = 0; e < n.witnesses.length; e++)r.inputs[e].finalScriptWitness = n.witnesses[e]; return r } static fromPSBT (e, t = {}) { let n; try { n = _s.decode(e) } catch (t) { try { n = Es.decode(e) } catch (e) { throw t } } const r = n.global.version || 0; if (r !== 0 && r !== 2) throw new Error(`Wrong PSBT version=${r}`); const i = n.global.unsignedTx; const o = r === 0 ? i?.version : n.global.txVersion; const a = r === 0 ? i?.lockTime : n.global.fallbackLocktime; const s = new Qs({ ...t, version: o, lockTime: a, PSBTVersion: r }); const c = r === 0 ? i?.inputs.length : n.global.inputCount; s.inputs = n.inputs.slice(0, c).map((e, t) => ({ finalScriptSig: Ro, ...n.global.unsignedTx?.inputs[t], ...e })); const u = r === 0 ? i?.outputs.length : n.global.outputCount; return s.outputs = n.outputs.slice(0, u).map((e, t) => ({ ...e, ...n.global.unsignedTx?.outputs[t] })), s.global = { ...n.global, txVersion: o }, a !== 0 && (s.global.fallbackLocktime = a), s }toPSBT (e = this.opts.PSBTVersion) { if (e !== 0 && e !== 2) throw new Error(`Wrong PSBT version=${e}`); const t = this.inputs.map(t => bs(e, rs, t)); for (const e of t)e.partialSig && !e.partialSig.length && delete e.partialSig, e.finalScriptSig && !e.finalScriptSig.length && delete e.finalScriptSig, e.finalScriptWitness && !e.finalScriptWitness.length && delete e.finalScriptWitness; const n = this.outputs.map(t => bs(e, as, t)); const r = { ...this.global }; return e === 0 ? (r.unsignedTx = Va.decode(this.unsignedTx), delete r.fallbackLocktime, delete r.txVersion) : (r.version = e, r.txVersion = this.version, r.inputCount = this.inputs.length, r.outputCount = this.outputs.length, r.fallbackLocktime && r.fallbackLocktime === 0 && delete r.fallbackLocktime), this.opts.bip174jsCompat && (t.length || t.push({}), n.length || n.push({})), (e === 0 ? _s : Es).encode({ global: r, inputs: t, outputs: n }) } get lockTime () { let e = 0; let t = 0; let n = 0; let r = 0; for (const i of this.inputs)i.requiredHeightLocktime && (e = Math.max(e, i.requiredHeightLocktime), t++), i.requiredTimeLocktime && (n = Math.max(n, i.requiredTimeLocktime), r++); return t && t >= r ? e : n !== 0 ? n : this.global.fallbackLocktime || 0 } get version () { if (void 0 === this.global.txVersion) throw new Error('No global.txVersion'); return this.global.txVersion }inputStatus (e) { this.checkInputIdx(e); const t = this.inputs[e]; return t.finalScriptSig && t.finalScriptSig.length || t.finalScriptWitness && t.finalScriptWitness.length ? 'finalized' : t.tapKeySig || t.tapScriptSig && t.tapScriptSig.length || t.partialSig && t.partialSig.length ? 'signed' : 'unsigned' }inputSighash (e) { this.checkInputIdx(e); const t = this.inputType(this.inputs[e]).sighash; const n = t === Ks.DEFAULT ? Ks.ALL : 3 & t; return { sigInputs: t & Ks.ANYONECANPAY, sigOutputs: n } }signStatus () { let e = !0; let t = !0; const n = []; const r = []; for (let i = 0; i < this.inputs.length; i++) { if (this.inputStatus(i) === 'unsigned') continue; const { sigInputs: o, sigOutputs: a } = this.inputSighash(i); if (o === Ks.ANYONECANPAY ? n.push(i) : e = !1, a === Ks.ALL)t = !1; else if (a === Ks.SINGLE)r.push(i); else if (a !== Ks.NONE) throw new Error(`Wrong signature hash output type: ${a}`) } return { addInput: e, addOutput: t, inputs: n, outputs: r } } get isFinal () { for (let e = 0; e < this.inputs.length; e++) if (this.inputStatus(e) !== 'finalized') return !1; return !0 } get hasWitnesses () { let e = !1; for (const t of this.inputs)t.finalScriptWitness && t.finalScriptWitness.length && (e = !0); return e } get weight () { if (!this.isFinal) throw new Error('Transaction is not finalized'); let e = 32; const t = this.outputs.map(Gs); this.hasWitnesses && (e += 2), e += 4 * Da.encode(this.inputs.length).length, e += 4 * Da.encode(this.outputs.length).length; for (const t of this.inputs)t.finalScriptSig && (e += 160 + 4 * Ma.encode(t.finalScriptSig).length); for (const n of t)e += 32 + 4 * Ma.encode(n.script).length; if (this.hasWitnesses) for (const t of this.inputs)t.finalScriptWitness && (e += qa.encode(t.finalScriptWitness).length); return e } get vsize () { return Math.ceil(this.weight / 4) }toBytes (e = !1, t = !1) { return Va.encode({ version: this.version, lockTime: this.lockTime, inputs: this.inputs.map(Ws).map(t => ({ ...t, finalScriptSig: e && t.finalScriptSig || Ro })), outputs: this.outputs.map(Gs), witnesses: this.inputs.map(e => e.finalScriptWitness || []), segwitFlag: t && this.hasWitnesses }) } get unsignedTx () { return this.toBytes(!1, !1) } get hex () { return To.encode(this.toBytes(!0, this.hasWitnesses)) } get hash () { if (!this.isFinal) throw new Error('Transaction is not finalized'); return To.encode(ga(this.toBytes(!0))) } get id () { if (!this.isFinal) throw new Error('Transaction is not finalized'); return To.encode(ga(this.toBytes(!0)).reverse()) }checkInputIdx (e) { if (!Number.isSafeInteger(e) || e < 0 || e >= this.inputs.length) throw new Error(`Wrong input index=${e}`) }getInput (e) { return this.checkInputIdx(e), ba(this.inputs[e]) } get inputsLength () { return this.inputs.length }normalizeInput (e, t, n) { let { nonWitnessUtxo: r, txid: i } = e; typeof r === 'string' && (r = To.decode(r)), ha(r) && (r = Va.decode(r)), void 0 === r && (r = t?.nonWitnessUtxo), typeof i === 'string' && (i = To.decode(i)), void 0 === i && (i = t?.txid); let o; let a = { ...t, ...e, nonWitnessUtxo: r, txid: i }; return void 0 === a.nonWitnessUtxo && delete a.nonWitnessUtxo, void 0 === a.sequence && (a.sequence = Na), a.tapMerkleRoot === null && delete a.tapMerkleRoot, a = ws(rs, a, t, n), fs.encode(a), a.nonWitnessUtxo && void 0 !== a.index ? o = a.nonWitnessUtxo.outputs[a.index] : a.witnessUtxo && (o = a.witnessUtxo), o && !this.opts.disableScriptCheck && ds(o && o.script, a.redeemScript, a.witnessScript), a }addInput (e, t = !1) { if (!t && !this.signStatus().addInput) throw new Error('Tx has signed inputs, cannot add new one'); return this.inputs.push(this.normalizeInput(e)), this.inputs.length - 1 }updateInput (e, t, n = !1) { let r; if (this.checkInputIdx(e), !n) { const t = this.signStatus(); t.addInput && !t.inputs.includes(e) || (r = os) } this.inputs[e] = this.normalizeInput(t, this.inputs[e], r) }checkOutputIdx (e) { if (!Number.isSafeInteger(e) || e < 0 || e >= this.outputs.length) throw new Error(`Wrong output index=${e}`) }getOutput (e) { return this.checkInputIdx(e), ba(this.outputs[e]) } get outputsLength () { return this.outputs.length }normalizeOutput (e, t, n) { let { amount: r, script: i } = e; if (void 0 === r && (r = t?.amount), typeof r !== 'bigint') throw new Error('amount must be bigint sats'); typeof i === 'string' && (i = To.decode(i)), void 0 === i && (i = t?.script); let o = { ...t, ...e, amount: r, script: i }; if (void 0 === o.amount && delete o.amount, o = ws(as, o, t, n), hs.encode(o), o.script && !this.opts.allowUnknowOutput && Ms.decode(o.script).type === 'unknown') throw new Error('Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnkownScript=true, if you sure'); return this.opts.disableScriptCheck || ds(o.script, o.redeemScript, o.witnessScript), o }addOutput (e, t = !1) { if (!t && !this.signStatus().addOutput) throw new Error('Tx has signed outputs, cannot add new one'); return this.outputs.push(this.normalizeOutput(e)), this.outputs.length - 1 }updateOutput (e, t, n = !1) { let r; if (this.checkOutputIdx(e), !n) { const t = this.signStatus(); t.addOutput && !t.outputs.includes(e) || (r = ss) } this.outputs[e] = this.normalizeOutput(t, this.outputs[e], r) }addOutputAddress (e, t, n = Ia) { return this.addOutput({ script: Ms.encode(qs(n).decode(e)), amount: t }) } get fee () { let e = 0n; for (const t of this.inputs) { const n = this.prevOut(t); if (!n) throw new Error('Empty input amount'); e += n.amount } const t = this.outputs.map(Gs); for (const n of t)e -= n.amount; return e }preimageLegacy (e, t, n) { const { isAny: r, isNone: i, isSingle: o } = Vs(n); if (e < 0 || !Number.isSafeInteger(e)) throw new Error(`Invalid input idx=${e}`); if (o && e >= this.outputs.length || e >= this.inputs.length) return Vo.encode(1n); t = Ca.encode(Ca.decode(t).filter(e => e !== 'CODESEPARATOR')); let a = this.inputs.map(Ws).map((n, r) => ({ ...n, finalScriptSig: r === e ? t : Ro })); r ? a = [a[e]] : (i || o) && (a = a.map((t, n) => ({ ...t, sequence: n === e ? t.sequence : 0 }))); let s = this.outputs.map(Gs); i ? s = [] : o && (s = s.slice(0, e).fill(Ha).concat([s[e]])); const c = Va.encode({ lockTime: this.lockTime, version: this.version, segwitFlag: !1, inputs: a, outputs: s }); return ga(c, Jo.encode(n)) }preimageWitnessV0 (e, t, n, r) { const { isAny: i, isNone: o, isSingle: a } = Vs(n); let s = Ta; let c = Ta; let u = Ta; const l = this.inputs.map(Ws); const d = this.outputs.map(Gs); i || (s = ga(...l.map(ks.encode))), i || a || o || (c = ga(...l.map(e => Yo.encode(e.sequence)))), a || o ? a && e < d.length && (u = ga(Fa.encode(d[e]))) : u = ga(...d.map(Fa.encode)); const f = l[e]; return ga(Jo.encode(this.version), s, c, ea(32, !0).encode(f.txid), Yo.encode(f.index), Ma.encode(t), Wo.encode(r), Yo.encode(f.sequence), u, Yo.encode(this.lockTime), Yo.encode(n)) }preimageWitnessV1 (e, t, n, r, i = -1, o, a = 192, s) { if (!Array.isArray(r) || this.inputs.length !== r.length) throw new Error(`Invalid amounts array=${r}`); if (!Array.isArray(t) || this.inputs.length !== t.length) throw new Error(`Invalid prevOutScript array=${t}`); const c = [Qo.encode(0), Qo.encode(n), Jo.encode(this.version), Yo.encode(this.lockTime)]; const u = n === Ks.DEFAULT ? Ks.ALL : 3 & n; const l = n & Ks.ANYONECANPAY; const d = this.inputs.map(Ws); const f = this.outputs.map(Gs); l !== Ks.ANYONECANPAY && c.push(...[d.map(ks.encode), r.map(Wo.encode), t.map(Ma.encode), d.map(e => Yo.encode(e.sequence))].map(e => zi(ma(...e)))), u === Ks.ALL && c.push(zi(ma(...f.map(Fa.encode)))); const h = (s ? 1 : 0) | (o ? 2 : 0); if (c.push(new Uint8Array([h])), l === Ks.ANYONECANPAY) { const n = d[e]; c.push(ks.encode(n), Wo.encode(r[e]), Ma.encode(t[e]), Yo.encode(n.sequence)) } else c.push(Yo.encode(e)); return 1 & h && c.push(zi(Ma.encode(s || Ro))), u === Ks.SINGLE && c.push(e < f.length ? zi(Fa.encode(f[e])) : Ta), o && c.push(Zs(o, a), Qo.encode(0), Jo.encode(i)), di.utils.taggedHash('TapSighash', ...c) }prevOut (e) { if (e.nonWitnessUtxo) { if (void 0 === e.index) throw new Error('Uknown input index'); return e.nonWitnessUtxo.outputs[e.index] } if (e.witnessUtxo) return e.witnessUtxo; throw new Error('Cannot find previous output info.') }inputType (e) { let t = 'legacy'; let n = Ks.ALL; const r = this.prevOut(e); const i = Ms.decode(r.script); let o = i.type; let a = i; const s = [i]; if (i.type === 'tr') return n = Ks.DEFAULT, { txType: 'taproot', type: 'tr', last: i, lastScript: r.script, defaultSighash: n, sighash: e.sighashType || n }; { if (i.type !== 'wpkh' && i.type !== 'wsh' || (t = 'segwit'), i.type === 'sh') { if (!e.redeemScript) throw new Error('inputType: sh without redeemScript'); const n = Ms.decode(e.redeemScript); n.type !== 'wpkh' && n.type !== 'wsh' || (t = 'segwit'), s.push(n), a = n, o += `-${n.type}` } if (a.type === 'wsh') { if (!e.witnessScript) throw new Error('inputType: wsh without witnessScript'); const n = Ms.decode(e.witnessScript); n.type === 'wsh' && (t = 'segwit'), s.push(n), a = n, o += `-${n.type}` } const r = s[s.length - 1]; if (r.type === 'sh' || r.type === 'wsh') throw new Error('inputType: sh/wsh cannot be terminal type'); const c = { type: o, txType: t, last: r, lastScript: Ms.encode(r), defaultSighash: n, sighash: e.sighashType || n }; if (t === 'legacy' && !this.opts.allowLegacyWitnessUtxo && !e.nonWitnessUtxo) throw new Error('Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure'); return c } }signIdx (e, t, n, r) { this.checkInputIdx(t); const i = this.inputs[t]; const o = this.inputType(i); if (!ha(e)) { if (!i.bip32Derivation || !i.bip32Derivation.length) throw new Error('bip32Derivation: empty'); const n = i.bip32Derivation.filter(t => t[1].fingerprint == e.fingerprint).map(([t, { path: n }]) => { let r = e; for (const e of n)r = r.deriveChild(e); if (!Co(r.publicKey, t)) throw new Error('bip32Derivation: wrong pubKey'); if (!r.privateKey) throw new Error('bip32Derivation: no privateKey'); return r }); if (!n.length) throw new Error(`bip32Derivation: no items with fingerprint=${e.fingerprint}`); let r = !1; for (const e of n) this.signIdx(e.privateKey, t) && (r = !0); return r }n || (n = [o.defaultSighash]); const a = o.sighash; if (!n.includes(a)) throw new Error(`Input with not allowed sigHash=${a}. Allowed: ${n.join(', ')}`); const { sigInputs: s, sigOutputs: c } = this.inputSighash(t); if (c === Ks.SINGLE && t >= this.outputs.length) throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${t}`); const u = this.prevOut(i); if (o.txType === 'taproot') { if (i.tapBip32Derivation) throw new Error('tapBip32Derivation unsupported'); const n = this.inputs.map(this.prevOut); const o = n.map(e => e.script); const s = n.map(e => e.amount); let c = !1; const u = di.getPublicKey(e); const l = i.tapMerkleRoot || Ro; if (i.tapInternalKey) { const { pubKey: n, privKey: d } = Js(e, u, i.tapInternalKey, l); const [f, h] = Sa(i.tapInternalKey, l); if (Co(f, n)) { const e = this.preimageWitnessV1(t, o, a, s); const n = ma(di.sign(e, d, r), a !== Ks.DEFAULT ? new Uint8Array([a]) : Ro); this.updateInput(t, { tapKeySig: n }, !0), c = !0 } } if (i.tapLeafScript) { i.tapScriptSig = i.tapScriptSig || []; for (const [n, l] of i.tapLeafScript) { const i = l.subarray(0, -1); const d = Ca.decode(i); const f = l[l.length - 1]; const h = Zs(i, f); const { pubKey: p, privKey: g } = Js(e, u, n.internalKey, Ro); const m = d.findIndex(e => ha(e) && Co(e, p)); if (m === -1) continue; const y = this.preimageWitnessV1(t, o, a, s, void 0, i, f); const b = ma(di.sign(y, g, r), a !== Ks.DEFAULT ? new Uint8Array([a]) : Ro); this.updateInput(t, { tapScriptSig: [[{ pubKey: p, leafHash: h }, b]] }, !0), c = !0 } } if (!c) throw new Error('No taproot scripts signed'); return !0 } { const n = la(e); let r = !1; const i = pa(n); for (const e of Ca.decode(o.lastScript))ha(e) && (Co(e, n) || Co(e, i)) && (r = !0); if (!r) throw new Error(`Input script doesn't have pubKey: ${o.lastScript}`); let s; if (o.txType === 'legacy')s = this.preimageLegacy(t, o.lastScript, a); else { if (o.txType !== 'segwit') throw new Error(`Transaction/sign: unknown tx type: ${o.txType}`); { let e = o.lastScript; o.last.type === 'wpkh' && (e = Ms.encode({ type: 'pkh', hash: o.last.hash })), s = this.preimageWitnessV0(t, e, a, u.amount) } } const c = (function (e, t, n = !1) { let r = ua(e, t); if (n && !Ea(r)) { const n = new Uint8Array(32); for (let i = 0; i < Number.MAX_SAFE_INTEGER && (n.set(Yo.encode(i)), r = ua(e, t, { extraEntropy: n }), !Ea(r)); i++); } return r.toDERRawBytes() }(s, e, this.opts.lowR)); this.updateInput(t, { partialSig: [[n, ma(c, new Uint8Array([a]))]] }, !0) } return !0 }sign (e, t, n) { let r = 0; for (let i = 0; i < this.inputs.length; i++) try { this.signIdx(e, i, t, n) && r++ } catch (e) {} if (!r) throw new Error('No inputs signed'); return r }finalizeIdx (e) { if (this.checkInputIdx(e), this.fee < 0n) throw new Error('Outputs spends more than inputs amount'); const t = this.inputs[e]; const n = this.inputType(t); if (n.txType === 'taproot') { if (t.tapKeySig)t.finalScriptWitness = [t.tapKeySig]; else { if (!t.tapLeafScript || !t.tapScriptSig) throw new Error('finalize/taproot: unknown input'); { const e = t.tapLeafScript.sort((e, t) => Ga.encode(e[0]).length - Ga.encode(t[0]).length); for (const [n, r] of e) { const e = r.slice(0, -1); const i = r[r.length - 1]; const o = Ms.decode(e); const a = Zs(e, i); const s = t.tapScriptSig.filter(e => Co(e[0].leafHash, a)); let c = []; if (o.type === 'tr_ms') { const e = o.m; const t = o.pubkeys; let n = 0; for (const r of t) { const t = s.findIndex(e => Co(e[0].pubKey, r)); n !== e && t !== -1 ? (c.push(s[t][1]), n++) : c.push(Ro) } if (n !== e) continue } else if (o.type === 'tr_ns') { for (const e of o.pubkeys) { const t = s.findIndex(t => Co(t[0].pubKey, e)); t !== -1 && c.push(s[t][1]) } if (c.length !== o.pubkeys.length) continue } else { if (o.type !== 'unknown' || !this.opts.allowUnknowInput) throw new Error('Finalize: Unknown tapLeafScript'); { const t = Ca.decode(e); if (c = s.map(([{ pubKey: e }, n]) => { const r = t.findIndex(t => ha(t) && Co(t, e)); if (r === -1) throw new Error('finalize/taproot: cannot find position of pubkey in script'); return { signature: n, pos: r } }).sort((e, t) => e.pos - t.pos).map(e => e.signature), !c.length) continue } }t.finalScriptWitness = c.reverse().concat([e, Ga.encode(n)]); break } if (!t.finalScriptWitness) throw new Error('finalize/taproot: empty witness') } } return t.finalScriptSig = Ro, void $s(t) } if (!t.partialSig || !t.partialSig.length) throw new Error('Not enough partial sign'); let r; let i; let o = Ro; let a = []; if (n.last.type === 'ms') { const e = n.last.m; const r = n.last.pubkeys; let i = []; for (const e of r) { const n = t.partialSig.find(t => Co(e, t[0])); n && i.push(n[1]) } if (i = i.slice(0, e), i.length !== e) throw new Error(`Multisig: wrong signatures count, m=${e} n=${r.length} signatures=${i.length}`); o = Ca.encode([0, ...i]) } else if (n.last.type === 'pk')o = Ca.encode([t.partialSig[0][1]]); else if (n.last.type === 'pkh')o = Ca.encode([t.partialSig[0][1], t.partialSig[0][0]]); else if (n.last.type === 'wpkh')o = Ro, a = [t.partialSig[0][1], t.partialSig[0][0]]; else if (n.last.type === 'unknown' && !this.opts.allowUnknowInput) throw new Error('Unknown inputs not allowed'); if (n.type.includes('wsh-') && (o.length && n.lastScript.length && (a = Ca.decode(o).map(e => { if (e === 0) return Ro; if (ha(e)) return e; throw new Error(`Wrong witness op=${e}`) })), a = a.concat(n.lastScript)), n.txType === 'segwit' && (i = a), n.type.startsWith('sh-wsh-') ? r = Ca.encode([Ca.encode([0, zi(n.lastScript)])]) : n.type.startsWith('sh-') ? r = Ca.encode([...Ca.decode(o), n.lastScript]) : n.type.startsWith('wsh-') || n.txType !== 'segwit' && (r = o), !r && !i) throw new Error('Unknown error finalizing input'); r && (t.finalScriptSig = r), i && (t.finalScriptWitness = i), $s(t) }finalize () { for (let e = 0; e < this.inputs.length; e++) this.finalizeIdx(e) }extract () { if (!this.isFinal) throw new Error('Transaction has unfinalized inputs'); if (!this.outputs.length) throw new Error('Transaction has no outputs'); if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount'); return this.toBytes(!0, !0) }combine (e) { for (const t of ['PSBTVersion', 'version', 'lockTime']) if (this.opts[t] !== e.opts[t]) throw new Error(`Transaction/combine: different ${t} this=${this.opts[t]} other=${e.opts[t]}`); for (const t of ['inputs', 'outputs']) if (this[t].length !== e[t].length) throw new Error(`Transaction/combine: different ${t} length this=${this[t].length} other=${e[t].length}`); if (!Co(this.global.unsignedTx ? Va.encode(this.global.unsignedTx) : Ro, e.global.unsignedTx ? Va.encode(e.global.unsignedTx) : Ro)) throw new Error('Transaction/combine: different unsigned tx'); this.global = ws(ns, this.global, e.global); for (let t = 0; t < this.inputs.length; t++) this.updateInput(t, e.inputs[t], !0); for (let t = 0; t < this.outputs.length; t++) this.updateOutput(t, e.outputs[t], !0); return this }clone () { return Qs.fromPSBT(this.toPSBT(2), this.opts) }} function ec (e, t, n = Ia) { if (e === 'tr') return Ls(di.getPublicKey(t), void 0, n).address; const r = la(t); if (e === 'pkh') return ((e, t = Ia) => { if (!_a(e, va.ecdsa)) throw new Error('P2PKH: invalid publicKey'); const n = pa(e); return { type: 'pkh', script: Ms.encode({ type: 'pkh', hash: n }), address: qs(t).encode({ type: 'pkh', hash: n }) } })(r, n).address; if (e === 'wpkh') return ((e, t = Ia) => { if (!_a(e, va.ecdsa)) throw new Error('P2WPKH: invalid publicKey'); if (e.length === 65) throw new Error('P2WPKH: uncompressed public key'); const n = pa(e); return { type: 'wpkh', script: Ms.encode({ type: 'wpkh', hash: n }), address: qs(t).encode({ type: 'wpkh', hash: n }) } })(r, n).address; throw new Error(`getAddress: unknown type=${e}`) } const tc = class {networkType; mnemonic; network; constructor (e, t) { this.mnemonic = e, this.networkType = t, this.network = nc[this.networkType] }getTaprootAddress () { const e = `${this.networkType === 'bitcoin' ? "m/86'/0'/0'/0" : "m/86'/1'/0'/0"}/0`; const t = this.mnemonic.deriveKey(e); const n = ec('tr', t.privateKey, this.network); if (!n) throw new Error('No taproot address found from private key'); return { address: n, derivationPath: e, index: 0, publicKey: wn.bytesToHex(t.publicKey) } }}; const nc = { bitcoin: { messagePrefix: 'Bitcoin Signed Message:\n', bech32: 'bc', bip32: { public: 76067358, private: 76066276 }, pubKeyHash: 0, scriptHash: 5, wif: 128 }, testnet: { messagePrefix: 'Bitcoin Signed Message:\n', bech32: 'tb', bip32: { public: 70617039, private: 70615956 }, pubKeyHash: 111, scriptHash: 196, wif: 239 }, regtest: { messagePrefix: 'Bitcoin Signed Message:\n', bech32: 'bcrt', bip32: { public: 70617039, private: 70615956 }, pubKeyHash: 111, scriptHash: 196, wif: 239 } }; class rc extends Ii {constructor (e, t) { super(), this.finished = !1, this.destroyed = !1, vi.hash(e); const n = Oi(t); if (this.iHash = e.create(), typeof this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash'); this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen; const r = this.blockLen; const i = new Uint8Array(r); i.set(n.length > r ? e.create().update(n).digest() : n); for (let e = 0; e < i.length; e++)i[e] ^= 54; this.iHash.update(i), this.oHash = e.create(); for (let e = 0; e < i.length; e++)i[e] ^= 106; this.oHash.update(i), i.fill(0) }update (e) { return vi.exists(this), this.iHash.update(e), this }digestInto (e) { vi.exists(this), vi.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy() }digest () { const e = new Uint8Array(this.oHash.outputLen); return this.digestInto(e), e }_cloneInto (e) { e || (e = Object.create(Object.getPrototypeOf(this), {})); const { oHash: t, iHash: n, finished: r, destroyed: i, blockLen: o, outputLen: a } = this; return e.finished = r, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e }destroy () { this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy() }} const ic = (e, t, n) => new rc(e, t).update(n).digest(); ic.create = (e, t) => new rc(e, t); const oc = BigInt(2 ** 32 - 1); const ac = BigInt(32); function sc (e, t = !1) { return t ? { h: Number(e & oc), l: Number(e >> ac & oc) } : { h: 0 | Number(e >> ac & oc), l: 0 | Number(e & oc) } } const cc = { fromBig: sc, split: function (e, t = !1) { const n = new Uint32Array(e.length); const r = new Uint32Array(e.length); for (let i = 0; i < e.length; i++) { const { h: o, l: a } = sc(e[i], t); [n[i], r[i]] = [o, a] } return [n, r] }, toBig: (e, t) => BigInt(e >>> 0) << ac | BigInt(t >>> 0), shrSH: (e, t, n) => e >>> n, shrSL: (e, t, n) => e << 32 - n | t >>> n, rotrSH: (e, t, n) => e >>> n | t << 32 - n, rotrSL: (e, t, n) => e << 32 - n | t >>> n, rotrBH: (e, t, n) => e << 64 - n | t >>> n - 32, rotrBL: (e, t, n) => e >>> n - 32 | t << 64 - n, rotr32H: (e, t) => t, rotr32L: (e, t) => e, rotlSH: (e, t, n) => e << n | t >>> 32 - n, rotlSL: (e, t, n) => t << n | e >>> 32 - n, rotlBH: (e, t, n) => t << n - 32 | e >>> 64 - n, rotlBL: (e, t, n) => e << n - 32 | t >>> 64 - n, add: function (e, t, n, r) { const i = (t >>> 0) + (r >>> 0); return { h: e + n + (i / 2 ** 32 | 0) | 0, l: 0 | i } }, add3L: (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0), add3H: (e, t, n, r) => t + n + r + (e / 2 ** 32 | 0) | 0, add4L: (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0), add4H: (e, t, n, r, i) => t + n + r + i + (e / 2 ** 32 | 0) | 0, add5H: (e, t, n, r, i, o) => t + n + r + i + o + (e / 2 ** 32 | 0) | 0, add5L: (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0) }; const uc = cc; const [lc, dc] = uc.split(['0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc', '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118', '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2', '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694', '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65', '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5', '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4', '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70', '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df', '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b', '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30', '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8', '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8', '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3', '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec', '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b', '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178', '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b', '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c', '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'].map(e => BigInt(e))); const fc = new Uint32Array(80); const hc = new Uint32Array(80); class pc extends Pi {constructor () { super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209 }get () { const { Ah: e, Al: t, Bh: n, Bl: r, Ch: i, Cl: o, Dh: a, Dl: s, Eh: c, El: u, Fh: l, Fl: d, Gh: f, Gl: h, Hh: p, Hl: g } = this; return [e, t, n, r, i, o, a, s, c, u, l, d, f, h, p, g] }set (e, t, n, r, i, o, a, s, c, u, l, d, f, h, p, g) { this.Ah = 0 | e, this.Al = 0 | t, this.Bh = 0 | n, this.Bl = 0 | r, this.Ch = 0 | i, this.Cl = 0 | o, this.Dh = 0 | a, this.Dl = 0 | s, this.Eh = 0 | c, this.El = 0 | u, this.Fh = 0 | l, this.Fl = 0 | d, this.Gh = 0 | f, this.Gl = 0 | h, this.Hh = 0 | p, this.Hl = 0 | g }process (e, t) { for (let n = 0; n < 16; n++, t += 4)fc[n] = e.getUint32(t), hc[n] = e.getUint32(t += 4); for (let e = 16; e < 80; e++) { const t = 0 | fc[e - 15]; const n = 0 | hc[e - 15]; const r = uc.rotrSH(t, n, 1) ^ uc.rotrSH(t, n, 8) ^ uc.shrSH(t, n, 7); const i = uc.rotrSL(t, n, 1) ^ uc.rotrSL(t, n, 8) ^ uc.shrSL(t, n, 7); const o = 0 | fc[e - 2]; const a = 0 | hc[e - 2]; const s = uc.rotrSH(o, a, 19) ^ uc.rotrBH(o, a, 61) ^ uc.shrSH(o, a, 6); const c = uc.rotrSL(o, a, 19) ^ uc.rotrBL(o, a, 61) ^ uc.shrSL(o, a, 6); const u = uc.add4L(i, c, hc[e - 7], hc[e - 16]); const l = uc.add4H(u, r, s, fc[e - 7], fc[e - 16]); fc[e] = 0 | l, hc[e] = 0 | u } let { Ah: n, Al: r, Bh: i, Bl: o, Ch: a, Cl: s, Dh: c, Dl: u, Eh: l, El: d, Fh: f, Fl: h, Gh: p, Gl: g, Hh: m, Hl: y } = this; for (let e = 0; e < 80; e++) { const t = uc.rotrSH(l, d, 14) ^ uc.rotrSH(l, d, 18) ^ uc.rotrBH(l, d, 41); const b = uc.rotrSL(l, d, 14) ^ uc.rotrSL(l, d, 18) ^ uc.rotrBL(l, d, 41); const v = l & f ^ ~l & p; const w = d & h ^ ~d & g; const _ = uc.add5L(y, b, w, dc[e], hc[e]); const E = uc.add5H(_, m, t, v, lc[e], fc[e]); const k = 0 | _; const S = uc.rotrSH(n, r, 28) ^ uc.rotrBH(n, r, 34) ^ uc.rotrBH(n, r, 39); const A = uc.rotrSL(n, r, 28) ^ uc.rotrBL(n, r, 34) ^ uc.rotrBL(n, r, 39); const O = n & i ^ n & a ^ i & a; const x = r & o ^ r & s ^ o & s; m = 0 | p, y = 0 | g, p = 0 | f, g = 0 | h, f = 0 | l, h = 0 | d, ({ h: l, l: d } = uc.add(0 | c, 0 | u, 0 | E, 0 | k)), c = 0 | a, u = 0 | s, a = 0 | i, s = 0 | o, i = 0 | n, o = 0 | r; const I = uc.add3L(k, A, x); n = uc.add3H(I, E, S, O), r = 0 | I }({ h: n, l: r } = uc.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)), ({ h: i, l: o } = uc.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)), ({ h: a, l: s } = uc.add(0 | this.Ch, 0 | this.Cl, 0 | a, 0 | s)), ({ h: c, l: u } = uc.add(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | u)), ({ h: l, l: d } = uc.add(0 | this.Eh, 0 | this.El, 0 | l, 0 | d)), ({ h: f, l: h } = uc.add(0 | this.Fh, 0 | this.Fl, 0 | f, 0 | h)), ({ h: p, l: g } = uc.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)), ({ h: m, l: y } = uc.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)), this.set(n, r, i, o, a, s, c, u, l, d, f, h, p, g, m, y) }roundClean () { fc.fill(0), hc.fill(0) }destroy () { this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) }} class gc extends pc {constructor () { super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28 }} class mc extends pc {constructor () { super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32 }} class yc extends pc {constructor () { super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48 }} const bc = Ti(() => new pc()); const vc = (Ti(() => new gc()), Ti(() => new mc()), Ti(() => new yc()), BigInt(0), BigInt(1)); const wc = BigInt(2); const _c = e => e instanceof Uint8Array; const Ec = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0')); function kc (e) { if (!_c(e)) throw new Error('Uint8Array expected'); let t = ''; for (let n = 0; n < e.length; n++)t += Ec[e[n]]; return t } function Sc (e) { if (typeof e !== 'string') throw new Error('hex string expected, got ' + typeof e); return BigInt(e === '' ? '0' : `0x${e}`) } function Ac (e) { if (typeof e !== 'string') throw new Error('hex string expected, got ' + typeof e); const t = e.length; if (t % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + t); const n = new Uint8Array(t / 2); for (let t = 0; t < n.length; t++) { const r = 2 * t; const i = e.slice(r, r + 2); const o = Number.parseInt(i, 16); if (Number.isNaN(o) || o < 0) throw new Error('Invalid byte sequence'); n[t] = o } return n } function Oc (e) { return Sc(kc(e)) } function xc (e) { if (!_c(e)) throw new Error('Uint8Array expected'); return Sc(kc(Uint8Array.from(e).reverse())) } function Ic (e, t) { return Ac(e.toString(16).padStart(2 * t, '0')) } function Nc (e, t) { return Ic(e, t).reverse() } function Tc (e, t, n) { let r; if (typeof t === 'string') try { r = Ac(t) } catch (n) { throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${n}`) } else { if (!_c(t)) throw new Error(`${e} must be hex string or Uint8Array`); r = Uint8Array.from(t) } const i = r.length; if (typeof n === 'number' && i !== n) throw new Error(`${e} expected ${n} bytes, got ${i}`); return r } function Rc (...e) { const t = new Uint8Array(e.reduce((e, t) => e + t.length, 0)); let n = 0; return e.forEach(e => { if (!_c(e)) throw new Error('Uint8Array expected'); t.set(e, n), n += e.length }), t } const Pc = e => (wc << BigInt(e - 1)) - vc; const Cc = e => new Uint8Array(e); const Bc = e => Uint8Array.from(e); function Lc (e, t, n) { if (typeof e !== 'number' || e < 2) throw new Error('hashLen must be a number'); if (typeof t !== 'number' || t < 2) throw new Error('qByteLen must be a number'); if (typeof n !== 'function') throw new Error('hmacFn must be a function'); let r = Cc(e); let i = Cc(e); let o = 0; const a = () => { r.fill(1), i.fill(0), o = 0 }; const s = (...e) => n(i, r, ...e); const c = (e = Cc()) => { i = s(Bc([0]), e), r = s(), e.length !== 0 && (i = s(Bc([1]), e), r = s()) }; const u = () => { if (o++ >= 1e3) throw new Error('drbg: tried 1000 values'); let e = 0; const n = []; for (;e < t;) { r = s(); const t = r.slice(); n.push(t), e += r.length } return Rc(...n) }; return (e, t) => { let n; for (a(), c(e); !(n = t(u()));)c(); return a(), n } } const jc = { bigint: e => typeof e === 'bigint', function: e => typeof e === 'function', boolean: e => typeof e === 'boolean', string: e => typeof e === 'string', isSafeInteger: e => Number.isSafeInteger(e), array: e => Array.isArray(e), field: (e, t) => t.Fp.isValid(e), hash: e => typeof e === 'function' && Number.isSafeInteger(e.outputLen) }; function Dc (e, t, n = {}) { const r = (t, n, r) => { const i = jc[n]; if (typeof i !== 'function') throw new Error(`Invalid validator "${n}", expected function`); const o = e[t]; if (!(r && void 0 === o || i(o, e))) throw new Error(`Invalid param ${String(t)}=${o} (${typeof o}), expected ${n}`) }; for (const [e, n] of Object.entries(t))r(e, n, !1); for (const [e, t] of Object.entries(n))r(e, t, !0); return e } const Uc = BigInt(0); const Mc = BigInt(1); const zc = BigInt(2); const Fc = BigInt(3); const Hc = BigInt(4); const qc = BigInt(5); const Kc = BigInt(8); BigInt(9), BigInt(16); function Vc (e, t) { const n = e % t; return n >= Uc ? n : t + n } function Wc (e, t, n) { if (n <= Uc || t < Uc) throw new Error('Expected power/modulo > 0'); if (n === Mc) return Uc; let r = Mc; for (;t > Uc;)t & Mc && (r = r * e % n), e = e * e % n, t >>= Mc; return r } function $c (e, t, n) { let r = e; for (;t-- > Uc;)r *= r, r %= n; return r } function Gc (e, t) { if (e === Uc || t <= Uc) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`); let n = Vc(e, t); let r = t; let i = Uc; let o = Mc; let a = Mc; let s = Uc; for (;n !== Uc;) { const e = r / n; const t = r % n; const c = i - a * e; const u = o - s * e; r = n, n = t, i = a, o = s, a = c, s = u } if (r !== Mc) throw new Error('invert: does not exist'); return Vc(i, t) } function Yc (e) { if (e % Hc === Fc) { const t = (e + Mc) / Hc; return function (e, n) { const r = e.pow(n, t); if (!e.eql(e.sqr(r), n)) throw new Error('Cannot find square root'); return r } } if (e % Kc === qc) { const t = (e - qc) / Kc; return function (e, n) { const r = e.mul(n, zc); const i = e.pow(r, t); const o = e.mul(n, i); const a = e.mul(e.mul(o, zc), i); const s = e.mul(o, e.sub(a, e.ONE)); if (!e.eql(e.sqr(s), n)) throw new Error('Cannot find square root'); return s } } return (function (e) { const t = (e - Mc) / zc; let n, r, i; for (n = e - Mc, r = 0; n % zc === Uc; n /= zc, r++);for (i = zc; i < e && Wc(i, t, e) !== e - Mc; i++);if (r === 1) { const t = (e + Mc) / Hc; return function (e, n) { const r = e.pow(n, t); if (!e.eql(e.sqr(r), n)) throw new Error('Cannot find square root'); return r } } const o = (n + Mc) / zc; return function (e, a) { if (e.pow(a, t) === e.neg(e.ONE)) throw new Error('Cannot find square root'); let s = r; let c = e.pow(e.mul(e.ONE, i), n); let u = e.pow(a, o); let l = e.pow(a, n); for (;!e.eql(l, e.ONE);) { if (e.eql(l, e.ZERO)) return e.ZERO; let t = 1; for (let n = e.sqr(l); t < s && !e.eql(n, e.ONE); t++)n = e.sqr(n); const n = e.pow(c, Mc << BigInt(s - t - 1)); c = e.sqr(n), u = e.mul(u, n), l = e.mul(l, c), s = t } return u } }(e)) } const Zc = ['create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr', 'eql', 'add', 'sub', 'mul', 'pow', 'div', 'addN', 'subN', 'mulN', 'sqrN']; function Jc (e, t) { const n = void 0 !== t ? t : e.toString(2).length; return { nBitLength: n, nByteLength: Math.ceil(n / 8) } } const Xc = BigInt(0); const Qc = BigInt(1); function eu (e) { return (function (e) { const t = Zc.reduce((e, t) => (e[t] = 'function', e), { ORDER: 'bigint', MASK: 'bigint', BYTES: 'isSafeInteger', BITS: 'isSafeInteger' }); Dc(e, t) }(e.Fp)), Dc(e, { n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field' }, { nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger' }), Object.freeze({ ...Jc(e.n, e.nBitLength), ...e, p: e.Fp.ORDER }) } const { bytesToNumberBE: tu, hexToBytes: nu } = t; const ru = { Err: class extends Error {constructor (e = '') { super(e) }}, _parseInt (e) { const { Err: t } = ru; if (e.length < 2 || e[0] !== 2) throw new t('Invalid signature integer tag'); const n = e[1]; const r = e.subarray(2, n + 2); if (!n || r.length !== n) throw new t('Invalid signature integer: wrong length'); if (128 & r[0]) throw new t('Invalid signature integer: negative'); if (r[0] === 0 && !(128 & r[1])) throw new t('Invalid signature integer: unnecessary leading zero'); return { d: tu(r), l: e.subarray(n + 2) } }, toSig (e) { const { Err: t } = ru; const n = typeof e === 'string' ? nu(e) : e; if (!(n instanceof Uint8Array)) throw new Error('ui8a expected'); const r = n.length; if (r < 2 || n[0] != 48) throw new t('Invalid signature tag'); if (n[1] !== r - 2) throw new t('Invalid signature: incorrect length'); const { d: i, l: o } = ru._parseInt(n.subarray(2)); const { d: a, l: s } = ru._parseInt(o); if (s.length) throw new t('Invalid signature: left bytes after parsing'); return { r: i, s: a } }, hexFromSig (e) { const t = e => 8 & Number.parseInt(e[0], 16) ? '00' + e : e; const n = e => { const t = e.toString(16); return 1 & t.length ? `0${t}` : t }; const r = t(n(e.s)); const i = t(n(e.r)); const o = r.length / 2; const a = i.length / 2; const s = n(o); const c = n(a); return `30${n(a + o + 4)}02${c}${i}02${s}${r}` } }; const iu = BigInt(0); const ou = BigInt(1); const au = (BigInt(2), BigInt(3)); BigInt(4); function su (e) { const t = (function (e) { const t = eu(e); Dc(t, { a: 'field', b: 'field' }, { allowedPrivateKeyLengths: 'array', wrapPrivateKey: 'boolean', isTorsionFree: 'function', clearCofactor: 'function', allowInfinityPoint: 'boolean', fromBytes: 'function', toBytes: 'function' }); const { endo: n, Fp: r, a: i } = t; if (n) { if (!r.eql(i, r.ZERO)) throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0'); if (typeof n !== 'object' || typeof n.beta !== 'bigint' || typeof n.splitScalar !== 'function') throw new Error('Expected endomorphism with beta: bigint and splitScalar: function') } return Object.freeze({ ...t }) }(e)); const { Fp: n } = t; const r = t.toBytes || ((e, t, r) => { const i = t.toAffine(); return Rc(Uint8Array.from([4]), n.toBytes(i.x), n.toBytes(i.y)) }); const i = t.fromBytes || (e => { const t = e.subarray(1); return { x: n.fromBytes(t.subarray(0, n.BYTES)), y: n.fromBytes(t.subarray(n.BYTES, 2 * n.BYTES)) } }); function o (e) { const { a: r, b: i } = t; const o = n.sqr(e); const a = n.mul(o, e); return n.add(n.add(a, n.mul(e, r)), i) } if (!n.eql(n.sqr(t.Gy), o(t.Gx))) throw new Error('bad generator point: equation left != right'); function a (e) { return typeof e === 'bigint' && iu < e && e < t.n } function s (e) { if (!a(e)) throw new Error('Expected valid bigint: 0 < bigint < curve.n') } function c (e) { const { allowedPrivateKeyLengths: n, nByteLength: r, wrapPrivateKey: i, n: o } = t; if (n && typeof e !== 'bigint') { if (e instanceof Uint8Array && (e = kc(e)), typeof e !== 'string' || !n.includes(e.length)) throw new Error('Invalid key'); e = e.padStart(2 * r, '0') } let a; try { a = typeof e === 'bigint' ? e : Oc(Tc('private key', e, r)) } catch (t) { throw new Error(`private key must be ${r} bytes, hex or bigint, not ${typeof e}`) } return i && (a = Vc(a, o)), s(a), a } const u = new Map(); function l (e) { if (!(e instanceof d)) throw new Error('ProjectivePoint expected') } class d {constructor (e, t, r) { if (this.px = e, this.py = t, this.pz = r, e == null || !n.isValid(e)) throw new Error('x required'); if (t == null || !n.isValid(t)) throw new Error('y required'); if (r == null || !n.isValid(r)) throw new Error('z required') } static fromAffine (e) { const { x: t, y: r } = e || {}; if (!e || !n.isValid(t) || !n.isValid(r)) throw new Error('invalid affine point'); if (e instanceof d) throw new Error('projective point not allowed'); const i = e => n.eql(e, n.ZERO); return i(t) && i(r) ? d.ZERO : new d(t, r, n.ONE) } get x () { return this.toAffine().x } get y () { return this.toAffine().y } static normalizeZ (e) { const t = n.invertBatch(e.map(e => e.pz)); return e.map((e, n) => e.toAffine(t[n])).map(d.fromAffine) } static fromHex (e) { const t = d.fromAffine(i(Tc('pointHex', e))); return t.assertValidity(), t } static fromPrivateKey (e) { return d.BASE.multiply(c(e)) }_setWindowSize (e) { this._WINDOW_SIZE = e, u.delete(this) }assertValidity () { if (this.is0()) { if (t.allowInfinityPoint) return; throw new Error('bad point: ZERO') } const { x: e, y: r } = this.toAffine(); if (!n.isValid(e) || !n.isValid(r)) throw new Error('bad point: x or y not FE'); const i = n.sqr(r); const a = o(e); if (!n.eql(i, a)) throw new Error('bad point: equation left != right'); if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup') }hasEvenY () { const { y: e } = this.toAffine(); if (n.isOdd) return !n.isOdd(e); throw new Error("Field doesn't support isOdd") }equals (e) { l(e); const { px: t, py: r, pz: i } = this; const { px: o, py: a, pz: s } = e; const c = n.eql(n.mul(t, s), n.mul(o, i)); const u = n.eql(n.mul(r, s), n.mul(a, i)); return c && u }negate () { return new d(this.px, n.neg(this.py), this.pz) }double () { const { a: e, b: r } = t; const i = n.mul(r, au); const { px: o, py: a, pz: s } = this; let c = n.ZERO; let u = n.ZERO; let l = n.ZERO; let f = n.mul(o, o); const h = n.mul(a, a); let p = n.mul(s, s); let g = n.mul(o, a); return g = n.add(g, g), l = n.mul(o, s), l = n.add(l, l), c = n.mul(e, l), u = n.mul(i, p), u = n.add(c, u), c = n.sub(h, u), u = n.add(h, u), u = n.mul(c, u), c = n.mul(g, c), l = n.mul(i, l), p = n.mul(e, p), g = n.sub(f, p), g = n.mul(e, g), g = n.add(g, l), l = n.add(f, f), f = n.add(l, f), f = n.add(f, p), f = n.mul(f, g), u = n.add(u, f), p = n.mul(a, s), p = n.add(p, p), f = n.mul(p, g), c = n.sub(c, f), l = n.mul(p, h), l = n.add(l, l), l = n.add(l, l), new d(c, u, l) }add (e) { l(e); const { px: r, py: i, pz: o } = this; const { px: a, py: s, pz: c } = e; let u = n.ZERO; let f = n.ZERO; let h = n.ZERO; const p = t.a; const g = n.mul(t.b, au); let m = n.mul(r, a); let y = n.mul(i, s); let b = n.mul(o, c); let v = n.add(r, i); let w = n.add(a, s); v = n.mul(v, w), w = n.add(m, y), v = n.sub(v, w), w = n.add(r, o); let _ = n.add(a, c); return w = n.mul(w, _), _ = n.add(m, b), w = n.sub(w, _), _ = n.add(i, o), u = n.add(s, c), _ = n.mul(_, u), u = n.add(y, b), _ = n.sub(_, u), h = n.mul(p, w), u = n.mul(g, b), h = n.add(u, h), u = n.sub(y, h), h = n.add(y, h), f = n.mul(u, h), y = n.add(m, m), y = n.add(y, m), b = n.mul(p, b), w = n.mul(g, w), y = n.add(y, b), b = n.sub(m, b), b = n.mul(p, b), w = n.add(w, b), m = n.mul(y, w), f = n.add(f, m), m = n.mul(_, w), u = n.mul(v, u), u = n.sub(u, m), m = n.mul(v, y), h = n.mul(_, h), h = n.add(h, m), new d(u, f, h) }subtract (e) { return this.add(e.negate()) }is0 () { return this.equals(d.ZERO) }wNAF (e) { return h.wNAFCached(this, u, e, e => { const t = n.invertBatch(e.map(e => e.pz)); return e.map((e, n) => e.toAffine(t[n])).map(d.fromAffine) }) }multiplyUnsafe (e) { const r = d.ZERO; if (e === iu) return r; if (s(e), e === ou) return this; const { endo: i } = t; if (!i) return h.unsafeLadder(this, e); let { k1neg: o, k1: a, k2neg: c, k2: u } = i.splitScalar(e); let l = r; let f = r; let p = this; for (;a > iu || u > iu;)a & ou && (l = l.add(p)), u & ou && (f = f.add(p)), p = p.double(), a >>= ou, u >>= ou; return o && (l = l.negate()), c && (f = f.negate()), f = new d(n.mul(f.px, i.beta), f.py, f.pz), l.add(f) }multiply (e) { s(e); let r; let i; const o = e; const { endo: a } = t; if (a) { const { k1neg: e, k1: t, k2neg: s, k2: c } = a.splitScalar(o); let { p: u, f: l } = this.wNAF(t); let { p: f, f: p } = this.wNAF(c); u = h.constTimeNegate(e, u), f = h.constTimeNegate(s, f), f = new d(n.mul(f.px, a.beta), f.py, f.pz), r = u.add(f), i = l.add(p) } else { const { p: e, f: t } = this.wNAF(o); r = e, i = t } return d.normalizeZ([r, i])[0] }multiplyAndAddUnsafe (e, t, n) { const r = d.BASE; const i = (e, t) => t !== iu && t !== ou && e.equals(r) ? e.multiply(t) : e.multiplyUnsafe(t); const o = i(this, t).add(i(e, n)); return o.is0() ? void 0 : o }toAffine (e) { const { px: t, py: r, pz: i } = this; const o = this.is0(); e == null && (e = o ? n.ONE : n.inv(i)); const a = n.mul(t, e); const s = n.mul(r, e); const c = n.mul(i, e); if (o) return { x: n.ZERO, y: n.ZERO }; if (!n.eql(c, n.ONE)) throw new Error('invZ was invalid'); return { x: a, y: s } }isTorsionFree () { const { h: e, isTorsionFree: n } = t; if (e === ou) return !0; if (n) return n(d, this); throw new Error('isTorsionFree() has not been declared for the elliptic curve') }clearCofactor () { const { h: e, clearCofactor: n } = t; return e === ou ? this : n ? n(d, this) : this.multiplyUnsafe(t.h) }toRawBytes (e = !0) { return this.assertValidity(), r(d, this, e) }toHex (e = !0) { return kc(this.toRawBytes(e)) }}d.BASE = new d(t.Gx, t.Gy, n.ONE), d.ZERO = new d(n.ZERO, n.ONE, n.ZERO); const f = t.nBitLength; const h = (function (e, t) { const n = (e, t) => { const n = t.negate(); return e ? n : t }; const r = e => ({ windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1) }); return { constTimeNegate: n, unsafeLadder (t, n) { let r = e.ZERO; let i = t; for (;n > Xc;)n & Qc && (r = r.add(i)), i = i.double(), n >>= Qc; return r }, precomputeWindow (e, t) { const { windows: n, windowSize: i } = r(t); const o = []; let a = e; let s = a; for (let e = 0; e < n; e++) { s = a, o.push(s); for (let e = 1; e < i; e++)s = s.add(a), o.push(s); a = s.double() } return o }, wNAF (t, i, o) { const { windows: a, windowSize: s } = r(t); let c = e.ZERO; let u = e.BASE; const l = BigInt(2 ** t - 1); const d = 2 ** t; const f = BigInt(t); for (let e = 0; e < a; e++) { const t = e * s; let r = Number(o & l); o >>= f, r > s && (r -= d, o += Qc); const a = t; const h = t + Math.abs(r) - 1; const p = e % 2 != 0; const g = r < 0; r === 0 ? u = u.add(n(p, i[a])) : c = c.add(n(g, i[h])) } return { p: c, f: u } }, wNAFCached (e, t, n, r) { const i = e._WINDOW_SIZE || 1; let o = t.get(e); return o || (o = this.precomputeWindow(e, i), i !== 1 && t.set(e, r(o))), this.wNAF(i, o, n) } } }(d, t.endo ? Math.ceil(f / 2) : f)); return { CURVE: t, ProjectivePoint: d, normPrivateKeyToScalar: c, weierstrassEquation: o, isWithinCurveOrder: a } } function cu (e) { const t = (function (e) { const t = eu(e); return Dc(t, { hash: 'hash', hmac: 'function', randomBytes: 'function' }, { bits2int: 'function', bits2int_modN: 'function', lowS: 'boolean' }), Object.freeze({ lowS: !0, ...t }) }(e)); const { Fp: n, n: r } = t; const i = n.BYTES + 1; const o = 2 * n.BYTES + 1; function a (e) { return Vc(e, r) } function s (e) { return Gc(e, r) } const { ProjectivePoint: c, normPrivateKeyToScalar: u, weierstrassEquation: l, isWithinCurveOrder: d } = su({ ...t, toBytes (e, t, r) { const i = t.toAffine(); const o = n.toBytes(i.x); const a = Rc; return r ? a(Uint8Array.from([t.hasEvenY() ? 2 : 3]), o) : a(Uint8Array.from([4]), o, n.toBytes(i.y)) }, fromBytes (e) { const t = e.length; const r = e[0]; const a = e.subarray(1); if (t !== i || r !== 2 && r !== 3) { if (t === o && r === 4) { return { x: n.fromBytes(a.subarray(0, n.BYTES)), y: n.fromBytes(a.subarray(n.BYTES, 2 * n.BYTES)) } } throw new Error(`Point of length ${t} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`) } { const e = Oc(a); if (!(iu < (s = e) && s < n.ORDER)) throw new Error('Point is not on curve'); const t = l(e); let i = n.sqrt(t); return (1 & r) == 1 !== ((i & ou) === ou) && (i = n.neg(i)), { x: e, y: i } } let s } }); const f = e => kc(Ic(e, t.nByteLength)); function h (e) { return e > r >> ou } const p = (e, t, n) => Oc(e.slice(t, n)); class g {constructor (e, t, n) { this.r = e, this.s = t, this.recovery = n, this.assertValidity() } static fromCompact (e) { const n = t.nByteLength; return e = Tc('compactSignature', e, 2 * n), new g(p(e, 0, n), p(e, n, 2 * n)) } static fromDER (e) { const { r: t, s: n } = ru.toSig(Tc('DER', e)); return new g(t, n) }assertValidity () { if (!d(this.r)) throw new Error('r must be 0 < r < CURVE.n'); if (!d(this.s)) throw new Error('s must be 0 < s < CURVE.n') }addRecoveryBit (e) { return new g(this.r, this.s, e) }recoverPublicKey (e) { const { r, s: i, recovery: o } = this; const u = v(Tc('msgHash', e)); if (o == null || ![0, 1, 2, 3].includes(o)) throw new Error('recovery id invalid'); const l = o === 2 || o === 3 ? r + t.n : r; if (l >= n.ORDER) throw new Error('recovery id 2 or 3 invalid'); const d = (1 & o) == 0 ? '02' : '03'; const h = c.fromHex(d + f(l)); const p = s(l); const g = a(-u * p); const m = a(i * p); const y = c.BASE.multiplyAndAddUnsafe(h, g, m); if (!y) throw new Error('point at infinify'); return y.assertValidity(), y }hasHighS () { return h(this.s) }normalizeS () { return this.hasHighS() ? new g(this.r, a(-this.s), this.recovery) : this }toDERRawBytes () { return Ac(this.toDERHex()) }toDERHex () { return ru.hexFromSig({ r: this.r, s: this.s }) }toCompactRawBytes () { return Ac(this.toCompactHex()) }toCompactHex () { return f(this.r) + f(this.s) }} const m = { isValidPrivateKey (e) { try { return u(e), !0 } catch (e) { return !1 } }, normPrivateKeyToScalar: u, randomPrivateKey: () => { const e = (function (e, t, n = !1) { const r = (e = Tc('privateHash', e)).length; const i = Jc(t).nByteLength + 8; if (i < 24 || r < i || r > 1024) throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${r}`); return Vc(n ? xc(e) : Oc(e), t - Mc) + Mc }(t.randomBytes(n.BYTES + 8), r)); return Ic(e, t.nByteLength) }, precompute: (e = 8, t = c.BASE) => (t._setWindowSize(e), t.multiply(BigInt(3)), t) }; function y (e) { const t = e instanceof Uint8Array; const n = typeof e === 'string'; const r = (t || n) && e.length; return t ? r === i || r === o : n ? r === 2 * i || r === 2 * o : e instanceof c } const b = t.bits2int || function (e) { const n = Oc(e); const r = 8 * e.length - t.nBitLength; return r > 0 ? n >> BigInt(r) : n }; const v = t.bits2int_modN || function (e) { return a(b(e)) }; const w = Pc(t.nBitLength); function _ (e) { if (typeof e !== 'bigint') throw new Error('bigint expected'); if (!(iu <= e && e < w)) throw new Error(`bigint expected < 2^${t.nBitLength}`); return Ic(e, t.nByteLength) } function E (e, r, i = k) { if (['recovered', 'canonical'].some(e => e in i)) throw new Error('sign() legacy options not supported'); const { hash: o, randomBytes: l } = t; let { lowS: f, prehash: p, extraEntropy: m } = i; f == null && (f = !0), e = Tc('msgHash', e), p && (e = Tc('prehashed msgHash', o(e))); const y = v(e); const w = u(r); const E = [_(w), _(y)]; if (m != null) { const e = !0 === m ? l(n.BYTES) : m; E.push(Tc('extraEntropy', e, n.BYTES)) } const S = Rc(...E); const A = y; return { seed: S, k2sig: function (e) { const t = b(e); if (!d(t)) return; const n = s(t); const r = c.BASE.multiply(t).toAffine(); const i = a(r.x); if (i === iu) return; const o = a(n * a(A + i * w)); if (o === iu) return; let u = (r.x === i ? 0 : 2) | Number(r.y & ou); let l = o; return f && h(o) && (l = (function (e) { return h(e) ? a(-e) : e }(o)), u ^= 1), new g(i, l, u) } } } const k = { lowS: t.lowS, prehash: !1 }; const S = { lowS: t.lowS, prehash: !1 }; return c.BASE._setWindowSize(8), { CURVE: t, getPublicKey: function (e, t = !0) { return c.fromPrivateKey(e).toRawBytes(t) }, getSharedSecret: function (e, t, n = !0) { if (y(e)) throw new Error('first arg must be private key'); if (!y(t)) throw new Error('second arg must be public key'); return c.fromHex(t).multiply(u(e)).toRawBytes(n) }, sign: function (e, n, r = k) { const { seed: i, k2sig: o } = E(e, n, r); const a = t; return Lc(a.hash.outputLen, a.nByteLength, a.hmac)(i, o) }, verify: function (e, n, r, i = S) { const o = e; if (n = Tc('msgHash', n), r = Tc('publicKey', r), 'strict' in i) throw new Error('options.strict was renamed to lowS'); const { lowS: u, prehash: l } = i; let d, f; try { if (typeof o === 'string' || o instanceof Uint8Array) try { d = g.fromDER(o) } catch (e) { if (!(e instanceof ru.Err)) throw e; d = g.fromCompact(o) } else { if (typeof o !== 'object' || typeof o.r !== 'bigint' || typeof o.s !== 'bigint') throw new Error('PARSE'); { const { r: e, s: t } = o; d = new g(e, t) } }f = c.fromHex(r) } catch (e) { if (e.message === 'PARSE') throw new Error('signature must be Signature instance, Uint8Array or hex string'); return !1 } if (u && d.hasHighS()) return !1; l && (n = t.hash(n)); const { r: h, s: p } = d; const m = v(n); const y = s(p); const b = a(m * y); const w = a(h * y); const _ = c.BASE.multiplyAndAddUnsafe(f, b, w)?.toAffine(); return !!_ && a(_.x) === h }, ProjectivePoint: c, Signature: g, utils: m } } function uu (e) { return { hash: e, hmac: (t, ...n) => ic(e, t, xi(...n)), randomBytes: Ri } } const lu = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'); const du = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'); const fu = BigInt(1); const hu = BigInt(2); const pu = (e, t) => (e + t / hu) / t; function gu (e) { const t = lu; const n = BigInt(3); const r = BigInt(6); const i = BigInt(11); const o = BigInt(22); const a = BigInt(23); const s = BigInt(44); const c = BigInt(88); const u = e * e * e % t; const l = u * u * e % t; const d = $c(l, n, t) * l % t; const f = $c(d, n, t) * l % t; const h = $c(f, hu, t) * u % t; const p = $c(h, i, t) * h % t; const g = $c(p, o, t) * p % t; const m = $c(g, s, t) * g % t; const y = $c(m, c, t) * m % t; const b = $c(y, s, t) * g % t; const v = $c(b, n, t) * l % t; const w = $c(v, a, t) * p % t; const _ = $c(w, r, t) * u % t; const E = $c(_, hu, t); if (!mu.eql(mu.sqr(E), e)) throw new Error('Cannot find square root'); return E } const mu = (function (e, t, n = !1, r = {}) { if (e <= Uc) throw new Error(`Expected Fp ORDER > 0, got ${e}`); const { nBitLength: i, nByteLength: o } = Jc(e, t); if (o > 2048) throw new Error('Field lengths over 2048 bytes are not supported'); const a = Yc(e); const s = Object.freeze({ ORDER: e, BITS: i, BYTES: o, MASK: Pc(i), ZERO: Uc, ONE: Mc, create: t => Vc(t, e), isValid: t => { if (typeof t !== 'bigint') throw new Error('Invalid field element: expected bigint, got ' + typeof t); return Uc <= t && t < e }, is0: e => e === Uc, isOdd: e => (e & Mc) === Mc, neg: t => Vc(-t, e), eql: (e, t) => e === t, sqr: t => Vc(t * t, e), add: (t, n) => Vc(t + n, e), sub: (t, n) => Vc(t - n, e), mul: (t, n) => Vc(t * n, e), pow: (e, t) => (function (e, t, n) { if (n < Uc) throw new Error('Expected power > 0'); if (n === Uc) return e.ONE; if (n === Mc) return t; let r = e.ONE; let i = t; for (;n > Uc;)n & Mc && (r = e.mul(r, i)), i = e.sqr(i), n >>= Mc; return r }(s, e, t)), div: (t, n) => Vc(t * Gc(n, e), e), sqrN: e => e * e, addN: (e, t) => e + t, subN: (e, t) => e - t, mulN: (e, t) => e * t, inv: t => Gc(t, e), sqrt: r.sqrt || (e => a(s, e)), invertBatch: e => (function (e, t) { const n = new Array(t.length); const r = t.reduce((t, r, i) => e.is0(r) ? t : (n[i] = t, e.mul(t, r)), e.ONE); const i = e.inv(r); return t.reduceRight((t, r, i) => e.is0(r) ? t : (n[i] = e.mul(t, n[i]), e.mul(t, r)), i), n }(s, e)), cmov: (e, t, n) => n ? t : e, toBytes: e => n ? Nc(e, o) : Ic(e, o), fromBytes: e => { if (e.length !== o) throw new Error(`Fp.fromBytes: expected ${o}, got ${e.length}`); return n ? xc(e) : Oc(e) } }); return Object.freeze(s) }(lu, void 0, void 0, { sqrt: gu })); const yu = (function (e, t) { const n = t => cu({ ...e, ...uu(t) }); return Object.freeze({ ...n(t), create: n }) }({ a: BigInt(0), b: BigInt(7), Fp: mu, n: du, Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'), Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'), h: BigInt(1), lowS: !0, endo: { beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'), splitScalar: e => { const t = du; const n = BigInt('0x3086d221a7d46bcde86c90e49284eb15'); const r = -fu * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'); const i = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'); const o = n; const a = BigInt('0x100000000000000000000000000000000'); const s = pu(o * e, t); const c = pu(-r * e, t); let u = Vc(e - s * n - c * i, t); let l = Vc(-s * r - c * o, t); const d = u > a; const f = l > a; if (d && (u = t - u), f && (l = t - l), u > a || l > a) throw new Error('splitScalar: Endomorphism failed, k=' + e); return { k1neg: d, k1: u, k2neg: f, k2: l } } } }, zi)); const bu = BigInt(0); const vu = e => typeof e === 'bigint' && bu < e && e < lu; const wu = e => typeof e === 'bigint' && bu < e && e < du; const _u = {}; function Eu (e, ...t) { let n = _u[e]; if (void 0 === n) { const t = zi(Uint8Array.from(e, e => e.charCodeAt(0))); n = Rc(t, t), _u[e] = n } return zi(Rc(n, ...t)) } const ku = e => e.toRawBytes(!0).slice(1); const Su = e => Ic(e, 32); const Au = e => Vc(e, lu); const Ou = e => Vc(e, du); const xu = yu.ProjectivePoint; const Iu = (e, t, n) => xu.BASE.multiplyAndAddUnsafe(e, t, n); function Nu (e) { const t = yu.utils.normPrivateKeyToScalar(e); const n = xu.fromPrivateKey(t); return { scalar: n.hasEvenY() ? t : Ou(-t), bytes: ku(n) } } function Tu (e) { if (!vu(e)) throw new Error('bad x: need 0 < x < p'); const t = Au(e * e); let n = gu(Au(t * e + BigInt(7))); n % hu !== bu && (n = Au(-n)); const r = new xu(e, n, fu); return r.assertValidity(), r } function Ru (...e) { return Ou(Oc(Eu('BIP0340/challenge', ...e))) } function Pu (e) { return Nu(e).bytes } function Cu (e, t, n = Ri(32)) { const r = Tc('message', e); const { bytes: i, scalar: o } = Nu(t); const a = Tc('auxRand', n, 32); const s = Su(o ^ Oc(Eu('BIP0340/aux', a))); const c = Eu('BIP0340/nonce', s, i, r); const u = Ou(Oc(c)); if (u === bu) throw new Error('sign failed: k is zero'); const { bytes: l, scalar: d } = Nu(u); const f = Ru(l, i, r); const h = new Uint8Array(64); if (h.set(l, 0), h.set(Su(Ou(d + f * o)), 32), !Bu(h, r, i)) throw new Error('sign: Invalid signature produced'); return h } function Bu (e, t, n) { const r = Tc('signature', e, 64); const i = Tc('message', t); const o = Tc('publicKey', n, 32); try { const e = Tu(Oc(o)); const t = Oc(r.subarray(0, 32)); if (!vu(t)) return !1; const n = Oc(r.subarray(32, 64)); if (!wu(n)) return !1; const a = Ru(Su(t), ku(e), i); const s = Iu(e, n, Ou(-a)); return !(!s || !s.hasEvenY() || s.toAffine().x !== t) } catch (e) { return !1 } } const Lu = (() => ({ getPublicKey: Pu, sign: Cu, verify: Bu, utils: { randomPrivateKey: yu.utils.randomPrivateKey, lift_x: Tu, pointToBytes: ku, numberToBytesBE: Ic, bytesToNumberBE: Oc, taggedHash: Eu, mod: Vc } }))(); const ju = yu.ProjectivePoint; const Du = _o(zi); function Uu (e) { return BigInt(`0x${(function (e) { if (!_i(e)) throw new Error('Uint8Array expected'); let t = ''; for (let n = 0; n < e.length; n++)t += Si[e[n]]; return t }(e))}`) } function Mu (e) { return (function (e) { if (typeof e !== 'string') throw new Error('hex string expected, got ' + typeof e); const t = e.length; if (t % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + t); const n = new Uint8Array(t / 2); for (let t = 0; t < n.length; t++) { const r = 2 * t; const i = e.slice(r, r + 2); const o = Number.parseInt(i, 16); if (Number.isNaN(o) || o < 0) throw new Error('Invalid byte sequence'); n[t] = o } return n }(e.toString(16).padStart(64, '0'))) } const zu = Ai('Bitcoin seed'); const Fu = { private: 76066276, public: 76067358 }; const Hu = 2147483648; const qu = e => { if (!Number.isSafeInteger(e) || e < 0 || e > 2 ** 32 - 1) throw new Error(`Invalid number=${e}. Should be from 0 to 2 ** 32 - 1`); const t = new Uint8Array(4); return Ei(t).setUint32(0, e, !1), t }; class Ku {get fingerprint () { if (!this.pubHash) throw new Error('No publicKey set!'); return e = this.pubHash, Ei(e).getUint32(0, !1); let e } get identifier () { return this.pubHash } get pubKeyHash () { return this.pubHash } get privateKey () { return this.privKeyBytes || null } get publicKey () { return this.pubKey || null } get privateExtendedKey () { const e = this.privateKey; if (!e) throw new Error('No private key'); return Du.encode(this.serialize(this.versions.private, xi(new Uint8Array([0]), e))) } get publicExtendedKey () { if (!this.pubKey) throw new Error('No public key'); return Du.encode(this.serialize(this.versions.public, this.pubKey)) } static fromMasterSeed (e, t = Fu) { if (yi(e), 8 * e.length < 128 || 8 * e.length > 512) throw new Error(`HDKey: wrong seed length=${e.length}. Should be between 128 and 512 bits; 256 bits is advised)`); const n = ic(bc, zu, e); return new Ku({ versions: t, chainCode: n.slice(32), privateKey: n.slice(0, 32) }) } static fromExtendedKey (e, t = Fu) { const n = Du.decode(e); const r = Ei(n); const i = r.getUint32(0, !1); const o = { versions: t, depth: n[4], parentFingerprint: r.getUint32(5, !1), index: r.getUint32(9, !1), chainCode: n.slice(13, 45) }; const a = n.slice(45); const s = a[0] === 0; if (i !== t[s ? 'private' : 'public']) throw new Error('Version mismatch'); return new Ku(s ? { ...o, privateKey: a.slice(1) } : { ...o, publicKey: a }) } static fromJSON (e) { return Ku.fromExtendedKey(e.xpriv) }constructor (e) { if (this.depth = 0, this.index = 0, this.chainCode = null, this.parentFingerprint = 0, !e || typeof e !== 'object') throw new Error('HDKey.constructor must not be called directly'); if (this.versions = e.versions || Fu, this.depth = e.depth || 0, this.chainCode = e.chainCode, this.index = e.index || 0, this.parentFingerprint = e.parentFingerprint || 0, !this.depth && (this.parentFingerprint || this.index)) throw new Error('HDKey: zero depth with non-zero index/parent fingerprint'); if (e.publicKey && e.privateKey) throw new Error('HDKey: publicKey and privateKey at same time.'); if (e.privateKey) { if (!yu.utils.isValidPrivateKey(e.privateKey)) throw new Error('Invalid private key'); this.privKey = typeof e.privateKey === 'bigint' ? e.privateKey : Uu(e.privateKey), this.privKeyBytes = Mu(this.privKey), this.pubKey = yu.getPublicKey(e.privateKey, !0) } else { if (!e.publicKey) throw new Error('HDKey: no public or private key provided'); this.pubKey = ju.fromHex(e.publicKey).toRawBytes(!0) } let t; this.pubHash = (t = this.pubKey, to(zi(t))) }derive (e) { if (!/^[mM]'?/.test(e)) throw new Error('Path must start with "m" or "M"'); if (/^[mM]'?$/.test(e)) return this; const t = e.replace(/^[mM]'?\//, '').split('/'); let n = this; for (const e of t) { const t = /^(\d+)('?)$/.exec(e); if (!t || t.length !== 3) throw new Error(`Invalid child index: ${e}`); let r = +t[1]; if (!Number.isSafeInteger(r) || r >= Hu) throw new Error('Invalid index'); t[2] === "'" && (r += Hu), n = n.deriveChild(r) } return n }deriveChild (e) { if (!this.pubKey || !this.chainCode) throw new Error('No publicKey or chainCode set'); let t = qu(e); if (e >= Hu) { const e = this.privateKey; if (!e) throw new Error('Could not derive hardened child key'); t = xi(new Uint8Array([0]), e, t) } else t = xi(this.pubKey, t); const n = ic(bc, this.chainCode, t); const r = Uu(n.slice(0, 32)); const i = n.slice(32); if (!yu.utils.isValidPrivateKey(r)) throw new Error('Tweak bigger than curve order'); const o = { versions: this.versions, chainCode: i, depth: this.depth + 1, parentFingerprint: this.fingerprint, index: e }; try { if (this.privateKey) { const e = Vc(this.privKey + r, yu.CURVE.n); if (!yu.utils.isValidPrivateKey(e)) throw new Error('The tweak was out of range or the resulted private key is invalid'); o.privateKey = e } else { const e = ju.fromHex(this.pubKey).add(ju.fromPrivateKey(r)); if (e.equals(ju.ZERO)) throw new Error('The tweak was equal to negative P, which made the result key invalid'); o.publicKey = e.toRawBytes(!0) } return new Ku(o) } catch (t) { return this.deriveChild(e + 1) } }sign (e) { if (!this.privateKey) throw new Error('No privateKey set!'); return yi(e, 32), yu.sign(e, this.privKey).toCompactRawBytes() }verify (e, t) { if (yi(e, 32), yi(t, 64), !this.publicKey) throw new Error('No publicKey set!'); let n; try { n = yu.Signature.fromCompact(t) } catch (e) { return !1 } return yu.verify(n, e, this.publicKey) }wipePrivateData () { return this.privKey = void 0, this.privKeyBytes && (this.privKeyBytes.fill(0), this.privKeyBytes = void 0), this }toJSON () { return { xpriv: this.privateExtendedKey, xpub: this.publicExtendedKey } }serialize (e, t) { if (!this.chainCode) throw new Error('No chainCode set'); return yi(t, 33), xi(qu(e), new Uint8Array([this.depth]), qu(this.parentFingerprint), qu(this.index), this.chainCode, t) }} function Vu (e, t, n, r) { vi.hash(e); const i = (function (e, t) { if (void 0 !== t && (typeof t !== 'object' || !Ni(t))) throw new Error('Options should be object or undefined'); return Object.assign(e, t) }({ dkLen: 32, asyncTick: 10 }, r)); const { c: o, dkLen: a, asyncTick: s } = i; if (vi.number(o), vi.number(a), vi.number(s), o < 1) throw new Error('PBKDF2: iterations (c) should be >= 1'); const c = Oi(t); const u = Oi(n); const l = new Uint8Array(a); const d = ic.create(e, c); const f = d._cloneInto().update(u); return { c: o, dkLen: a, asyncTick: s, DK: l, PRF: d, PRFSalt: f } } function Wu (e, t, n, r, i) { return e.destroy(), t.destroy(), r && r.destroy(), i.fill(0), n } const $u = e => e[0] === ''; function Gu (e) { if (typeof e !== 'string') throw new TypeError('Invalid mnemonic type: ' + typeof e); return e.normalize('NFKD') } function Yu (e) { const t = Gu(e); const n = t.split(' '); if (![12, 15, 18, 21, 24].includes(n.length)) throw new Error('Invalid mnemonic'); return { nfkd: t, words: n } } function Zu (e) { vi.bytes(e, 16, 20, 24, 28, 32) } function Ju (e, t = 128) { if (vi.number(t), t % 32 != 0 || t > 256) throw new TypeError('Invalid entropy'); return (function (e, t) { Zu(e); const n = Qu(t).encode(e); return n.join($u(t) ? '' : ' ') }(Ri(t / 8), e)) } const Xu = e => { const t = 8 - e.length / 4; return new Uint8Array([zi(e)[0] >> t << t]) }; function Qu (e) { if (!Array.isArray(e) || e.length !== 2048 || typeof e[0] !== 'string') throw new Error('Worlist: expected array of 2048 strings'); return e.forEach(e => { if (typeof e !== 'string') throw new Error(`Wordlist: non-string element: ${e}`) }), yo.chain(yo.checksum(1, Xu), yo.radix2(11, !0), yo.alphabet(e)) } const el = e => Gu(`mnemonic${e}`); function tl (e, t = '') { return (function (e, t, n, r) { const { c: i, dkLen: o, DK: a, PRF: s, PRFSalt: c } = Vu(e, t, n, r); let u; const l = new Uint8Array(4); const d = Ei(l); const f = new Uint8Array(s.outputLen); for (let e = 1, t = 0; t < o; e++, t += s.outputLen) { const n = a.subarray(t, t + s.outputLen); d.setInt32(0, e, !1), (u = c._cloneInto(u)).update(l).digestInto(f), n.set(f.subarray(0, n.length)); for (let e = 1; e < i; e++) { s._cloneInto(u).update(f).digestInto(f); for (let e = 0; e < n.length; e++)n[e] ^= f[e] } } return Wu(s, c, a, u, f) }(bc, Yu(e).nfkd, el(t), { c: 2048, dkLen: 64 })) } const nl = a(3465); const rl = a.n(nl); const il = a(2153); const ol = a.n(il); const al = class {mnemonic; _hdkey; constructor (e) { this.mnemonic = e; const t = tl(e); this._hdkey = Ku.fromMasterSeed(t) }deriveNostrPrivateKeyHex () { return wn.bytesToHex(this.deriveKey("m/44'/1237'/0'/0/0").privateKey) }deriveKey (e) { return this._hdkey.derive(e) } async signMessage (e) { const t = ol()(e).toString(rl()); const n = await (async function (e, t, n = gn) { const { seed: r, k2sig: i } = mn(e, t, n); return yn(!0)(r, i) }(t, this._hdkey.privateKey)); return wn.bytesToHex(n.toCompactRawBytes()) }}; function sl (e) { if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`) } function cl (e, ...t) { if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array'); if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`) } const ul = { number: sl, bool: function (e) { if (typeof e !== 'boolean') throw new Error(`Expected boolean, not ${e}`) }, bytes: cl, hash: function (e) { if (typeof e !== 'function' || typeof e.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor'); sl(e.outputLen), sl(e.blockLen) }, exists: function (e, t = !0) { if (e.destroyed) throw new Error('Hash instance has been destroyed'); if (t && e.finished) throw new Error('Hash#digest() has already been called') }, output: function (e, t) { cl(e); const n = t.outputLen; if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`) } }; const ll = ul; const dl = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0; const fl = e => new DataView(e.buffer, e.byteOffset, e.byteLength); const hl = (e, t) => e << 32 - t | e >>> t; if (!(new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)) throw new Error('Non little-endian hardware is not supported'); const pl = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0')); function gl (e) { if (!(e instanceof Uint8Array)) throw new Error('Uint8Array expected'); let t = ''; for (let n = 0; n < e.length; n++)t += pl[e[n]]; return t } function ml (e) { if (typeof e !== 'string') throw new TypeError('hexToBytes: expected string, got ' + typeof e); if (e.length % 2) throw new Error('hexToBytes: received invalid unpadded hex'); const t = new Uint8Array(e.length / 2); for (let n = 0; n < t.length; n++) { const r = 2 * n; const i = e.slice(r, r + 2); const o = Number.parseInt(i, 16); if (Number.isNaN(o) || o < 0) throw new Error('Invalid byte sequence'); t[n] = o } return t } function yl (e) { if (typeof e === 'string' && (e = (function (e) { if (typeof e !== 'string') throw new TypeError('utf8ToBytes expected string, got ' + typeof e); return (new TextEncoder()).encode(e) }(e))), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`); return e } function bl (...e) { if (!e.every(e => e instanceof Uint8Array)) throw new Error('Uint8Array list expected'); if (e.length === 1) return e[0]; const t = e.reduce((e, t) => e + t.length, 0); const n = new Uint8Array(t); for (let t = 0, r = 0; t < e.length; t++) { const i = e[t]; n.set(i, r), r += i.length } return n } class vl {clone () { return this._cloneInto() }} function wl (e) { const t = t => e().update(yl(t)).digest(); const n = e(); return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t } function _l (e = 32) { if (dl && typeof dl.getRandomValues === 'function') return dl.getRandomValues(new Uint8Array(e)); throw new Error('crypto.getRandomValues must be defined') } class El extends vl {constructor (e, t, n, r) { super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = fl(this.buffer) }update (e) { ll.exists(this); const { view: t, buffer: n, blockLen: r } = this; const i = (e = yl(e)).length; for (let o = 0; o < i;) { const a = Math.min(r - this.pos, i - o); if (a !== r)n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === r && (this.process(t, 0), this.pos = 0); else { const t = fl(e); for (;r <= i - o; o += r) this.process(t, o) } } return this.length += e.length, this.roundClean(), this }digestInto (e) { ll.exists(this), ll.output(e, this), this.finished = !0; const { buffer: t, view: n, blockLen: r, isLE: i } = this; let { pos: o } = this; t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > r - o && (this.process(n, 0), o = 0); for (let e = o; e < r; e++)t[e] = 0; !(function (e, t, n, r) { if (typeof e.setBigUint64 === 'function') return e.setBigUint64(t, n, r); const i = BigInt(32); const o = BigInt(4294967295); const a = Number(n >> i & o); const s = Number(n & o); const c = r ? 4 : 0; const u = r ? 0 : 4; e.setUint32(t + c, a, r), e.setUint32(t + u, s, r) }(n, r - 8, BigInt(8 * this.length), i)), this.process(n, 0); const a = fl(e); const s = this.outputLen; if (s % 4) throw new Error('_sha2: outputLen should be aligned to 32bit'); const c = s / 4; const u = this.get(); if (c > u.length) throw new Error('_sha2: outputLen bigger than state'); for (let e = 0; e < c; e++)a.setUint32(4 * e, u[e], i) }digest () { const { buffer: e, outputLen: t } = this; this.digestInto(e); const n = e.slice(0, t); return this.destroy(), n }_cloneInto (e) { e || (e = new this.constructor()), e.set(...this.get()); const { blockLen: t, buffer: n, length: r, finished: i, destroyed: o, pos: a } = this; return e.length = r, e.pos = a, e.finished = i, e.destroyed = o, r % t && e.buffer.set(n), e }} const kl = (e, t, n) => e & t ^ ~e & n; const Sl = (e, t, n) => e & t ^ e & n ^ t & n; const Al = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]); const Ol = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]); const xl = new Uint32Array(64); class Il extends El {constructor () { super(64, 32, 8, !1), this.A = 0 | Ol[0], this.B = 0 | Ol[1], this.C = 0 | Ol[2], this.D = 0 | Ol[3], this.E = 0 | Ol[4], this.F = 0 | Ol[5], this.G = 0 | Ol[6], this.H = 0 | Ol[7] }get () { const { A: e, B: t, C: n, D: r, E: i, F: o, G: a, H: s } = this; return [e, t, n, r, i, o, a, s] }set (e, t, n, r, i, o, a, s) { this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | o, this.G = 0 | a, this.H = 0 | s }process (e, t) { for (let n = 0; n < 16; n++, t += 4)xl[n] = e.getUint32(t, !1); for (let e = 16; e < 64; e++) { const t = xl[e - 15]; const n = xl[e - 2]; const r = hl(t, 7) ^ hl(t, 18) ^ t >>> 3; const i = hl(n, 17) ^ hl(n, 19) ^ n >>> 10; xl[e] = i + xl[e - 7] + r + xl[e - 16] | 0 } let { A: n, B: r, C: i, D: o, E: a, F: s, G: c, H: u } = this; for (let e = 0; e < 64; e++) { const t = u + (hl(a, 6) ^ hl(a, 11) ^ hl(a, 25)) + kl(a, s, c) + Al[e] + xl[e] | 0; const l = (hl(n, 2) ^ hl(n, 13) ^ hl(n, 22)) + Sl(n, r, i) | 0; u = c, c = s, s = a, a = o + t | 0, o = i, i = r, r = n, n = t + l | 0 }n = n + this.A | 0, r = r + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, s = s + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(n, r, i, o, a, s, c, u) }roundClean () { xl.fill(0) }destroy () { this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0) }} class Nl extends Il {constructor () { super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28 }} const Tl = wl(() => new Il()); const Rl = (wl(() => new Nl()), BigInt(0), BigInt(1)); const Pl = BigInt(2); const Cl = e => e instanceof Uint8Array; const Bl = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0')); function Ll (e) { if (!Cl(e)) throw new Error('Uint8Array expected'); let t = ''; for (let n = 0; n < e.length; n++)t += Bl[e[n]]; return t } function jl (e) { if (typeof e !== 'string') throw new Error('hex string expected, got ' + typeof e); return BigInt(e === '' ? '0' : `0x${e}`) } function Dl (e) { if (typeof e !== 'string') throw new Error('hex string expected, got ' + typeof e); if (e.length % 2) throw new Error('hex string is invalid: unpadded ' + e.length); const t = new Uint8Array(e.length / 2); for (let n = 0; n < t.length; n++) { const r = 2 * n; const i = e.slice(r, r + 2); const o = Number.parseInt(i, 16); if (Number.isNaN(o) || o < 0) throw new Error('invalid byte sequence'); t[n] = o } return t } function Ul (e) { return jl(Ll(e)) } function Ml (e) { if (!Cl(e)) throw new Error('Uint8Array expected'); return jl(Ll(Uint8Array.from(e).reverse())) } const zl = (e, t) => Dl(e.toString(16).padStart(2 * t, '0')); const Fl = (e, t) => zl(e, t).reverse(); function Hl (e, t, n) { let r; if (typeof t === 'string') try { r = Dl(t) } catch (n) { throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${n}`) } else { if (!Cl(t)) throw new Error(`${e} must be hex string or Uint8Array`); r = Uint8Array.from(t) } const i = r.length; if (typeof n === 'number' && i !== n) throw new Error(`${e} expected ${n} bytes, got ${i}`); return r } function ql (...e) { const t = new Uint8Array(e.reduce((e, t) => e + t.length, 0)); let n = 0; return e.forEach(e => { if (!Cl(e)) throw new Error('Uint8Array expected'); t.set(e, n), n += e.length }), t } function Kl (e) { if (typeof e !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof e); return (new TextEncoder()).encode(e) } const Vl = e => (Pl << BigInt(e - 1)) - Rl; const Wl = e => new Uint8Array(e); const $l = e => Uint8Array.from(e); function Gl (e, t, n) { if (typeof e !== 'number' || e < 2) throw new Error('hashLen must be a number'); if (typeof t !== 'number' || t < 2) throw new Error('qByteLen must be a number'); if (typeof n !== 'function') throw new Error('hmacFn must be a function'); let r = Wl(e); let i = Wl(e); let o = 0; const a = () => { r.fill(1), i.fill(0), o = 0 }; const s = (...e) => n(i, r, ...e); const c = (e = Wl()) => { i = s($l([0]), e), r = s(), e.length !== 0 && (i = s($l([1]), e), r = s()) }; const u = () => { if (o++ >= 1e3) throw new Error('drbg: tried 1000 values'); let e = 0; const n = []; for (;e < t;) { r = s(); const t = r.slice(); n.push(t), e += r.length } return ql(...n) }; return (e, t) => { let n; for (a(), c(e); !(n = t(u()));)c(); return a(), n } } const Yl = { bigint: e => typeof e === 'bigint', function: e => typeof e === 'function', boolean: e => typeof e === 'boolean', string: e => typeof e === 'string', isSafeInteger: e => Number.isSafeInteger(e), array: e => Array.isArray(e), field: (e, t) => t.Fp.isValid(e), hash: e => typeof e === 'function' && Number.isSafeInteger(e.outputLen) }; function Zl (e, t, n = {}) { const r = (t, n, r) => { const i = Yl[n]; if (typeof i !== 'function') throw new Error(`Invalid validator "${n}", expected function`); const o = e[t]; if (!(r && void 0 === o || i(o, e))) throw new Error(`Invalid param ${String(t)}=${o} (${typeof o}), expected ${n}`) }; for (const [e, n] of Object.entries(t))r(e, n, !1); for (const [e, t] of Object.entries(n))r(e, t, !0); return e } const Jl = BigInt(0); const Xl = BigInt(1); const Ql = BigInt(2); const ed = BigInt(3); const td = BigInt(4); const nd = BigInt(5); const rd = BigInt(8); BigInt(9), BigInt(16); function id (e, t) { const n = e % t; return n >= Jl ? n : t + n } function od (e, t, n) { if (n <= Jl || t < Jl) throw new Error('Expected power/modulo > 0'); if (n === Xl) return Jl; let r = Xl; for (;t > Jl;)t & Xl && (r = r * e % n), e = e * e % n, t >>= Xl; return r } function ad (e, t, n) { let r = e; for (;t-- > Jl;)r *= r, r %= n; return r } function sd (e, t) { if (e === Jl || t <= Jl) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`); let n = id(e, t); let r = t; let i = Jl; let o = Xl; let a = Xl; let s = Jl; for (;n !== Jl;) { const e = r / n; const t = r % n; const c = i - a * e; const u = o - s * e; r = n, n = t, i = a, o = s, a = c, s = u } if (r !== Xl) throw new Error('invert: does not exist'); return id(i, t) } function cd (e) { if (e % td === ed) { const t = (e + Xl) / td; return function (e, n) { const r = e.pow(n, t); if (!e.eql(e.sqr(r), n)) throw new Error('Cannot find square root'); return r } } if (e % rd === nd) { const t = (e - nd) / rd; return function (e, n) { const r = e.mul(n, Ql); const i = e.pow(r, t); const o = e.mul(n, i); const a = e.mul(e.mul(o, Ql), i); const s = e.mul(o, e.sub(a, e.ONE)); if (!e.eql(e.sqr(s), n)) throw new Error('Cannot find square root'); return s } } return (function (e) { const t = (e - Xl) / Ql; let n, r, i; for (n = e - Xl, r = 0; n % Ql === Jl; n /= Ql, r++);for (i = Ql; i < e && od(i, t, e) !== e - Xl; i++);if (r === 1) { const t = (e + Xl) / td; return function (e, n) { const r = e.pow(n, t); if (!e.eql(e.sqr(r), n)) throw new Error('Cannot find square root'); return r } } const o = (n + Xl) / Ql; return function (e, a) { if (e.pow(a, t) === e.neg(e.ONE)) throw new Error('Cannot find square root'); let s = r; let c = e.pow(e.mul(e.ONE, i), n); let u = e.pow(a, o); let l = e.pow(a, n); for (;!e.eql(l, e.ONE);) { if (e.eql(l, e.ZERO)) return e.ZERO; let t = 1; for (let n = e.sqr(l); t < s && !e.eql(n, e.ONE); t++)n = e.sqr(n); const n = e.pow(c, Xl << BigInt(s - t - 1)); c = e.sqr(n), u = e.mul(u, n), l = e.mul(l, c), s = t } return u } }(e)) } const ud = ['create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr', 'eql', 'add', 'sub', 'mul', 'pow', 'div', 'addN', 'subN', 'mulN', 'sqrN']; function ld (e) { const t = ud.reduce((e, t) => (e[t] = 'function', e), { ORDER: 'bigint', MASK: 'bigint', BYTES: 'isSafeInteger', BITS: 'isSafeInteger' }); return Zl(e, t) } function dd (e, t) { const n = void 0 !== t ? t : e.toString(2).length; return { nBitLength: n, nByteLength: Math.ceil(n / 8) } } const fd = BigInt(0); const hd = BigInt(1); function pd (e) { return ld(e.Fp), Zl(e, { n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field' }, { nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger' }), Object.freeze({ ...dd(e.n, e.nBitLength), ...e, p: e.Fp.ORDER }) } const { bytesToNumberBE: gd, hexToBytes: md } = n; const yd = { Err: class extends Error {constructor (e = '') { super(e) }}, _parseInt (e) { const { Err: t } = yd; if (e.length < 2 || e[0] !== 2) throw new t('Invalid signature integer tag'); const n = e[1]; const r = e.subarray(2, n + 2); if (!n || r.length !== n) throw new t('Invalid signature integer: wrong length'); if (128 & r[0]) throw new t('Invalid signature integer: negative'); if (r[0] === 0 && !(128 & r[1])) throw new t('Invalid signature integer: unnecessary leading zero'); return { d: gd(r), l: e.subarray(n + 2) } }, toSig (e) { const { Err: t } = yd; const n = typeof e === 'string' ? md(e) : e; if (!(n instanceof Uint8Array)) throw new Error('ui8a expected'); const r = n.length; if (r < 2 || n[0] != 48) throw new t('Invalid signature tag'); if (n[1] !== r - 2) throw new t('Invalid signature: incorrect length'); const { d: i, l: o } = yd._parseInt(n.subarray(2)); const { d: a, l: s } = yd._parseInt(o); if (s.length) throw new t('Invalid signature: left bytes after parsing'); return { r: i, s: a } }, hexFromSig (e) { const t = e => 8 & Number.parseInt(e[0], 16) ? '00' + e : e; const n = e => { const t = e.toString(16); return 1 & t.length ? `0${t}` : t }; const r = t(n(e.s)); const i = t(n(e.r)); const o = r.length / 2; const a = i.length / 2; const s = n(o); const c = n(a); return `30${n(a + o + 4)}02${c}${i}02${s}${r}` } }; const bd = BigInt(0); const vd = BigInt(1); const wd = BigInt(2); const _d = BigInt(3); const Ed = BigInt(4); function kd (e) { const t = (function (e) { const t = pd(e); Zl(t, { a: 'field', b: 'field' }, { allowedPrivateKeyLengths: 'array', wrapPrivateKey: 'boolean', isTorsionFree: 'function', clearCofactor: 'function', allowInfinityPoint: 'boolean', fromBytes: 'function', toBytes: 'function' }); const { endo: n, Fp: r, a: i } = t; if (n) { if (!r.eql(i, r.ZERO)) throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0'); if (typeof n !== 'object' || typeof n.beta !== 'bigint' || typeof n.splitScalar !== 'function') throw new Error('Expected endomorphism with beta: bigint and splitScalar: function') } return Object.freeze({ ...t }) }(e)); const { Fp: n } = t; const r = t.toBytes || ((e, t, r) => { const i = t.toAffine(); return ql(Uint8Array.from([4]), n.toBytes(i.x), n.toBytes(i.y)) }); const i = t.fromBytes || (e => { const t = e.subarray(1); return { x: n.fromBytes(t.subarray(0, n.BYTES)), y: n.fromBytes(t.subarray(n.BYTES, 2 * n.BYTES)) } }); function o (e) { const { a: r, b: i } = t; const o = n.sqr(e); const a = n.mul(o, e); return n.add(n.add(a, n.mul(e, r)), i) } if (!n.eql(n.sqr(t.Gy), o(t.Gx))) throw new Error('bad generator point: equation left != right'); function a (e) { return typeof e === 'bigint' && bd < e && e < t.n } function s (e) { if (!a(e)) throw new Error('Expected valid bigint: 0 < bigint < curve.n') } function c (e) { const { allowedPrivateKeyLengths: n, nByteLength: r, wrapPrivateKey: i, n: o } = t; if (n && typeof e !== 'bigint') { if (e instanceof Uint8Array && (e = Ll(e)), typeof e !== 'string' || !n.includes(e.length)) throw new Error('Invalid key'); e = e.padStart(2 * r, '0') } let a; try { a = typeof e === 'bigint' ? e : Ul(Hl('private key', e, r)) } catch (t) { throw new Error(`private key must be ${r} bytes, hex or bigint, not ${typeof e}`) } return i && (a = id(a, o)), s(a), a } const u = new Map(); function l (e) { if (!(e instanceof d)) throw new Error('ProjectivePoint expected') } class d {constructor (e, t, r) { if (this.px = e, this.py = t, this.pz = r, e == null || !n.isValid(e)) throw new Error('x required'); if (t == null || !n.isValid(t)) throw new Error('y required'); if (r == null || !n.isValid(r)) throw new Error('z required') } static fromAffine (e) { const { x: t, y: r } = e || {}; if (!e || !n.isValid(t) || !n.isValid(r)) throw new Error('invalid affine point'); if (e instanceof d) throw new Error('projective point not allowed'); const i = e => n.eql(e, n.ZERO); return i(t) && i(r) ? d.ZERO : new d(t, r, n.ONE) } get x () { return this.toAffine().x } get y () { return this.toAffine().y } static normalizeZ (e) { const t = n.invertBatch(e.map(e => e.pz)); return e.map((e, n) => e.toAffine(t[n])).map(d.fromAffine) } static fromHex (e) { const t = d.fromAffine(i(Hl('pointHex', e))); return t.assertValidity(), t } static fromPrivateKey (e) { return d.BASE.multiply(c(e)) }_setWindowSize (e) { this._WINDOW_SIZE = e, u.delete(this) }assertValidity () { if (this.is0()) { if (t.allowInfinityPoint) return; throw new Error('bad point: ZERO') } const { x: e, y: r } = this.toAffine(); if (!n.isValid(e) || !n.isValid(r)) throw new Error('bad point: x or y not FE'); const i = n.sqr(r); const a = o(e); if (!n.eql(i, a)) throw new Error('bad point: equation left != right'); if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup') }hasEvenY () { const { y: e } = this.toAffine(); if (n.isOdd) return !n.isOdd(e); throw new Error("Field doesn't support isOdd") }equals (e) { l(e); const { px: t, py: r, pz: i } = this; const { px: o, py: a, pz: s } = e; const c = n.eql(n.mul(t, s), n.mul(o, i)); const u = n.eql(n.mul(r, s), n.mul(a, i)); return c && u }negate () { return new d(this.px, n.neg(this.py), this.pz) }double () { const { a: e, b: r } = t; const i = n.mul(r, _d); const { px: o, py: a, pz: s } = this; let c = n.ZERO; let u = n.ZERO; let l = n.ZERO; let f = n.mul(o, o); const h = n.mul(a, a); let p = n.mul(s, s); let g = n.mul(o, a); return g = n.add(g, g), l = n.mul(o, s), l = n.add(l, l), c = n.mul(e, l), u = n.mul(i, p), u = n.add(c, u), c = n.sub(h, u), u = n.add(h, u), u = n.mul(c, u), c = n.mul(g, c), l = n.mul(i, l), p = n.mul(e, p), g = n.sub(f, p), g = n.mul(e, g), g = n.add(g, l), l = n.add(f, f), f = n.add(l, f), f = n.add(f, p), f = n.mul(f, g), u = n.add(u, f), p = n.mul(a, s), p = n.add(p, p), f = n.mul(p, g), c = n.sub(c, f), l = n.mul(p, h), l = n.add(l, l), l = n.add(l, l), new d(c, u, l) }add (e) { l(e); const { px: r, py: i, pz: o } = this; const { px: a, py: s, pz: c } = e; let u = n.ZERO; let f = n.ZERO; let h = n.ZERO; const p = t.a; const g = n.mul(t.b, _d); let m = n.mul(r, a); let y = n.mul(i, s); let b = n.mul(o, c); let v = n.add(r, i); let w = n.add(a, s); v = n.mul(v, w), w = n.add(m, y), v = n.sub(v, w), w = n.add(r, o); let _ = n.add(a, c); return w = n.mul(w, _), _ = n.add(m, b), w = n.sub(w, _), _ = n.add(i, o), u = n.add(s, c), _ = n.mul(_, u), u = n.add(y, b), _ = n.sub(_, u), h = n.mul(p, w), u = n.mul(g, b), h = n.add(u, h), u = n.sub(y, h), h = n.add(y, h), f = n.mul(u, h), y = n.add(m, m), y = n.add(y, m), b = n.mul(p, b), w = n.mul(g, w), y = n.add(y, b), b = n.sub(m, b), b = n.mul(p, b), w = n.add(w, b), m = n.mul(y, w), f = n.add(f, m), m = n.mul(_, w), u = n.mul(v, u), u = n.sub(u, m), m = n.mul(v, y), h = n.mul(_, h), h = n.add(h, m), new d(u, f, h) }subtract (e) { return this.add(e.negate()) }is0 () { return this.equals(d.ZERO) }wNAF (e) { return h.wNAFCached(this, u, e, e => { const t = n.invertBatch(e.map(e => e.pz)); return e.map((e, n) => e.toAffine(t[n])).map(d.fromAffine) }) }multiplyUnsafe (e) { const r = d.ZERO; if (e === bd) return r; if (s(e), e === vd) return this; const { endo: i } = t; if (!i) return h.unsafeLadder(this, e); let { k1neg: o, k1: a, k2neg: c, k2: u } = i.splitScalar(e); let l = r; let f = r; let p = this; for (;a > bd || u > bd;)a & vd && (l = l.add(p)), u & vd && (f = f.add(p)), p = p.double(), a >>= vd, u >>= vd; return o && (l = l.negate()), c && (f = f.negate()), f = new d(n.mul(f.px, i.beta), f.py, f.pz), l.add(f) }multiply (e) { s(e); let r; let i; const o = e; const { endo: a } = t; if (a) { const { k1neg: e, k1: t, k2neg: s, k2: c } = a.splitScalar(o); let { p: u, f: l } = this.wNAF(t); let { p: f, f: p } = this.wNAF(c); u = h.constTimeNegate(e, u), f = h.constTimeNegate(s, f), f = new d(n.mul(f.px, a.beta), f.py, f.pz), r = u.add(f), i = l.add(p) } else { const { p: e, f: t } = this.wNAF(o); r = e, i = t } return d.normalizeZ([r, i])[0] }multiplyAndAddUnsafe (e, t, n) { const r = d.BASE; const i = (e, t) => t !== bd && t !== vd && e.equals(r) ? e.multiply(t) : e.multiplyUnsafe(t); const o = i(this, t).add(i(e, n)); return o.is0() ? void 0 : o }toAffine (e) { const { px: t, py: r, pz: i } = this; const o = this.is0(); e == null && (e = o ? n.ONE : n.inv(i)); const a = n.mul(t, e); const s = n.mul(r, e); const c = n.mul(i, e); if (o) return { x: n.ZERO, y: n.ZERO }; if (!n.eql(c, n.ONE)) throw new Error('invZ was invalid'); return { x: a, y: s } }isTorsionFree () { const { h: e, isTorsionFree: n } = t; if (e === vd) return !0; if (n) return n(d, this); throw new Error('isTorsionFree() has not been declared for the elliptic curve') }clearCofactor () { const { h: e, clearCofactor: n } = t; return e === vd ? this : n ? n(d, this) : this.multiplyUnsafe(t.h) }toRawBytes (e = !0) { return this.assertValidity(), r(d, this, e) }toHex (e = !0) { return Ll(this.toRawBytes(e)) }}d.BASE = new d(t.Gx, t.Gy, n.ONE), d.ZERO = new d(n.ZERO, n.ONE, n.ZERO); const f = t.nBitLength; const h = (function (e, t) { const n = (e, t) => { const n = t.negate(); return e ? n : t }; const r = e => ({ windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1) }); return { constTimeNegate: n, unsafeLadder (t, n) { let r = e.ZERO; let i = t; for (;n > fd;)n & hd && (r = r.add(i)), i = i.double(), n >>= hd; return r }, precomputeWindow (e, t) { const { windows: n, windowSize: i } = r(t); const o = []; let a = e; let s = a; for (let e = 0; e < n; e++) { s = a, o.push(s); for (let e = 1; e < i; e++)s = s.add(a), o.push(s); a = s.double() } return o }, wNAF (t, i, o) { const { windows: a, windowSize: s } = r(t); let c = e.ZERO; let u = e.BASE; const l = BigInt(2 ** t - 1); const d = 2 ** t; const f = BigInt(t); for (let e = 0; e < a; e++) { const t = e * s; let r = Number(o & l); o >>= f, r > s && (r -= d, o += hd); const a = t; const h = t + Math.abs(r) - 1; const p = e % 2 != 0; const g = r < 0; r === 0 ? u = u.add(n(p, i[a])) : c = c.add(n(g, i[h])) } return { p: c, f: u } }, wNAFCached (e, t, n, r) { const i = e._WINDOW_SIZE || 1; let o = t.get(e); return o || (o = this.precomputeWindow(e, i), i !== 1 && t.set(e, r(o))), this.wNAF(i, o, n) } } }(d, t.endo ? Math.ceil(f / 2) : f)); return { CURVE: t, ProjectivePoint: d, normPrivateKeyToScalar: c, weierstrassEquation: o, isWithinCurveOrder: a } } function Sd (e) { const t = (function (e) { const t = pd(e); return Zl(t, { hash: 'hash', hmac: 'function', randomBytes: 'function' }, { bits2int: 'function', bits2int_modN: 'function', lowS: 'boolean' }), Object.freeze({ lowS: !0, ...t }) }(e)); const { Fp: n, n: r } = t; const i = n.BYTES + 1; const o = 2 * n.BYTES + 1; function a (e) { return id(e, r) } function s (e) { return sd(e, r) } const { ProjectivePoint: c, normPrivateKeyToScalar: u, weierstrassEquation: l, isWithinCurveOrder: d } = kd({ ...t, toBytes (e, t, r) { const i = t.toAffine(); const o = n.toBytes(i.x); const a = ql; return r ? a(Uint8Array.from([t.hasEvenY() ? 2 : 3]), o) : a(Uint8Array.from([4]), o, n.toBytes(i.y)) }, fromBytes (e) { const t = e.length; const r = e[0]; const a = e.subarray(1); if (t !== i || r !== 2 && r !== 3) { if (t === o && r === 4) { return { x: n.fromBytes(a.subarray(0, n.BYTES)), y: n.fromBytes(a.subarray(n.BYTES, 2 * n.BYTES)) } } throw new Error(`Point of length ${t} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`) } { const e = Ul(a); if (!(bd < (s = e) && s < n.ORDER)) throw new Error('Point is not on curve'); const t = l(e); let i = n.sqrt(t); return (1 & r) == 1 !== ((i & vd) === vd) && (i = n.neg(i)), { x: e, y: i } } let s } }); const f = e => Ll(zl(e, t.nByteLength)); function h (e) { return e > r >> vd } const p = (e, t, n) => Ul(e.slice(t, n)); class g {constructor (e, t, n) { this.r = e, this.s = t, this.recovery = n, this.assertValidity() } static fromCompact (e) { const n = t.nByteLength; return e = Hl('compactSignature', e, 2 * n), new g(p(e, 0, n), p(e, n, 2 * n)) } static fromDER (e) { const { r: t, s: n } = yd.toSig(Hl('DER', e)); return new g(t, n) }assertValidity () { if (!d(this.r)) throw new Error('r must be 0 < r < CURVE.n'); if (!d(this.s)) throw new Error('s must be 0 < s < CURVE.n') }addRecoveryBit (e) { return new g(this.r, this.s, e) }recoverPublicKey (e) { const { r, s: i, recovery: o } = this; const u = v(Hl('msgHash', e)); if (o == null || ![0, 1, 2, 3].includes(o)) throw new Error('recovery id invalid'); const l = o === 2 || o === 3 ? r + t.n : r; if (l >= n.ORDER) throw new Error('recovery id 2 or 3 invalid'); const d = (1 & o) == 0 ? '02' : '03'; const h = c.fromHex(d + f(l)); const p = s(l); const g = a(-u * p); const m = a(i * p); const y = c.BASE.multiplyAndAddUnsafe(h, g, m); if (!y) throw new Error('point at infinify'); return y.assertValidity(), y }hasHighS () { return h(this.s) }normalizeS () { return this.hasHighS() ? new g(this.r, a(-this.s), this.recovery) : this }toDERRawBytes () { return Dl(this.toDERHex()) }toDERHex () { return yd.hexFromSig({ r: this.r, s: this.s }) }toCompactRawBytes () { return Dl(this.toCompactHex()) }toCompactHex () { return f(this.r) + f(this.s) }} const m = { isValidPrivateKey (e) { try { return u(e), !0 } catch (e) { return !1 } }, normPrivateKeyToScalar: u, randomPrivateKey: () => { const e = (function (e, t, n = !1) { const r = (e = Hl('privateHash', e)).length; const i = dd(t).nByteLength + 8; if (i < 24 || r < i || r > 1024) throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${r}`); return id(n ? Ml(e) : Ul(e), t - Xl) + Xl }(t.randomBytes(n.BYTES + 8), r)); return zl(e, t.nByteLength) }, precompute: (e = 8, t = c.BASE) => (t._setWindowSize(e), t.multiply(BigInt(3)), t) }; function y (e) { const t = e instanceof Uint8Array; const n = typeof e === 'string'; const r = (t || n) && e.length; return t ? r === i || r === o : n ? r === 2 * i || r === 2 * o : e instanceof c } const b = t.bits2int || function (e) { const n = Ul(e); const r = 8 * e.length - t.nBitLength; return r > 0 ? n >> BigInt(r) : n }; const v = t.bits2int_modN || function (e) { return a(b(e)) }; const w = Vl(t.nBitLength); function _ (e) { if (typeof e !== 'bigint') throw new Error('bigint expected'); if (!(bd <= e && e < w)) throw new Error(`bigint expected < 2^${t.nBitLength}`); return zl(e, t.nByteLength) } function E (e, r, i = k) { if (['recovered', 'canonical'].some(e => e in i)) throw new Error('sign() legacy options not supported'); const { hash: o, randomBytes: l } = t; let { lowS: f, prehash: p, extraEntropy: m } = i; f == null && (f = !0), e = Hl('msgHash', e), p && (e = Hl('prehashed msgHash', o(e))); const y = v(e); const w = u(r); const E = [_(w), _(y)]; if (m != null) { const e = !0 === m ? l(n.BYTES) : m; E.push(Hl('extraEntropy', e, n.BYTES)) } const S = ql(...E); const A = y; return { seed: S, k2sig: function (e) { const t = b(e); if (!d(t)) return; const n = s(t); const r = c.BASE.multiply(t).toAffine(); const i = a(r.x); if (i === bd) return; const o = a(n * a(A + i * w)); if (o === bd) return; let u = (r.x === i ? 0 : 2) | Number(r.y & vd); let l = o; return f && h(o) && (l = (function (e) { return h(e) ? a(-e) : e }(o)), u ^= 1), new g(i, l, u) } } } const k = { lowS: t.lowS, prehash: !1 }; const S = { lowS: t.lowS, prehash: !1 }; return c.BASE._setWindowSize(8), { CURVE: t, getPublicKey: function (e, t = !0) { return c.fromPrivateKey(e).toRawBytes(t) }, getSharedSecret: function (e, t, n = !0) { if (y(e)) throw new Error('first arg must be private key'); if (!y(t)) throw new Error('second arg must be public key'); return c.fromHex(t).multiply(u(e)).toRawBytes(n) }, sign: function (e, n, r = k) { const { seed: i, k2sig: o } = E(e, n, r); return Gl(t.hash.outputLen, t.nByteLength, t.hmac)(i, o) }, verify: function (e, n, r, i = S) { const o = e; if (n = Hl('msgHash', n), r = Hl('publicKey', r), 'strict' in i) throw new Error('options.strict was renamed to lowS'); const { lowS: u, prehash: l } = i; let d, f; try { if (typeof o === 'string' || o instanceof Uint8Array) try { d = g.fromDER(o) } catch (e) { if (!(e instanceof yd.Err)) throw e; d = g.fromCompact(o) } else { if (typeof o !== 'object' || typeof o.r !== 'bigint' || typeof o.s !== 'bigint') throw new Error('PARSE'); { const { r: e, s: t } = o; d = new g(e, t) } }f = c.fromHex(r) } catch (e) { if (e.message === 'PARSE') throw new Error('signature must be Signature instance, Uint8Array or hex string'); return !1 } if (u && d.hasHighS()) return !1; l && (n = t.hash(n)); const { r: h, s: p } = d; const m = v(n); const y = s(p); const b = a(m * y); const w = a(h * y); const _ = c.BASE.multiplyAndAddUnsafe(f, b, w)?.toAffine(); return !!_ && a(_.x) === h }, ProjectivePoint: c, Signature: g, utils: m } } const Ad = Ul; function Od (e, t) { if (e < 0 || e >= 1 << 8 * t) throw new Error(`bad I2OSP call: value=${e} length=${t}`); const n = Array.from({ length: t }).fill(0); for (let r = t - 1; r >= 0; r--)n[r] = 255 & e, e >>>= 8; return new Uint8Array(n) } function xd (e, t) { const n = new Uint8Array(e.length); for (let r = 0; r < e.length; r++)n[r] = e[r] ^ t[r]; return n } function Id (e) { if (!(e instanceof Uint8Array)) throw new Error('Uint8Array expected') } function Nd (e) { if (!Number.isSafeInteger(e)) throw new Error('number expected') } function Td (e, t, n) { Zl(n, { DST: 'string', p: 'bigint', m: 'isSafeInteger', k: 'isSafeInteger', hash: 'hash' }); const { p: r, k: i, m: o, hash: a, expand: s, DST: c } = n; Id(e), Nd(t); const u = (function (e) { if (e instanceof Uint8Array) return e; if (typeof e === 'string') return Kl(e); throw new Error('DST must be Uint8Array or string') }(c)); const l = r.toString(2).length; const d = Math.ceil((l + i) / 8); const f = t * o * d; let h; if (s === 'xmd')h = (function (e, t, n, r) { Id(e), Id(t), Nd(n), t.length > 255 && (t = r(ql(Kl('H2C-OVERSIZE-DST-'), t))); const { outputLen: i, blockLen: o } = r; const a = Math.ceil(n / i); if (a > 255) throw new Error('Invalid xmd length'); const s = ql(t, Od(t.length, 1)); const c = Od(0, o); const u = Od(n, 2); const l = new Array(a); const d = r(ql(c, e, u, Od(0, 1), s)); l[0] = r(ql(d, Od(1, 1), s)); for (let e = 1; e <= a; e++) { const t = [xd(d, l[e - 1]), Od(e + 1, 1), s]; l[e] = r(ql(...t)) } return ql(...l).slice(0, n) }(e, u, f, a)); else if (s === 'xof')h = (function (e, t, n, r, i) { if (Id(e), Id(t), Nd(n), t.length > 255) { const e = Math.ceil(2 * r / 8); t = i.create({ dkLen: e }).update(Kl('H2C-OVERSIZE-DST-')).update(t).digest() } if (n > 65535 || t.length > 255) throw new Error('expand_message_xof: invalid lenInBytes'); return i.create({ dkLen: n }).update(e).update(Od(n, 2)).update(t).update(Od(t.length, 1)).digest() }(e, u, f, i, a)); else { if (s !== '_internal_pass') throw new Error('expand must be "xmd" or "xof"'); h = e } const p = new Array(t); for (let e = 0; e < t; e++) { const t = new Array(o); for (let n = 0; n < o; n++) { const i = d * (n + e * o); const a = h.subarray(i, i + d); t[n] = id(Ad(a), r) }p[e] = t } return p } class Rd extends vl {constructor (e, t) { super(), this.finished = !1, this.destroyed = !1, ll.hash(e); const n = yl(t); if (this.iHash = e.create(), typeof this.iHash.update !== 'function') throw new TypeError('Expected instance of class which extends utils.Hash'); this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen; const r = this.blockLen; const i = new Uint8Array(r); i.set(n.length > r ? e.create().update(n).digest() : n); for (let e = 0; e < i.length; e++)i[e] ^= 54; this.iHash.update(i), this.oHash = e.create(); for (let e = 0; e < i.length; e++)i[e] ^= 106; this.oHash.update(i), i.fill(0) }update (e) { return ll.exists(this), this.iHash.update(e), this }digestInto (e) { ll.exists(this), ll.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy() }digest () { const e = new Uint8Array(this.oHash.outputLen); return this.digestInto(e), e }_cloneInto (e) { e || (e = Object.create(Object.getPrototypeOf(this), {})); const { oHash: t, iHash: n, finished: r, destroyed: i, blockLen: o, outputLen: a } = this; return e.finished = r, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e }destroy () { this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy() }} const Pd = (e, t, n) => new Rd(e, t).update(n).digest(); function Cd (e) { return { hash: e, hmac: (t, ...n) => Pd(e, t, bl(...n)), randomBytes: _l } }Pd.create = (e, t) => new Rd(e, t); const Bd = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'); const Ld = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'); const jd = BigInt(1); const Dd = BigInt(2); const Ud = (e, t) => (e + t / Dd) / t; function Md (e) { const t = Bd; const n = BigInt(3); const r = BigInt(6); const i = BigInt(11); const o = BigInt(22); const a = BigInt(23); const s = BigInt(44); const c = BigInt(88); const u = e * e * e % t; const l = u * u * e % t; const d = ad(l, n, t) * l % t; const f = ad(d, n, t) * l % t; const h = ad(f, Dd, t) * u % t; const p = ad(h, i, t) * h % t; const g = ad(p, o, t) * p % t; const m = ad(g, s, t) * g % t; const y = ad(m, c, t) * m % t; const b = ad(y, s, t) * g % t; const v = ad(b, n, t) * l % t; const w = ad(v, a, t) * p % t; const _ = ad(w, r, t) * u % t; const E = ad(_, Dd, t); if (!zd.eql(zd.sqr(E), e)) throw new Error('Cannot find square root'); return E } const zd = (function (e, t, n = !1, r = {}) { if (e <= Jl) throw new Error(`Expected Fp ORDER > 0, got ${e}`); const { nBitLength: i, nByteLength: o } = dd(e, t); if (o > 2048) throw new Error('Field lengths over 2048 bytes are not supported'); const a = cd(e); const s = Object.freeze({ ORDER: e, BITS: i, BYTES: o, MASK: Vl(i), ZERO: Jl, ONE: Xl, create: t => id(t, e), isValid: t => { if (typeof t !== 'bigint') throw new Error('Invalid field element: expected bigint, got ' + typeof t); return Jl <= t && t < e }, is0: e => e === Jl, isOdd: e => (e & Xl) === Xl, neg: t => id(-t, e), eql: (e, t) => e === t, sqr: t => id(t * t, e), add: (t, n) => id(t + n, e), sub: (t, n) => id(t - n, e), mul: (t, n) => id(t * n, e), pow: (e, t) => (function (e, t, n) { if (n < Jl) throw new Error('Expected power > 0'); if (n === Jl) return e.ONE; if (n === Xl) return t; let r = e.ONE; let i = t; for (;n > Jl;)n & Xl && (r = e.mul(r, i)), i = e.sqr(i), n >>= Xl; return r }(s, e, t)), div: (t, n) => id(t * sd(n, e), e), sqrN: e => e * e, addN: (e, t) => e + t, subN: (e, t) => e - t, mulN: (e, t) => e * t, inv: t => sd(t, e), sqrt: r.sqrt || (e => a(s, e)), invertBatch: e => (function (e, t) { const n = new Array(t.length); const r = t.reduce((t, r, i) => e.is0(r) ? t : (n[i] = t, e.mul(t, r)), e.ONE); const i = e.inv(r); return t.reduceRight((t, r, i) => e.is0(r) ? t : (n[i] = e.mul(t, n[i]), e.mul(t, r)), i), n }(s, e)), cmov: (e, t, n) => n ? t : e, toBytes: e => n ? Fl(e, o) : zl(e, o), fromBytes: e => { if (e.length !== o) throw new Error(`Fp.fromBytes: expected ${o}, got ${e.length}`); return n ? Ml(e) : Ul(e) } }); return Object.freeze(s) }(Bd, void 0, void 0, { sqrt: Md })); const Fd = (function (e, t) { const n = t => Sd({ ...e, ...Cd(t) }); return Object.freeze({ ...n(t), create: n }) }({ a: BigInt(0), b: BigInt(7), Fp: zd, n: Ld, Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'), Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'), h: BigInt(1), lowS: !0, endo: { beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'), splitScalar: e => { const t = Ld; const n = BigInt('0x3086d221a7d46bcde86c90e49284eb15'); const r = -jd * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'); const i = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'); const o = n; const a = BigInt('0x100000000000000000000000000000000'); const s = Ud(o * e, t); const c = Ud(-r * e, t); let u = id(e - s * n - c * i, t); let l = id(-s * r - c * o, t); const d = u > a; const f = l > a; if (d && (u = t - u), f && (l = t - l), u > a || l > a) throw new Error('splitScalar: Endomorphism failed, k=' + e); return { k1neg: d, k1: u, k2neg: f, k2: l } } } }, Tl)); const Hd = BigInt(0); const qd = e => typeof e === 'bigint' && Hd < e && e < Bd; const Kd = e => typeof e === 'bigint' && Hd < e && e < Ld; const Vd = {}; function Wd (e, ...t) { let n = Vd[e]; if (void 0 === n) { const t = Tl(Uint8Array.from(e, e => e.charCodeAt(0))); n = ql(t, t), Vd[e] = n } return Tl(ql(n, ...t)) } const $d = e => e.toRawBytes(!0).slice(1); const Gd = e => zl(e, 32); const Yd = e => id(e, Bd); const Zd = e => id(e, Ld); const Jd = Fd.ProjectivePoint; const Xd = (e, t, n) => Jd.BASE.multiplyAndAddUnsafe(e, t, n); function Qd (e) { const t = Fd.utils.normPrivateKeyToScalar(e); const n = Jd.fromPrivateKey(t); return { scalar: n.hasEvenY() ? t : Zd(-t), bytes: $d(n) } } function ef (e) { if (!qd(e)) throw new Error('bad x: need 0 < x < p'); const t = Yd(e * e); let n = Md(Yd(t * e + BigInt(7))); n % Dd !== Hd && (n = Yd(-n)); const r = new Jd(e, n, jd); return r.assertValidity(), r } function tf (...e) { return Zd(Ul(Wd('BIP0340/challenge', ...e))) } function nf (e, t, n) { const r = Hl('signature', e, 64); const i = Hl('message', t); const o = Hl('publicKey', n, 32); try { const e = ef(Ul(o)); const t = Ul(r.subarray(0, 32)); if (!qd(t)) return !1; const n = Ul(r.subarray(32, 64)); if (!Kd(n)) return !1; const a = tf(Gd(t), $d(e), i); const s = Xd(e, n, Zd(-a)); return !(!s || !s.hasEvenY() || s.toAffine().x !== t) } catch (e) { return !1 } } const rf = { getPublicKey: function (e) { return Qd(e).bytes }, sign: function (e, t, n = _l(32)) { const r = Hl('message', e); const { bytes: i, scalar: o } = Qd(t); const a = Hl('auxRand', n, 32); const s = Gd(o ^ Ul(Wd('BIP0340/aux', a))); const c = Wd('BIP0340/nonce', s, i, r); const u = Zd(Ul(c)); if (u === Hd) throw new Error('sign failed: k is zero'); const { bytes: l, scalar: d } = Qd(u); const f = tf(l, i, r); const h = new Uint8Array(64); if (h.set(l, 0), h.set(Gd(Zd(d + f * o)), 32), !nf(h, r, i)) throw new Error('sign: Invalid signature produced'); return h }, verify: nf, utils: { randomPrivateKey: Fd.utils.randomPrivateKey, lift_x: ef, pointToBytes: $d, numberToBytesBE: zl, bytesToNumberBE: Ul, taggedHash: Wd, mod: id } }; const of = (function (e, t) { const n = t.map(e => Array.from(e).reverse()); return (t, r) => { const [i, o, a, s] = n.map(n => n.reduce((n, r) => e.add(e.mul(n, t), r))); return t = e.div(i, o), r = e.mul(r, e.div(a, s)), { x: t, y: r } } }(zd, [['0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7', '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581', '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262', '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'], ['0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b', '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14', '0x0000000000000000000000000000000000000000000000000000000000000001'], ['0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c', '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3', '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931', '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'], ['0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b', '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573', '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f', '0x0000000000000000000000000000000000000000000000000000000000000001']].map(e => e.map(e => BigInt(e))))); const af = (function (e, t) { if (ld(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts'); const n = (function (e, t) { const n = e.ORDER; let r = bd; for (let e = n - vd; e % wd === bd; e /= wd)r += vd; const i = r; const o = (n - vd) / wd ** i; const a = (o - vd) / wd; const s = wd ** i - vd; const c = wd ** (i - vd); const u = e.pow(t, o); const l = e.pow(t, (o + vd) / wd); let d = (t, n) => { let r = u; let o = e.pow(n, s); let d = e.sqr(o); d = e.mul(d, n); let f = e.mul(t, d); f = e.pow(f, a), f = e.mul(f, o), o = e.mul(f, n), d = e.mul(f, t); let h = e.mul(d, o); f = e.pow(h, c); const p = e.eql(f, e.ONE); o = e.mul(d, l), f = e.mul(h, r), d = e.cmov(o, d, p), h = e.cmov(f, h, p); for (let t = i; t > vd; t--) { const n = wd ** (t - wd); let i = e.pow(h, n); const a = e.eql(i, e.ONE); o = e.mul(d, r), r = e.mul(r, r), i = e.mul(h, r), d = e.cmov(o, d, a), h = e.cmov(i, h, a) } return { isValid: p, value: d } }; if (e.ORDER % Ed === _d) { const n = (e.ORDER - _d) / Ed; const r = e.sqrt(e.neg(t)); d = (t, i) => { let o = e.sqr(i); const a = e.mul(t, i); o = e.mul(o, a); let s = e.pow(o, n); s = e.mul(s, a); const c = e.mul(s, r); const u = e.mul(e.sqr(s), i); const l = e.eql(u, t); return { isValid: l, value: e.cmov(c, s, l) } } } return d }(e, t.Z)); if (!e.isOdd) throw new Error('Fp.isOdd is not implemented!'); return r => { let i, o, a, s, c, u, l, d; i = e.sqr(r), i = e.mul(i, t.Z), o = e.sqr(i), o = e.add(o, i), a = e.add(o, e.ONE), a = e.mul(a, t.B), s = e.cmov(t.Z, e.neg(o), !e.eql(o, e.ZERO)), s = e.mul(s, t.A), o = e.sqr(a), u = e.sqr(s), c = e.mul(u, t.A), o = e.add(o, c), o = e.mul(o, a), u = e.mul(u, s), c = e.mul(u, t.B), o = e.add(o, c), l = e.mul(i, a); const { isValid: f, value: h } = n(o, u); d = e.mul(i, r), d = e.mul(d, h), l = e.cmov(l, a, f), d = e.cmov(d, h, f); const p = e.isOdd(r) === e.isOdd(d); return d = e.cmov(e.neg(d), d, p), l = e.div(l, s), { x: l, y: d } } }(zd, { A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'), B: BigInt('1771'), Z: zd.create(BigInt('-11')) })); const { hashToCurve: sf, encodeToCurve: cf } = (function (e, t, n) { if (typeof t !== 'function') throw new Error('mapToCurve() must be defined'); return { hashToCurve (r, i) { const o = Td(r, 2, { ...n, DST: n.DST, ...i }); const a = e.fromAffine(t(o[0])); const s = e.fromAffine(t(o[1])); const c = a.add(s).clearCofactor(); return c.assertValidity(), c }, encodeToCurve (r, i) { const o = Td(r, 1, { ...n, DST: n.encodeDST, ...i }); const a = e.fromAffine(t(o[0])).clearCofactor(); return a.assertValidity(), a } } }(Fd.ProjectivePoint, e => { const { x: t, y: n } = af(zd.create(e[0])); return of(t, n) }, { DST: 'secp256k1_XMD:SHA-256_SSWU_RO_', encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_', p: zd.ORDER, m: 1, k: 128, expand: 'xmd', hash: Tl })); const uf = a(8883); const lf = a(5435); function df (e) { if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`) } function ff (e, ...t) { if (!(e instanceof Uint8Array)) throw new Error('Expected Uint8Array'); if (t.length > 0 && !t.includes(e.length)) throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`) } const hf = { number: df, bool: function (e) { if (typeof e !== 'boolean') throw new Error(`Expected boolean, not ${e}`) }, bytes: ff, hash: function (e) { if (typeof e !== 'function' || typeof e.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor'); df(e.outputLen), df(e.blockLen) }, exists: function (e, t = !0) { if (e.destroyed) throw new Error('Hash instance has been destroyed'); if (t && e.finished) throw new Error('Hash#digest() has already been called') }, output: function (e, t) { ff(e); const n = t.outputLen; if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`) } }; const pf = hf; const gf = (typeof globalThis === 'object' && 'crypto' in globalThis && globalThis.crypto, e => e instanceof Uint8Array); const mf = e => new DataView(e.buffer, e.byteOffset, e.byteLength); const yf = (e, t) => e << 32 - t | e >>> t; if (!(new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)) throw new Error('Non little-endian hardware is not supported'); const bf = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0')); function vf (e) { if (typeof e !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof e); return new Uint8Array((new TextEncoder()).encode(e)) } function wf (e) { if (typeof e === 'string' && (e = vf(e)), !gf(e)) throw new Error('expected Uint8Array, got ' + typeof e); return e } function _f (...e) { const t = new Uint8Array(e.reduce((e, t) => e + t.length, 0)); let n = 0; return e.forEach(e => { if (!gf(e)) throw new Error('Uint8Array expected'); t.set(e, n), n += e.length }), t } class Ef {clone () { return this._cloneInto() }} function kf (e) { const t = t => e().update(wf(t)).digest(); const n = e(); return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t } class Sf extends Ef {constructor (e, t) { super(), this.finished = !1, this.destroyed = !1, pf.hash(e); const n = wf(t); if (this.iHash = e.create(), typeof this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash'); this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen; const r = this.blockLen; const i = new Uint8Array(r); i.set(n.length > r ? e.create().update(n).digest() : n); for (let e = 0; e < i.length; e++)i[e] ^= 54; this.iHash.update(i), this.oHash = e.create(); for (let e = 0; e < i.length; e++)i[e] ^= 106; this.oHash.update(i), i.fill(0) }update (e) { return pf.exists(this), this.iHash.update(e), this }digestInto (e) { pf.exists(this), pf.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy() }digest () { const e = new Uint8Array(this.oHash.outputLen); return this.digestInto(e), e }_cloneInto (e) { e || (e = Object.create(Object.getPrototypeOf(this), {})); const { oHash: t, iHash: n, finished: r, destroyed: i, blockLen: o, outputLen: a } = this; return e.finished = r, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e }destroy () { this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy() }} const Af = (e, t, n) => new Sf(e, t).update(n).digest(); Af.create = (e, t) => new Sf(e, t); class Of extends Ef {constructor (e, t, n, r) { super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = mf(this.buffer) }update (e) { pf.exists(this); const { view: t, buffer: n, blockLen: r } = this; const i = (e = wf(e)).length; for (let o = 0; o < i;) { const a = Math.min(r - this.pos, i - o); if (a !== r)n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === r && (this.process(t, 0), this.pos = 0); else { const t = mf(e); for (;r <= i - o; o += r) this.process(t, o) } } return this.length += e.length, this.roundClean(), this }digestInto (e) { pf.exists(this), pf.output(e, this), this.finished = !0; const { buffer: t, view: n, blockLen: r, isLE: i } = this; let { pos: o } = this; t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > r - o && (this.process(n, 0), o = 0); for (let e = o; e < r; e++)t[e] = 0; !(function (e, t, n, r) { if (typeof e.setBigUint64 === 'function') return e.setBigUint64(t, n, r); const i = BigInt(32); const o = BigInt(4294967295); const a = Number(n >> i & o); const s = Number(n & o); const c = r ? 4 : 0; const u = r ? 0 : 4; e.setUint32(t + c, a, r), e.setUint32(t + u, s, r) }(n, r - 8, BigInt(8 * this.length), i)), this.process(n, 0); const a = mf(e); const s = this.outputLen; if (s % 4) throw new Error('_sha2: outputLen should be aligned to 32bit'); const c = s / 4; const u = this.get(); if (c > u.length) throw new Error('_sha2: outputLen bigger than state'); for (let e = 0; e < c; e++)a.setUint32(4 * e, u[e], i) }digest () { const { buffer: e, outputLen: t } = this; this.digestInto(e); const n = e.slice(0, t); return this.destroy(), n }_cloneInto (e) { e || (e = new this.constructor()), e.set(...this.get()); const { blockLen: t, buffer: n, length: r, finished: i, destroyed: o, pos: a } = this; return e.length = r, e.pos = a, e.finished = i, e.destroyed = o, r % t && e.buffer.set(n), e }} const xf = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]); const If = Uint8Array.from({ length: 16 }, (e, t) => t); const Nf = If.map(e => (9 * e + 5) % 16); const Tf = [If]; const Rf = [Nf]; for (let e = 0; e < 4; e++) for (const t of [Tf, Rf])t.push(t[e].map(e => xf[e])); const Pf = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(e => new Uint8Array(e)); const Cf = Tf.map((e, t) => e.map(e => Pf[t][e])); const Bf = Rf.map((e, t) => e.map(e => Pf[t][e])); const Lf = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]); const jf = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]); const Df = (e, t) => e << t | e >>> 32 - t; function Uf (e, t, n, r) { return e === 0 ? t ^ n ^ r : e === 1 ? t & n | ~t & r : e === 2 ? (t | ~n) ^ r : e === 3 ? t & r | n & ~r : t ^ (n | ~r) } const Mf = new Uint32Array(16); class zf extends Of {constructor () { super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776 }get () { const { h0: e, h1: t, h2: n, h3: r, h4: i } = this; return [e, t, n, r, i] }set (e, t, n, r, i) { this.h0 = 0 | e, this.h1 = 0 | t, this.h2 = 0 | n, this.h3 = 0 | r, this.h4 = 0 | i }process (e, t) { for (let n = 0; n < 16; n++, t += 4)Mf[n] = e.getUint32(t, !0); let n = 0 | this.h0; let r = n; let i = 0 | this.h1; let o = i; let a = 0 | this.h2; let s = a; let c = 0 | this.h3; let u = c; let l = 0 | this.h4; let d = l; for (let e = 0; e < 5; e++) { const t = 4 - e; const f = Lf[e]; const h = jf[e]; const p = Tf[e]; const g = Rf[e]; const m = Cf[e]; const y = Bf[e]; for (let t = 0; t < 16; t++) { const r = Df(n + Uf(e, i, a, c) + Mf[p[t]] + f, m[t]) + l | 0; n = l, l = c, c = 0 | Df(a, 10), a = i, i = r } for (let e = 0; e < 16; e++) { const n = Df(r + Uf(t, o, s, u) + Mf[g[e]] + h, y[e]) + d | 0; r = d, d = u, u = 0 | Df(s, 10), s = o, o = n } } this.set(this.h1 + a + u | 0, this.h2 + c + d | 0, this.h3 + l + r | 0, this.h4 + n + o | 0, this.h0 + i + s | 0) }roundClean () { Mf.fill(0) }destroy () { this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0) }} const Ff = kf(() => new zf()); const Hf = (e, t, n) => e & t ^ ~e & n; const qf = (e, t, n) => e & t ^ e & n ^ t & n; const Kf = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]); const Vf = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]); const Wf = new Uint32Array(64); class $f extends Of {constructor () { super(64, 32, 8, !1), this.A = 0 | Vf[0], this.B = 0 | Vf[1], this.C = 0 | Vf[2], this.D = 0 | Vf[3], this.E = 0 | Vf[4], this.F = 0 | Vf[5], this.G = 0 | Vf[6], this.H = 0 | Vf[7] }get () { const { A: e, B: t, C: n, D: r, E: i, F: o, G: a, H: s } = this; return [e, t, n, r, i, o, a, s] }set (e, t, n, r, i, o, a, s) { this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | o, this.G = 0 | a, this.H = 0 | s }process (e, t) { for (let n = 0; n < 16; n++, t += 4)Wf[n] = e.getUint32(t, !1); for (let e = 16; e < 64; e++) { const t = Wf[e - 15]; const n = Wf[e - 2]; const r = yf(t, 7) ^ yf(t, 18) ^ t >>> 3; const i = yf(n, 17) ^ yf(n, 19) ^ n >>> 10; Wf[e] = i + Wf[e - 7] + r + Wf[e - 16] | 0 } let { A: n, B: r, C: i, D: o, E: a, F: s, G: c, H: u } = this; for (let e = 0; e < 64; e++) { const t = u + (yf(a, 6) ^ yf(a, 11) ^ yf(a, 25)) + Hf(a, s, c) + Kf[e] + Wf[e] | 0; const l = (yf(n, 2) ^ yf(n, 13) ^ yf(n, 22)) + qf(n, r, i) | 0; u = c, c = s, s = a, a = o + t | 0, o = i, i = r, r = n, n = t + l | 0 }n = n + this.A | 0, r = r + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, s = s + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(n, r, i, o, a, s, c, u) }roundClean () { Wf.fill(0) }destroy () { this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0) }} class Gf extends $f {constructor () { super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28 }} const Yf = kf(() => new $f()); const Zf = (kf(() => new Gf()), BigInt(2 ** 32 - 1)); const Jf = BigInt(32); function Xf (e, t = !1) { return t ? { h: Number(e & Zf), l: Number(e >> Jf & Zf) } : { h: 0 | Number(e >> Jf & Zf), l: 0 | Number(e & Zf) } } const Qf = { fromBig: Xf, split: function (e, t = !1) { const n = new Uint32Array(e.length); const r = new Uint32Array(e.length); for (let i = 0; i < e.length; i++) { const { h: o, l: a } = Xf(e[i], t); [n[i], r[i]] = [o, a] } return [n, r] }, toBig: (e, t) => BigInt(e >>> 0) << Jf | BigInt(t >>> 0), shrSH: (e, t, n) => e >>> n, shrSL: (e, t, n) => e << 32 - n | t >>> n, rotrSH: (e, t, n) => e >>> n | t << 32 - n, rotrSL: (e, t, n) => e << 32 - n | t >>> n, rotrBH: (e, t, n) => e << 64 - n | t >>> n - 32, rotrBL: (e, t, n) => e >>> n - 32 | t << 64 - n, rotr32H: (e, t) => t, rotr32L: (e, t) => e, rotlSH: (e, t, n) => e << n | t >>> 32 - n, rotlSL: (e, t, n) => t << n | e >>> 32 - n, rotlBH: (e, t, n) => t << n - 32 | e >>> 64 - n, rotlBL: (e, t, n) => e << n - 32 | t >>> 64 - n, add: function (e, t, n, r) { const i = (t >>> 0) + (r >>> 0); return { h: e + n + (i / 2 ** 32 | 0) | 0, l: 0 | i } }, add3L: (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0), add3H: (e, t, n, r) => t + n + r + (e / 2 ** 32 | 0) | 0, add4L: (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0), add4H: (e, t, n, r, i) => t + n + r + i + (e / 2 ** 32 | 0) | 0, add5H: (e, t, n, r, i, o) => t + n + r + i + o + (e / 2 ** 32 | 0) | 0, add5L: (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0) }; const eh = Qf; const [th, nh] = eh.split(['0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc', '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118', '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2', '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694', '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65', '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5', '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4', '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70', '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df', '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b', '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30', '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8', '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8', '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3', '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec', '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b', '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178', '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b', '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c', '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'].map(e => BigInt(e))); const rh = new Uint32Array(80); const ih = new Uint32Array(80); class oh extends Of {constructor () { super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209 }get () { const { Ah: e, Al: t, Bh: n, Bl: r, Ch: i, Cl: o, Dh: a, Dl: s, Eh: c, El: u, Fh: l, Fl: d, Gh: f, Gl: h, Hh: p, Hl: g } = this; return [e, t, n, r, i, o, a, s, c, u, l, d, f, h, p, g] }set (e, t, n, r, i, o, a, s, c, u, l, d, f, h, p, g) { this.Ah = 0 | e, this.Al = 0 | t, this.Bh = 0 | n, this.Bl = 0 | r, this.Ch = 0 | i, this.Cl = 0 | o, this.Dh = 0 | a, this.Dl = 0 | s, this.Eh = 0 | c, this.El = 0 | u, this.Fh = 0 | l, this.Fl = 0 | d, this.Gh = 0 | f, this.Gl = 0 | h, this.Hh = 0 | p, this.Hl = 0 | g }process (e, t) { for (let n = 0; n < 16; n++, t += 4)rh[n] = e.getUint32(t), ih[n] = e.getUint32(t += 4); for (let e = 16; e < 80; e++) { const t = 0 | rh[e - 15]; const n = 0 | ih[e - 15]; const r = eh.rotrSH(t, n, 1) ^ eh.rotrSH(t, n, 8) ^ eh.shrSH(t, n, 7); const i = eh.rotrSL(t, n, 1) ^ eh.rotrSL(t, n, 8) ^ eh.shrSL(t, n, 7); const o = 0 | rh[e - 2]; const a = 0 | ih[e - 2]; const s = eh.rotrSH(o, a, 19) ^ eh.rotrBH(o, a, 61) ^ eh.shrSH(o, a, 6); const c = eh.rotrSL(o, a, 19) ^ eh.rotrBL(o, a, 61) ^ eh.shrSL(o, a, 6); const u = eh.add4L(i, c, ih[e - 7], ih[e - 16]); const l = eh.add4H(u, r, s, rh[e - 7], rh[e - 16]); rh[e] = 0 | l, ih[e] = 0 | u } let { Ah: n, Al: r, Bh: i, Bl: o, Ch: a, Cl: s, Dh: c, Dl: u, Eh: l, El: d, Fh: f, Fl: h, Gh: p, Gl: g, Hh: m, Hl: y } = this; for (let e = 0; e < 80; e++) { const t = eh.rotrSH(l, d, 14) ^ eh.rotrSH(l, d, 18) ^ eh.rotrBH(l, d, 41); const b = eh.rotrSL(l, d, 14) ^ eh.rotrSL(l, d, 18) ^ eh.rotrBL(l, d, 41); const v = l & f ^ ~l & p; const w = d & h ^ ~d & g; const _ = eh.add5L(y, b, w, nh[e], ih[e]); const E = eh.add5H(_, m, t, v, th[e], rh[e]); const k = 0 | _; const S = eh.rotrSH(n, r, 28) ^ eh.rotrBH(n, r, 34) ^ eh.rotrBH(n, r, 39); const A = eh.rotrSL(n, r, 28) ^ eh.rotrBL(n, r, 34) ^ eh.rotrBL(n, r, 39); const O = n & i ^ n & a ^ i & a; const x = r & o ^ r & s ^ o & s; m = 0 | p, y = 0 | g, p = 0 | f, g = 0 | h, f = 0 | l, h = 0 | d, ({ h: l, l: d } = eh.add(0 | c, 0 | u, 0 | E, 0 | k)), c = 0 | a, u = 0 | s, a = 0 | i, s = 0 | o, i = 0 | n, o = 0 | r; const I = eh.add3L(k, A, x); n = eh.add3H(I, E, S, O), r = 0 | I }({ h: n, l: r } = eh.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)), ({ h: i, l: o } = eh.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)), ({ h: a, l: s } = eh.add(0 | this.Ch, 0 | this.Cl, 0 | a, 0 | s)), ({ h: c, l: u } = eh.add(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | u)), ({ h: l, l: d } = eh.add(0 | this.Eh, 0 | this.El, 0 | l, 0 | d)), ({ h: f, l: h } = eh.add(0 | this.Fh, 0 | this.Fl, 0 | f, 0 | h)), ({ h: p, l: g } = eh.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)), ({ h: m, l: y } = eh.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)), this.set(n, r, i, o, a, s, c, u, l, d, f, h, p, g, m, y) }roundClean () { rh.fill(0), ih.fill(0) }destroy () { this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) }} class ah extends oh {constructor () { super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28 }} class sh extends oh {constructor () { super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32 }} class ch extends oh {constructor () { super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48 }} const uh = kf(() => new oh()); const lh = (kf(() => new ah()), kf(() => new sh()), kf(() => new ch()), Fd.ProjectivePoint); const dh = _o(Yf); function fh (e) { return BigInt(`0x${(function (e) { if (!gf(e)) throw new Error('Uint8Array expected'); let t = ''; for (let n = 0; n < e.length; n++)t += bf[e[n]]; return t }(e))}`) } function hh (e) { return (function (e) { if (typeof e !== 'string') throw new Error('hex string expected, got ' + typeof e); const t = e.length; if (t % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + t); const n = new Uint8Array(t / 2); for (let t = 0; t < n.length; t++) { const r = 2 * t; const i = e.slice(r, r + 2); const o = Number.parseInt(i, 16); if (Number.isNaN(o) || o < 0) throw new Error('Invalid byte sequence'); n[t] = o } return n }(e.toString(16).padStart(64, '0'))) } const ph = vf('Bitcoin seed'); const gh = { private: 76066276, public: 76067358 }; const mh = 2147483648; const yh = e => { if (!Number.isSafeInteger(e) || e < 0 || e > 2 ** 32 - 1) throw new Error(`Invalid number=${e}. Should be from 0 to 2 ** 32 - 1`); const t = new Uint8Array(4); return mf(t).setUint32(0, e, !1), t }; class bh {get fingerprint () { if (!this.pubHash) throw new Error('No publicKey set!'); return e = this.pubHash, mf(e).getUint32(0, !1); let e } get identifier () { return this.pubHash } get pubKeyHash () { return this.pubHash } get privateKey () { return this.privKeyBytes || null } get publicKey () { return this.pubKey || null } get privateExtendedKey () { const e = this.privateKey; if (!e) throw new Error('No private key'); return dh.encode(this.serialize(this.versions.private, _f(new Uint8Array([0]), e))) } get publicExtendedKey () { if (!this.pubKey) throw new Error('No public key'); return dh.encode(this.serialize(this.versions.public, this.pubKey)) } static fromMasterSeed (e, t = gh) { if (ff(e), 8 * e.length < 128 || 8 * e.length > 512) throw new Error(`HDKey: wrong seed length=${e.length}. Should be between 128 and 512 bits; 256 bits is advised)`); const n = Af(uh, ph, e); return new bh({ versions: t, chainCode: n.slice(32), privateKey: n.slice(0, 32) }) } static fromExtendedKey (e, t = gh) { const n = dh.decode(e); const r = mf(n); const i = r.getUint32(0, !1); const o = { versions: t, depth: n[4], parentFingerprint: r.getUint32(5, !1), index: r.getUint32(9, !1), chainCode: n.slice(13, 45) }; const a = n.slice(45); const s = a[0] === 0; if (i !== t[s ? 'private' : 'public']) throw new Error('Version mismatch'); return new bh(s ? { ...o, privateKey: a.slice(1) } : { ...o, publicKey: a }) } static fromJSON (e) { return bh.fromExtendedKey(e.xpriv) }constructor (e) { if (this.depth = 0, this.index = 0, this.chainCode = null, this.parentFingerprint = 0, !e || typeof e !== 'object') throw new Error('HDKey.constructor must not be called directly'); if (this.versions = e.versions || gh, this.depth = e.depth || 0, this.chainCode = e.chainCode, this.index = e.index || 0, this.parentFingerprint = e.parentFingerprint || 0, !this.depth && (this.parentFingerprint || this.index)) throw new Error('HDKey: zero depth with non-zero index/parent fingerprint'); if (e.publicKey && e.privateKey) throw new Error('HDKey: publicKey and privateKey at same time.'); if (e.privateKey) { if (!Fd.utils.isValidPrivateKey(e.privateKey)) throw new Error('Invalid private key'); this.privKey = typeof e.privateKey === 'bigint' ? e.privateKey : fh(e.privateKey), this.privKeyBytes = hh(this.privKey), this.pubKey = Fd.getPublicKey(e.privateKey, !0) } else { if (!e.publicKey) throw new Error('HDKey: no public or private key provided'); this.pubKey = lh.fromHex(e.publicKey).toRawBytes(!0) } let t; this.pubHash = (t = this.pubKey, Ff(Yf(t))) }derive (e) { if (!/^[mM]'?/.test(e)) throw new Error('Path must start with "m" or "M"'); if (/^[mM]'?$/.test(e)) return this; const t = e.replace(/^[mM]'?\//, '').split('/'); let n = this; for (const e of t) { const t = /^(\d+)('?)$/.exec(e); if (!t || t.length !== 3) throw new Error(`Invalid child index: ${e}`); let r = +t[1]; if (!Number.isSafeInteger(r) || r >= mh) throw new Error('Invalid index'); t[2] === "'" && (r += mh), n = n.deriveChild(r) } return n }deriveChild (e) { if (!this.pubKey || !this.chainCode) throw new Error('No publicKey or chainCode set'); let t = yh(e); if (e >= mh) { const e = this.privateKey; if (!e) throw new Error('Could not derive hardened child key'); t = _f(new Uint8Array([0]), e, t) } else t = _f(this.pubKey, t); const n = Af(uh, this.chainCode, t); const r = fh(n.slice(0, 32)); const i = n.slice(32); if (!Fd.utils.isValidPrivateKey(r)) throw new Error('Tweak bigger than curve order'); const o = { versions: this.versions, chainCode: i, depth: this.depth + 1, parentFingerprint: this.fingerprint, index: e }; try { if (this.privateKey) { const e = id(this.privKey + r, Fd.CURVE.n); if (!Fd.utils.isValidPrivateKey(e)) throw new Error('The tweak was out of range or the resulted private key is invalid'); o.privateKey = e } else { const e = lh.fromHex(this.pubKey).add(lh.fromPrivateKey(r)); if (e.equals(lh.ZERO)) throw new Error('The tweak was equal to negative P, which made the result key invalid'); o.publicKey = e.toRawBytes(!0) } return new bh(o) } catch (t) { return this.deriveChild(e + 1) } }sign (e) { if (!this.privateKey) throw new Error('No privateKey set!'); return ff(e, 32), Fd.sign(e, this.privKey).toCompactRawBytes() }verify (e, t) { if (ff(e, 32), ff(t, 64), !this.publicKey) throw new Error('No publicKey set!'); let n; try { n = Fd.Signature.fromCompact(t) } catch (e) { return !1 } return Fd.verify(n, e, this.publicKey) }wipePrivateData () { return this.privKey = void 0, this.privKeyBytes && (this.privKeyBytes.fill(0), this.privKeyBytes = void 0), this }toJSON () { return { xpriv: this.privateExtendedKey, xpub: this.publicExtendedKey } }serialize (e, t) { if (!this.chainCode) throw new Error('No chainCode set'); return ff(t, 33), _f(yh(e), new Uint8Array([this.depth]), yh(this.parentFingerprint), yh(this.index), this.chainCode, t) }} const vh = Object.defineProperty; const wh = (e, t) => { for (const n in t)vh(e, n, { get: t[n], enumerable: !0 }) }; function _h (e) { return gl(rf.getPublicKey(e)) }wh({}, { insertEventIntoAscendingList: () => Oh, insertEventIntoDescendingList: () => Ah, normalizeURL: () => Sh, utf8Decoder: () => Eh, utf8Encoder: () => kh }); var Eh = new TextDecoder('utf-8'); var kh = new TextEncoder(); function Sh (e) { const t = new URL(e); return t.pathname = t.pathname.replace(/\/+/g, '/'), t.pathname.endsWith('/') && (t.pathname = t.pathname.slice(0, -1)), (t.port === '80' && t.protocol === 'ws:' || t.port === '443' && t.protocol === 'wss:') && (t.port = ''), t.searchParams.sort(), t.hash = '', t.toString() } function Ah (e, t) { let n; let r = 0; let i = e.length - 1; let o = r; if (i < 0)o = 0; else if (t.created_at < e[i].created_at)o = i + 1; else if (t.created_at >= e[r].created_at)o = r; else for (;;) { if (i <= r + 1) { o = i; break } if (n = Math.floor(r + (i - r) / 2), e[n].created_at > t.created_at)r = n; else { if (!(e[n].created_at < t.created_at)) { o = n; break }i = n } } return e[o]?.id !== t.id ? [...e.slice(0, o), t, ...e.slice(o)] : e } function Oh (e, t) { let n; let r = 0; let i = e.length - 1; let o = r; if (i < 0)o = 0; else if (t.created_at > e[i].created_at)o = i + 1; else if (t.created_at <= e[r].created_at)o = r; else for (;;) { if (i <= r + 1) { o = i; break } if (n = Math.floor(r + (i - r) / 2), e[n].created_at < t.created_at)r = n; else { if (!(e[n].created_at > t.created_at)) { o = n; break }i = n } } return e[o]?.id !== t.id ? [...e.slice(0, o), t, ...e.slice(o)] : e } function xh (e, t) { const n = e; return n.pubkey = _h(t), n.id = Ih(n), n.sig = Ph(n, t), n } function Ih (e) { return gl(Tl(kh.encode(function (e) { if (!Th(e)) throw new Error("can't serialize event with wrong or missing properties"); return JSON.stringify([0, e.pubkey, e.created_at, e.kind, e.tags, e.content]) }(e)))) } const Nh = e => e instanceof Object; function Th (e) { if (!Nh(e)) return !1; if (typeof e.kind !== 'number') return !1; if (typeof e.content !== 'string') return !1; if (typeof e.created_at !== 'number') return !1; if (typeof e.pubkey !== 'string') return !1; if (!e.pubkey.match(/^[a-f0-9]{64}$/)) return !1; if (!Array.isArray(e.tags)) return !1; for (let t = 0; t < e.tags.length; t++) { const n = e.tags[t]; if (!Array.isArray(n)) return !1; for (let e = 0; e < n.length; e++) if (typeof n[e] === 'object') return !1 } return !0 } function Rh (e) { try { return rf.verify(e.sig, Ih(e), e.pubkey) } catch (e) { return !1 } } function Ph (e, t) { return gl(rf.sign(Ih(e), t)) } function Ch (e, t) { const n = t.length + 3; const r = e.indexOf(`"${t}":`) + n; const i = e.slice(r).indexOf('"') + r + 1; return e.slice(i, i + 64) } function Bh (e, t) { const n = t.length; const r = e.indexOf(`"${t}":`) + n + 3; const i = e.slice(r); const o = Math.min(i.indexOf(','), i.indexOf('}')); return parseInt(i.slice(0, o), 10) } function Lh (e) { const t = e.slice(0, 22).indexOf('"EVENT"'); if (t === -1) return null; const n = e.slice(t + 7 + 1).indexOf('"'); if (n === -1) return null; const r = t + 7 + 1 + n; const i = e.slice(r + 1, 80).indexOf('"'); if (i === -1) return null; const o = r + 1 + i; return e.slice(r + 1, o) } function jh (e, t) { return t === Ch(e, 'id') } function Dh (e, t) { return t === Ch(e, 'pubkey') } function Uh (e, t) { return t === Bh(e, 'kind') }wh({}, { getHex64: () => Ch, getInt: () => Bh, getSubscriptionId: () => Lh, matchEventId: () => jh, matchEventKind: () => Uh, matchEventPubkey: () => Dh }); const Mh = {}; wh(Mh, { BECH32_REGEX: () => Fh, decode: () => Hh, naddrEncode: () => Zh, neventEncode: () => Yh, noteEncode: () => Wh, nprofileEncode: () => Gh, npubEncode: () => Vh, nrelayEncode: () => Jh, nsecEncode: () => Kh }); const zh = 5e3; var Fh = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/; function Hh (e) { const { prefix: t, words: n } = xo.decode(e, zh); const r = new Uint8Array(xo.fromWords(n)); switch (t) { case 'nprofile':{ const e = qh(r); if (!e[0]?.[0]) throw new Error('missing TLV 0 for nprofile'); if (e[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes'); return { type: 'nprofile', data: { pubkey: gl(e[0][0]), relays: e[1] ? e[1].map(e => Eh.decode(e)) : [] } } } case 'nevent':{ const e = qh(r); if (!e[0]?.[0]) throw new Error('missing TLV 0 for nevent'); if (e[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes'); if (e[2] && e[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes'); return { type: 'nevent', data: { id: gl(e[0][0]), relays: e[1] ? e[1].map(e => Eh.decode(e)) : [], author: e[2]?.[0] ? gl(e[2][0]) : void 0 } } } case 'naddr':{ const e = qh(r); if (!e[0]?.[0]) throw new Error('missing TLV 0 for naddr'); if (!e[2]?.[0]) throw new Error('missing TLV 2 for naddr'); if (e[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes'); if (!e[3]?.[0]) throw new Error('missing TLV 3 for naddr'); if (e[3][0].length !== 4) throw new Error('TLV 3 should be 4 bytes'); return { type: 'naddr', data: { identifier: Eh.decode(e[0][0]), pubkey: gl(e[2][0]), kind: parseInt(gl(e[3][0]), 16), relays: e[1] ? e[1].map(e => Eh.decode(e)) : [] } } } case 'nrelay':{ const e = qh(r); if (!e[0]?.[0]) throw new Error('missing TLV 0 for nrelay'); return { type: 'nrelay', data: Eh.decode(e[0][0]) } } case 'nsec':case 'npub':case 'note':return { type: t, data: gl(r) }; default:throw new Error(`unknown prefix ${t}`) } } function qh (e) { const t = {}; let n = e; for (;n.length > 0;) { const e = n[0]; const r = n[1]; const i = n.slice(2, 2 + r); n = n.slice(2 + r), i.length < r || (t[e] = t[e] || [], t[e].push(i)) } return t } function Kh (e) { return $h('nsec', e) } function Vh (e) { return $h('npub', e) } function Wh (e) { return $h('note', e) } function $h (e, t) { const n = ml(t); const r = xo.toWords(n); return xo.encode(e, r, zh) } function Gh (e) { const t = Xh({ 0: [ml(e.pubkey)], 1: (e.relays || []).map(e => kh.encode(e)) }); const n = xo.toWords(t); return xo.encode('nprofile', n, zh) } function Yh (e) { const t = Xh({ 0: [ml(e.id)], 1: (e.relays || []).map(e => kh.encode(e)), 2: e.author ? [ml(e.author)] : [] }); const n = xo.toWords(t); return xo.encode('nevent', n, zh) } function Zh (e) { const t = new ArrayBuffer(4); new DataView(t).setUint32(0, e.kind, !1); const n = Xh({ 0: [kh.encode(e.identifier)], 1: (e.relays || []).map(e => kh.encode(e)), 2: [ml(e.pubkey)], 3: [new Uint8Array(t)] }); const r = xo.toWords(n); return xo.encode('naddr', r, zh) } function Jh (e) { const t = Xh({ 0: [kh.encode(e)] }); const n = xo.toWords(t); return xo.encode('nrelay', n, zh) } function Xh (e) { const t = []; return Object.entries(e).forEach(([e, n]) => { n.forEach(n => { const r = new Uint8Array(n.length + 2); r.set([parseInt(e)], 0), r.set([n.length], 1), r.set(n, 2), t.push(r) }) }), bl(...t) } const Qh = {}; async function ep (e, t, n) { const r = np(Fd.getSharedSecret(e, '02' + t)); const i = Uint8Array.from(_l(16)); const o = kh.encode(n); const a = await crypto.subtle.importKey('raw', r, { name: 'AES-CBC' }, !1, ['encrypt']); const s = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: i }, a, o); return `${bo.encode(new Uint8Array(s))}?iv=${bo.encode(new Uint8Array(i.buffer))}` } async function tp (e, t, n) { const [r, i] = n.split('?iv='); const o = np(Fd.getSharedSecret(e, '02' + t)); const a = await crypto.subtle.importKey('raw', o, { name: 'AES-CBC' }, !1, ['decrypt']); const s = bo.decode(r); const c = bo.decode(i); const u = await crypto.subtle.decrypt({ name: 'AES-CBC', iv: c }, a, s); return Eh.decode(u) } function np (e) { return e.slice(1, 33) }wh(Qh, { decrypt: () => tp, encrypt: () => ep }), typeof crypto !== 'undefined' && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle); wh({}, { NIP05_REGEX: () => ip, queryProfile: () => sp, searchDomain: () => ap, useFetchImplementation: () => op }); let rp; var ip = /^(?:([\w.+-]+)@)?([\w.-]+)$/; try { rp = fetch } catch {} function op (e) { rp = e } async function ap (e, t = '') { try { return (await (await rp(`https://${e}/.well-known/nostr.json?name=${t}`)).json()).names } catch (e) { return {} } } async function sp (e) { const t = e.match(ip); if (!t) return null; const [n, r = '_', i] = t; try { const e = await rp(`https://${i}/.well-known/nostr.json?name=${r}`); const { names: t, relays: n } = (function (e) { const t = { names: {} }; for (const [n, r] of Object.entries(e.names)) typeof n === 'string' && typeof r === 'string' && (t.names[n] = r); if (e.relays) { t.relays = {}; for (const [n, r] of Object.entries(e.relays)) typeof n === 'string' && Array.isArray(r) && (t.relays[n] = r.filter(e => typeof e === 'string')) } return t }(await e.json())); const o = t[r]; return o ? { pubkey: o, relays: n?.[o] } : null } catch (e) { return null } } function cp (e, t) { const n = bh.fromMasterSeed((0, lf.Z1)(e, t)).derive("m/44'/1237'/0'/0/0").privateKey; if (!n) throw new Error('could not derive private key'); return gl(n) } function up () { return (0, lf.OF)(uf.U) } function lp (e) { return (0, lf._I)(e, uf.U) }wh({}, { generateSeedWords: () => up, privateKeyFromSeedWords: () => cp, validateWords: () => lp }); function dp (e) { const t = { reply: void 0, root: void 0, mentions: [], profiles: [] }; const n = []; for (const r of e.tags)r[0] === 'e' && r[1] && n.push(r), r[0] === 'p' && r[1] && t.profiles.push({ pubkey: r[1], relays: r[2] ? [r[2]] : [] }); for (let e = 0; e < n.length; e++) { const r = n[e]; const [i, o, a, s] = r; const c = { id: o, relays: a ? [a] : [] }; const u = e === 0; const l = e === n.length - 1; s !== 'root' ? s !== 'reply' ? s !== 'mention' ? u ? t.root = c : l ? t.reply = c : t.mentions.push(c) : t.mentions.push(c) : t.reply = c : t.root = c } return t }wh({}, { parse: () => dp }); function fp (e) { return (function (e) { let t, n, r; for (n = 0, t = 0; n < e.length && (r = hp(e[n]), t += r, r === 8); n++);return t }(ml(e))) } function hp (e) { let t = 0; if (e === 0) return 8; for (;e >>= 1;)t++; return 7 - t }wh({}, { getPow: () => fp }); function pp (e, t, n, r) { return xh({ kind: 6, tags: [...e.tags ?? [], ['e', t.id, n], ['p', t.pubkey]], content: e.content === '' ? '' : JSON.stringify(t), created_at: e.created_at }, r) } function gp (e) { if (e.kind !== 6) return; let t, n; for (let r = e.tags.length - 1; r >= 0 && (void 0 === t || void 0 === n); r--) { const i = e.tags[r]; i.length >= 2 && (i[0] === 'e' && void 0 === t ? t = i : i[0] === 'p' && void 0 === n && (n = i)) } return void 0 !== t ? { id: t[1], relays: [t[2], n?.[2]].filter(e => typeof e === 'string'), author: n?.[1] } : void 0 } function mp (e, { skipVerification: t } = {}) { const n = gp(e); if (void 0 === n || e.content === '') return; let r; try { r = JSON.parse(e.content) } catch (e) { return } return r.id === n.id && (t || Rh(r)) ? r : void 0 }wh({}, { finishRepostEvent: () => pp, getRepostedEvent: () => mp, getRepostedEventPointer: () => gp }); wh({}, { NOSTR_URI_REGEX: () => yp, parse: () => vp, test: () => bp }); var yp = new RegExp(`nostr:(${Fh.source})`); function bp (e) { return typeof e === 'string' && new RegExp(`^${yp.source}$`).test(e) } function vp (e) { const t = e.match(new RegExp(`^${yp.source}$`)); if (!t) throw new Error(`Invalid Nostr URI: ${e}`); return { uri: t[0], value: t[1], decoded: Hh(t[1]) } } function wp (e, t, n) { const r = t.tags.filter(e => e.length >= 2 && (e[0] === 'e' || e[0] === 'p')); return xh({ ...e, kind: 7, tags: [...e.tags ?? [], ...r, ['e', t.id], ['p', t.pubkey]], content: e.content ?? '+' }, n) } function _p (e) { if (e.kind !== 7) return; let t, n; for (let r = e.tags.length - 1; r >= 0 && (void 0 === t || void 0 === n); r--) { const i = e.tags[r]; i.length >= 2 && (i[0] === 'e' && void 0 === t ? t = i : i[0] === 'p' && void 0 === n && (n = i)) } return void 0 !== t && void 0 !== n ? { id: t[1], relays: [t[2], n[2]].filter(e => void 0 !== e), author: n[1] } : void 0 }wh({}, { finishReactionEvent: () => wp, getReactedEventPointer: () => _p }); function Ep (e, t) { const n = []; (t.kind || -1) >= 0 && n.push(`kind=${t.kind}`), t.until && n.push(`created_at<${t.until}`), t.since && n.push(`created_at>${t.since}`); const r = n.join('&'); if (r === '') throw new Error('refusing to create a delegation without any conditions'); const i = Tl(kh.encode(`nostr:delegation:${t.pubkey}:${r}`)); const o = gl(rf.sign(i, e)); return { from: _h(e), to: t.pubkey, cond: r, sig: o } } function kp (e) { const t = e.tags.find(e => e[0] === 'delegation' && e.length >= 4); if (!t) return null; const n = t[1]; const r = t[2]; const i = t[3]; const o = r.split('&'); for (let t = 0; t < o.length; t++) { const [n, r, i] = o[t].split(/\b/); if ((n !== 'kind' || r !== '=' || e.kind !== parseInt(i)) && !(n === 'created_at' && r === '<' && e.created_at < parseInt(i) || n === 'created_at' && r === '>' && e.created_at > parseInt(i))) return null } const a = Tl(kh.encode(`nostr:delegation:${e.pubkey}:${r}`)); return rf.verify(i, a, n) ? n : null }wh({}, { createDelegation: () => Ep, getDelegator: () => kp }); wh({}, { matchAll: () => Ap, regex: () => Sp, replaceAll: () => Op }); var Sp = () => new RegExp(`\\b${yp.source}\\b`, 'g'); function * Ap (e) { const t = e.matchAll(Sp()); for (const e of t) { const [t, n] = e; yield { uri: t, value: n, decoded: Hh(n), start: e.index, end: e.index + t.length } } } function Op (e, t) { return e.replaceAll(Sp(), (e, n) => t({ uri: e, value: n, decoded: Hh(n) })) } let xp; wh({}, { useFetchImplementation: () => Ip, validateGithub: () => Np }); try { xp = fetch } catch {} function Ip (e) { xp = e } async function Np (e, t, n) { try { return await (await xp(`https://gist.github.com/${t}/${n}/raw`)).text() === `Verifying that I control the following Nostr public key: ${e}` } catch (e) { return !1 } }wh({}, { authenticate: () => Rp }); let Tp; var Rp = async ({ challenge: e, relay: t, sign: n }) => { const r = { kind: 22242, created_at: Math.floor(Date.now() / 1e3), tags: [['relay', t.url], ['challenge', e]], content: '' }; const i = t.auth(await n(r)); return new Promise((e, t) => { i.on('ok', function t () { i.off('ok', t), e() }), i.on('failed', function e (n) { i.off('failed', e), t(n) }) }) }; wh({}, { getZapEndpoint: () => Cp, makeZapReceipt: () => jp, makeZapRequest: () => Bp, useFetchImplementation: () => Pp, validateZapRequest: () => Lp }); try { Tp = fetch } catch {} function Pp (e) { Tp = e } async function Cp (e) { try { let t = ''; const { lud06: n, lud16: r } = JSON.parse(e.content); if (n) { const { words: e } = xo.decode(n, 1e3); const r = xo.fromWords(e); t = Eh.decode(r) } else { if (!r) return null; { const [e, n] = r.split('@'); t = `https://${n}/.well-known/lnurlp/${e}` } } const i = await Tp(t); const o = await i.json(); if (o.allowsNostr && o.nostrPubkey) return o.callback } catch (e) {} return null } function Bp ({ profile: e, event: t, amount: n, relays: r, comment: i = '' }) { if (!n) throw new Error('amount not given'); if (!e) throw new Error('profile not given'); const o = { kind: 9734, created_at: Math.round(Date.now() / 1e3), content: i, tags: [['p', e], ['amount', n.toString()], ['relays', ...r]] }; return t && o.tags.push(['e', t]), o } function Lp (e) { let t; try { t = JSON.parse(e) } catch (e) { return 'Invalid zap request JSON.' } if (!Th(t)) return 'Zap request is not a valid Nostr event.'; if (!Rh(t)) return 'Invalid signature on zap request.'; const n = t.tags.find(([e, t]) => e === 'p' && t); if (!n) return "Zap request doesn't have a 'p' tag."; if (!n[1].match(/^[a-f0-9]{64}$/)) return "Zap request 'p' tag is not valid hex."; const r = t.tags.find(([e, t]) => e === 'e' && t); if (r && !r[1].match(/^[a-f0-9]{64}$/)) return "Zap request 'e' tag is not valid hex."; const i = t.tags.find(([e, t]) => e === 'relays' && t); return i ? null : "Zap request doesn't have a 'relays' tag." } function jp ({ zapRequest: e, preimage: t, bolt11: n, paidAt: r }) { const i = JSON.parse(e).tags.filter(([e]) => e === 'e' || e === 'p' || e === 'a'); const o = { kind: 9735, created_at: Math.round(r.getTime() / 1e3), content: '', tags: [...i, ['bolt11', n], ['description', e]] }; return t && o.tags.push(['preimage', t]), o } function Dp () { return Dp = Object.assign ? Object.assign.bind() : function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Dp.apply(this, arguments) } function Up (e, t) { if (e == null) return {}; let n; let r; const i = {}; const o = Object.keys(e); for (r = 0; r < o.length; r++)t.indexOf(n = o[r]) >= 0 || (i[n] = e[n]); return i } function Mp (e) { return Object.entries(e).map(([e, t]) => e && t ? `${e}=${t}` : '').join('&') } function zp (e, t) { return `Basic ${btoa(`${e}:${t}`)}` } class Fp extends Error {constructor (e, t, n, r) { let i = e.toString(); t && (i += ` ${t}`), i += ': ', i += r.message ? r.message : JSON.stringify(r), super(i), this.status = void 0, this.statusText = void 0, this.headers = void 0, this.error = void 0, this.status = e, this.statusText = t, this.headers = n, this.error = r }} const Hp = ['auth', 'endpoint', 'params', 'request_body', 'method', 'max_retries', 'base_url', 'user_agent', 'headers']; const qp = 'https://api.getalby.com'; async function Kp (e, t, n = 0) { const r = await fetch(e, t); if (r.status === 429 && n > 0) { const i = Number(r.headers.get('x-rate-limit-reset')); const o = Number(r.headers.get('x-rate-limit-remaining')); const a = 1e3 * i - Date.now(); let s = 1e3; return o === 0 && (s = a), await new Promise(e => setTimeout(e, s)), Kp(e, t, n - 1) } return r } async function Vp (e) { const { auth: t, endpoint: n, params: r = {}, request_body: i, method: o, max_retries: a, base_url: s = qp, user_agent: c, headers: u } = e; const l = Up(e, Hp); const d = new URL(s + n); d.search = Mp(r); const f = o === 'POST' && !!i; const h = t ? await t.getAuthHeader(d.href, o) : void 0; const p = await Kp(d.toString(), Dp({ headers: Dp({}, f ? { 'Content-Type': 'application/json; charset=utf-8' } : void 0, h, u, { 'User-Agent': c != null ? c : 'alby-js-api', 'X-User-Agent': c != null ? c : 'alby-js-api' }), method: o, body: f ? JSON.stringify(i) : void 0 }, l), a); if (!p.ok) { const e = await p.json(); throw new Fp(p.status, p.statusText, p.headers, e) } return p } async function Wp (e) { return (await Vp(e)).json() } const $p = ['expires_in']; const Gp = ['token']; function Yp (e) { const { expires_in: t } = e; return Dp({}, Up(e, $p), !!t && { expires_at: Date.now() + 1e3 * t }) } class Zp {constructor (e) { this.bearer_token = void 0, this.bearer_token = e }getAuthHeader () { return { Authorization: `Bearer ${this.bearer_token}` } }} const Jp = class {constructor (e) { this.token = void 0, this.options = void 0, this.code_verifier = void 0, this.code_challenge = void 0, this._refreshAccessTokenPromise = void 0; const { token: t } = e; const n = Up(e, Gp); this.options = Dp({ client_secret: '' }, n), this.token = t, this._refreshAccessTokenPromise = null } async refreshAccessToken () { const e = this; return this._refreshAccessTokenPromise || (this._refreshAccessTokenPromise = new Promise(async function (t, n) { try { let r; const n = (r = e.token) == null ? void 0 : r.refresh_token; const { client_id: i, client_secret: o, request_options: a, user_agent: s } = e.options; if (!i) throw new Error('client_id is required'); if (!n) throw new Error('refresh_token is required'); const c = Yp(await Wp(Dp({}, a, { endpoint: '/oauth/token', params: { client_id: i, grant_type: 'refresh_token', refresh_token: n }, user_agent: s, method: 'POST', headers: Dp({}, a == null ? void 0 : a.headers, { 'Content-type': 'application/x-www-form-urlencoded' }, { Authorization: zp(i, o) }) }))); e.token = c, t({ token: c }) } catch (e) { n(e) } finally { e._refreshAccessTokenPromise = null } })), this._refreshAccessTokenPromise }isAccessTokenExpired () { let e, t; const n = (e = this.token) == null ? void 0 : e.refresh_token; const r = (t = this.token) == null ? void 0 : t.expires_at; return !r || !!n && r <= Date.now() + 1e3 } async requestAccessToken (e) { const { client_id: t, client_secret: n, callback: r, request_options: i, user_agent: o } = this.options; const a = this.code_verifier; if (!t) throw new Error('client_id is required'); if (!r) throw new Error('callback is required'); const s = { code: e, grant_type: 'authorization_code', code_verifier: a, client_id: t, redirect_uri: r }; const c = Yp(await Wp(Dp({}, i, { endpoint: '/oauth/token', params: s, user_agent: o, method: 'POST', headers: Dp({}, i == null ? void 0 : i.headers, { 'Content-Type': 'application/x-www-form-urlencoded' }, { Authorization: zp(t, n) }) }))); return this.token = c, { token: c } }generateAuthURL (e) { e || (e = {}), console.log(e); const { client_id: t, callback: n, scopes: r } = this.options; if (!n) throw new Error('callback required'); if (!r) throw new Error('scopes required'); let i; if (e.code_challenge_method === 'S256') { const e = v.lib.WordArray.random(64); this.code_verifier = e.toString(), this.code_challenge = v.SHA256(this.code_verifier).toString(v.enc.Base64).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, ''), i = 'S256' } else e.code_challenge_method === 'plain' && e.code_challenge && (this.code_challenge = e.code_challenge, this.code_verifier = e.code_challenge, i = 'plain'); const o = this.code_challenge; const a = new URL('https://getalby.com/oauth'); return a.search = Mp(Dp({}, e, { client_id: t, scope: r.join(' '), response_type: 'code', redirect_uri: n, code_challenge_method: i, code_challenge: o })), a.toString() } async getAuthHeader () { let e; if ((e = this.token) == null || !e.access_token) throw new Error('access_token is required'); return this.isAccessTokenExpired() && await this.refreshAccessToken(), { Authorization: `Bearer ${this.token.access_token}` } }}; function Xp (e) { const t = {}; return e.recipient.customKey && e.recipient.customValue && (t[e.recipient.customKey] = e.recipient.customValue), t[7629169] = JSON.stringify(e.boostagram), { destination: e.recipient.address, amount: e.amount, customRecords: t } } class Qp {constructor (e, t) { this.auth = void 0, this.defaultRequestOptions = void 0, this.auth = typeof e === 'string' ? new Zp(e) : e, this.defaultRequestOptions = Dp({}, t, { user_agent: t == null ? void 0 : t.user_agent }) }accountBalance (e, t) { return Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: '/balance', params: e, method: 'GET' })) }accountSummary (e, t) { return Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: '/user/summary', params: e, method: 'GET' })) }accountInformation (e, t) { return Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: '/user/me', params: e, method: 'GET' })) }accountValue4Value (e, t) { return Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: '/user/value4value', params: e, method: 'GET' })) }incomingInvoices (e, t) { return Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: '/invoices/incoming', params: e, method: 'GET' })) }outgoingInvoices (e, t) { return Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: '/invoices/outgoing', params: e, method: 'GET' })) }getInvoice (e, t) { return Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: `/invoices/${e}`, method: 'GET' })) }createInvoice (e, t) { return Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: '/invoices', request_body: e, method: 'POST' })) }keysend (e, t) { let n, r; return Array.isArray(e) ? (n = '/payments/keysend/multi', r = { keysends: e }) : (n = '/payments/keysend', r = e), Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: n, request_body: r, method: 'POST' })) }sendPayment (e, t) { return Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: '/payments/bolt11', request_body: e, method: 'POST' })) }sendBoostagram (e, t) { let n, r; return Array.isArray(e) ? (n = '/payments/keysend/multi', r = { keysends: e.map(e => Xp(e)) }) : (n = '/payments/keysend', r = Xp(e)), Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: n, request_body: r, method: 'POST' })) }sendToAlbyAccount (e, t) { return Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: '/payments/keysend', request_body: { destination: '030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3', customRecords: { 696969: e.account }, amount: e.amount, memo: e.memo }, method: 'POST' })) }createWebhookEndpoint (e, t) { return Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: '/webhook_endpoints', request_body: e, method: 'POST' })) }deleteWebhookEndpoint (e, t) { return Wp(Dp({ auth: this.auth }, this.defaultRequestOptions, t, { endpoint: `/webhook_endpoints/${e}`, method: 'DELETE' })) }} const eg = class {account; config; jwt; constructor (e, t) { this.account = e, this.config = t, this.jwt = '' }_requestFunc; set requestFunc (e) { this._requestFunc = e }init () { return Promise.resolve() }unload () { return Promise.resolve() } get supportedMethods () { return ['makeInvoice', 'sendPayment', 'signMessage', 'getInfo'] } async getInfo () { return await this.ensureLogin(), this.request('GET', 'api/v1/lnd/info').then(e => ({ data: { alias: e.alias, pubkey: e.identityPubkey, color: e.color } })) } async getInvoices () { throw console.error(`Not yet supported with the currently used account: ${this.constructor.name}`), new Error(`${this.constructor.name}: "getInvoices" is not yet supported. Contact us if you need it.`) } async connectPeer () { throw console.error(`${this.constructor.name} does not implement the getInvoices call`), new Error('Not yet supported with the currently used account.') } async getBalance () { return await this.ensureLogin(), this.request('GET', 'api/v1/lnd/wallet/lightning').then(e => ({ data: { balance: parseInt(e.localBalance?.sat) } })) } async keysend (e) { throw new Error('not supported') } async sendPayment (e) { return await this.ensureLogin(), this.request('POST', 'api/v1/lnd/lightning/payInvoice', { paymentRequest: e.paymentRequest }).then(e => ({ data: { preimage: e.paymentPreimage, paymentHash: e.paymentHash, route: { total_amt: Math.floor(parseInt(e.paymentRoute?.totalAmtMsat) / 1e3), total_fees: parseInt(e.paymentRoute?.totalFeesMsat) } } })) } async signMessage (e) { return await this.ensureLogin(), this.request('POST', 'api/v1/lnd/util/sign-message', { message: e.message }).then(t => ({ data: { message: e.message, signature: t.signature } })) } async refresh () { const e = await this.request('POST', 'manager-api/v1/account/refresh'); if (typeof e !== 'object' || e === null || !e.jwt) throw new Error('Failed to login.'); return e.jwt } async login (e, t) { const n = await this.request('POST', 'manager-api/v1/account/login', { password: e, totpToken: t }); if (typeof n !== 'object' || n === null || !n.jwt) throw new Error('Failed to login.'); return n.jwt } async ensureLogin () { try { this.jwt = await this.refresh() } catch { this.jwt = await this.login(this.config.password, '') } } async makeInvoice (e) { return await this.ensureLogin(), this.request('POST', 'api/v1/lnd/util/lightning/addInvoice', { memo: e.memo, amt: e.amount.toString() }).then(e => ({ data: { paymentRequest: e.paymentRequest, rHash: e.rHashStr } })) } async checkPayment (e) { return await this.ensureLogin(), this.request('GET', `invoice-info?paymentHash=${e.paymentHash}`).then(e => ({ data: { paid: e.isPaid || e.state === 1 } })) } async request (e, t, n) { const r = this.config.url + (this.config.url.endsWith('/') ? '' : '/') + t; const i = new Headers(); i.append('Accept', 'application/json'), i.append('Content-Type', 'application/json'), this.jwt && i.append('Authorization', `JWT ${this.jwt}`); const o = await fetch(r, { headers: i, method: e, ...e !== 'GET' ? { body: JSON.stringify(n) } : {} }); if (!o.ok) { const e = await o.json(); throw console.error('errBody', e), new Error(e.detail) } return await o.json() }}; const tg = a(5743); const ng = a.n(tg); let rg = function (e, t) { return rg = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (const n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]) }, rg(e, t) }; function ig (e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Class extends value ' + String(t) + ' is not a constructor or null'); function n () { this.constructor = e }rg(e, t), e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n()) }Object.create; function og (e) { const t = typeof Symbol === 'function' && Symbol.iterator; const n = t && e[t]; let r = 0; if (n) return n.call(e); if (e && typeof e.length === 'number') return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.') } function ag (e, t) { let n = typeof Symbol === 'function' && e[Symbol.iterator]; if (!n) return e; let r; let i; const o = n.call(e); const a = []; try { for (;(void 0 === t || t-- > 0) && !(r = o.next()).done;)a.push(r.value) } catch (e) { i = { error: e } } finally { try { r && !r.done && (n = o.return) && n.call(o) } finally { if (i) throw i.error } } return a } function sg (e, t, n) { if (n || arguments.length === 2) for (var r, i = 0, o = t.length; i < o; i++)!r && i in t || (r || (r = Array.prototype.slice.call(t, 0, i)), r[i] = t[i]); return e.concat(r || Array.prototype.slice.call(t)) }Object.create; function cg (e) { return typeof e === 'function' } function ug (e) { const t = e(function (e) { Error.call(e), e.stack = (new Error()).stack }); return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t } const lg = ug(function (e) { return function (t) { e(this), this.message = t ? t.length + ' errors occurred during unsubscription:\n' + t.map(function (e, t) { return t + 1 + ') ' + e.toString() }).join('\n  ') : '', this.name = 'UnsubscriptionError', this.errors = t } }); function dg (e, t) { if (e) { const n = e.indexOf(t); n >= 0 && e.splice(n, 1) } } const fg = (function () { function e (e) { this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null } let t; return e.prototype.unsubscribe = function () { let e, t, n, r, i; if (!this.closed) { this.closed = !0; const o = this._parentage; if (o) if (this._parentage = null, Array.isArray(o)) try { for (var a = og(o), s = a.next(); !s.done; s = a.next()) { s.value.remove(this) } } catch (t) { e = { error: t } } finally { try { s && !s.done && (t = a.return) && t.call(a) } finally { if (e) throw e.error } } else o.remove(this); const c = this.initialTeardown; if (cg(c)) try { c() } catch (e) { i = e instanceof lg ? e.errors : [e] } const u = this._finalizers; if (u) { this._finalizers = null; try { for (var l = og(u), d = l.next(); !d.done; d = l.next()) { const f = d.value; try { gg(f) } catch (e) { i = i != null ? i : [], e instanceof lg ? i = sg(sg([], ag(i)), ag(e.errors)) : i.push(e) } } } catch (e) { n = { error: e } } finally { try { d && !d.done && (r = l.return) && r.call(l) } finally { if (n) throw n.error } } } if (i) throw new lg(i) } }, e.prototype.add = function (t) { let n; if (t && t !== this) if (this.closed)gg(t); else { if (t instanceof e) { if (t.closed || t._hasParent(this)) return; t._addParent(this) }(this._finalizers = (n = this._finalizers) !== null && void 0 !== n ? n : []).push(t) } }, e.prototype._hasParent = function (e) { const t = this._parentage; return t === e || Array.isArray(t) && t.includes(e) }, e.prototype._addParent = function (e) { const t = this._parentage; this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e }, e.prototype._removeParent = function (e) { const t = this._parentage; t === e ? this._parentage = null : Array.isArray(t) && dg(t, e) }, e.prototype.remove = function (t) { const n = this._finalizers; n && dg(n, t), t instanceof e && t._removeParent(this) }, e.EMPTY = ((t = new e()).closed = !0, t), e }()); const hg = fg.EMPTY; function pg (e) { return e instanceof fg || e && 'closed' in e && cg(e.remove) && cg(e.add) && cg(e.unsubscribe) } function gg (e) { cg(e) ? e() : e.unsubscribe() } const mg = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }; var yg = { setTimeout: function (e, t) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; const i = yg.delegate; return (i == null ? void 0 : i.setTimeout) ? i.setTimeout.apply(i, sg([e, t], ag(n))) : setTimeout.apply(void 0, sg([e, t], ag(n))) }, clearTimeout: function (e) { const t = yg.delegate; return ((t == null ? void 0 : t.clearTimeout) || clearTimeout)(e) }, delegate: void 0 }; function bg () {} const vg = wg('C', void 0, void 0); function wg (e, t, n) { return { kind: e, value: t, error: n } } let _g = null; function Eg (e) { if (mg.useDeprecatedSynchronousErrorHandling) { const t = !_g; if (t && (_g = { errorThrown: !1, error: null }), e(), t) { const n = _g; const r = n.errorThrown; const i = n.error; if (_g = null, r) throw i } } else e() } const kg = (function (e) { function t (t) { const n = e.call(this) || this; return n.isStopped = !1, t ? (n.destination = t, pg(t) && t.add(n)) : n.destination = Tg, n } return ig(t, e), t.create = function (e, t, n) { return new xg(e, t, n) }, t.prototype.next = function (e) { this.isStopped ? Ng((function (e) { return wg('N', e, void 0) }(e)), this) : this._next(e) }, t.prototype.error = function (e) { this.isStopped ? Ng(wg('E', void 0, e), this) : (this.isStopped = !0, this._error(e)) }, t.prototype.complete = function () { this.isStopped ? Ng(vg, this) : (this.isStopped = !0, this._complete()) }, t.prototype.unsubscribe = function () { this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null) }, t.prototype._next = function (e) { this.destination.next(e) }, t.prototype._error = function (e) { try { this.destination.error(e) } finally { this.unsubscribe() } }, t.prototype._complete = function () { try { this.destination.complete() } finally { this.unsubscribe() } }, t }(fg)); const Sg = Function.prototype.bind; function Ag (e, t) { return Sg.call(e, t) } const Og = (function () { function e (e) { this.partialObserver = e } return e.prototype.next = function (e) { const t = this.partialObserver; if (t.next) try { t.next(e) } catch (e) { Ig(e) } }, e.prototype.error = function (e) { const t = this.partialObserver; if (t.error) try { t.error(e) } catch (e) { Ig(e) } else Ig(e) }, e.prototype.complete = function () { const e = this.partialObserver; if (e.complete) try { e.complete() } catch (e) { Ig(e) } }, e }()); var xg = (function (e) { function t (t, n, r) { let i; let o; const a = e.call(this) || this; cg(t) || !t ? i = { next: t != null ? t : void 0, error: n != null ? n : void 0, complete: r != null ? r : void 0 } : a && mg.useDeprecatedNextContext ? ((o = Object.create(t)).unsubscribe = function () { return a.unsubscribe() }, i = { next: t.next && Ag(t.next, o), error: t.error && Ag(t.error, o), complete: t.complete && Ag(t.complete, o) }) : i = t; return a.destination = new Og(i), a } return ig(t, e), t }(kg)); function Ig (e) { mg.useDeprecatedSynchronousErrorHandling ? (function (e) { mg.useDeprecatedSynchronousErrorHandling && _g && (_g.errorThrown = !0, _g.error = e) }(e)) : (function (e) { yg.setTimeout(function () { const t = mg.onUnhandledError; if (!t) throw e; t(e) }) }(e)) } function Ng (e, t) { const n = mg.onStoppedNotification; n && yg.setTimeout(function () { return n(e, t) }) } var Tg = { closed: !0, next: bg, error: function (e) { throw e }, complete: bg }; const Rg = typeof Symbol === 'function' && Symbol.observable || '@@observable'; function Pg (e) { return e } function Cg (e) { return e.length === 0 ? Pg : e.length === 1 ? e[0] : function (t) { return e.reduce(function (e, t) { return t(e) }, t) } } const Bg = (function () { function e (e) { e && (this._subscribe = e) } return e.prototype.lift = function (t) { const n = new e(); return n.source = this, n.operator = t, n }, e.prototype.subscribe = function (e, t, n) { let r; const i = this; const o = (r = e) && r instanceof kg || (function (e) { return e && cg(e.next) && cg(e.error) && cg(e.complete) }(r)) && pg(r) ? e : new xg(e, t, n); return Eg(function () { const e = i; const t = e.operator; const n = e.source; o.add(t ? t.call(o, n) : n ? i._subscribe(o) : i._trySubscribe(o)) }), o }, e.prototype._trySubscribe = function (e) { try { return this._subscribe(e) } catch (t) { e.error(t) } }, e.prototype.forEach = function (e, t) { const n = this; return new (t = Lg(t))(function (t, r) { var i = new xg({ next: function (t) { try { e(t) } catch (e) { r(e), i.unsubscribe() } }, error: r, complete: t }); n.subscribe(i) }) }, e.prototype._subscribe = function (e) { let t; return (t = this.source) === null || void 0 === t ? void 0 : t.subscribe(e) }, e.prototype[Rg] = function () { return this }, e.prototype.pipe = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return Cg(e)(this) }, e.prototype.toPromise = function (e) { const t = this; return new (e = Lg(e))(function (e, n) { let r; t.subscribe(function (e) { return r = e }, function (e) { return n(e) }, function () { return e(r) }) }) }, e.create = function (t) { return new e(t) }, e }()); function Lg (e) { let t; return (t = e != null ? e : mg.Promise) !== null && void 0 !== t ? t : Promise } const jg = ug(function (e) { return function () { e(this), this.name = 'ObjectUnsubscribedError', this.message = 'object unsubscribed' } }); const Dg = (function (e) { function t () { const t = e.call(this) || this; return t.closed = !1, t.currentObservers = null, t.observers = [], t.isStopped = !1, t.hasError = !1, t.thrownError = null, t } return ig(t, e), t.prototype.lift = function (e) { const t = new Ug(this, this); return t.operator = e, t }, t.prototype._throwIfClosed = function () { if (this.closed) throw new jg() }, t.prototype.next = function (e) { const t = this; Eg(function () { let n, r; if (t._throwIfClosed(), !t.isStopped) { t.currentObservers || (t.currentObservers = Array.from(t.observers)); try { for (var i = og(t.currentObservers), o = i.next(); !o.done; o = i.next()) { o.value.next(e) } } catch (e) { n = { error: e } } finally { try { o && !o.done && (r = i.return) && r.call(i) } finally { if (n) throw n.error } } } }) }, t.prototype.error = function (e) { const t = this; Eg(function () { if (t._throwIfClosed(), !t.isStopped) { t.hasError = t.isStopped = !0, t.thrownError = e; for (let n = t.observers; n.length;)n.shift().error(e) } }) }, t.prototype.complete = function () { const e = this; Eg(function () { if (e._throwIfClosed(), !e.isStopped) { e.isStopped = !0; for (let t = e.observers; t.length;)t.shift().complete() } }) }, t.prototype.unsubscribe = function () { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null }, Object.defineProperty(t.prototype, 'observed', { get: function () { let e; return ((e = this.observers) === null || void 0 === e ? void 0 : e.length) > 0 }, enumerable: !1, configurable: !0 }), t.prototype._trySubscribe = function (t) { return this._throwIfClosed(), e.prototype._trySubscribe.call(this, t) }, t.prototype._subscribe = function (e) { return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e) }, t.prototype._innerSubscribe = function (e) { const t = this; const n = this; const r = n.hasError; const i = n.isStopped; const o = n.observers; return r || i ? hg : (this.currentObservers = null, o.push(e), new fg(function () { t.currentObservers = null, dg(o, e) })) }, t.prototype._checkFinalizedStatuses = function (e) { const t = this; const n = t.hasError; const r = t.thrownError; const i = t.isStopped; n ? e.error(r) : i && e.complete() }, t.prototype.asObservable = function () { const e = new Bg(); return e.source = this, e }, t.create = function (e, t) { return new Ug(e, t) }, t }(Bg)); var Ug = (function (e) { function t (t, n) { const r = e.call(this) || this; return r.destination = t, r.source = n, r } return ig(t, e), t.prototype.next = function (e) { let t, n; (n = (t = this.destination) === null || void 0 === t ? void 0 : t.next) === null || void 0 === n || n.call(t, e) }, t.prototype.error = function (e) { let t, n; (n = (t = this.destination) === null || void 0 === t ? void 0 : t.error) === null || void 0 === n || n.call(t, e) }, t.prototype.complete = function () { let e, t; (t = (e = this.destination) === null || void 0 === e ? void 0 : e.complete) === null || void 0 === t || t.call(e) }, t.prototype._subscribe = function (e) { let t, n; return (n = (t = this.source) === null || void 0 === t ? void 0 : t.subscribe(e)) !== null && void 0 !== n ? n : hg }, t }(Dg)); const Mg = (function (e) { function t (t) { const n = e.call(this) || this; return n._value = t, n } return ig(t, e), Object.defineProperty(t.prototype, 'value', { get: function () { return this.getValue() }, enumerable: !1, configurable: !0 }), t.prototype._subscribe = function (t) { const n = e.prototype._subscribe.call(this, t); return !n.closed && t.next(this._value), n }, t.prototype.getValue = function () { const e = this; const t = e.hasError; const n = e.thrownError; const r = e._value; if (t) throw n; return this._throwIfClosed(), r }, t.prototype.next = function (t) { e.prototype.next.call(this, this._value = t) }, t }(Dg)); const zg = ug(function (e) { return function () { e(this), this.name = 'EmptyError', this.message = 'no elements in sequence' } }); function Fg (e, t) { const n = typeof t === 'object'; return new Promise(function (r, i) { var o = new xg({ next: function (e) { r(e), o.unsubscribe() }, error: i, complete: function () { n ? r(t.defaultValue) : i(new zg()) } }); e.subscribe(o) }) } function Hg (e) { return function (t) { if (function (e) { return cg(e == null ? void 0 : e.lift) }(t)) return t.lift(function (t) { try { return e(t, this) } catch (e) { this.error(e) } }); throw new TypeError('Unable to lift unknown Observable type') } } function qg (e, t, n, r, i) { return new Kg(e, t, n, r, i) } var Kg = (function (e) { function t (t, n, r, i, o, a) { const s = e.call(this, t) || this; return s.onFinalize = o, s.shouldUnsubscribe = a, s._next = n ? function (e) { try { n(e) } catch (e) { t.error(e) } } : e.prototype._next, s._error = i ? function (e) { try { i(e) } catch (e) { t.error(e) } finally { this.unsubscribe() } } : e.prototype._error, s._complete = r ? function () { try { r() } catch (e) { t.error(e) } finally { this.unsubscribe() } } : e.prototype._complete, s } return ig(t, e), t.prototype.unsubscribe = function () { let t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const n = this.closed; e.prototype.unsubscribe.call(this), !n && ((t = this.onFinalize) === null || void 0 === t || t.call(this)) } }, t }(kg)); function Vg (e, t) { return Hg(function (n, r) { let i = 0; n.subscribe(qg(r, function (n) { r.next(e.call(t, n, i++)) })) }) } function Wg (e, t) { return Hg(function (n, r) { let i = 0; n.subscribe(qg(r, function (n) { return e.call(t, n, i++) && r.next(n) })) }) } const $g = a(8764); const Gg = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0; const Yg = e => new DataView(e.buffer, e.byteOffset, e.byteLength); const Zg = (e, t) => e << 32 - t | e >>> t; if (!(new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)) throw new Error('Non little-endian hardware is not supported'); const Jg = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0')); function Xg (e) { if (!(e instanceof Uint8Array)) throw new Error('Uint8Array expected'); let t = ''; for (let n = 0; n < e.length; n++)t += Jg[e[n]]; return t } function Qg (e) { if (typeof e === 'string' && (e = (function (e) { if (typeof e !== 'string') throw new TypeError('utf8ToBytes expected string, got ' + typeof e); return (new TextEncoder()).encode(e) }(e))), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`); return e } class em {clone () { return this._cloneInto() }} function tm (e) { const t = t => e().update(Qg(t)).digest(); const n = e(); return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t } function nm (e = 32) { if (Gg && typeof Gg.getRandomValues === 'function') return Gg.getRandomValues(new Uint8Array(e)); throw new Error('crypto.getRandomValues must be defined') } const rm = a(6403); const im = a.t(rm, 2); const om = BigInt(0); const am = BigInt(1); const sm = BigInt(2); const cm = BigInt(3); const um = BigInt(8); const lm = Object.freeze({ a: om, b: BigInt(7), P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'), n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'), h: am, Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'), Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'), beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee') }); const dm = (e, t) => (e + t / sm) / t; const fm = { beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'), splitScalar (e) { const { n: t } = lm; const n = BigInt('0x3086d221a7d46bcde86c90e49284eb15'); const r = -am * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'); const i = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'); const o = n; const a = BigInt('0x100000000000000000000000000000000'); const s = dm(o * e, t); const c = dm(-r * e, t); let u = zm(e - s * n - c * i, t); let l = zm(-s * r - c * o, t); const d = u > a; const f = l > a; if (d && (u = t - u), f && (l = t - l), u > a || l > a) throw new Error('splitScalarEndo: Endomorphism failed, k=' + e); return { k1neg: d, k1: u, k2neg: f, k2: l } } }; const hm = 32; const pm = 32; const gm = hm + 1; const mm = 2 * hm + 1; function ym (e) { const { a: t, b: n } = lm; const r = zm(e * e); const i = zm(r * e); return zm(i + t * e + n) } const bm = lm.a === om; class vm extends Error {constructor (e) { super(e) }} function wm (e) { if (!(e instanceof _m)) throw new TypeError('JacobianPoint expected') } class _m {constructor (e, t, n) { this.x = e, this.y = t, this.z = n } static fromAffine (e) { if (!(e instanceof Sm)) throw new TypeError('JacobianPoint#fromAffine: expected Point'); return e.equals(Sm.ZERO) ? _m.ZERO : new _m(e.x, e.y, am) } static toAffineBatch (e) { const t = (function (e, t = lm.P) { const n = new Array(e.length); const r = e.reduce((e, r, i) => r === om ? e : (n[i] = e, zm(e * r, t)), am); const i = Hm(r, t); return e.reduceRight((e, r, i) => r === om ? e : (n[i] = zm(e * n[i], t), zm(e * r, t)), i), n }(e.map(e => e.z))); return e.map((e, n) => e.toAffine(t[n])) } static normalizeZ (e) { return _m.toAffineBatch(e).map(_m.fromAffine) }equals (e) { wm(e); const { x: t, y: n, z: r } = this; const { x: i, y: o, z: a } = e; const s = zm(r * r); const c = zm(a * a); const u = zm(t * c); const l = zm(i * s); const d = zm(zm(n * a) * c); const f = zm(zm(o * r) * s); return u === l && d === f }negate () { return new _m(this.x, zm(-this.y), this.z) }double () { const { x: e, y: t, z: n } = this; const r = zm(e * e); const i = zm(t * t); const o = zm(i * i); const a = e + i; const s = zm(sm * (zm(a * a) - r - o)); const c = zm(cm * r); const u = zm(c * c); const l = zm(u - sm * s); const d = zm(c * (s - l) - um * o); const f = zm(sm * t * n); return new _m(l, d, f) }add (e) { wm(e); const { x: t, y: n, z: r } = this; const { x: i, y: o, z: a } = e; if (i === om || o === om) return this; if (t === om || n === om) return e; const s = zm(r * r); const c = zm(a * a); const u = zm(t * c); const l = zm(i * s); const d = zm(zm(n * a) * c); const f = zm(zm(o * r) * s); const h = zm(l - u); const p = zm(f - d); if (h === om) return p === om ? this.double() : _m.ZERO; const g = zm(h * h); const m = zm(h * g); const y = zm(u * g); const b = zm(p * p - m - sm * y); const v = zm(p * (y - b) - d * m); const w = zm(r * a * h); return new _m(b, v, w) }subtract (e) { return this.add(e.negate()) }multiplyUnsafe (e) { const t = _m.ZERO; if (typeof e === 'bigint' && e === om) return t; let n = Mm(e); if (n === am) return this; if (!bm) { let e = t; let r = this; for (;n > om;)n & am && (e = e.add(r)), r = r.double(), n >>= am; return e } let { k1neg: r, k1: i, k2neg: o, k2: a } = fm.splitScalar(n); let s = t; let c = t; let u = this; for (;i > om || a > om;)i & am && (s = s.add(u)), a & am && (c = c.add(u)), u = u.double(), i >>= am, a >>= am; return r && (s = s.negate()), o && (c = c.negate()), c = new _m(zm(c.x * fm.beta), c.y, c.z), s.add(c) }precomputeWindow (e) { const t = bm ? 128 / e + 1 : 256 / e + 1; const n = []; let r = this; let i = r; for (let o = 0; o < t; o++) { i = r, n.push(i); for (let t = 1; t < 2 ** (e - 1); t++)i = i.add(r), n.push(i); r = i.double() } return n }wNAF (e, t) { !t && this.equals(_m.BASE) && (t = Sm.BASE); const n = t && t._WINDOW_SIZE || 1; if (256 % n) throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2'); let r = t && km.get(t); r || (r = this.precomputeWindow(n), t && n !== 1 && (r = _m.normalizeZ(r), km.set(t, r))); let i = _m.ZERO; let o = _m.BASE; const a = 1 + (bm ? 128 / n : 256 / n); const s = 2 ** (n - 1); const c = BigInt(2 ** n - 1); const u = 2 ** n; const l = BigInt(n); for (let t = 0; t < a; t++) { const n = t * s; let a = Number(e & c); e >>= l, a > s && (a -= u, e += am); const d = n; const f = n + Math.abs(a) - 1; const h = t % 2 != 0; const p = a < 0; a === 0 ? o = o.add(Em(h, r[d])) : i = i.add(Em(p, r[f])) } return { p: i, f: o } }multiply (e, t) { let n; let r; const i = Mm(e); if (bm) { const { k1neg: e, k1: o, k2neg: a, k2: s } = fm.splitScalar(i); let { p: c, f: u } = this.wNAF(o, t); let { p: l, f: d } = this.wNAF(s, t); c = Em(e, c), l = Em(a, l), l = new _m(zm(l.x * fm.beta), l.y, l.z), n = c.add(l), r = u.add(d) } else { const { p: e, f: o } = this.wNAF(i, t); n = e, r = o } return _m.normalizeZ([n, r])[0] }toAffine (e) { const { x: t, y: n, z: r } = this; const i = this.equals(_m.ZERO); e == null && (e = i ? um : Hm(r)); const o = e; const a = zm(o * o); const s = zm(a * o); const c = zm(t * a); const u = zm(n * s); const l = zm(r * o); if (i) return Sm.ZERO; if (l !== am) throw new Error('invZ was invalid'); return new Sm(c, u) }} function Em (e, t) { const n = t.negate(); return e ? n : t }_m.BASE = new _m(lm.Gx, lm.Gy, am), _m.ZERO = new _m(om, am, om); const km = new WeakMap(); class Sm {constructor (e, t) { this.x = e, this.y = t }_setWindowSize (e) { this._WINDOW_SIZE = e, km.delete(this) }hasEvenY () { return this.y % sm === om } static fromCompressedHex (e) { const t = e.length === 32; const n = Dm(t ? e : e.subarray(1)); if (!$m(n)) throw new Error('Point is not on curve'); let r = (function (e) { const { P: t } = lm; const n = BigInt(6); const r = BigInt(11); const i = BigInt(22); const o = BigInt(23); const a = BigInt(44); const s = BigInt(88); const c = e * e * e % t; const u = c * c * e % t; const l = Fm(u, cm) * u % t; const d = Fm(l, cm) * u % t; const f = Fm(d, sm) * c % t; const h = Fm(f, r) * f % t; const p = Fm(h, i) * h % t; const g = Fm(p, a) * p % t; const m = Fm(g, s) * g % t; const y = Fm(m, a) * p % t; const b = Fm(y, cm) * u % t; const v = Fm(b, o) * h % t; const w = Fm(v, n) * c % t; const _ = Fm(w, sm); const E = _ * _ % t; if (E !== e) throw new Error('Cannot find square root'); return _ }(ym(n))); const i = (r & am) === am; if (t)i && (r = zm(-r)); else { (1 & e[0]) == 1 !== i && (r = zm(-r)) } const o = new Sm(n, r); return o.assertValidity(), o } static fromUncompressedHex (e) { const t = Dm(e.subarray(1, hm + 1)); const n = Dm(e.subarray(hm + 1, 2 * hm + 1)); const r = new Sm(t, n); return r.assertValidity(), r } static fromHex (e) { const t = Um(e); const n = t.length; const r = t[0]; if (n === hm) return this.fromCompressedHex(t); if (n === gm && (r === 2 || r === 3)) return this.fromCompressedHex(t); if (n === mm && r === 4) return this.fromUncompressedHex(t); throw new Error(`Point.fromHex: received invalid point. Expected 32-${gm} compressed bytes or ${mm} uncompressed bytes, not ${n}`) } static fromPrivateKey (e) { return Sm.BASE.multiply(Gm(e)) } static fromSignature (e, t, n) { const { r, s: i } = Zm(t); if (![0, 1, 2, 3].includes(n)) throw new Error('Cannot recover: invalid recovery bit'); const o = qm(Um(e)); const { n: a } = lm; const s = n === 2 || n === 3 ? r + a : r; const c = Hm(s, a); const u = zm(-o * c, a); const l = zm(i * c, a); const d = 1 & n ? '03' : '02'; const f = Sm.fromHex(d + Pm(s)); const h = Sm.BASE.multiplyAndAddUnsafe(f, u, l); if (!h) throw new Error('Cannot recover signature: point at infinify'); return h.assertValidity(), h }toRawBytes (e = !1) { return jm(this.toHex(e)) }toHex (e = !1) { const t = Pm(this.x); if (e) { return `${this.hasEvenY() ? '02' : '03'}${t}` } return `04${t}${Pm(this.y)}` }toHexX () { return this.toHex(!0).slice(2) }toRawX () { return this.toRawBytes(!0).slice(1) }assertValidity () { const e = 'Point is not on elliptic curve'; const { x: t, y: n } = this; if (!$m(t) || !$m(n)) throw new Error(e); const r = zm(n * n); if (zm(r - ym(t)) !== om) throw new Error(e) }equals (e) { return this.x === e.x && this.y === e.y }negate () { return new Sm(this.x, zm(-this.y)) }double () { return _m.fromAffine(this).double().toAffine() }add (e) { return _m.fromAffine(this).add(_m.fromAffine(e)).toAffine() }subtract (e) { return this.add(e.negate()) }multiply (e) { return _m.fromAffine(this).multiply(e, this).toAffine() }multiplyAndAddUnsafe (e, t, n) { const r = _m.fromAffine(this); const i = t === om || t === am || this !== Sm.BASE ? r.multiplyUnsafe(t) : r.multiply(t); const o = _m.fromAffine(e).multiplyUnsafe(n); const a = i.add(o); return a.equals(_m.ZERO) ? void 0 : a.toAffine() }} function Am (e) { return Number.parseInt(e[0], 16) >= 8 ? '00' + e : e } function Om (e) { if (e.length < 2 || e[0] !== 2) throw new Error(`Invalid signature integer tag: ${Tm(e)}`); const t = e[1]; const n = e.subarray(2, t + 2); if (!t || n.length !== t) throw new Error('Invalid signature integer: wrong length'); if (n[0] === 0 && n[1] <= 127) throw new Error('Invalid signature integer: trailing length'); return { data: Dm(n), left: e.subarray(t + 2) } }Sm.BASE = new Sm(lm.Gx, lm.Gy), Sm.ZERO = new Sm(om, om); class xm {constructor (e, t) { this.r = e, this.s = t, this.assertValidity() } static fromCompact (e) { const t = e instanceof Uint8Array; const n = 'Signature.fromCompact'; if (typeof e !== 'string' && !t) throw new TypeError(`${n}: Expected string or Uint8Array`); const r = t ? Tm(e) : e; if (r.length !== 128) throw new Error(`${n}: Expected 64-byte hex`); return new xm(Lm(r.slice(0, 64)), Lm(r.slice(64, 128))) } static fromDER (e) { const t = e instanceof Uint8Array; if (typeof e !== 'string' && !t) throw new TypeError('Signature.fromDER: Expected string or Uint8Array'); const { r: n, s: r } = (function (e) { if (e.length < 2 || e[0] != 48) throw new Error(`Invalid signature tag: ${Tm(e)}`); if (e[1] !== e.length - 2) throw new Error('Invalid signature: incorrect length'); const { data: t, left: n } = Om(e.subarray(2)); const { data: r, left: i } = Om(n); if (i.length) throw new Error(`Invalid signature: left bytes after parsing: ${Tm(i)}`); return { r: t, s: r } }(t ? e : jm(e))); return new xm(n, r) } static fromHex (e) { return this.fromDER(e) }assertValidity () { const { r: e, s: t } = this; if (!Wm(e)) throw new Error('Invalid Signature: r must be 0 < r < n'); if (!Wm(t)) throw new Error('Invalid Signature: s must be 0 < s < n') }hasHighS () { const e = lm.n >> am; return this.s > e }normalizeS () { return this.hasHighS() ? new xm(this.r, zm(-this.s, lm.n)) : this }toDERRawBytes () { return jm(this.toDERHex()) }toDERHex () { const e = Am(Bm(this.s)); const t = Am(Bm(this.r)); const n = e.length / 2; const r = t.length / 2; const i = Bm(n); const o = Bm(r); return `30${Bm(r + n + 4)}02${o}${t}02${i}${e}` }toRawBytes () { return this.toDERRawBytes() }toHex () { return this.toDERHex() }toCompactRawBytes () { return jm(this.toCompactHex()) }toCompactHex () { return Pm(this.r) + Pm(this.s) }} function Im (...e) { if (!e.every(e => e instanceof Uint8Array)) throw new Error('Uint8Array list expected'); if (e.length === 1) return e[0]; const t = e.reduce((e, t) => e + t.length, 0); const n = new Uint8Array(t); for (let t = 0, r = 0; t < e.length; t++) { const i = e[t]; n.set(i, r), r += i.length } return n } const Nm = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0')); function Tm (e) { if (!(e instanceof Uint8Array)) throw new Error('Expected Uint8Array'); let t = ''; for (let n = 0; n < e.length; n++)t += Nm[e[n]]; return t } const Rm = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000'); function Pm (e) { if (typeof e !== 'bigint') throw new Error('Expected bigint'); if (!(om <= e && e < Rm)) throw new Error('Expected number 0 <= n < 2^256'); return e.toString(16).padStart(64, '0') } function Cm (e) { const t = jm(Pm(e)); if (t.length !== 32) throw new Error('Error: expected 32 bytes'); return t } function Bm (e) { const t = e.toString(16); return 1 & t.length ? `0${t}` : t } function Lm (e) { if (typeof e !== 'string') throw new TypeError('hexToNumber: expected string, got ' + typeof e); return BigInt(`0x${e}`) } function jm (e) { if (typeof e !== 'string') throw new TypeError('hexToBytes: expected string, got ' + typeof e); if (e.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + e.length); const t = new Uint8Array(e.length / 2); for (let n = 0; n < t.length; n++) { const r = 2 * n; const i = e.slice(r, r + 2); const o = Number.parseInt(i, 16); if (Number.isNaN(o) || o < 0) throw new Error('Invalid byte sequence'); t[n] = o } return t } function Dm (e) { return Lm(Tm(e)) } function Um (e) { return e instanceof Uint8Array ? Uint8Array.from(e) : jm(e) } function Mm (e) { if (typeof e === 'number' && Number.isSafeInteger(e) && e > 0) return BigInt(e); if (typeof e === 'bigint' && Wm(e)) return e; throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n') } function zm (e, t = lm.P) { const n = e % t; return n >= om ? n : t + n } function Fm (e, t) { const { P: n } = lm; let r = e; for (;t-- > om;)r *= r, r %= n; return r } function Hm (e, t = lm.P) { if (e === om || t <= om) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`); let n = zm(e, t); let r = t; let i = om; let o = am; let a = am; let s = om; for (;n !== om;) { const e = r / n; const t = r % n; const c = i - a * e; const u = o - s * e; r = n, n = t, i = a, o = s, a = c, s = u } if (r !== am) throw new Error('invert: does not exist'); return zm(i, t) } function qm (e, t = !1) { const n = (function (e) { const t = 8 * e.length - 8 * pm; const n = Dm(e); return t > 0 ? n >> BigInt(t) : n }(e)); if (t) return n; const { n: r } = lm; return n >= r ? n - r : n } let Km, Vm; function Wm (e) { return om < e && e < lm.n } function $m (e) { return om < e && e < lm.P } function Gm (e) { let t; if (typeof e === 'bigint')t = e; else if (typeof e === 'number' && Number.isSafeInteger(e) && e > 0)t = BigInt(e); else if (typeof e === 'string') { if (e.length !== 2 * pm) throw new Error('Expected 32 bytes of private key'); t = Lm(e) } else { if (!(e instanceof Uint8Array)) throw new TypeError('Expected valid private key'); if (e.length !== pm) throw new Error('Expected 32 bytes of private key'); t = Dm(e) } if (!Wm(t)) throw new Error('Expected private key: 0 < key < n'); return t } function Ym (e) { return e instanceof Sm ? (e.assertValidity(), e) : Sm.fromHex(e) } function Zm (e) { if (e instanceof xm) return e.assertValidity(), e; try { return xm.fromDER(e) } catch (t) { return xm.fromCompact(e) } } function Jm (e) { const t = e instanceof Uint8Array; const n = typeof e === 'string'; const r = (t || n) && e.length; return t ? r === gm || r === mm : n ? r === 2 * gm || r === 2 * mm : e instanceof Sm }Sm.BASE._setWindowSize(8); const Xm = { node: im, web: typeof self === 'object' && 'crypto' in self ? self.crypto : void 0 }; const Qm = {}; const ey = { bytesToHex: Tm, hexToBytes: jm, concatBytes: Im, mod: zm, invert: Hm, isValidPrivateKey (e) { try { return Gm(e), !0 } catch (e) { return !1 } }, _bigintTo32Bytes: Cm, _normalizePrivateKey: Gm, hashToPrivateKey: e => { e = Um(e); const t = pm + 8; if (e.length < t || e.length > 1024) throw new Error('Expected valid bytes of private key as per FIPS 186'); return Cm(zm(Dm(e), lm.n - am) + am) }, randomBytes: (e = 32) => { if (Xm.web) return Xm.web.getRandomValues(new Uint8Array(e)); if (Xm.node) { const { randomBytes: t } = Xm.node; return Uint8Array.from(t(e)) } throw new Error("The environment doesn't have randomBytes function") }, randomPrivateKey: () => ey.hashToPrivateKey(ey.randomBytes(pm + 8)), precompute (e = 8, t = Sm.BASE) { const n = t === Sm.BASE ? t : new Sm(t.x, t.y); return n._setWindowSize(e), n.multiply(cm), n }, sha256: async (...e) => { if (Xm.web) { const t = await Xm.web.subtle.digest('SHA-256', Im(...e)); return new Uint8Array(t) } if (Xm.node) { const { createHash: t } = Xm.node; const n = t('sha256'); return e.forEach(e => n.update(e)), Uint8Array.from(n.digest()) } throw new Error("The environment doesn't have sha256 function") }, hmacSha256: async (e, ...t) => { if (Xm.web) { const n = await Xm.web.subtle.importKey('raw', e, { name: 'HMAC', hash: { name: 'SHA-256' } }, !1, ['sign']); const r = Im(...t); const i = await Xm.web.subtle.sign('HMAC', n, r); return new Uint8Array(i) } if (Xm.node) { const { createHmac: n } = Xm.node; const r = n('sha256', e); return t.forEach(e => r.update(e)), Uint8Array.from(r.digest()) } throw new Error("The environment doesn't have hmac-sha256 function") }, sha256Sync: void 0, hmacSha256Sync: void 0, taggedHash: async (e, ...t) => { let n = Qm[e]; if (void 0 === n) { const t = await ey.sha256(Uint8Array.from(e, e => e.charCodeAt(0))); n = Im(t, t), Qm[e] = n } return ey.sha256(n, ...t) }, taggedHashSync: (e, ...t) => { if (typeof Km !== 'function') throw new vm('sha256Sync is undefined, you need to set it'); let n = Qm[e]; if (void 0 === n) { const t = Km(Uint8Array.from(e, e => e.charCodeAt(0))); n = Im(t, t), Qm[e] = n } return Km(n, ...t) }, _JacobianPoint: _m }; function ty (e, t) { return e << t | e >>> 32 - t }Object.defineProperties(ey, { sha256Sync: { configurable: !1, get: () => Km, set (e) { Km || (Km = e) } }, hmacSha256Sync: { configurable: !1, get: () => Vm, set (e) { Vm || (Vm = e) } } }); const ny = $g.Buffer.from('expand 32-byte k'); const ry = class {input; cachePos; buffer; output; constructor (e, t) { this.input = new Uint32Array(16), this.input[0] = ny.readUInt32LE(0), this.input[1] = ny.readUInt32LE(4), this.input[2] = ny.readUInt32LE(8), this.input[3] = ny.readUInt32LE(12), this.input[4] = e.readUInt32LE(0), this.input[5] = e.readUInt32LE(4), this.input[6] = e.readUInt32LE(8), this.input[7] = e.readUInt32LE(12), this.input[8] = e.readUInt32LE(16), this.input[9] = e.readUInt32LE(20), this.input[10] = e.readUInt32LE(24), this.input[11] = e.readUInt32LE(28), this.input[12] = 0, this.input[13] = t.readUInt32LE(0), this.input[14] = t.readUInt32LE(4), this.input[15] = t.readUInt32LE(8), this.cachePos = 64, this.buffer = new Uint32Array(16), this.output = $g.Buffer.alloc(64) }quarterRound (e, t, n, r) { const i = this.buffer; i[e] += i[t], i[r] = ty(i[r] ^ i[e], 16), i[n] += i[r], i[t] = ty(i[t] ^ i[n], 12), i[e] += i[t], i[r] = ty(i[r] ^ i[e], 8), i[n] += i[r], i[t] = ty(i[t] ^ i[n], 7) }makeBlock (e, t) { let n = -1; for (;++n < 16;) this.buffer[n] = this.input[n]; for (n = -1; ++n < 10;) this.quarterRound(0, 4, 8, 12), this.quarterRound(1, 5, 9, 13), this.quarterRound(2, 6, 10, 14), this.quarterRound(3, 7, 11, 15), this.quarterRound(0, 5, 10, 15), this.quarterRound(1, 6, 11, 12), this.quarterRound(2, 7, 8, 13), this.quarterRound(3, 4, 9, 14); for (n = -1; ++n < 16;) this.buffer[n] += this.input[n], e.writeUInt32LE(this.buffer[n], t), t += 4; if (this.input[12]++, !this.input[12]) throw new Error('counter is exausted') }getBytes (e) { let t = 0; const n = $g.Buffer.alloc(e); const r = 64 - this.cachePos; if (r) { if (r >= e) return this.output.copy(n, 0, this.cachePos, 64), this.cachePos += e, n; this.output.copy(n, 0, this.cachePos, 64), e -= r, t += r, this.cachePos = 64 } for (;e > 0;) { if (e <= 64) return this.makeBlock(this.output, 0), this.output.copy(n, t, 0, e), e < 64 && (this.cachePos = e), n; this.makeBlock(n, t), e -= 64, t += 64 } throw new Error('something bad happended') }}; const iy = class {buffer; leftover; r; h; pad; finished; constructor (e) { this.buffer = $g.Buffer.alloc(16), this.leftover = 0, this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.finished = 0; let t; const n = new Uint16Array(8); for (t = 8; t--;)n[t] = e.readUInt16LE(2 * t); for (this.r[0] = 8191 & n[0], this.r[1] = 8191 & (n[0] >>> 13 | n[1] << 3), this.r[2] = 7939 & (n[1] >>> 10 | n[2] << 6), this.r[3] = 8191 & (n[2] >>> 7 | n[3] << 9), this.r[4] = 255 & (n[3] >>> 4 | n[4] << 12), this.r[5] = n[4] >>> 1 & 8190, this.r[6] = 8191 & (n[4] >>> 14 | n[5] << 2), this.r[7] = 8065 & (n[5] >>> 11 | n[6] << 5), this.r[8] = 8191 & (n[6] >>> 8 | n[7] << 8), this.r[9] = n[7] >>> 5 & 127, t = 8; t--;) this.h[t] = 0, this.pad[t] = e.readUInt16LE(16 + 2 * t); this.h[8] = 0, this.h[9] = 0, this.leftover = 0, this.finished = 0 }blocks (e, t, n) { const r = this.finished ? 0 : 2048; const i = new Uint16Array(8); const o = new Uint32Array(10); let a = 0; let s = 0; let c = 0; for (;n >= 16;) { for (s = 8; s--;)i[s] = e.readUInt16LE(2 * s + t); for (this.h[0] += 8191 & i[0], this.h[1] += 8191 & (i[0] >>> 13 | i[1] << 3), this.h[2] += 8191 & (i[1] >>> 10 | i[2] << 6), this.h[3] += 8191 & (i[2] >>> 7 | i[3] << 9), this.h[4] += 8191 & (i[3] >>> 4 | i[4] << 12), this.h[5] += i[4] >>> 1 & 8191, this.h[6] += 8191 & (i[4] >>> 14 | i[5] << 2), this.h[7] += 8191 & (i[5] >>> 11 | i[6] << 5), this.h[8] += 8191 & (i[6] >>> 8 | i[7] << 8), this.h[9] += i[7] >>> 5 | r, s = 0, a = 0; s < 10; s++) { for (o[s] = a, c = 0; c < 10; c++)o[s] += (4294967295 & this.h[c]) * (c <= s ? this.r[s - c] : 5 * this.r[s + 10 - c]), c === 4 && (a = o[s] >>> 13, o[s] &= 8191); a += o[s] >>> 13, o[s] &= 8191 } for (a = (a << 2) + a, a += o[0], o[0] = 8191 & a, a >>>= 13, o[1] += a, s = 10; s--;) this.h[s] = o[s]; t += 16, n -= 16 } }update (e) { let t = e.length; let n = 0; let r = 0; let i = 0; if (this.leftover) { for (n = 16 - this.leftover, n > t && (n = t), r = n; r--;) this.buffer[this.leftover + r] = e[r + i]; if (t -= n, i += n, this.leftover += n, this.leftover < 16) return this; this.blocks(this.buffer, 0, 16), this.leftover = 0 } if (t >= 16 && (n = -16 & t, this.blocks(e, i, n), i += n, t -= n), t) { for (r = t; r--;) this.buffer[this.leftover + r] = e[r + i]; this.leftover += t } return this }finish () { const e = $g.Buffer.alloc(16); const t = new Uint16Array(10); let n = 0; let r = 0; let i = 0; let o = 0; if (this.leftover) { for (o = this.leftover, this.buffer[o++] = 1; o < 16; o++) this.buffer[o] = 0; this.finished = 1, this.blocks(this.buffer, 0, 16) } for (n = this.h[1] >>> 13, this.h[1] &= 8191, o = 2; o < 10; o++) this.h[o] += n, n = this.h[o] >>> 13, this.h[o] &= 8191; for (this.h[0] += 5 * n, n = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += n, n = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += n, t[0] = this.h[0] + 5, n = t[0] >>> 13, t[0] &= 8191, o = 1; o < 10; o++)t[o] = this.h[o] + n, n = t[o] >>> 13, t[o] &= 8191; for (t[9] -= 8192, r = (t[9] >>> 15) - 1, o = 10; o--;)t[o] &= r; for (r = ~r, o = 10; o--;) this.h[o] = this.h[o] & r | t[o]; for (this.h[0] = this.h[0] | this.h[1] << 13, this.h[1] = this.h[1] >> 3 | this.h[2] << 10, this.h[2] = this.h[2] >> 6 | this.h[3] << 7, this.h[3] = this.h[3] >> 9 | this.h[4] << 4, this.h[4] = this.h[4] >> 12 | this.h[5] << 1 | this.h[6] << 14, this.h[5] = this.h[6] >> 2 | this.h[7] << 11, this.h[6] = this.h[7] >> 5 | this.h[8] << 8, this.h[7] = this.h[8] >> 8 | this.h[9] << 5, i = (4294967295 & this.h[0]) + this.pad[0], this.h[0] = i, o = 1; o < 8; o++)i = (4294967295 & this.h[o]) + this.pad[o] + (i >>> 16), this.h[o] = i; for (o = 8; o--;)e.writeUInt16LE(this.h[o], 2 * o), this.pad[o] = 0; for (o = 10; o--;) this.h[o] = 0, this.r[o] = 0; return e }}; class oy {alen; clen; chacha; poly; tag; _decrypt; _hasData; constructor (e, t, n = !1) { this.alen = 0, this.clen = 0, this.chacha = new ry(e, t), this.poly = new iy(this.chacha.getBytes(64)), this.tag = null, this._decrypt = n, this._hasData = !1 }setAAD (e) { if (this._hasData) throw new Error('Attempting to set AAD in unsupported state'); this.alen = e.length, this.poly.update(e); const t = $g.Buffer.alloc(ay(this.alen)); t.length && (t.fill(0), this.poly.update(t)) }update (e, t, n) { typeof e === 'string' && (e = $g.Buffer.from(e, t)); const r = this._update(e) || $g.Buffer.from(''); return n ? r.toString(n) : r }final (e) { const t = this._final() || $g.Buffer.from(''); return e ? t.toString(e) : t }_update (e) { this._hasData || (this._hasData = !0); const t = e.length; if (!t) return; this.clen += t; const n = this.chacha.getBytes(t); let r = -1; for (;++r < t;)n[r] ^= e[r]; return this._decrypt ? this.poly.update(e) : this.poly.update(n), n }_final () { if (this._decrypt && !this.tag) throw new Error('Unsupported state or unable to authenticate data'); const e = $g.Buffer.alloc(ay(this.clen)); e.length && (e.fill(0), this.poly.update(e)); const t = $g.Buffer.alloc(16); t.fill(0), t.writeUInt32LE(this.alen, 0), t.writeUInt32LE(this.clen, 8); const n = this.poly.update(t).finish(); if (this._decrypt) { if (function (e, t) { let n = 0; e.length !== t.length && n++; const r = Math.min(e.length, t.length); let i = -1; for (;++i < r;)n += e[i] ^ t[i]; return n }(n, this.tag)) throw new Error('Unsupported state or unable to authenticate data') } else this.tag = n; return n }getAuthTag () { return this._decrypt || this.tag === null ? $g.Buffer.from('') : this.tag }setAuthTag (e) { if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state'); this.tag = e }} function ay (e) { const t = e % 16; return t ? 16 - t : 0 } function sy (e) { if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`) } function cy (e, ...t) { if (!(e instanceof Uint8Array)) throw new TypeError('Expected Uint8Array'); if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`) } const uy = { number: sy, bool: function (e) { if (typeof e !== 'boolean') throw new Error(`Expected boolean, not ${e}`) }, bytes: cy, hash: function (e) { if (typeof e !== 'function' || typeof e.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor'); sy(e.outputLen), sy(e.blockLen) }, exists: function (e, t = !0) { if (e.destroyed) throw new Error('Hash instance has been destroyed'); if (t && e.finished) throw new Error('Hash#digest() has already been called') }, output: function (e, t) { cy(e); const n = t.outputLen; if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`) } }; const ly = uy; class dy extends em {constructor (e, t) { super(), this.finished = !1, this.destroyed = !1, ly.hash(e); const n = Qg(t); if (this.iHash = e.create(), typeof this.iHash.update !== 'function') throw new TypeError('Expected instance of class which extends utils.Hash'); this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen; const r = this.blockLen; const i = new Uint8Array(r); i.set(n.length > r ? e.create().update(n).digest() : n); for (let e = 0; e < i.length; e++)i[e] ^= 54; this.iHash.update(i), this.oHash = e.create(); for (let e = 0; e < i.length; e++)i[e] ^= 106; this.oHash.update(i), i.fill(0) }update (e) { return ly.exists(this), this.iHash.update(e), this }digestInto (e) { ly.exists(this), ly.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy() }digest () { const e = new Uint8Array(this.oHash.outputLen); return this.digestInto(e), e }_cloneInto (e) { e || (e = Object.create(Object.getPrototypeOf(this), {})); const { oHash: t, iHash: n, finished: r, destroyed: i, blockLen: o, outputLen: a } = this; return e.finished = r, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e }destroy () { this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy() }} const fy = (e, t, n) => new dy(e, t).update(n).digest(); fy.create = (e, t) => new dy(e, t); class hy extends em {constructor (e, t, n, r) { super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Yg(this.buffer) }update (e) { ly.exists(this); const { view: t, buffer: n, blockLen: r } = this; const i = (e = Qg(e)).length; for (let o = 0; o < i;) { const a = Math.min(r - this.pos, i - o); if (a !== r)n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === r && (this.process(t, 0), this.pos = 0); else { const t = Yg(e); for (;r <= i - o; o += r) this.process(t, o) } } return this.length += e.length, this.roundClean(), this }digestInto (e) { ly.exists(this), ly.output(e, this), this.finished = !0; const { buffer: t, view: n, blockLen: r, isLE: i } = this; let { pos: o } = this; t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > r - o && (this.process(n, 0), o = 0); for (let e = o; e < r; e++)t[e] = 0; !(function (e, t, n, r) { if (typeof e.setBigUint64 === 'function') return e.setBigUint64(t, n, r); const i = BigInt(32); const o = BigInt(4294967295); const a = Number(n >> i & o); const s = Number(n & o); const c = r ? 4 : 0; const u = r ? 0 : 4; e.setUint32(t + c, a, r), e.setUint32(t + u, s, r) }(n, r - 8, BigInt(8 * this.length), i)), this.process(n, 0); const a = Yg(e); const s = this.outputLen; if (s % 4) throw new Error('_sha2: outputLen should be aligned to 32bit'); const c = s / 4; const u = this.get(); if (c > u.length) throw new Error('_sha2: outputLen bigger than state'); for (let e = 0; e < c; e++)a.setUint32(4 * e, u[e], i) }digest () { const { buffer: e, outputLen: t } = this; this.digestInto(e); const n = e.slice(0, t); return this.destroy(), n }_cloneInto (e) { e || (e = new this.constructor()), e.set(...this.get()); const { blockLen: t, buffer: n, length: r, finished: i, destroyed: o, pos: a } = this; return e.length = r, e.pos = a, e.finished = i, e.destroyed = o, r % t && e.buffer.set(n), e }} const py = (e, t, n) => e & t ^ ~e & n; const gy = (e, t, n) => e & t ^ e & n ^ t & n; const my = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]); const yy = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]); const by = new Uint32Array(64); class vy extends hy {constructor () { super(64, 32, 8, !1), this.A = 0 | yy[0], this.B = 0 | yy[1], this.C = 0 | yy[2], this.D = 0 | yy[3], this.E = 0 | yy[4], this.F = 0 | yy[5], this.G = 0 | yy[6], this.H = 0 | yy[7] }get () { const { A: e, B: t, C: n, D: r, E: i, F: o, G: a, H: s } = this; return [e, t, n, r, i, o, a, s] }set (e, t, n, r, i, o, a, s) { this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | o, this.G = 0 | a, this.H = 0 | s }process (e, t) { for (let n = 0; n < 16; n++, t += 4)by[n] = e.getUint32(t, !1); for (let e = 16; e < 64; e++) { const t = by[e - 15]; const n = by[e - 2]; const r = Zg(t, 7) ^ Zg(t, 18) ^ t >>> 3; const i = Zg(n, 17) ^ Zg(n, 19) ^ n >>> 10; by[e] = i + by[e - 7] + r + by[e - 16] | 0 } let { A: n, B: r, C: i, D: o, E: a, F: s, G: c, H: u } = this; for (let e = 0; e < 64; e++) { const t = u + (Zg(a, 6) ^ Zg(a, 11) ^ Zg(a, 25)) + py(a, s, c) + my[e] + by[e] | 0; const l = (Zg(n, 2) ^ Zg(n, 13) ^ Zg(n, 22)) + gy(n, r, i) | 0; u = c, c = s, s = a, a = o + t | 0, o = i, i = r, r = n, n = t + l | 0 }n = n + this.A | 0, r = r + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, s = s + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(n, r, i, o, a, s, c, u) }roundClean () { by.fill(0) }destroy () { this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0) }} class wy extends vy {constructor () { super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28 }} const _y = tm(() => new vy()); tm(() => new wy()); function Ey (e) { return $g.Buffer.from(_y(e)) } function ky (e, t) { const n = Sm.fromHex(function (e, t, n = !1) { if (Jm(e)) throw new TypeError('getSharedSecret: first arg must be private key'); if (!Jm(t)) throw new TypeError('getSharedSecret: second arg must be public key'); const r = Ym(t); return r.assertValidity(), r.multiply(Gm(e)).toRawBytes(n) }(t, e)); return $g.Buffer.from(Ey(n.toRawBytes(!0))) } function Sy (e, t) { return $g.Buffer.from(fy(_y, e, t)) } function Ay (e, t, n = $g.Buffer.alloc(0), r = $g.Buffer.alloc(0)) { const i = Sy(n, e); const o = Math.ceil(t / i.byteLength); if (o > 255) throw new Error('Output length exceeds maximum'); const a = [$g.Buffer.alloc(0)]; for (let e = 1; e <= o; e++) { const t = a[a.length - 1]; const n = $g.Buffer.from([e]); a.push(Sy(i, $g.Buffer.concat([t, r, n]))) } return $g.Buffer.concat(a.slice(1)).subarray(0, t) } function Oy (e, t = !0) { return $g.Buffer.from(function (e, t = !1) { return Sm.fromPrivateKey(e).toRawBytes(t) }(e, t)) } function xy (e, t, n, r) { const i = new oy(e, t); i.setAAD(n); const o = i.update(r); i.final && i.final(); const a = i.getAuthTag(); return $g.Buffer.concat([o, a]) } function Iy (e, t, n, r) { const i = new oy(e, t, !0); if (i.setAAD(n), r.length === 16) return i.setAuthTag(r), i.final(); if (r.length > 16) { const e = r.subarray(r.length - 16); const t = r.subarray(0, r.length - 16); i.setAuthTag(e); let n = i.update(t); const o = i.final(); return n = $g.Buffer.concat([n, o]), n } } function Ny () { let e; do { e = nm(32) } while (!Ty($g.Buffer.from(e))); return Xg(e) } function Ty (e) { return ey.isValidPrivateKey(e) } class Ry {protocolName = $g.Buffer.from('Noise_XK_secp256k1_ChaChaPoly_SHA256'); prologue = $g.Buffer.from('lightning'); ls; lpk; es; epk; rpk; repk; h; ck; rk; sk; sn; rn; sck; rck; tempK1; tempK2; tempK3; constructor ({ ls: e, es: t }) { this.ls = e, this.lpk = Oy(e), this.es = t, this.epk = Oy(t) }initiatorAct1 (e) { this.rpk = e, this._initialize(this.rpk), this.h = Ey($g.Buffer.concat([this.h, this.epk])); const t = Ay(ky(this.rpk, this.es), 64, this.ck); this.ck = t.subarray(0, 32), this.tempK1 = $g.Buffer.from(t.subarray(32)); const n = xy(this.tempK1, $g.Buffer.alloc(12), this.h, $g.Buffer.alloc(0)); this.h = Ey($g.Buffer.concat([this.h, n])); return $g.Buffer.concat([$g.Buffer.alloc(1), this.epk, n]) }initiatorAct2 (e) { if (e.length !== 50) throw new Error('ACT2_READ_FAILED'); const t = e.subarray(0, 1)[0]; const n = e.subarray(1, 34); const r = e.subarray(34); if (this.repk = n, t !== 0) throw new Error('ACT2_BAD_VERSION'); this.h = Ey($g.Buffer.concat([this.h, this.repk])); const i = Ay(ky(this.repk, this.es), 64, this.ck); this.ck = i.subarray(0, 32), this.tempK2 = i.subarray(32), Iy(this.tempK2, $g.Buffer.alloc(12), this.h, r), this.h = Ey($g.Buffer.concat([this.h, r])) }initiatorAct3 () { const e = xy(this.tempK2, $g.Buffer.from([0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]), this.h, this.lpk); this.h = Ey($g.Buffer.concat([this.h, e])); const t = Ay(ky(this.repk, this.ls), 64, this.ck); this.ck = t.subarray(0, 32), this.tempK3 = $g.Buffer.from(t.subarray(32)), this.rck = this.sck = this.ck; const n = xy(this.tempK3, $g.Buffer.alloc(12), this.h, $g.Buffer.alloc(0)); const r = Ay($g.Buffer.alloc(0), 64, this.ck); this.rk = r.subarray(32), this.sk = r.subarray(0, 32), this.sn = $g.Buffer.alloc(12), this.rn = $g.Buffer.alloc(12); return $g.Buffer.concat([$g.Buffer.alloc(1), e, n]) }receiveAct1 (e) { if (this._initialize(this.lpk), e.length !== 50) throw new Error('ACT1_READ_FAILED'); const t = e.subarray(0, 1)[0]; const n = e.subarray(1, 34); const r = e.subarray(34); if (this.repk = n, t !== 0) throw new Error('ACT1_BAD_VERSION'); this.h = Ey($g.Buffer.concat([this.h, n])); const i = Ay(ky(n, this.ls), 64, this.ck); this.ck = i.subarray(0, 32), this.tempK1 = i.subarray(32), Iy(this.tempK1, $g.Buffer.alloc(12), this.h, r), this.h = Ey($g.Buffer.concat([this.h, r])) }recieveAct2 () { this.h = Ey($g.Buffer.concat([this.h, this.epk])); const e = Ay(ky(this.repk, this.es), 64, this.ck); this.ck = e.subarray(0, 32), this.tempK2 = $g.Buffer.from(e.subarray(32)); const t = xy(this.tempK2, $g.Buffer.alloc(12), this.h, $g.Buffer.alloc(0)); this.h = Ey($g.Buffer.concat([this.h, t])); return $g.Buffer.concat([$g.Buffer.alloc(1), this.epk, t]) }receiveAct3 (e) { if (e.length !== 66) throw new Error('ACT3_READ_FAILED'); const t = e.subarray(0, 1)[0]; const n = e.subarray(1, 50); const r = e.subarray(50); if (t !== 0) throw new Error('ACT3_BAD_VERSION'); const i = Iy(this.tempK2, $g.Buffer.from('000000000100000000000000', 'hex'), this.h, n); this.rpk = i, this.h = Ey($g.Buffer.concat([this.h, n])); const o = Ay(ky(this.rpk, this.es), 64, this.ck); this.ck = o.subarray(0, 32), this.tempK3 = o.subarray(32), Iy(this.tempK3, $g.Buffer.alloc(12), this.h, r); const a = Ay($g.Buffer.alloc(0), 64, this.ck); this.rk = a.subarray(0, 32), this.sk = a.subarray(32), this.rn = $g.Buffer.alloc(12), this.sn = $g.Buffer.alloc(12) }encryptMessage (e) { const t = $g.Buffer.alloc(2); t.writeUInt16BE(e.length, 0); const n = xy(this.sk, this.sn, $g.Buffer.alloc(0), t); this._incrementSendingNonce() >= 1e3 && this._rotateSendingKeys(); const r = xy(this.sk, this.sn, $g.Buffer.alloc(0), e); return this._incrementSendingNonce() >= 1e3 && this._rotateSendingKeys(), $g.Buffer.concat([n, r]) }decryptLength (e) { const t = Iy(this.rk, this.rn, $g.Buffer.alloc(0), e); return this._incrementRecievingNonce() >= 1e3 && this._rotateRecievingKeys(), t.readUInt16BE(0) }decryptMessage (e) { const t = Iy(this.rk, this.rn, $g.Buffer.alloc(0), e); return this._incrementRecievingNonce() >= 1e3 && this._rotateRecievingKeys(), t }_initialize (e) { this.h = Ey($g.Buffer.from(this.protocolName)), this.ck = this.h, this.h = Ey($g.Buffer.concat([this.h, this.prologue])), this.h = Ey($g.Buffer.concat([this.h, e])) }_incrementSendingNonce () { const e = this.sn.readUInt16LE(4) + 1; return this.sn.writeUInt16LE(e, 4), e }_incrementRecievingNonce () { const e = this.rn.readUInt16LE(4) + 1; return this.rn.writeUInt16LE(e, 4), e }_rotateSendingKeys () { const e = Ay(this.sk, 64, this.sck); this.sk = e.subarray(32), this.sck = e.subarray(0, 32), this.sn = $g.Buffer.alloc(12) }_rotateRecievingKeys () { const e = Ay(this.rk, 64, this.rck); this.rk = e.subarray(32), this.rck = e.subarray(0, 32), this.rn = $g.Buffer.alloc(12) }} function Py (e) { const { remoteNodePublicKey: t, wsProxy: n, privateKey: r, ip: i, port: o, logger: a } = e; if (!t || !(function (e) { try { return Sm.fromHex(e), !0 } catch (e) { return !1 } }(t))) throw new Error(`${t} is not a valid public key`); if (!i || !i.match(/^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)(\.(?!$)|$)){4}$/) && !i.match(/^((?!-))(xn--)?[a-z0-9][a-z0-9-_]{0,61}[a-z0-9]{0,1}\.(xn--)?([a-z0-9-]{1,61}|[a-z0-9-]{1,30}\.[a-z]{2,})$/) && i !== 'localhost') throw new Error(`${i} is not a valid IP or DNS address`); if (!o || o < 1 || o > 65535) throw new Error(`${o} is not a valid port number`); if (n) { const e = `${n} is not a valid url`; try { const t = new URL(n); if (t.protocol !== 'wss:' && t.protocol !== 'ws:') throw new Error(e) } catch (t) { throw new Error(e) } } if (r && !Ty(r)) throw new Error(`${r} is not a valid private key`); if (a) { if (typeof a !== 'object') throw new Error('Logger must be of type object'); const e = ['info', 'warn', 'error']; Object.entries(a).forEach(([t, n]) => { if (!e.includes(t)) throw new Error(`Invalid logger level: ${t}`); if (typeof n !== 'function') throw new Error(`Logger for level: ${t} is not a function`) }) } } class Cy {static bigSizeBytes (e) { return e < BigInt(253) ? 1 : e < BigInt(65536) ? 3 : e < BigInt(4294967296) ? 5 : 9 }_buffer; _position; _lastReadBytes; constructor (e) { this._buffer = e, this._position = 0, this._lastReadBytes = 0 } get position () { return this._position } set position (e) { this._position = e } get eof () { return this._position === this._buffer.length } get buffer () { return this._buffer } get lastReadBytes () { return this._lastReadBytes }readUInt8 () { return this._readStandard(this.readUInt8.name, 1) }readUInt16LE () { return this._readStandard(this.readUInt16LE.name, 2) }readUInt16BE () { return this._readStandard(this.readUInt16BE.name, 2) }readUInt32LE () { return this._readStandard(this.readUInt32LE.name, 4) }readUInt32BE () { return this._readStandard(this.readUInt32BE.name, 4) }readUInt64BE () { return BigInt('0x' + this.readBytes(8).toString('hex')) }readUInt64LE () { return BigInt('0x' + this.readBytes(8).reverse().toString('hex')) }readVarUint () { const e = this.readUInt8(); if (e < 253) return this._lastReadBytes = 1, BigInt(e); switch (e) { case 253:return this._lastReadBytes = 3, BigInt(this.readUInt16LE()); case 254:return this._lastReadBytes = 5, BigInt(this.readUInt32LE()); case 255:return this._lastReadBytes = 9, this.readUInt64LE() } }readBigSize () { const e = this.readUInt8(); if (e < 253) return this._lastReadBytes = 1, BigInt(e); switch (e) { case 253:{ this._lastReadBytes = 3; const e = this.readUInt16BE(); if (e < 253) throw new Error('decoded varint is not canonical'); return BigInt(e) } case 254:{ this._lastReadBytes = 5; const e = this.readUInt32BE(); if (e < 65536) throw new Error('decoded varint is not canonical'); return BigInt(e) } case 255:{ this._lastReadBytes = 9; const e = this.readUInt64BE(); if (e < BigInt(4294967296)) throw new Error('decoded varint is not canonical'); return e } default:throw new Error(`Unrecognised size: ${e} when trying to read BigSize`) } }readBytes (e) { if (e === 0) return this._lastReadBytes = 0, $g.Buffer.alloc(0); if (typeof e === 'number' && e > 0) { if (this._position + e > this._buffer.length) throw new RangeError('Index out of range'); const t = this._buffer.subarray(this._position, this._position + e); const n = $g.Buffer.alloc(t.length, t); return this._position += e, this._lastReadBytes = e, n } { if (this._position === this._buffer.length) return this._lastReadBytes = 0, $g.Buffer.alloc(0); const e = this._buffer.subarray(this._position); const t = $g.Buffer.alloc(e.length, e); return this._position = this._buffer.length, this._lastReadBytes = t.length, t } }peakBytes (e) { if (e === 0) return $g.Buffer.alloc(0); if (typeof e === 'number' && e > 0) { if (this._position + e > this._buffer.length) throw new RangeError('Index out of range'); const t = this._buffer.subarray(this._position, this._position + e); return $g.Buffer.alloc(t.length, t) } { if (this._position === this._buffer.length) throw new RangeError('Index out of range'); const e = this._buffer.subarray(this._position); return $g.Buffer.alloc(e.length, e) } }readTUInt16 () { const e = Math.min(2, this._buffer.length - this._position); if (e === 0) return 0; const t = this._buffer.readUIntBE(this._position, e); return this._assertMinimalTUInt(BigInt(t), e), this._position += e, t }readTUInt32 () { const e = Math.min(4, this._buffer.length - this._position); if (e === 0) return 0; const t = this._buffer.readUIntBE(this._position, e); return this._assertMinimalTUInt(BigInt(t), e), this._position += e, t }readTUInt64 () { const e = Math.min(8, this._buffer.length - this._position); if (e === 0) return BigInt(0); const t = this._buffer.subarray(this._position, this._position + e).toString('hex') || '0'; const n = BigInt('0x' + t); return this._assertMinimalTUInt(n, e), this._position += e, n }_readStandard (e, t) { if (this._position + t > this._buffer.length) throw new RangeError('Index out of range'); const n = this._buffer[e](this._position); return this._position += t, this._lastReadBytes = t, n }_assertMinimalTUInt (e, t) { for (let n = 0; n < 9; n++) if (e < BigInt('0x1' + ''.padStart(2 * n, '0')) && t !== n) throw new Error('TUInt not minimal') }} class By {_position; _fixed; _buffer; constructor (e) { this._position = 0, this._fixed = !!e, this._buffer = e || $g.Buffer.alloc(0) } get size () { return this._position }toBuffer () { return this._fixed ? this._buffer : this._buffer.subarray(0, this._position) }writeUInt8 (e) { this._writeStandard(this.writeUInt8.name, e, 1) }writeUInt16LE (e) { this._writeStandard(this.writeUInt16LE.name, e, 2) }writeUInt16BE (e) { this._writeStandard(this.writeUInt16BE.name, e, 2) }writeUInt32LE (e) { this._writeStandard(this.writeUInt32LE.name, e, 4) }writeUInt32BE (e) { this._writeStandard(this.writeUInt32BE.name, e, 4) }writeUInt64LE (e) { const t = BigInt(e); if (t < 0 || t >= BigInt(2) ** BigInt(64)) throw new RangeError(`The value of "value" is out of range. It must be >= 0 and <= 18446744073709551615. Received ${e.toString()}`); const n = $g.Buffer.from(t.toString(16).padStart(16, '0'), 'hex'); this.writeBytes(n.reverse()) }writeUInt64BE (e) { const t = BigInt(e); if (t < 0 || t >= BigInt(2) ** BigInt(64)) throw new RangeError(`The value of "value" is out of range. It must be >= 0 and <= 18446744073709551615. Received ${e.toString()}`); const n = $g.Buffer.from(t.toString(16).padStart(16, '0'), 'hex'); this.writeBytes(n) }writeBytes (e) { e && e.length && (this._expand(e.length), e.copy(this._buffer, this._position), this._position += e.length) }writeVarInt (e) { const t = BigInt(e); t < BigInt(253) ? this.writeUInt8(Number(t)) : t < BigInt(65536) ? (this.writeUInt8(253), this.writeUInt16LE(Number(t))) : t < BigInt(4294967296) ? (this.writeUInt8(254), this.writeUInt32LE(Number(t))) : (this.writeUInt8(255), this.writeUInt64LE(t)) }writeBigSize (e) { const t = BigInt(e); t < BigInt(253) ? this.writeUInt8(Number(t)) : t < BigInt(65536) ? (this.writeUInt8(253), this.writeUInt16BE(Number(t))) : t < BigInt(4294967296) ? (this.writeUInt8(254), this.writeUInt32BE(Number(t))) : (this.writeUInt8(255), this.writeUInt64BE(t)) }writeTUInt16 (e) { if (e === 0) return; const t = e > 255 ? 2 : 1; this._expand(t), this._buffer.writeUIntBE(e, this._position, t), this._position += t }writeTUInt32 (e) { if (e === 0) return; const t = e > 16777215 ? 4 : e > 65535 ? 3 : e > 255 ? 2 : 1; this._expand(t), this._buffer.writeUIntBE(e, this._position, t), this._position += t }writeTUInt64 (e) { if (e === BigInt(0)) return; let t = e.toString(16); t.length % 2 == 1 && (t = '0' + t); const n = $g.Buffer.from(t, 'hex'); this.writeBytes(n) }_expand (e) { const t = this._position + e; if (this._fixed && t > this._buffer.length) throw new RangeError('Out of range'); if (this._buffer.length < t) { const e = 1 << Math.ceil(Math.log2(t)); const n = $g.Buffer.alloc(e); this._buffer.copy(n), this._buffer = n } }_writeStandard (e, t, n) { this._expand(n), this._buffer[e](t, this._position), this._position += n }} function Ly (e) { const t = (function (e) { let t = 0; for (;e > BigInt(0);)t += 1, e /= BigInt(256); return t }(e)); return $g.Buffer.from(e.toString(16).padStart(2 * t, '0'), 'hex') } class jy {static fromNumber (e) { return new jy(BigInt(e)) } static fromBuffer (e) { return e.length === 0 ? new jy() : new jy(BigInt('0x' + e.toString('hex'))) }value; constructor (e) { this.value = e || BigInt(0) }isSet (e) { return (this.value & BigInt(1) << BigInt(e)) > BigInt(0) }set (e) { this.value |= BigInt(1) << BigInt(e) }unset (e) { this.value &= ~(this.value & BigInt(1) << BigInt(e)) }toggle (e) { this.value ^= BigInt(1) << BigInt(e) }flags () { const e = []; let t = 0; let n = 1n; for (;n < this.value;) this.value & n && e.push(t), t += 1, n <<= 1n; return e }msb () { let e = this.value; let t = 0; for (;e > 1;)e >>= 1n, t += 1; return t }and (e) { return new jy(this.value & e.value) }or (e) { return new jy(this.value | e.value) }xor (e) { return new jy(this.value ^ e.value) }toBigInt () { return this.value }toNumber () { return Number(this.value) }toBuffer () { return this.value === BigInt(0) ? $g.Buffer.alloc(0) : Ly(this.value) }} let Dy, Uy, My; !(function (e) { e[e.Init = 16] = 'Init', e[e.Error = 17] = 'Error', e[e.Ping = 18] = 'Ping', e[e.Pong = 19] = 'Pong', e[e.OpenChannel = 32] = 'OpenChannel', e[e.AcceptChannel = 33] = 'AcceptChannel', e[e.FundingCreated = 34] = 'FundingCreated', e[e.FundingSigned = 35] = 'FundingSigned', e[e.FundingLocked = 36] = 'FundingLocked', e[e.Shutdown = 38] = 'Shutdown', e[e.ClosingSigned = 39] = 'ClosingSigned', e[e.ChannelAnnouncement = 256] = 'ChannelAnnouncement', e[e.NodeAnnouncement = 257] = 'NodeAnnouncement', e[e.ChannelUpdate = 258] = 'ChannelUpdate', e[e.AnnouncementSignatures = 259] = 'AnnouncementSignatures', e[e.QueryShortChannelIds = 261] = 'QueryShortChannelIds', e[e.ReplyShortChannelIdsEnd = 262] = 'ReplyShortChannelIdsEnd', e[e.QueryChannelRange = 263] = 'QueryChannelRange', e[e.ReplyChannelRange = 264] = 'ReplyChannelRange', e[e.GossipTimestampFilter = 265] = 'GossipTimestampFilter', e[e.CommandoRequest = 19535] = 'CommandoRequest', e[e.CommandoResponseContinues = 22859] = 'CommandoResponseContinues', e[e.CommandoResponse = 22861] = 'CommandoResponse' }(Dy || (Dy = {}))), (function (e) { e[e.INITIATOR_INITIATING = 0] = 'INITIATOR_INITIATING', e[e.AWAITING_INITIATOR = 1] = 'AWAITING_INITIATOR', e[e.AWAITING_RESPONDER_REPLY = 2] = 'AWAITING_RESPONDER_REPLY', e[e.AWAITING_INITIATOR_REPLY = 3] = 'AWAITING_INITIATOR_REPLY', e[e.READY = 100] = 'READY' }(Uy || (Uy = {}))), (function (e) { e[e.READY_FOR_LEN = 2] = 'READY_FOR_LEN', e[e.READY_FOR_BODY = 3] = 'READY_FOR_BODY', e[e.BLOCKED = 4] = 'BLOCKED' }(My || (My = {}))); class zy {static deserialize (e) { const t = new zy(); const n = new Cy(e); n.readUInt16BE(); const r = n.readUInt16BE(); const i = jy.fromBuffer(n.readBytes(r)); const o = n.readUInt16BE(); const a = jy.fromBuffer(n.readBytes(o)); return t.features = (new jy()).or(i).or(a), (function (e, t) { let n = BigInt(-1); for (;!e.eof;) try { const r = e.readBigSize(); const i = e.readBigSize(); const o = e.readBytes(Number(i)); const a = new Cy(o); if (r <= n) throw new Error('Invalid TLV stream'); const s = r % BigInt(2) === BigInt(0); const c = t(r, a); if (!c && s) throw new Error('Unknown even type'); if (c && !a.eof) throw new Error('Non-canonical length'); n = r } catch (e) {} }(n, (e, n) => { if (e === BigInt(1)) { for (;!n.eof;) { const e = n.readBytes(32); t.chainHashes.push(e) } return !0 } return !1 })), t }type = Dy.Init; features = new jy(); chainHashes = []; serialize () { const e = new By(); e.writeUInt16BE(this.type); e.writeUInt16BE(0); const t = $g.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]); const n = t.length; return e.writeUInt16BE(n), e.writeBytes(t), this.chainHashes.length && (e.writeBigSize(1), e.writeBigSize(32 * this.chainHashes.length), e.writeBytes($g.Buffer.concat(this.chainHashes))), e.toBuffer() }} class Fy {static deserialize (e) { const t = new Cy(e); t.readUInt16BE(); const n = new Fy(); n.numPongBytes = t.readUInt16BE(); const r = t.readUInt16BE(); return n.ignored = t.readBytes(r), n }type = Dy.Ping; numPongBytes = 1; ignored = $g.Buffer.alloc(0); serialize () { const e = 6 + this.ignored.length; const t = new By($g.Buffer.alloc(e)); return t.writeUInt16BE(this.type), t.writeUInt16BE(this.numPongBytes), t.writeUInt16BE(this.ignored.length), t.writeBytes(this.ignored), t.toBuffer() } get triggersReply () { return this.numPongBytes < 65532 }} class Hy {static deserialize (e) { const t = new Hy(); const n = new Cy(e); n.readUInt16BE(); const r = n.readUInt16BE(); return t.ignored = n.readBytes(r), t }type = Dy.Pong; ignored; constructor (e = 0) { this.ignored = $g.Buffer.alloc(e) }serialize () { const e = +this.ignored.length + 4; const t = new By($g.Buffer.alloc(e)); return t.writeUInt16BE(this.type), t.writeUInt16BE(this.ignored.length), t.writeBytes(this.ignored), t.toBuffer() }} class qy {static deserialize (e) { const t = new qy(); const n = new Cy(e); n.readUInt16BE(), t.id = n.readBytes(8).toString('hex'); const r = n.readBytes(e.byteLength - 26).toString(); try { t.response = JSON.parse(r) } catch (e) { t.response = { jsonrpc: '2.0', id: null, error: { code: 1, message: 'Could not parse json response' } } } return t }type = Dy.CommandoResponse; id; response} const Ky = class {noise; remoteNodePublicKey; publicKey; privateKey; wsUrl; socket; tcpSocket; connected$; connectionStatus$; connecting; decryptedMsgs$; commandoMsgs$; Buffer; _ls; _es; _handshakeState; _readState; _decryptedMsgs$; _commandoMsgs$; _partialCommandoMsgs; _attemptedReconnects; _logger; _attemptReconnect; _messageBuffer; _processingBuffer; _l; constructor (e) { Py(e); const { remoteNodePublicKey: t, wsProxy: n, wsProtocol: r = 'wss:', privateKey: i, ip: o, port: a = 9735, logger: s, tcpSocket: c } = e; this._ls = $g.Buffer.from(i || Ny(), 'hex'), this._es = $g.Buffer.from(Ny(), 'hex'), this.noise = new Ry({ ls: this._ls, es: this._es }), this.remoteNodePublicKey = t, this.publicKey = this.noise.lpk.toString('hex'), this.privateKey = this._ls.toString('hex'), this.wsUrl = n ? `${n}/${o}:${a}` : `${r}//${o}:${a}`, this.connectionStatus$ = new Mg('disconnected'), this.connected$ = new Mg(!1), this.connecting = !1, this.Buffer = $g.Buffer, this.tcpSocket = c, this._handshakeState = Uy.INITIATOR_INITIATING, this._decryptedMsgs$ = new Dg(), this.decryptedMsgs$ = this._decryptedMsgs$.asObservable(), this._commandoMsgs$ = new Dg(), this.commandoMsgs$ = this._commandoMsgs$.asObservable().pipe(Vg(({ response: e, id: t }) => ({ ...e, reqId: t }))), this._partialCommandoMsgs = {}, this._attemptedReconnects = 0, this._logger = s, this._readState = My.READY_FOR_LEN, this._processingBuffer = !1, this._l = null, this.decryptedMsgs$.subscribe(e => { this.handleDecryptedMessage(e) }) } async connect (e = !0) { const t = this.connectionStatus$.value; return t === 'connected' || (t === 'connecting' || (this._log('info', `Initiating connection to node ${this.remoteNodePublicKey}`), this._messageBuffer = new Cy($g.Buffer.from('')), this.connecting = !0, this.connectionStatus$.next('connecting'), this._attemptReconnect = e, this.socket = this.tcpSocket ? new ((await a.e(853).then(a.bind(a, 9853))).default)(this.wsUrl, this.tcpSocket) : void 0 === globalThis.WebSocket ? new ((await a.e(26).then(a.t.bind(a, 7026, 19))).default)(this.wsUrl) : new globalThis.WebSocket(this.wsUrl), this.socket.binaryType && (this.socket.binaryType = 'arraybuffer'), this.socket.onopen = async () => { this._log('info', 'WebSocket is connected at ' + (new Date()).toISOString()), this._log('info', 'Creating Act1 message'); const e = this.noise.initiatorAct1($g.Buffer.from(this.remoteNodePublicKey, 'hex')); this.socket && (this._log('info', 'Sending Act1 message'), this.socket.send(e), this._handshakeState = Uy.AWAITING_RESPONDER_REPLY) }, this.socket.onclose = async () => { this._log('error', 'WebSocket is closed at ' + (new Date()).toISOString()), this.connectionStatus$.next('disconnected'), this.connected$.next(!1), this._attemptReconnect && this._attemptedReconnects < 5 && (this._log('info', 'Waiting to reconnect'), this._log('info', `Attempted reconnects: ${this._attemptedReconnects}`), this.connectionStatus$.next('waiting_reconnect'), this.connecting = !0, await new Promise(e => setTimeout(e, 1e3 * (this._attemptedReconnects || 1))), this.connect(), this._attemptedReconnects += 1) }, this.socket.onerror = e => { this._log('error', `WebSocket error: ${JSON.stringify(e)}`) }, this.socket.onmessage = this.queueMessage.bind(this)), Fg(this.connectionStatus$.pipe(Wg(e => e === 'connected' || e === 'disconnected'), Vg(e => e === 'connected')))) }queueMessage (e) { const { data: t } = e; const n = $g.Buffer.from(t); const r = this._messageBuffer && !this._messageBuffer.eof && this._messageBuffer.readBytes(); this._messageBuffer = new Cy(r ? $g.Buffer.concat([r, n]) : n), this._processingBuffer || (this._processingBuffer = !0, this._processBuffer()) }disconnect () { this._log('info', 'Manually disconnecting from WebSocket'), this.noise = new Ry({ ls: this._ls, es: this._es }), this._attemptReconnect = !1, this.socket && this.socket.close() } async _processBuffer () { try { let e = !0; do { if (this._handshakeState !== Uy.READY) switch (this._handshakeState) { case Uy.INITIATOR_INITIATING:throw new Error('Received data before intialised'); case Uy.AWAITING_RESPONDER_REPLY:e = this._processResponderReply() } else switch (this._readState) { case My.READY_FOR_LEN:e = this._processPacketLength(); break; case My.READY_FOR_BODY:e = this._processPacketBody(); break; case My.BLOCKED:e = !1; break; default:throw new Error('Unknown read state') } } while (e) } catch (e) { this._log('error', `Noise state has rotated nonce: ${e}`), this.disconnect() } this._processingBuffer = !1 }_processResponderReply () { const e = this._messageBuffer.readBytes(50); if (e.byteLength !== 50) throw new Error('Invalid message received from remote node'); this._log('info', 'Validating message as part of Act2'), this.noise.initiatorAct2(e), this._log('info', 'Creating reply for Act3'); const t = this.noise.initiatorAct3(); return this.socket && (this._log('info', 'Sending reply for act3'), this.socket.send(t), this._handshakeState = Uy.READY), !0 }_processPacketLength () { try { const e = this._messageBuffer.readBytes(18); if (!e) return !1; const t = this.noise.decryptLength(e); return this._l = t, this._readState = My.READY_FOR_BODY, !0 } catch (e) { return !1 } }_processPacketBody () { if (!this._l) return !1; try { const e = this._messageBuffer.readBytes(this._l + 16); if (!e) return !1; const t = this.noise.decryptMessage(e); return this._l = null, this._decryptedMsgs$.next(t), this._readState = My.READY_FOR_LEN, !0 } catch (e) { return !1 } } async handleDecryptedMessage (e) { try { const t = new Cy(e); const n = t.readUInt16BE(); const [r] = Object.entries(Dy).find(([e, t]) => t === n) || []; const i = t.readBytes(8).toString('hex'); const o = t.readBytes(); if (this._log('info', `Received message type is: ${r || 'unknown'}`), n === Dy.CommandoResponseContinues) return this._log('info', 'Received a partial commando message, caching it to join with other parts'), void (this._partialCommandoMsgs[i] = this._partialCommandoMsgs[i] ? $g.Buffer.concat([this._partialCommandoMsgs[i], o.subarray(0, o.byteLength - 16)]) : e.subarray(0, e.length - 16)); n === Dy.CommandoResponse && this._partialCommandoMsgs[i] && (this._log('info', 'Received a final commando msg and we have a partial message to join it to. Joining now'), e = $g.Buffer.concat([this._partialCommandoMsgs[i], o]), delete this._partialCommandoMsgs[i]), this._log('info', 'Deserialising payload'); const a = (function (e) { const t = e.readUInt16BE(0); switch (t) { case Dy.Init:return zy.deserialize(e); case Dy.Ping:return Fy.deserialize(e); case Dy.Pong:return Hy.deserialize(e); case Dy.CommandoResponse:case Dy.CommandoResponseContinues:return qy.deserialize(e) } return { type: t } }(e)); switch (a.type) { case Dy.Init:{ this._log('info', 'Constructing Init message reply'); const e = this.noise.encryptMessage(a.serialize()); this.socket && (this._log('info', 'Sending Init message reply'), this.socket.send(e), this._log('info', 'Connected and ready to send messages!'), this.connectionStatus$.next('connected'), this.connected$.next(!0), this.connecting = !1, this._attemptedReconnects = 0); break } case Dy.Ping:{ this._log('info', 'Received a Ping message'), this._log('info', 'Creating a Pong message'); const e = new Hy(a.numPongBytes).serialize(); const t = this.noise.encryptMessage(e); this.socket && (this._log('info', 'Sending a Pong message'), this.socket.send(t)); break } case Dy.CommandoResponse:this._commandoMsgs$.next(a) } } catch (e) { this._log('error', `Error handling incoming message: ${e.message}`) } } async commando ({ method: e, params: t = [], rune: n, reqId: r }) { if (this._log('info', `Commando request method: ${e} params: ${JSON.stringify(t)}`), this.connectionStatus$.value === 'disconnected') { this._log('info', 'No socket connection, so creating one now'); if (!await this.connect()) throw { code: 2, message: 'Could not establish a connection to node' } } else this._log('info', 'Ensuring we have a connection before making request'), await Fg(this.connectionStatus$.pipe(Wg(e => e === 'connected'))); const i = new By(); if (!r) { const e = nm(8); r = Xg(e) }i.writeUInt16BE(Dy.CommandoRequest), i.writeBytes($g.Buffer.from(r, 'hex')); const o = `lnmessage:${e}#${r}`; i.writeBytes($g.Buffer.from(JSON.stringify({ id: o, rune: n, method: e, params: t }))), this._log('info', 'Creating message to send'); const a = this.noise.encryptMessage(i.toBuffer()); if (this.socket) { this._log('info', 'Sending commando message'), this.socket.send(a), this._log('info', `Message sent with id ${o} and awaiting response`); const { response: e } = await Fg(this._commandoMsgs$.pipe(Wg(e => e.id === r))); const { result: t } = e; const { error: n } = e; if (this._log('info', t ? `Successful response received for ID: ${e.id}` : `Error response received: ${n.message}`), n) throw n; return t } throw new Error('No socket initialised and connected') }_log (e, t) { this._logger && this._logger[e] && this._logger[e](`[${e.toUpperCase()} - ${(new Date()).toISOString()}]: ${t}`) }}; const Vy = { randomUUID: typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto) }; let Wy; const $y = new Uint8Array(16); function Gy () { if (!Wy && (Wy = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Wy)) throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'); return Wy($y) } const Yy = []; for (let e = 0; e < 256; ++e)Yy.push((e + 256).toString(16).slice(1)); function Zy (e, t = 0) { return (Yy[e[t + 0]] + Yy[e[t + 1]] + Yy[e[t + 2]] + Yy[e[t + 3]] + '-' + Yy[e[t + 4]] + Yy[e[t + 5]] + '-' + Yy[e[t + 6]] + Yy[e[t + 7]] + '-' + Yy[e[t + 8]] + Yy[e[t + 9]] + '-' + Yy[e[t + 10]] + Yy[e[t + 11]] + Yy[e[t + 12]] + Yy[e[t + 13]] + Yy[e[t + 14]] + Yy[e[t + 15]]).toLowerCase() } const Jy = function (e, t, n) { if (Vy.randomUUID && !t && !e) return Vy.randomUUID(); const r = (e = e || {}).random || (e.rng || Gy)(); if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) { n = n || 0; for (let e = 0; e < 16; ++e)t[n + e] = r[e]; return t } return Zy(r) }; const Xy = ['bkpr-listbalances', 'checkmessage', 'connect', 'decode', 'decodepay', 'disconnect', 'feerates', 'fundchannel', 'getinfo', 'getroute', 'invoice', 'keysend', 'listforwards', 'listfunds', 'listinvoices', 'listnodes', 'listoffers', 'listpays', 'listpeers', 'listsendpays', 'listtransactions', 'multifundchannel', 'offer', 'pay', 'sendpay', 'setchannel', 'signmessage']; const Qy = a(8269); const eb = a.n(Qy); const tb = class {account; config; constructor (e, t) { this.account = e, this.config = t }init () { return Promise.resolve() }unload () { return Promise.resolve() } get supportedMethods () { return ['getInfo', 'keysend', 'makeInvoice', 'sendPayment', 'signMessage', 'listInvoices'] }getInfo () { return this.request('/getinfo', void 0).then(e => ({ data: { alias: e.alias, pubkey: e.nodeId, color: e.color } })) } async connectPeer () { throw console.error(`${this.constructor.name} does not implement the getInvoices call`), new Error('Not yet supported with the currently used account.') } async getInvoices () { const e = (await this.request('/listinvoices')).map(e => ({ id: e.paymentHash, memo: e.description, settled: !0, settleDate: 1e3 * e.timestamp, totalAmount: e.amount / 1e3, type: 'received' })).sort((e, t) => t.settleDate - e.settleDate); return { data: { invoices: e } } } async getBalance () { const e = (await this.request('/usablebalances')).map(e => e.canSend || 0).reduce((e, t) => e + t, 0); return { data: { balance: Math.floor(e / 1e3) } } } async sendPayment (e) { const { paymentHash: t, paymentPreimage: n } = await this.request('/payinvoice', { invoice: e.paymentRequest, blocking: !0 }); const r = await this.request('/getsentinfo', { paymentHash: t }); const { status: i, recipientAmount: o } = r[r.length - 1]; return { data: { preimage: n, paymentHash: t, route: { total_amt: Math.floor(o / 1e3), total_fees: Math.floor(i.feesPaid / 1e3) } } } } async keysend (e) { throw new Error('not supported') } async checkPayment (e) { const t = await this.request('/getreceivedinfo', { paymentHash: e.paymentHash }); return { data: { paid: t && t.status.type === 'received' } } } async signMessage (e) { const { signature: t } = await this.request('/signmessage', { msg: eb().stringify(ng().parse(e.message)) }); return { data: { message: e.message, signature: t } } } async makeInvoice (e) { const t = await this.request('/createinvoice', { description: e.memo, amountMsat: 1e3 * +e.amount }); return { data: { paymentRequest: t.serialized, rHash: t.paymentHash } } } async request (e, t) { const n = new URL(this.config.url.startsWith('http') ? this.config.url : 'http://' + this.config.url); n.pathname = e; const r = new Headers(); r.append('Accept', 'application/json'); const i = eb().stringify(ng().parse(':' + this.config.password)); r.append('Authorization', 'Basic ' + i); const o = new FormData(); if (t) for (const e in t)o.append(e, t[e]); const a = await fetch(n.toString(), { method: 'POST', headers: r, body: o }); if (!a.ok) { let e; try { const t = await a.text(); try { if (e = JSON.parse(t), !e.error) throw new Error('error response: ' + t.slice(0, 200)) } catch (e) { throw new Error('got a non-JSON response: ' + t.slice(0, 200)) } } catch (e) { throw new Error(a.statusText) } throw console.error('eclair error', e.error), new Error(e.error) } return await a.json() }}; const nb = a(9669); const rb = a.n(nb); const ib = a(6026); const ob = a.n(ib); const ab = a(5327); const sb = a.n(ab); const cb = a(4097); const ub = a.n(cb); const lb = a(4867); async function db (e) { const t = (function (e) { const t = new Headers(e.headers); if (e.auth) { const n = e.auth.username || ''; const r = e.auth.password ? decodeURI(encodeURIComponent(e.auth.password)) : ''; t.set('Authorization', `Basic ${btoa(n + ':' + r)}`) } const n = e.method.toUpperCase(); const r = { headers: t, method: n }; n !== 'GET' && n !== 'HEAD' && (r.body = e.data, (0, lb.isFormData)(r.body) && (0, lb.isStandardBrowserEnv)() && t.delete('Content-Type')); e.mode && (r.mode = e.mode); e.cache && (r.cache = e.cache); e.integrity && (r.integrity = e.integrity); e.redirect && (r.redirect = e.redirect); e.referrer && (r.referrer = e.referrer); (0, lb.isUndefined)(e.withCredentials) || (r.credentials = e.withCredentials ? 'include' : 'omit'); const i = ub()(e.baseURL, e.url); const o = sb()(i, e.params, e.paramsSerializer); return new Request(o, r) }(e)); const n = [fb(t, e)]; e.timeout && e.timeout > 0 && n.push(new Promise(n => { setTimeout(() => { const r = e.timeoutErrorMessage ? e.timeoutErrorMessage : 'timeout of ' + e.timeout + 'ms exceeded'; n(hb(r, e, 'ECONNABORTED', t)) }, e.timeout) })); const r = await Promise.race(n); return new Promise((t, n) => { r instanceof Error ? n(r) : Object.prototype.toString.call(e.settle) === '[object Function]' ? e.settle(t, n, r) : ob()(t, n, r) }) } async function fb (e, t) { let n; try { n = await fetch(e) } catch (n) { return hb('Network Error', t, 'ERR_NETWORK', e) } const r = { ok: n.ok, status: n.status, statusText: n.statusText, headers: new Headers(n.headers), config: t, request: e }; if (n.status >= 200 && n.status !== 204) switch (t.responseType) { case 'arraybuffer':r.data = await n.arrayBuffer(); break; case 'blob':r.data = await n.blob(); break; case 'json':r.data = await n.json(); break; case 'formData':r.data = await n.formData(); break; default:r.data = await n.text() } return r } function hb (e, t, n, r, i) { return rb().AxiosError && typeof rb().AxiosError === 'function' ? new (rb().AxiosError)(e, rb().AxiosError[n], t, r, i) : (function (e, t, n, r, i) { e.config = t, n && (e.code = n); return e.request = r, e.response = i, e.isAxiosError = !0, e.toJSON = function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null } }, e }(new Error(e), t, n, r, i)) } const pb = a(8805); const gb = a.n(pb); const mb = class {account; config; constructor (e, t) { this.account = e, this.config = t }init () { return Promise.resolve() }unload () { return Promise.resolve() } get supportedMethods () { return ['getInfo', 'makeInvoice', 'sendPayment', 'signMessage'] } async getInfo () { const e = { query: '\n        query getinfo {\n          me {\n              id\n              username\n          }\n        }\n      ' }; return this.request(e).then(({ data: e, errors: t }) => { const n = t || e.me.errors; if (n && n.length) throw new Error(n[0].message || JSON.stringify(n)); return { data: { alias: e.me.username ? e.me.username.substr(0, 10) : e.me.id.substr(0, 8) } } }) } async connectPeer () { throw console.error(`${this.constructor.name} does not implement the getInvoices call`), new Error('Not yet supported with the currently used account.') } async getInvoices () { return console.error(`Not yet supported with the currently used account: ${this.constructor.name}`), { data: { invoices: [] } } } async getBalance () { const e = { query: '\n        query getinfo {\n          me {\n            defaultAccount {\n              defaultWalletId\n              wallets {\n                id\n                balance\n              }\n            }\n          }\n        }\n      ' }; return this.request(e).then(({ data: e, errors: t }) => { const n = t || e.me.errors; if (n && n.length) throw new Error(n[0].message || JSON.stringify(n)); const { defaultWalletId: r, wallets: i } = e.me.defaultAccount; const o = i.find(e => e.id === r); if (o) return { data: { balance: o.balance } }; throw new Error('Valid wallet not found') }) } async sendPayment (e) { const t = { query: '\n        mutation lnInvoicePaymentSend($input: LnInvoicePaymentInput!) {\n          lnInvoicePaymentSend(input:$input) {\n            status\n            errors {\n              message\n            }\n          }\n        }\n      ', variables: { input: { walletId: this.config.walletId, paymentRequest: e.paymentRequest, memo: 'Sent via Alby' } } }; const n = gb().decode(e.paymentRequest); const r = n.satoshis || 0; const i = n.tagsObject.payment_hash || ''; return this.request(t).then(({ data: e, errors: t }) => { const n = t || e.lnInvoicePaymentSend.errors; if (n && n.length) throw new Error(n[0].message || JSON.stringify(n)); switch (e.lnInvoicePaymentSend.status) { case 'ALREADY_PAID':throw new Error('Invoice was already paid.'); case 'FAILURE':throw new Error('Payment failed.'); case 'PENDING':return { data: { preimage: 'No preimage, payment still pending', paymentHash: i, route: { total_amt: r, total_fees: 0 } } }; default:return { data: { preimage: 'No preimage received', paymentHash: i, route: { total_amt: r, total_fees: 0 } } } } }) } async checkPayment (e) { const t = { query: '\n        query transactionsList($first: Int, $after: String) {\n          me {\n            defaultAccount {\n              defaultWalletId\n              wallets {\n                id\n                walletCurrency\n                transactions(first: $first, after: $after) {\n                  pageInfo {\n                      hasNextPage\n                  }\n                  edges {\n                    cursor\n                    node {\n                      status\n                      initiationVia {\n                        ... on InitiationViaLn {\n                            paymentHash\n                        }\n                      }\n                      settlementVia {\n                        ... on SettlementViaLn {\n                            paymentSecret\n                        }\n                        ... on SettlementViaIntraLedger {\n                          __typename\n                          counterPartyWalletId\n                          counterPartyUsername\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      ', variables: '' }; let n = null; let r = !0; for (;!0 === r;)t.variables = JSON.stringify({ first: 20, after: n }), r = await this.request(t).then(({ data: t, errors: r }) => { const i = r || t.me.errors; if (i && i.length) throw new Error(i[0].message || JSON.stringify(i)); const o = t.me.defaultAccount; const a = o.wallets.find(e => e.id === o.defaultWalletId); if (void 0 === a) throw new Error('Bad data received.'); if (a.walletCurrency !== 'BTC') throw new Error('Non-BTC wallets not implemented yet.'); const s = a.transactions.edges; const c = s.find(t => t.node.initiationVia.paymentHash === e.paymentHash); if (void 0 !== c) return { data: { paid: c.node.status === 'SUCCESS', preimage: c.node.settlementVia.__typename ? 'Payment executed internally' : c.node.settlementVia.paymentSecret || 'No preimage received' } }; if (!a.transactions.pageInfo.hasNextPage) throw new Error(`Transaction not found for payment hash: ${e.paymentHash}`); return n = s[s.length - 1].cursor, !0 }); return r } async keysend (e) { throw new Error('not supported') }signMessage (e) { return Promise.reject(new Error('Not yet supported with Galoy.')) } async makeInvoice (e) { const t = { query: '\n        mutation lnInvoiceCreate($input: LnInvoiceCreateInput!) {\n          lnInvoiceCreate(input: $input) {\n            invoice {\n              paymentRequest\n              paymentHash\n              paymentSecret\n              satoshis\n            }\n            errors {\n              message\n            }\n          }\n        }\n            ', variables: { input: { walletId: this.config.walletId, amount: e.amount, memo: e.memo } } }; return this.request(t).then(({ data: e, errors: t }) => { const n = t || e.lnInvoiceCreate.errors; if (n && n.length) throw new Error(n[0].message || JSON.stringify(n)); return { data: { paymentRequest: e.lnInvoiceCreate.invoice.paymentRequest, rHash: e.lnInvoiceCreate.invoice.paymentHash } } }) } async request (e) { const t = { method: 'POST', url: this.config.url, responseType: 'json', headers: { Accept: 'application/json', 'Access-Control-Allow-Origin': '*', 'Content-Type': 'application/json', Authorization: `Bearer ${this.config.accessToken}` }, adapter: db }; let n; t.data = e; try { n = (await rb()(t)).data } catch (e) { if (console.error(e), e instanceof Error) throw new Error(e.message) } return n }}; const yb = 1e8; const bb = e => Number(e) * yb; const vb = e => { const t = Number(e.amount) * e.rate; return (e => { const t = (e.locale || 'en').toLowerCase().replace('_', '-'); return new Intl.NumberFormat(t || 'en', { style: 'currency', currency: e.currency }).format(Number(e.amount)) })({ ...e, amount: t }) }; const wb = e => { const t = (e => { const t = (e.locale || 'en').toLowerCase().replace('_', '-'); return new Intl.NumberFormat(t || 'en').format(Number(e.amount)) })(e); return `${t} ${Ot.t('common:sats', { count: Number(e.amount) })}` }; const _b = a(6266); const Eb = a.n(_b); const kb = a(8764).Buffer; const Sb = new (Eb().ec)('secp256k1'); const Ab = class {sk; keyHex; constructor (e) { if (this.keyHex = e, !e) throw new Error('Invalid key'); this.sk = Sb.keyFromPrivate(kb.from(e, 'hex')) } get pk () { return this.sk.getPublic() } get pkHex () { return this.pk.encodeCompressed('hex') }sign (e) { if (!e) throw new Error('Invalid message'); return this.sk.sign(e, { canonical: !0 }) }verify (e, t) { try { return this.sk.verify(e, t) } catch (e) { return console.error(e), !1 } }}; const Ob = 'https://kollider.me/api'; const xb = { Accept: 'application/json', 'Access-Control-Allow-Origin': '*', 'Content-Type': 'application/json' }; const Ib = class {account; config; constructor (e, t) { this.account = e, this.config = t }init () { return Promise.resolve() }unload () { return Promise.resolve() } get supportedMethods () { return ['getInfo', 'makeInvoice', 'sendPayment', 'signMessage'] }getInfo () { return this.request('GET', '/api/v1/wallet', this.config.adminkey, void 0).then(e => ({ data: { alias: e.name } })) } async connectPeer () { throw console.error(`${this.constructor.name} does not implement the getInvoices call`), new Error('Not yet supported with the currently used account.') } async getInvoices () { return this.request('GET', '/api/v1/payments', this.config.adminkey, void 0).then(e => ({ data: { invoices: e.filter(e => e.amount > 0).map((e, t) => ({ id: `${e.checking_id}-${t}`, memo: e.memo, preimage: e.preimage, settled: !e.pending, settleDate: 1e3 * e.time, totalAmount: `${Math.floor(e.amount / 1e3)}`, type: 'received' })) } })) }getBalance () { return this.request('GET', '/api/v1/wallet', this.config.adminkey, void 0).then(e => ({ data: { balance: Math.floor(e.balance / 1e3) } })) }sendPayment (e) { const t = gb().decode(e.paymentRequest).satoshis || 0; return this.request('POST', '/api/v1/payments', this.config.adminkey, { bolt11: e.paymentRequest, out: !0 }).then(e => this.checkPayment({ paymentHash: e.payment_hash }).then(({ data: n }) => ({ data: { preimage: n?.preimage || '', paymentHash: e.payment_hash, route: { total_amt: t, total_fees: 0 } } }))) } async keysend (e) { throw new Error('not supported') } async checkPayment (e) { const t = await this.request('GET', `/api/v1/payments/${e.paymentHash}`, this.config.adminkey); return { data: { paid: t.isPaid, ...t } } }signMessage (e) { if (!this.config.url || !this.config.adminkey) return Promise.reject(new Error('Missing config')); if (!e.message) return Promise.reject(new Error('Invalid message')); let t; t = ol()(e.message).toString(rl()); let n = ol()(`lnbits://${this.config.adminkey}`).toString(rl()); const { settings: r } = NS.getState(); if (r.legacyLnurlAuth && (t = l.stringToUint8Array(e.message), n = ol()(`LBE-LNBITS-${this.config.url}-${this.config.adminkey}`).toString(rl())), !n) return Promise.reject(new Error('Could not create key')); const i = new Ab(n).sign(t).toDER('hex'); return i ? Promise.resolve({ data: { message: e.message, signature: i } }) : Promise.reject(new Error('Signing failed')) }makeInvoice (e) { return this.request('POST', '/api/v1/payments', this.config.adminkey, { amount: e.amount, memo: e.memo, out: !1 }).then(e => ({ data: { paymentRequest: e.payment_request, rHash: e.payment_hash } })) } async request (e, t, n, r) { let i = null; let o = ''; const a = new Headers(); a.append('Accept', 'application/json'), a.append('Content-Type', 'application/json'), a.append('X-Api-Key', n), e === 'POST' ? i = JSON.stringify(r) : void 0 !== r && (o = '?'); const s = await fetch(this.config.url + t + o, { method: e, headers: a, body: i }); if (!s.ok) { const e = await s.json(); throw console.error('errBody', e), new Error(e.detail) } return await s.json() }}; const Nb = a(4503); const Tb = a.n(Nb); const Rb = a(4433); const Pb = a.n(Rb); const Cb = a(7044); const Bb = a.n(Cb); const Lb = { addinvoice: 'lnd.lightning.AddInvoice', addholdinvoice: 'lnd.invoices.AddHoldInvoice', settleinvoice: 'lnd.invoices.SettleInvoice', channelbalance: 'lnd.lightning.ChannelBalance', connectpeer: 'lnd.lightning.ConnectPeer', decodepayreq: 'lnd.lightning.DecodePayReq', disconnectpeer: 'lnd.lightning.DisconnectPeer', estimatefee: 'lnd.lightning.EstimateFee', getchaninfo: 'lnd.lightning.GetChanInfo', getinfo: 'lnd.lightning.GetInfo', getnetworkinfo: 'lnd.lightning.GetNetworkInfo', getnodeinfo: 'lnd.lightning.GetNodeInfo', gettransactions: 'lnd.lightning.GetTransactions', listchannels: 'lnd.lightning.ListChannels', listinvoices: 'lnd.lightning.ListInvoices', listpayments: 'lnd.lightning.ListPayments', listpeers: 'lnd.lightning.ListPeers', lookupinvoice: 'lnd.lightning.LookupInvoice', openchannel: 'lnd.lightning.OpenChannelSync', queryroutes: 'lnd.lightning.QueryRoutes', routermc: 'lnd.router.QueryMissionControl', sendtoroute: 'lnd.lightning.SendToRouteSync', verifymessage: 'lnd.lightning.VerifyMessage', walletbalance: 'lnd.lightning.WalletBalance' }; const jb = e => { if (Array.isArray(e)) return e.map(jb); if (e && typeof e === 'object' && e.constructor === Object) { const t = {}; const n = Object.keys(e); const r = n.length; for (let i = 0; i < r; i += 1)t[Bb()(n[i])] = jb(e[n[i]]); return t } return e }; class Db {account; config; constructor (e, t) { this.account = e, this.config = t } get password () { return '' } set localKey (e) { this.config.localKey = e, this._save() } get localKey () { return this.config.localKey || '' } set remoteKey (e) { this.config.remoteKey = e, this._save() } get remoteKey () { return this.config.remoteKey || '' } get pairingPhrase () { return this.config.pairingPhrase } set serverHost (e) { this.config.serverHost = e, this._save() } get serverHost () { return this.config.serverHost || 'mailbox.terminal.lightning.today:443' } get isPaired () { return !0 } async clear () { this.config.localKey = '', this.config.remoteKey = '', this._save() } async _save () { const e = NS.getState().accounts; const t = await NS.getState().password(); return e[this.account.id].config = w(this.config, t), NS.setState({ accounts: e }), await NS.getState().saveToStorage(), !0 }} const Ub = class {account; config; lnc; constructor (e, t) { this.account = e, this.config = t, this.lnc = new (Tb())({ credentialStore: new Db(e, t), namespace: this.account.id }) } async init () { console.info('init LNC'); try { await this.lnc.connect() } catch (e) { console.error('Init LNC failed', e), await this.unload() } } async unload () { if (this.lnc) try { console.info('LNC disconnect'), await this.lnc.disconnect(), delete this.lnc } catch (e) { console.error('Unload LNC failed', e) } } get supportedMethods () { return Object.keys(Lb) } async requestMethod (e, t) { const n = Lb[e]; if (!n) throw new Error(`${e} is not supported`); return n.split('.').reduce((e, t) => e[t], this.lnc)(t).then(e => ({ data: jb(e) })) }getInfo () { return this.checkConnection(), this.lnc.lnd.lightning.GetInfo().then(e => ({ data: { alias: e.alias, pubkey: e.identityPubkey, color: e.color } })) }getBalance () { return this.checkConnection(), this.lnc.lnd.lightning.ChannelBalance().then(e => ({ data: { balance: e.balance } })) } async getInvoices () { this.checkConnection(); return { data: { invoices: (await this.lnc.lnd.lightning.ListInvoices({ reversed: !0 })).invoices.map((e, t) => ({ custom_records: e.htlcs[0] && e.htlcs[0].customRecords, id: `${e.paymentRequest}-${t}`, memo: e.memo, preimage: e.rPreimage, settled: e.settled, settleDate: 1e3 * parseInt(e.settleDate), totalAmount: e.value, type: 'received' })).reverse() } } } async connectPeer () { throw console.error(`${this.constructor.name} does not implement the getInvoices call`), new Error('Not yet supported with the currently used account.') } async checkPayment (e) { return this.checkConnection(), this.lnc.lnd.lightning.LookupInvoice({ r_hash_str: e.paymentHash }).then(e => ({ data: { paid: e.settled } })) }sendPayment (e) { return this.checkConnection(), this.lnc.lnd.lightning.SendPaymentSync({ payment_request: e.paymentRequest }).then(e => { if (e.paymentError) throw new Error(e.paymentError); return { data: { preimage: l.base64ToHex(e.paymentPreimage), paymentHash: l.base64ToHex(e.paymentHash), route: { total_amt: e.paymentRoute.totalAmt, total_fees: e.paymentRoute.totalFees } } } }) } async keysend (e) { this.checkConnection(); const t = e.pubkey; const n = rl().parse(t).toString(eb()); const r = Pb().random(32); const i = r.toString(eb()); const o = ol()(r).toString(eb()); const a = {}; for (const t in e.customRecords)a[parseInt(t)] = ng().parse(e.customRecords[t]).toString(eb()); return a[5482373484] = i, this.lnc.lnd.lightning.SendPaymentSync({ dest: n, amt: e.amount, payment_hash: o, dest_custom_records: a }).then(e => { if (e.paymentError) throw new Error(e.paymentError); return { data: { preimage: l.base64ToHex(e.paymentPreimage), paymentHash: l.base64ToHex(e.paymentHash), route: { total_amt: e.paymentRoute.totalAmt, total_fees: e.paymentRoute.totalFees } } } }) }signMessage (e) { return this.checkConnection(), this.lnc.lnd.lightning.SignMessage({ msg: eb().stringify(ng().parse(e.message)) }).then(t => ({ data: { message: e.message, signature: t.signature } })) }makeInvoice (e) { return this.checkConnection(), this.lnc.lnd.lightning.AddInvoice({ memo: e.memo, value: e.amount }).then(e => ({ data: { paymentRequest: e.paymentRequest, rHash: l.base64ToHex(e.rHash) } })) }checkConnection () { if (!this.lnc) throw new Error('Account failed to load'); if (!this.lnc.isConnected) throw new Error('Account is still loading') }}; const Mb = { getinfo: { path: '/v1/getinfo', httpMethod: 'GET' }, listchannels: { path: '/v1/channels', httpMethod: 'GET' }, listinvoices: { path: '/v1/invoices', httpMethod: 'GET' }, channelbalance: { path: '/v1/balance/channels', httpMethod: 'GET' }, walletbalance: { path: '/v1/balance/blockchain', httpMethod: 'GET' }, openchannel: { path: '/v1/channels', httpMethod: 'POST' }, connectpeer: { path: '/v1/peers', httpMethod: 'POST' }, disconnectpeer: { path: '/v1/peers/{{pub_key}}', httpMethod: 'DELETE' }, estimatefee: { path: '/v1/transactions/fee', httpMethod: 'GET' }, getchaninfo: { path: '/v1/graph/edge/{{chan_id}}', httpMethod: 'GET' }, getnetworkinfo: { path: '/v1/graph/info', httpMethod: 'GET' }, getnodeinfo: { path: '/v1/graph/node/{{pub_key}}', httpMethod: 'GET' }, gettransactions: { path: '/v1/transactions', httpMethod: 'GET' }, listpayments: { path: '/v1/payments', httpMethod: 'GET' }, listpeers: { path: '/v1/peers', httpMethod: 'GET' }, lookupinvoice: { path: '/v1/invoice/{{r_hash_str}}', httpMethod: 'GET' }, queryroutes: { path: '/v1/graph/routes/{{pub_key}}/{{amt}}', httpMethod: 'GET' }, verifymessage: { path: '/v1/verifymessage', httpMethod: 'POST' }, sendtoroute: { path: '/v1/channels/transactions/route', httpMethod: 'POST' }, decodepayreq: { path: '/v1/payreq/{{pay_req}}', httpMethod: 'GET' }, routermc: { path: '/v2/router/mc', httpMethod: 'GET' }, addinvoice: { path: '/v1/invoices', httpMethod: 'POST' }, addholdinvoice: { path: '/v2/invoices/hodl', httpMethod: 'POST' }, settleinvoice: { path: '/v2/invoices/settle', httpMethod: 'POST' } }; const zb = class {account; config; constructor (e, t) { this.account = e, this.config = t }init () { return Promise.resolve() }unload () { return Promise.resolve() } get supportedMethods () { return Object.keys(Mb) } async requestMethod (e, t) { const n = Mb[e]; if (!n) throw new Error(`${e} is not supported`); const r = n.httpMethod; let i = n.path; let o; o = t, i = i.replace(/{{(.*?)}}/g, e => { const t = e.split(/{{|}}/).filter(Boolean)[0]; const n = o[t]; if (void 0 === n) throw new Error(`Missing parameter ${t}`); return delete o[t], String(n) }); return { data: await this.request(r, i, t) } }getInfo () { return this.request('GET', '/v1/getinfo', void 0, {}).then(e => ({ data: { alias: e.alias, pubkey: e.identity_pubkey, color: e.color } })) }getBalance () { return this.getChannelsBalance() }connectPeer (e) { const { pubkey: t, host: n } = e; return this.request('POST', '/v1/peers', { addr: { pubkey: t, host: n }, perm: !0 }).then(e => ({ data: !0 })).catch(e => { if (e.message.match(/already connected/)) return { data: !0 }; throw new Error(e.message) }) }sendPayment (e) { return this.request('POST', '/v1/channels/transactions', { payment_request: e.paymentRequest }, {}).then(e => { if (e.payment_error) throw new Error(e.payment_error); return { data: { preimage: l.base64ToHex(e.payment_preimage), paymentHash: l.base64ToHex(e.payment_hash), route: e.payment_route } } }) } async keysend (e) { const t = e.pubkey; const n = rl().parse(t).toString(eb()); const r = Pb().random(32); const i = r.toString(eb()); const o = ol()(r).toString(eb()); const a = {}; for (const t in e.customRecords)a[t] = ng().parse(e.customRecords[t]).toString(eb()); return a[5482373484] = i, this.request('POST', '/v1/channels/transactions', { dest: n, amt: e.amount, payment_hash: o, dest_custom_records: a }, {}).then(e => { if (e.payment_error) throw new Error(e.payment_error); return { data: { preimage: l.base64ToHex(e.payment_preimage), paymentHash: l.base64ToHex(e.payment_hash), route: e.payment_route } } }) } async checkPayment (e) { return { data: { paid: (await this.request('GET', `/v1/invoice/${e.paymentHash}`)).settled } } }signMessage (e) { return this.request('POST', '/v1/signmessage', { msg: eb().stringify(ng().parse(e.message)) }).then(t => ({ data: { message: e.message, signature: t.signature } })) }makeInvoice (e) { return this.request('POST', '/v1/invoices', { memo: e.memo, value: e.amount }).then(e => ({ data: { paymentRequest: e.payment_request, rHash: l.base64ToHex(e.r_hash) } })) }getAddress () { return this.request('POST', '/v2/wallet/address/next', void 0, {}) }getBlockchainBalance = () => this.request('GET', '/v1/balance/blockchain', void 0, { unconfirmed_balance: '0', confirmed_balance: '0', total_balance: '0' }); getChannelsBalance = () => this.request('GET', '/v1/balance/channels', void 0, { pending_open_balance: '0', balance: '0' }).then(e => ({ data: { balance: e.balance, pending_open_balance: e.pending_open_balance } })); async getInvoices () { const e = (await this.request('GET', '/v1/invoices', { reversed: !0 })).invoices.map((e, t) => ({ custom_records: e.htlcs[0] && e.htlcs[0].custom_records, id: `${e.payment_request}-${t}`, memo: e.memo, preimage: e.r_preimage, settled: e.settled, settleDate: 1e3 * parseInt(e.settle_date), totalAmount: e.value, type: 'received' })).sort((e, t) => t.settleDate - e.settleDate); return { data: { invoices: e } } } async request (e, t, n, r) { const i = new URL(this.config.url); i.pathname = `${i.pathname.replace(/\/$/, '')}${t}`; let o = null; const a = new Headers(); a.append('Accept', 'application/json'), e === 'POST' ? (o = JSON.stringify(n), a.append('Content-Type', 'application/json')) : void 0 !== n && (i.search = new URLSearchParams(n).toString()), this.config.macaroon && a.append('Grpc-Metadata-macaroon', this.config.macaroon); const s = await fetch(i.toString(), { method: e, headers: a, body: o }); if (!s.ok) { let e; try { if (e = await s.json(), e.message && !e.error && (e.error = e.message, delete e.message), !e.error) throw new Error('Something went wrong') } catch (e) { throw new Error(s.statusText) } throw console.error(e), new Error(e.error) } let c = await s.json(); return r && (c = Object.assign(Object.assign({}, r), c)), c }}; const Fb = a(8010); const Hb = a.n(Fb); const qb = a(8764).Buffer; const Kb = { Accept: 'application/json', 'Access-Control-Allow-Origin': '*', 'Content-Type': 'application/json', 'X-User-Agent': 'alby-extension' }; class Vb {account; config; access_token; access_token_created; refresh_token; refresh_token_created; noRetry; constructor (e, t) { this.account = e, this.config = t } async init () { return this.authorize() }unload () { return Promise.resolve() } get supportedMethods () { return ['getInfo', 'keysend', 'makeInvoice', 'sendPayment', 'signMessage'] } async connectPeer () { throw console.error(`${this.constructor.name} does not implement the getInvoices call`), new Error('Not yet supported with the currently used account.') } async getInvoices () { const e = (await this.request('GET', '/getuserinvoices', void 0)).map((e, t) => ({ custom_records: e.custom_records, id: `${e.payment_request}-${t}`, memo: e.description, preimage: '', settled: e.ispaid, settleDate: 1e3 * e.timestamp, totalAmount: `${e.amt}`, type: 'received' })).sort((e, t) => t.settleDate - e.settleDate); return { data: { invoices: e } } } async getInfo () { const { alias: e } = await this.request('GET', '/getinfo', void 0); return { data: { alias: e } } } async getBalance () { const { BTC: e } = await this.request('GET', '/balance', void 0); return { data: { balance: e.AvailableBalance } } } async sendPayment (e) { const t = await this.request('POST', '/payinvoice', { invoice: e.paymentRequest }); if (t.error) throw new Error(t.message); if (t.payment_error) throw new Error(t.payment_error); if (typeof t.payment_hash === 'object' && t.payment_hash.type === 'Buffer' && (t.payment_hash = qb.from(t.payment_hash.data).toString('hex')), typeof t.payment_preimage === 'object' && t.payment_preimage.type === 'Buffer' && (t.payment_preimage = qb.from(t.payment_preimage.data).toString('hex')), !t.payment_route) { const n = gb().decode(e.paymentRequest).satoshis || 0; t.payment_route = { total_amt: n, total_fees: 0 } } return { data: { preimage: t.payment_preimage, paymentHash: t.payment_hash, route: t.payment_route } } } async keysend (e) { const t = await this.request('POST', '/keysend', { destination: e.pubkey, amount: e.amount, customRecords: e.customRecords }); if (t.error) throw new Error(t.message); if (t.payment_error) throw new Error(t.payment_error); return typeof t.payment_hash === 'object' && t.payment_hash.type === 'Buffer' && (t.payment_hash = qb.from(t.payment_hash.data).toString('hex')), typeof t.payment_preimage === 'object' && t.payment_preimage.type === 'Buffer' && (t.payment_preimage = qb.from(t.payment_preimage.data).toString('hex')), { data: { preimage: t.payment_preimage, paymentHash: t.payment_hash, route: t.payment_route } } } async checkPayment (e) { const { paid: t } = await this.request('GET', `/checkpayment/${e.paymentHash}`, void 0); return { data: { paid: t } } }signMessage (e) { if (!this.config.url || !this.config.login || !this.config.password) return Promise.reject(new Error('Missing config')); if (!e.message) return Promise.reject(new Error('Invalid message')); let t; t = ol()(e.message).toString(rl()); let n = ol()(`lndhub://${this.config.login}:${this.config.password}`).toString(rl()); const { settings: r } = NS.getState(); if (r.legacyLnurlAuth && (t = l.stringToUint8Array(e.message), n = ol()(`LBE-LNDHUB-${this.config.url}-${this.config.login}-${this.config.password}`).toString(rl())), !n) return Promise.reject(new Error('Could not create key')); const i = new Ab(n).sign(t).toDER('hex'); return i ? Promise.resolve({ data: { message: e.message, signature: i } }) : Promise.reject(new Error('Signing failed')) } async makeInvoice (e) { const t = await this.request('POST', '/addinvoice', { amt: e.amount, memo: e.memo }); return typeof t.r_hash === 'object' && t.r_hash.type === 'Buffer' && (t.r_hash = qb.from(t.r_hash.data).toString('hex')), { data: { paymentRequest: t.payment_request, rHash: t.r_hash } } } async authorize () { const e = `${this.config.url}/auth?type=auth`; try { const { data: t } = await rb().post(e, { login: this.config.login, password: this.config.password }, { headers: { ...Kb, 'X-TS': Math.floor(Date.now() / 1e3), 'X-VERIFY': this.generateHmacVerification(e) }, adapter: db }); if (t.error || t.errors) { const e = t.error || t.errors; throw new Error(e?.errors?.[0]?.message || e?.[0]?.message) } return this.refresh_token = t.refresh_token, this.access_token = t.access_token, this.refresh_token_created = +new Date(), this.access_token_created = +new Date(), t } catch (e) { throw new Error(`API error (${this.config.url})${e instanceof Error ? `: ${e.message}` : ''}`) } }generateHmacVerification (e) { const t = Hb()(e, 'alby-extension').toString(eb()); return encodeURIComponent(t) } async request (e, t, n) { this.access_token || await this.authorize(); const r = `${this.config.url}${t}`; const i = { method: e, url: r, responseType: 'json', headers: { ...Kb, Authorization: `Bearer ${this.access_token}`, 'X-TS': Math.floor(Date.now() / 1e3), 'X-VERIFY': this.generateHmacVerification(r) }, adapter: db }; let o; e === 'POST' ? i.data = n : void 0 !== n && (i.params = n); try { o = (await rb()(i)).data } catch (r) { if (console.error(r), rb().isAxiosError(r)) { const i = r.response; if (i?.status === 404) { const e = t.replace('/', ''); throw new Error(`${e} not supported by the connected account.`) } if (i?.status === 401) { try { await this.authorize() } catch (e) { if (console.error(e), e instanceof Error) throw new Error(e.message) } return this.request(e, t, n) } const o = `${i?.data.message}\n(${r.message})`; throw new Error(o) } } if (o?.error) { if (1 * o.code != 1 || this.noRetry) throw new Error(o.message); try { await this.authorize() } catch (e) { if (console.error(e), e instanceof Error) throw new Error(e.message) } return this.noRetry = !0, this.request(e, t, n) } return o }} function Wb (e) { return class extends e {_port; get port () { return this._port || this.connectNativeCompanion(), this._port }connectNativeCompanion () { this._port = i().runtime.connectNative('alby'), this._port.onMessage.addListener(e => { e.id === 'status' && e.status === 502 && e.header['X-Alby-Internal'] && (console.error('Error in the native companion. Shutting it down'), console.error(e), this.unload()) }), this._port.onDisconnect.addListener(e => { console.error('Native companion disconnected'), e.error && console.error(`Native companion error: ${e.error.message}`), this._port = null }) } async init () { this._port || this.connectNativeCompanion() }unload () { return new Promise((e, t) => { this._port ? (this._port.disconnect(), this._port = null, setTimeout(e, 5e3)) : e() }) }} } const $b = Wb(eg); const Gb = Wb(Ib); const Yb = Wb(zb); const Zb = Wb(Vb); const Jb = { lnd: zb, nativelnd: class extends Yb {request (e, t, n) { const r = new URL(this.config.url); r.pathname = t; let i = ''; const o = { Accept: 'application/json' }; return e === 'POST' ? (i = JSON.stringify(n), o['Content-Type'] = 'application/json') : void 0 !== n && (r.search = new URLSearchParams(n).toString()), this.config.macaroon && (o['Grpc-Metadata-macaroon'] = this.config.macaroon), new Promise((n, a) => { const s = e => { if (e.id === t) if (this.port.onMessage.removeListener(s), e.status > 299)a(new Error(e.body)); else { const t = JSON.parse(e.body); n(t) } }; this.port.onMessage.addListener(s), this.port.postMessage({ id: t, method: e, url: r.toString(), body: i, headers: o }) }) }}, lndhub: Vb, nativelndhub: class extends Zb {_nativeRequest (e) { return new Promise((t, n) => { const r = i => { i.id === e.id && (this.port.onMessage.removeListener(r), i.status > 299 ? n(new Error(i.body)) : t(i)) }; this.port.onMessage.addListener(r), this.port.postMessage(e) }) } async authorize () { const e = new URL(this.config.url); e.pathname = '/auth'; const t = JSON.stringify({ login: this.config.login, password: this.config.password }); return this._nativeRequest({ id: 'auth', method: 'POST', url: e.toString(), body: t, params: { type: 'auth' }, headers: { Accept: 'application/json', 'Access-Control-Allow-Origin': '*', 'Content-Type': 'application/json' } }).then(e => { const t = JSON.parse(e.body); if (t && t.error) throw new Error('API error: ' + t.message + ' (code ' + t.code + ')'); if (!t.access_token || !t.refresh_token) throw new Error('API unexpected response: ' + JSON.stringify(t)); return this.refresh_token = t.refresh_token, this.access_token = t.access_token, this.refresh_token_created = +new Date(), this.access_token_created = +new Date(), t }) } async request (e, t, n) { this.access_token || await this.authorize(); const r = { Accept: 'application/json', 'Access-Control-Allow-Origin': '*', 'Content-Type': 'application/json', Authorization: `Bearer ${this.access_token}` }; const i = new URL(this.config.url); let o, a; i.pathname = t, e === 'POST' ? o = JSON.stringify(n) : a = n; const s = { id: t, method: e, url: i.toString(), headers: r, body: o, params: a }; let c; try { const e = await this._nativeRequest(s); c = JSON.parse(e.body) } catch (e) { if (console.error(e), e instanceof Error) throw new Error(e.message) } if (c && c.error) { if (1 * c.code != 1 || this.noRetry) throw new Error(c.message); try { await this.authorize() } catch (e) { if (console.error(e), e instanceof Error) throw new Error(e.message) } return this.noRetry = !0, this.request(e, t, n) } return c }}, lnbits: Ib, lnc: Ub, nativelnbits: class extends Gb {_nativeRequest (e) { return new Promise((t, n) => { const r = i => { i.id === e.id && (this.port.onMessage.removeListener(r), i.status > 299 ? n(new Error(i.body)) : t(i)) }; this.port.onMessage.addListener(r), this.port.postMessage(e) }) } async request (e, t, n, r) { let i; const o = { Accept: 'application/json', 'Content-Type': 'application/json', 'X-Api-Key': n }; e === 'POST' && (i = JSON.stringify(r)); const a = new URL(this.config.url); a.pathname = t; const s = { id: t, method: e, url: a.toString(), headers: o, body: i }; let c; try { const e = await this._nativeRequest(s); c = JSON.parse(e.body) } catch (e) { if (console.error(e), e instanceof Error) throw new Error(e.message) } return c }}, galoy: mb, eclair: tb, citadel: eg, nativecitadel: class extends $b {_nativeRequest (e) { return new Promise((t, n) => { const r = i => { i.id === e.id && (this.port.onMessage.removeListener(r), i.status > 299 ? n(new Error(i.body)) : t(i)) }; this.port.onMessage.addListener(r), this.port.postMessage(e) }) } async request (e, t, n) { let r; let i = {}; t = this.config.url + (this.config.url.endsWith('/') ? '' : '/') + t, e !== 'GET' && (i = { 'Content-type': 'application/json' }), this.jwt && (i = { ...i, Authorization: `JWT ${this.jwt}` }), e === 'POST' && (r = JSON.stringify(n)); const o = await this._nativeRequest({ headers: i, url: t, method: e || 'GET', id: t + Math.floor(1e3 * Math.random() + 1).toString(), body: r }); if (o.status !== 200) throw new Error(o.body); const a = o.body; let s; try { s = JSON.parse(a) } catch { throw new Error(`Received invalid data: ${a}`) } if (typeof s === 'string') throw new Error(s); return s }}, commando: class {account; config; ln; constructor (e, t) { this.account = e, this.config = t, this.ln = new Ky({ remoteNodePublicKey: this.config.pubkey, wsProxy: this.config.wsProxy, ip: this.config.host, port: this.config.port || 9735, privateKey: this.config.privateKey }) } async init () { await this.ln.connect() } async unload () { await this.ln.disconnect() } get supportedMethods () { return Xy } async requestMethod (e, t) { if (!this.supportedMethods.includes(e)) throw new Error(`${e} is not supported`); return { data: await this.ln.commando({ method: e, params: t, rune: this.config.rune }) } } async connectPeer (e) { return this.ln.commando({ method: 'connect', params: { id: e.pubkey, host: e.host }, rune: this.config.rune }).then(e => ({ data: !0 })) } async getInvoices () { return this.ln.commando({ method: 'listinvoices', params: {}, rune: this.config.rune }).then(e => ({ data: { invoices: e.invoices.map((e, t) => ({ id: e.label, memo: e.description, settled: e.status === 'paid', preimage: e.payment_preimage, settleDate: 1e3 * e.paid_at, type: 'received', totalAmount: (e.msatoshi / 1e3).toString() })).filter(e => e.settled).sort((e, t) => t.settleDate - e.settleDate) } })) } async getInfo () { const e = await this.ln.commando({ method: 'getinfo', params: {}, rune: this.config.rune }); return { data: { alias: e.alias, pubkey: e.id, color: e.color } } } async getBalance () { const e = (await this.ln.commando({ method: 'listfunds', params: {}, rune: this.config.rune })).channels.reduce((e, t) => e + t.channel_sat, 0); return { data: { balance: e } } } async sendPayment (e) { return this.ln.commando({ method: 'pay', params: { bolt11: e.paymentRequest }, rune: this.config.rune }).then(e => { const t = e; return { data: { paymentHash: t.payment_hash, preimage: t.payment_preimage, route: { total_amt: Math.floor(t.msatoshi_sent / 1e3), total_fees: Math.floor((t.msatoshi_sent - t.msatoshi) / 1e3) } } } }) } async keysend (e) { const t = {}; for (const n in e.customRecords)t[n] = ng().parse(e.customRecords[n]).toString(rl()); const n = {}; for (const t in e.customRecords)n[t] = ng().parse(e.customRecords[t]).toString(rl()); return this.ln.commando({ method: 'keysend', params: { destination: e.pubkey, msatoshi: 1e3 * e.amount, extratlvs: n }, rune: this.config.rune }).then(e => { const t = e; return { data: { paymentHash: t.payment_hash, preimage: t.payment_preimage, route: { total_amt: Math.floor(t.msatoshi_sent / 1e3), total_fees: Math.floor((t.msatoshi_sent - t.msatoshi) / 1e3) } } } }) } async checkPayment (e) { return this.ln.commando({ method: 'listinvoices', params: { payment_hash: e.paymentHash }, rune: this.config.rune }).then(e => { const t = e; return { data: { paid: t.invoices[0]?.status === 'paid' } } }) }signMessage (e) { return this.ln.commando({ method: 'signmessage', params: { message: e.message }, rune: this.config.rune }).then(t => { const n = t; return { data: { message: e.message, signature: n.zbase } } }) } async makeInvoice (e) { const t = Jy(); const n = await this.ln.commando({ method: 'invoice', params: { amount_msat: 1e3 * e.amount, label: t, description: e.memo }, rune: this.config.rune }); return { data: { paymentRequest: n.bolt11, rHash: n.payment_hash } } }}, kollider: class {account; config; access_token; access_token_created; refresh_token; refresh_token_created; noRetry; accounts; currency; currentAccountId; constructor (e, t) { this.account = e, this.config = t, this.currency = t.currency, this.currentAccountId = null } async init () { await this.authorize(), await this.loadAccounts(), this.currentAccountId = await this.findAccountId(this.config.currency) }unload () { return Promise.resolve() } async connectPeer () { throw console.error(`${this.constructor.name} does not implement the connectPeer call`), new Error('Not yet supported with the currently used account.') } async getInvoices () { const e = (await this.request('GET', '/getuserinvoices', void 0)).filter(e => e.incoming).filter(e => e.account_id === this.currentAccountId).map((e, t) => ({ id: `${e.payment_hash}-${t}`, memo: e.reference, preimage: '', settled: e.settled, settleDate: e.settled_date, totalAmount: `${e.value}`, type: 'received' })).sort((e, t) => t.settleDate - e.settleDate); return { data: { invoices: e } } } async getInfo () { return { data: { alias: `Kollider (${this.currency})` } } } async getBalance () { await this.loadAccounts(); const e = await this.findAccount(this.currency); if (!e) throw new Error('Account not found'); let t = e.balance; return e.currency === 'BTC' && (t = Math.round(bb(e.balance)).toString()), { data: { balance: parseFloat(t), currency: e.currency } } } async sendPayment (e) { const t = await this.request('POST', '/payinvoice', { payment_request: e.paymentRequest, currency: this.config.currency }); if (t.error) throw new Error(t.error); const n = bb(t.amount?.value || 0).toString(); const r = bb(t.fees?.value || 0).toString(); const i = { total_amt: parseFloat(n), total_fees: parseFloat(r) }; return { data: { preimage: t.payment_preimage || '', paymentHash: t.payment_hash, route: i } } } async keysend (e) { throw new Error('Keysend is not supported with the currently used account.') } async checkPayment (e) { const t = await this.request('GET', '/checkpayment', { payment_hash: e.paymentHash }); return { data: { paid: !!t?.paid } } }signMessage (e) { if (!this.config.username || !this.config.password) return Promise.reject(new Error('Missing config')); if (!e.message) return Promise.reject(new Error('Invalid message')); const t = ol()(e.message).toString(rl()); const n = ol()(`kollider://${this.config.username}:${this.config.password}`).toString(rl()); if (!n) return Promise.reject(new Error('Could not create key')); const r = new Ab(n).sign(t).toDER('hex'); return r ? Promise.resolve({ data: { message: e.message, signature: r } }) : Promise.reject(new Error('Signing failed')) } async makeInvoice (e) { const t = (n = e.amount, Number(n) / yb); let n; const r = await this.request('GET', '/addinvoice', { amount: t, currency: 'BTC', target_account_currency: this.currency, account_id: this.currentAccountId, meta: e.memo }); if (r.error) throw new Error(r.error); return { data: { paymentRequest: r.payment_request, rHash: r.payment_hash } } } async authorize () { const { data: e } = await rb().post(`${Ob}/auth`, { username: this.config.username, password: this.config.password }, { headers: xb, adapter: db }); if (e.error || e.errors) { const t = e.error || e.errors; const n = t?.errors?.[0]?.message || t?.[0]?.message; throw console.error(n), new Error('Kollider API error: ' + n) } return this.refresh_token = e.refresh, this.access_token = e.token, this.refresh_token_created = +new Date(), this.access_token_created = +new Date(), e } async loadAccounts () { const e = await this.request('GET', '/balance', void 0); this.accounts = e.accounts } async findAccount (e) { const t = await this.findAccountId(e); return t && this.accounts ? this.accounts[t] : null } async findAccountId (e) { if (this.accounts || await this.loadAccounts(), !this.accounts) return null; const t = this.accounts; return Object.keys(this.accounts).find(n => t[n].currency === e) || null } async request (e, t, n) { this.access_token || await this.authorize(); const r = { method: e, url: `${Ob}${t}`, responseType: 'json', adapter: db, headers: { ...xb, Authorization: `${this.access_token}` } }; let i; e === 'POST' ? r.data = n : void 0 !== n && (r.params = n); try { i = (await rb()(r)).data } catch (r) { if (console.error(r), rb().isAxiosError(r)) { const i = r.response; if (i?.status === 404) { const e = t.replace('/', ''); throw new Error(`${e} not supported by the connected account.`) } if (i?.status === 401) { try { await this.authorize() } catch (e) { if (console.error(e), e instanceof Error) throw new Error(e.message) } return this.request(e, t, n) } const o = `${i?.data.error}\n(${r.message})`; throw new Error(o) } } return i }}, alby: class {account; config; _client; _authUser; constructor (e, t) { this.account = e, this.config = t } async init () { try { this._authUser = await this.authorize(), this._client = new Qp(this._authUser, this._getRequestOptions()) } catch (e) { console.error('Failed to initialize alby connector', e), this._authUser = void 0, this._client = void 0, await this.unload() } }getOAuthToken () { return this.config.oAuthToken }unload () { return Promise.resolve() } get supportedMethods () { return ['getInfo', 'keysend', 'makeInvoice', 'sendPayment'] } async connectPeer () { throw console.error(`${this.constructor.name} does not implement the connectPeer call`), new Error('Not yet supported with the currently used account.') } async getInvoices () { return { data: { invoices: (await this._request(e => e.incomingInvoices({}))).map((e, t) => ({ custom_records: e.custom_records, id: `${e.payment_request}-${t}`, memo: e.memo, preimage: '', settled: e.settled, settleDate: new Date(e.settled_at).getTime(), totalAmount: `${e.amount}`, type: 'received' })) } } } async getInfo () { try { return { data: { ...await this._request(e => e.accountInformation({})), alias: ' getalby.com' } } } catch (e) { throw console.error(e), e } } async getBalance () { const { balance: e } = await this._request(e => e.accountBalance({})); return { data: { balance: e } } } async sendPayment (e) { const t = await this._request(t => t.sendPayment({ invoice: e.paymentRequest })); return { data: { preimage: t.payment_preimage, paymentHash: t.payment_hash, route: { total_amt: t.amount, total_fees: t.fee } } } } async keysend (e) { const t = await this._request(t => t.keysend({ destination: e.pubkey, amount: e.amount, customRecords: e.customRecords })); return { data: { preimage: t.payment_preimage, paymentHash: t.payment_hash, route: { total_amt: t.amount, total_fees: t.fee } } } } async checkPayment (e) { let t = !1; try { const n = await this._request(t => t.getInvoice(e.paymentHash)); t = !!n?.settled } catch (e) { console.error(e) } return { data: { paid: t } } }signMessage (e) { throw new Error('SignMessage is not supported by Alby accounts. Generate a secret key to use LNURL auth.') } async makeInvoice (e) { const t = await this._request(t => t.createInvoice({ amount: parseInt(e.amount.toString()), description: e.memo })); return { data: { paymentRequest: t.payment_request, rHash: t.payment_hash } } } async authorize () { try { const e = 'dC3Xwf1FUR'; const t = 'Asz1OiSy8iXR1ZA9WZBV'; if (!e || !t) throw new Error('OAuth client credentials missing'); const n = i().identity.getRedirectURL(); const r = new Jp({ request_options: this._getRequestOptions(), client_id: e, client_secret: t, callback: n, user_agent: 'lightning-browser-extension:3.0.0', scopes: ['invoices:read', 'account:read', 'balance:read', 'invoices:create', 'invoices:read', 'payments:send', 'transactions:read'], token: this.config.oAuthToken }); if (this.config.oAuthToken) try { if (r.isAccessTokenExpired()) { const e = await r.refreshAccessToken(); await this._updateOAuthToken(e.token) } return r } catch (e) { console.error('Failed to request new auth token', e) } let o = r.generateAuthURL({ code_challenge_method: 'S256' }); 0, o += '&webln=false'; const a = await this.launchWebAuthFlow(o); const s = new URL(a).searchParams.get('code'); if (!s) throw new Error('Authentication failed: missing authResult'); const c = await r.requestAccessToken(s); return await this._updateOAuthToken(c.token), r } catch (e) { throw console.error(e), e } } async launchWebAuthFlow (e) { return await i().identity.launchWebAuthFlow({ interactive: !0, url: e }) } async _request (e) { if (!this._authUser || !this._client) throw new Error('Alby client was not initialized'); const t = this._authUser?.token; let n; try { n = await e(this._client) } catch (e) { throw console.error(e), e } finally { const e = this._authUser.token; e && e !== t && await this._updateOAuthToken(e) } return n }_getRequestOptions () { return { base_url: 'https://api.getalby.com' } } async _updateOAuthToken (e) { const t = e.access_token; const n = e.refresh_token; const r = e.expires_at; if (!(t && n && r)) throw console.error('Invalid token'), new Error('Invalid token'); if (this.config.oAuthToken = { access_token: t, refresh_token: n, expires_at: r }, this.account.id) { const e = NS.getState().accounts; const t = await NS.getState().password(); const n = _(e[this.account.id].config, t); n.oAuthToken = this.config.oAuthToken, e[this.account.id].config = w(n, t), NS.setState({ accounts: e }), await NS.getState().saveToStorage() } }} }; const Xb = Jb; const Qb = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : global; const ev = Object.keys; const tv = Array.isArray; function nv (e, t) { return typeof t !== 'object' || ev(t).forEach(function (n) { e[n] = t[n] }), e } typeof Promise === 'undefined' || Qb.Promise || (Qb.Promise = Promise); const rv = Object.getPrototypeOf; const iv = {}.hasOwnProperty; function ov (e, t) { return iv.call(e, t) } function av (e, t) { typeof t === 'function' && (t = t(rv(e))), (typeof Reflect === 'undefined' ? ev : Reflect.ownKeys)(t).forEach(n => { cv(e, n, t[n]) }) } const sv = Object.defineProperty; function cv (e, t, n, r) { sv(e, t, nv(n && ov(n, 'get') && typeof n.get === 'function' ? { get: n.get, set: n.set, configurable: !0 } : { value: n, configurable: !0, writable: !0 }, r)) } function uv (e) { return { from: function (t) { return e.prototype = Object.create(t.prototype), cv(e.prototype, 'constructor', e), { extend: av.bind(null, e.prototype) } } } } const lv = Object.getOwnPropertyDescriptor; function dv (e, t) { let n; return lv(e, t) || (n = rv(e)) && dv(n, t) } const fv = [].slice; function hv (e, t, n) { return fv.call(e, t, n) } function pv (e, t) { return t(e) } function gv (e) { if (!e) throw new Error('Assertion Failed') } function mv (e) { Qb.setImmediate ? setImmediate(e) : setTimeout(e, 0) } function yv (e, t) { return e.reduce((e, n, r) => { const i = t(n, r); return i && (e[i[0]] = i[1]), e }, {}) } function bv (e, t) { if (ov(e, t)) return e[t]; if (!t) return e; if (typeof t !== 'string') { for (var n = [], r = 0, i = t.length; r < i; ++r) { const o = bv(e, t[r]); n.push(o) } return n } const a = t.indexOf('.'); if (a !== -1) { const s = e[t.substr(0, a)]; return void 0 === s ? void 0 : bv(s, t.substr(a + 1)) } } function vv (e, t, n) { if (e && void 0 !== t && (!('isFrozen' in Object) || !Object.isFrozen(e))) if (typeof t !== 'string' && 'length' in t) { gv(typeof n !== 'string' && 'length' in n); for (let r = 0, i = t.length; r < i; ++r)vv(e, t[r], n[r]) } else { const o = t.indexOf('.'); if (o !== -1) { const a = t.substr(0, o); const s = t.substr(o + 1); if (s === '') void 0 === n ? tv(e) && !isNaN(parseInt(a)) ? e.splice(a, 1) : delete e[a] : e[a] = n; else { let c = e[a]; c && ov(e, a) || (c = e[a] = {}), vv(c, s, n) } } else void 0 === n ? tv(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = n } } function wv (e) { const t = {}; for (const n in e)ov(e, n) && (t[n] = e[n]); return t } const _v = [].concat; function Ev (e) { return _v.apply([], e) } const kv = 'Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey'.split(',').concat(Ev([8, 16, 32, 64].map(e => ['Int', 'Uint', 'Float'].map(t => t + e + 'Array')))).filter(e => Qb[e]); const Sv = kv.map(e => Qb[e]); yv(kv, e => [e, !0]); let Av = null; function Ov (e) { Av = typeof WeakMap !== 'undefined' && new WeakMap(); const t = xv(e); return Av = null, t } function xv (e) { if (!e || typeof e !== 'object') return e; let t = Av && Av.get(e); if (t) return t; if (tv(e)) { t = [], Av && Av.set(e, t); for (let n = 0, r = e.length; n < r; ++n)t.push(xv(e[n])) } else if (Sv.indexOf(e.constructor) >= 0)t = e; else { const n = rv(e); for (const i in t = n === Object.prototype ? {} : Object.create(n), Av && Av.set(e, t), e)ov(e, i) && (t[i] = xv(e[i])) } return t } const { toString: Iv } = {}; function Nv (e) { return Iv.call(e).slice(8, -1) } const Tv = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator'; const Rv = typeof Tv === 'symbol' ? function (e) { let t; return e != null && (t = e[Tv]) && t.apply(e) } : function () { return null }; const Pv = {}; function Cv (e) { let t, n, r, i; if (arguments.length === 1) { if (tv(e)) return e.slice(); if (this === Pv && typeof e === 'string') return [e]; if (i = Rv(e)) { for (n = []; !(r = i.next()).done;)n.push(r.value); return n } if (e == null) return [e]; if (typeof (t = e.length) === 'number') { for (n = new Array(t); t--;)n[t] = e[t]; return n } return [e] } for (t = arguments.length, n = new Array(t); t--;)n[t] = arguments[t]; return n } const Bv = typeof Symbol !== 'undefined' ? e => e[Symbol.toStringTag] === 'AsyncFunction' : () => !1; let Lv = typeof location !== 'undefined' && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href); function jv (e, t) { Lv = e, Dv = t } var Dv = () => !0; const Uv = !new Error('').stack; function Mv () { if (Uv) try { throw Mv.arguments, new Error() } catch (e) { return e } return new Error() } function zv (e, t) { const n = e.stack; return n ? (t = t || 0, n.indexOf(e.name) === 0 && (t += (e.name + e.message).split('\n').length), n.split('\n').slice(t).filter(Dv).map(e => '\n' + e).join('')) : '' } const Fv = ['Unknown', 'Constraint', 'Data', 'TransactionInactive', 'ReadOnly', 'Version', 'NotFound', 'InvalidState', 'InvalidAccess', 'Abort', 'Timeout', 'QuotaExceeded', 'Syntax', 'DataClone']; const Hv = ['Modify', 'Bulk', 'OpenFailed', 'VersionChange', 'Schema', 'Upgrade', 'InvalidTable', 'MissingAPI', 'NoSuchDatabase', 'InvalidArgument', 'SubTransaction', 'Unsupported', 'Internal', 'DatabaseClosed', 'PrematureCommit', 'ForeignAwait'].concat(Fv); const qv = { VersionChanged: 'Database version changed by other database connection', DatabaseClosed: 'Database has been closed', Abort: 'Transaction aborted', TransactionInactive: 'Transaction has already completed or failed', MissingAPI: 'IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb' }; function Kv (e, t) { this._e = Mv(), this.name = e, this.message = t } function Vv (e, t) { return e + '. Errors: ' + Object.keys(t).map(e => t[e].toString()).filter((e, t, n) => n.indexOf(e) === t).join('\n') } function Wv (e, t, n, r) { this._e = Mv(), this.failures = t, this.failedKeys = r, this.successCount = n, this.message = Vv(e, t) } function $v (e, t) { this._e = Mv(), this.name = 'BulkError', this.failures = Object.keys(t).map(e => t[e]), this.failuresByPos = t, this.message = Vv(e, t) }uv(Kv).from(Error).extend({ stack: { get: function () { return this._stack || (this._stack = this.name + ': ' + this.message + zv(this._e, 2)) } }, toString: function () { return this.name + ': ' + this.message } }), uv(Wv).from(Kv), uv($v).from(Kv); const Gv = Hv.reduce((e, t) => (e[t] = t + 'Error', e), {}); const Yv = Kv; const Zv = Hv.reduce((e, t) => { const n = t + 'Error'; function r (e, r) { this._e = Mv(), this.name = n, e ? typeof e === 'string' ? (this.message = `${e}${r ? '\n ' + r : ''}`, this.inner = r || null) : typeof e === 'object' && (this.message = `${e.name} ${e.message}`, this.inner = e) : (this.message = qv[t] || n, this.inner = null) } return uv(r).from(Yv), e[t] = r, e }, {}); Zv.Syntax = SyntaxError, Zv.Type = TypeError, Zv.Range = RangeError; const Jv = Fv.reduce((e, t) => (e[t + 'Error'] = Zv[t], e), {}); const Xv = Hv.reduce((e, t) => (['Syntax', 'Type', 'Range'].indexOf(t) === -1 && (e[t + 'Error'] = Zv[t]), e), {}); function Qv () {} function ew (e) { return e } function tw (e, t) { return e == null || e === ew ? t : function (n) { return t(e(n)) } } function nw (e, t) { return function () { e.apply(this, arguments), t.apply(this, arguments) } } function rw (e, t) { return e === Qv ? t : function () { const n = e.apply(this, arguments); void 0 !== n && (arguments[0] = n); const r = this.onsuccess; const i = this.onerror; this.onsuccess = null, this.onerror = null; const o = t.apply(this, arguments); return r && (this.onsuccess = this.onsuccess ? nw(r, this.onsuccess) : r), i && (this.onerror = this.onerror ? nw(i, this.onerror) : i), void 0 !== o ? o : n } } function iw (e, t) { return e === Qv ? t : function () { e.apply(this, arguments); const n = this.onsuccess; const r = this.onerror; this.onsuccess = this.onerror = null, t.apply(this, arguments), n && (this.onsuccess = this.onsuccess ? nw(n, this.onsuccess) : n), r && (this.onerror = this.onerror ? nw(r, this.onerror) : r) } } function ow (e, t) { return e === Qv ? t : function (n) { const r = e.apply(this, arguments); nv(n, r); const i = this.onsuccess; const o = this.onerror; this.onsuccess = null, this.onerror = null; const a = t.apply(this, arguments); return i && (this.onsuccess = this.onsuccess ? nw(i, this.onsuccess) : i), o && (this.onerror = this.onerror ? nw(o, this.onerror) : o), void 0 === r ? void 0 === a ? void 0 : a : nv(r, a) } } function aw (e, t) { return e === Qv ? t : function () { return !1 !== t.apply(this, arguments) && e.apply(this, arguments) } } function sw (e, t) { return e === Qv ? t : function () { const n = e.apply(this, arguments); if (n && typeof n.then === 'function') { for (var r = this, i = arguments.length, o = new Array(i); i--;)o[i] = arguments[i]; return n.then(function () { return t.apply(r, o) }) } return t.apply(this, arguments) } }Xv.ModifyError = Wv, Xv.DexieError = Kv, Xv.BulkError = $v; const cw = {}; const uw = 100; const [lw, dw, fw] = typeof Promise === 'undefined' ? [] : (() => { const e = Promise.resolve(); if (typeof crypto === 'undefined' || !crypto.subtle) return [e, rv(e), e]; const t = crypto.subtle.digest('SHA-512', new Uint8Array([0])); return [t, rv(t), e] })(); const hw = dw && dw.then; const pw = lw && lw.constructor; const gw = !!fw; let mw = !1; const yw = fw ? () => { fw.then(zw) } : Qb.setImmediate ? setImmediate.bind(null, zw) : Qb.MutationObserver ? () => { let e = document.createElement('div'); new MutationObserver(() => { zw(), e = null }).observe(e, { attributes: !0 }), e.setAttribute('i', '1') } : () => { setTimeout(zw, 0) }; let bw = function (e, t) { xw.push([e, t]), ww && (yw(), ww = !1) }; let vw = !0; var ww = !0; let _w = []; let Ew = []; let kw = null; let Sw = ew; const Aw = { id: 'global', global: !0, ref: 0, unhandleds: [], onunhandled: d_, pgp: !1, env: {}, finalize: function () { this.unhandleds.forEach(e => { try { d_(e[0], e[1]) } catch (e) {} }) } }; let Ow = Aw; var xw = []; let Iw = 0; const Nw = []; function Tw (e) { if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new'); this._listeners = [], this.onuncatched = Qv, this._lib = !1; const t = this._PSD = Ow; if (Lv && (this._stackHolder = Mv(), this._prev = null, this._numPrev = 0), typeof e !== 'function') { if (e !== cw) throw new TypeError('Not a function'); return this._state = arguments[1], this._value = arguments[2], void (!1 === this._state && Bw(this, this._value)) } this._state = null, this._value = null, ++t.ref, Cw(this, e) } const Rw = { get: function () { const e = Ow; const t = Zw; function n (n, r) { const i = !e.global && (e !== Ow || t !== Zw); const o = i && !e_(); const a = new Tw((t, a) => { jw(this, new Pw(c_(n, e, i, o), c_(r, e, i, o), t, a, e)) }); return Lv && Mw(a, this), a } return n.prototype = cw, n }, set: function (e) { cv(this, 'then', e && e.prototype === cw ? Rw : { get: function () { return e }, set: Rw.set }) } }; function Pw (e, t, n, r, i) { this.onFulfilled = typeof e === 'function' ? e : null, this.onRejected = typeof t === 'function' ? t : null, this.resolve = n, this.reject = r, this.psd = i } function Cw (e, t) { try { t(t => { if (e._state === null) { if (t === e) throw new TypeError('A promise cannot be resolved with itself.'); const n = e._lib && Fw(); t && typeof t.then === 'function' ? Cw(e, (e, n) => { t instanceof Tw ? t._then(e, n) : t.then(e, n) }) : (e._state = !0, e._value = t, Lw(e)), n && Hw() } }, Bw.bind(null, e)) } catch (t) { Bw(e, t) } } function Bw (e, t) { if (Ew.push(t), e._state === null) { const n = e._lib && Fw(); t = Sw(t), e._state = !1, e._value = t, Lv && t !== null && typeof t === 'object' && !t._promise && (function (e, t, n) { try { e.apply(null, void 0) } catch (e) {} }(() => { const n = dv(t, 'stack'); t._promise = e, cv(t, 'stack', { get: () => mw ? n && (n.get ? n.get.apply(t) : n.value) : e.stack }) })), (function (e) { _w.some(t => t._value === e._value) || _w.push(e) }(e)), Lw(e), n && Hw() } } function Lw (e) { const t = e._listeners; e._listeners = []; for (let n = 0, r = t.length; n < r; ++n)jw(e, t[n]); const i = e._PSD; --i.ref || i.finalize(), Iw === 0 && (++Iw, bw(() => { --Iw == 0 && qw() }, [])) } function jw (e, t) { if (e._state !== null) { const n = e._state ? t.onFulfilled : t.onRejected; if (n === null) return (e._state ? t.resolve : t.reject)(e._value); ++t.psd.ref, ++Iw, bw(Dw, [n, e, t]) } else e._listeners.push(t) } function Dw (e, t, n) { try { kw = t; let r; const i = t._value; t._state ? r = e(i) : (Ew.length && (Ew = []), r = e(i), Ew.indexOf(i) === -1 && (function (e) { for (let t = _w.length; t;) if (_w[--t]._value === e._value) return void _w.splice(t, 1) }(t))), n.resolve(r) } catch (e) { n.reject(e) } finally { kw = null, --Iw == 0 && qw(), --n.psd.ref || n.psd.finalize() } } function Uw (e, t, n) { if (t.length === n) return t; let r = ''; if (!1 === e._state) { let i; let o; const a = e._value; a != null ? (i = a.name || 'Error', o = a.message || a, r = zv(a, 0)) : (i = a, o = ''), t.push(i + (o ? ': ' + o : '') + r) } return Lv && ((r = zv(e._stackHolder, 2)) && t.indexOf(r) === -1 && t.push(r), e._prev && Uw(e._prev, t, n)), t } function Mw (e, t) { const n = t ? t._numPrev + 1 : 0; n < 100 && (e._prev = t, e._numPrev = n) } function zw () { Fw() && Hw() } function Fw () { const e = vw; return vw = !1, ww = !1, e } function Hw () { let e, t, n; do { for (;xw.length > 0;) for (e = xw, xw = [], n = e.length, t = 0; t < n; ++t) { const r = e[t]; r[0].apply(null, r[1]) } } while (xw.length > 0); vw = !0, ww = !0 } function qw () { const e = _w; _w = [], e.forEach(e => { e._PSD.onunhandled.call(null, e._value, e) }); for (let t = Nw.slice(0), n = t.length; n;)t[--n]() } function Kw (e) { return new Tw(cw, !1, e) } function Vw (e, t) { const n = Ow; return function () { const r = Fw(); const i = Ow; try { return i_(n, !0), e.apply(this, arguments) } catch (e) { t && t(e) } finally { i_(i, !1), r && Hw() } } }av(Tw.prototype, { then: Rw, _then: function (e, t) { jw(this, new Pw(null, null, e, t, Ow)) }, catch: function (e) { if (arguments.length === 1) return this.then(null, e); const t = arguments[0]; const n = arguments[1]; return typeof t === 'function' ? this.then(null, e => e instanceof t ? n(e) : Kw(e)) : this.then(null, e => e && e.name === t ? n(e) : Kw(e)) }, finally: function (e) { return this.then(t => (e(), t), t => (e(), Kw(t))) }, stack: { get: function () { if (this._stack) return this._stack; try { mw = !0; const e = Uw(this, [], 20).join('\nFrom previous: '); return this._state !== null && (this._stack = e), e } finally { mw = !1 } } }, timeout: function (e, t) { return e < 1 / 0 ? new Tw((n, r) => { const i = setTimeout(() => r(new Zv.Timeout(t)), e); this.then(n, r).finally(clearTimeout.bind(null, i)) }) : this } }), typeof Symbol !== 'undefined' && Symbol.toStringTag && cv(Tw.prototype, Symbol.toStringTag, 'Dexie.Promise'), Aw.env = o_(), av(Tw, { all: function () { const e = Cv.apply(null, arguments).map(t_); return new Tw(function (t, n) { e.length === 0 && t([]); let r = e.length; e.forEach((i, o) => Tw.resolve(i).then(n => { e[o] = n, --r || t(e) }, n)) }) }, resolve: e => { if (e instanceof Tw) return e; if (e && typeof e.then === 'function') return new Tw((t, n) => { e.then(t, n) }); const t = new Tw(cw, !0, e); return Mw(t, kw), t }, reject: Kw, race: function () { const e = Cv.apply(null, arguments).map(t_); return new Tw((t, n) => { e.map(e => Tw.resolve(e).then(t, n)) }) }, PSD: { get: () => Ow, set: e => Ow = e }, totalEchoes: { get: () => Zw }, newPSD: Xw, usePSD: a_, scheduler: { get: () => bw, set: e => { bw = e } }, rejectionMapper: { get: () => Sw, set: e => { Sw = e } }, follow: (e, t) => new Tw((n, r) => Xw((t, n) => { const r = Ow; r.unhandleds = [], r.onunhandled = n, r.finalize = nw(function () { !(function (e) { Nw.push(function t () { e(), Nw.splice(Nw.indexOf(t), 1) }), ++Iw, bw(() => { --Iw == 0 && qw() }, []) }(() => { this.unhandleds.length === 0 ? t() : n(this.unhandleds[0]) })) }, r.finalize), e() }, t, n, r)) }), pw && (pw.allSettled && cv(Tw, 'allSettled', function () { const e = Cv.apply(null, arguments).map(t_); return new Tw(t => { e.length === 0 && t([]); let n = e.length; const r = new Array(n); e.forEach((e, i) => Tw.resolve(e).then(e => r[i] = { status: 'fulfilled', value: e }, e => r[i] = { status: 'rejected', reason: e }).then(() => --n || t(r))) }) }), pw.any && typeof AggregateError !== 'undefined' && cv(Tw, 'any', function () { const e = Cv.apply(null, arguments).map(t_); return new Tw((t, n) => { e.length === 0 && n(new AggregateError([])); let r = e.length; const i = new Array(r); e.forEach((e, o) => Tw.resolve(e).then(e => t(e), e => { i[o] = e, --r || n(new AggregateError(i)) })) }) })); const Ww = { awaits: 0, echoes: 0, id: 0 }; let $w = 0; const Gw = []; let Yw = 0; var Zw = 0; let Jw = 0; function Xw (e, t, n, r) { const i = Ow; const o = Object.create(i); o.parent = i, o.ref = 0, o.global = !1, o.id = ++Jw; const a = Aw.env; o.env = gw ? { Promise: Tw, PromiseProp: { value: Tw, configurable: !0, writable: !0 }, all: Tw.all, race: Tw.race, allSettled: Tw.allSettled, any: Tw.any, resolve: Tw.resolve, reject: Tw.reject, nthen: u_(a.nthen, o), gthen: u_(a.gthen, o) } : {}, t && nv(o, t), ++i.ref, o.finalize = function () { --this.parent.ref || this.parent.finalize() }; const s = a_(o, e, n, r); return o.ref === 0 && o.finalize(), s } function Qw () { return Ww.id || (Ww.id = ++$w), ++Ww.awaits, Ww.echoes += uw, Ww.id } function e_ () { return !!Ww.awaits && (--Ww.awaits == 0 && (Ww.id = 0), Ww.echoes = Ww.awaits * uw, !0) } function t_ (e) { return Ww.echoes && e && e.constructor === pw ? (Qw(), e.then(e => (e_(), e), e => (e_(), f_(e)))) : e } function n_ (e) { ++Zw, Ww.echoes && --Ww.echoes != 0 || (Ww.echoes = Ww.id = 0), Gw.push(Ow), i_(e, !0) } function r_ () { const e = Gw[Gw.length - 1]; Gw.pop(), i_(e, !1) } function i_ (e, t) { const n = Ow; if ((t ? !Ww.echoes || Yw++ && e === Ow : !Yw || --Yw && e === Ow) || s_(t ? n_.bind(null, e) : r_), e !== Ow && (Ow = e, n === Aw && (Aw.env = o_()), gw)) { const r = Aw.env.Promise; const i = e.env; dw.then = i.nthen, r.prototype.then = i.gthen, (n.global || e.global) && (Object.defineProperty(Qb, 'Promise', i.PromiseProp), r.all = i.all, r.race = i.race, r.resolve = i.resolve, r.reject = i.reject, i.allSettled && (r.allSettled = i.allSettled), i.any && (r.any = i.any)) } } function o_ () { const e = Qb.Promise; return gw ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(Qb, 'Promise'), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject, nthen: dw.then, gthen: e.prototype.then } : {} } function a_ (e, t, n, r, i) { const o = Ow; try { return i_(e, !0), t(n, r, i) } finally { i_(o, !1) } } function s_ (e) { hw.call(lw, e) } function c_ (e, t, n, r) { return typeof e !== 'function' ? e : function () { const i = Ow; n && Qw(), i_(t, !0); try { return e.apply(this, arguments) } finally { i_(i, !1), r && s_(e_) } } } function u_ (e, t) { return function (n, r) { return e.call(this, c_(n, t), c_(r, t)) } }('' + hw).indexOf('[native code]') === -1 && (Qw = e_ = Qv); const l_ = 'unhandledrejection'; function d_ (e, t) { let n; try { n = t.onuncatched(e) } catch (e) {} if (!1 !== n) try { let r; const i = { promise: t, reason: e }; if (Qb.document && document.createEvent ? ((r = document.createEvent('Event')).initEvent(l_, !0, !0), nv(r, i)) : Qb.CustomEvent && nv(r = new CustomEvent(l_, { detail: i }), i), r && Qb.dispatchEvent && (dispatchEvent(r), !Qb.PromiseRejectionEvent && Qb.onunhandledrejection)) try { Qb.onunhandledrejection(r) } catch (e) {}Lv && r && !r.defaultPrevented && console.warn(`Unhandled rejection: ${e.stack || e}`) } catch (e) {} } var f_ = Tw.reject; function h_ (e, t, n, r) { if (e.idbdb && (e._state.openComplete || Ow.letThrough || e._vip)) { const i = e._createTransaction(t, n, e._dbSchema); try { i.create(), e._state.PR1398_maxLoop = 3 } catch (i) { return i.name === Gv.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn('Dexie: Need to reopen db'), e._close(), e.open().then(() => h_(e, t, n, r))) : f_(i) } return i._promise(t, (e, t) => Xw(() => (Ow.trans = i, r(e, t, i)))).then(e => i._completion.then(() => e)) } if (e._state.openComplete) return f_(new Zv.DatabaseClosed(e._state.dbOpenError)); if (!e._state.isBeingOpened) { if (!e._options.autoOpen) return f_(new Zv.DatabaseClosed()); e.open().catch(Qv) } return e._state.dbReadyPromise.then(() => h_(e, t, n, r)) } const p_ = '3.2.4'; const g_ = String.fromCharCode(65535); const m_ = -1 / 0; const y_ = 'Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.'; const b_ = 'String expected.'; const v_ = []; const w_ = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent); const __ = w_; const E_ = w_; const k_ = e => !/(dexie\.js|dexie\.min\.js)/.test(e); const S_ = '__dbnames'; const A_ = 'readonly'; const O_ = 'readwrite'; function x_ (e, t) { return e ? t ? function () { return e.apply(this, arguments) && t.apply(this, arguments) } : e : t } const I_ = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 }; function N_ (e) { return typeof e !== 'string' || /\./.test(e) ? e => e : t => (void 0 === t[e] && e in t && delete (t = Ov(t))[e], t) } class T_ {_trans (e, t, n) { const r = this._tx || Ow.trans; const i = this.name; function o (e, n, r) { if (!r.schema[i]) throw new Zv.NotFound('Table ' + i + ' not part of transaction'); return t(r.idbtrans, r) } const a = Fw(); try { return r && r.db === this.db ? r === Ow.trans ? r._promise(e, o, n) : Xw(() => r._promise(e, o, n), { trans: r, transless: Ow.transless || Ow }) : h_(this.db, e, [this.name], o) } finally { a && Hw() } }get (e, t) { return e && e.constructor === Object ? this.where(e).first(t) : this._trans('readonly', t => this.core.get({ trans: t, key: e }).then(e => this.hook.reading.fire(e))).then(t) }where (e) { if (typeof e === 'string') return new this.db.WhereClause(this, e); if (tv(e)) return new this.db.WhereClause(this, `[${e.join('+')}]`); const t = ev(e); if (t.length === 1) return this.where(t[0]).equals(e[t[0]]); const n = this.schema.indexes.concat(this.schema.primKey).filter(e => e.compound && t.every(t => e.keyPath.indexOf(t) >= 0) && e.keyPath.every(e => t.indexOf(e) >= 0))[0]; if (n && this.db._maxKey !== g_) return this.where(n.name).equals(n.keyPath.map(t => e[t])); !n && Lv && console.warn(`The query ${JSON.stringify(e)} on ${this.name} would benefit of a compound index [${t.join('+')}]`); const { idxByName: r } = this.schema; const i = this.db._deps.indexedDB; function o (e, t) { try { return i.cmp(e, t) === 0 } catch (e) { return !1 } } const [a, s] = t.reduce(([t, n], i) => { const a = r[i]; const s = e[i]; return [t || a, t || !a ? x_(n, a && a.multi ? e => { const t = bv(e, i); return tv(t) && t.some(e => o(s, e)) } : e => o(s, bv(e, i))) : n] }, [null, null]); return a ? this.where(a.name).equals(e[a.keyPath]).filter(s) : n ? this.filter(s) : this.where(t).equals('') }filter (e) { return this.toCollection().and(e) }count (e) { return this.toCollection().count(e) }offset (e) { return this.toCollection().offset(e) }limit (e) { return this.toCollection().limit(e) }each (e) { return this.toCollection().each(e) }toArray (e) { return this.toCollection().toArray(e) }toCollection () { return new this.db.Collection(new this.db.WhereClause(this)) }orderBy (e) { return new this.db.Collection(new this.db.WhereClause(this, tv(e) ? `[${e.join('+')}]` : e)) }reverse () { return this.toCollection().reverse() }mapToClass (e) { this.schema.mappedClass = e; const t = t => { if (!t) return t; const n = Object.create(e.prototype); for (const r in t) if (ov(t, r)) try { n[r] = t[r] } catch (e) {} return n }; return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = t, this.hook('reading', t), e }defineClass () { return this.mapToClass(function (e) { nv(this, e) }) }add (e, t) { const { auto: n, keyPath: r } = this.schema.primKey; let i = e; return r && n && (i = N_(r)(e)), this._trans('readwrite', e => this.core.mutate({ trans: e, type: 'add', keys: t != null ? [t] : null, values: [i] })).then(e => e.numFailures ? Tw.reject(e.failures[0]) : e.lastResult).then(t => { if (r) try { vv(e, r, t) } catch (e) {} return t }) }update (e, t) { if (typeof e !== 'object' || tv(e)) return this.where(':id').equals(e).modify(t); { const n = bv(e, this.schema.primKey.keyPath); if (void 0 === n) return f_(new Zv.InvalidArgument('Given object does not contain its primary key')); try { typeof t !== 'function' ? ev(t).forEach(n => { vv(e, n, t[n]) }) : t(e, { value: e, primKey: n }) } catch (e) {} return this.where(':id').equals(n).modify(t) } }put (e, t) { const { auto: n, keyPath: r } = this.schema.primKey; let i = e; return r && n && (i = N_(r)(e)), this._trans('readwrite', e => this.core.mutate({ trans: e, type: 'put', values: [i], keys: t != null ? [t] : null })).then(e => e.numFailures ? Tw.reject(e.failures[0]) : e.lastResult).then(t => { if (r) try { vv(e, r, t) } catch (e) {} return t }) }delete (e) { return this._trans('readwrite', t => this.core.mutate({ trans: t, type: 'delete', keys: [e] })).then(e => e.numFailures ? Tw.reject(e.failures[0]) : void 0) }clear () { return this._trans('readwrite', e => this.core.mutate({ trans: e, type: 'deleteRange', range: I_ })).then(e => e.numFailures ? Tw.reject(e.failures[0]) : void 0) }bulkGet (e) { return this._trans('readonly', t => this.core.getMany({ keys: e, trans: t }).then(e => e.map(e => this.hook.reading.fire(e)))) }bulkAdd (e, t, n) { const r = Array.isArray(t) ? t : void 0; const i = (n = n || (r ? void 0 : t)) ? n.allKeys : void 0; return this._trans('readwrite', t => { const { auto: n, keyPath: o } = this.schema.primKey; if (o && r) throw new Zv.InvalidArgument('bulkAdd(): keys argument invalid on tables with inbound keys'); if (r && r.length !== e.length) throw new Zv.InvalidArgument('Arguments objects and keys must have the same length'); const a = e.length; const s = o && n ? e.map(N_(o)) : e; return this.core.mutate({ trans: t, type: 'add', keys: r, values: s, wantResults: i }).then(({ numFailures: e, results: t, lastResult: n, failures: r }) => { if (e === 0) return i ? t : n; throw new $v(`${this.name}.bulkAdd(): ${e} of ${a} operations failed`, r) }) }) }bulkPut (e, t, n) { const r = Array.isArray(t) ? t : void 0; const i = (n = n || (r ? void 0 : t)) ? n.allKeys : void 0; return this._trans('readwrite', t => { const { auto: n, keyPath: o } = this.schema.primKey; if (o && r) throw new Zv.InvalidArgument('bulkPut(): keys argument invalid on tables with inbound keys'); if (r && r.length !== e.length) throw new Zv.InvalidArgument('Arguments objects and keys must have the same length'); const a = e.length; const s = o && n ? e.map(N_(o)) : e; return this.core.mutate({ trans: t, type: 'put', keys: r, values: s, wantResults: i }).then(({ numFailures: e, results: t, lastResult: n, failures: r }) => { if (e === 0) return i ? t : n; throw new $v(`${this.name}.bulkPut(): ${e} of ${a} operations failed`, r) }) }) }bulkDelete (e) { const t = e.length; return this._trans('readwrite', t => this.core.mutate({ trans: t, type: 'delete', keys: e })).then(({ numFailures: e, lastResult: n, failures: r }) => { if (e === 0) return n; throw new $v(`${this.name}.bulkDelete(): ${e} of ${t} operations failed`, r) }) }} function R_ (e) { const t = {}; const n = function (n, r) { if (r) { for (var i = arguments.length, o = new Array(i - 1); --i;)o[i - 1] = arguments[i]; return t[n].subscribe.apply(null, o), e } if (typeof n === 'string') return t[n] }; n.addEventType = o; for (let r = 1, i = arguments.length; r < i; ++r)o(arguments[r]); return n; function o (e, r, i) { if (typeof e !== 'object') { var a; r || (r = aw), i || (i = Qv); var s = { subscribers: [], fire: i, subscribe: function (e) { s.subscribers.indexOf(e) === -1 && (s.subscribers.push(e), s.fire = r(s.fire, e)) }, unsubscribe: function (e) { s.subscribers = s.subscribers.filter(function (t) { return t !== e }), s.fire = s.subscribers.reduce(r, i) } }; return t[e] = n[e] = s, s }ev(a = e).forEach(function (e) { const t = a[e]; if (tv(t))o(e, a[e][0], a[e][1]); else { if (t !== 'asap') throw new Zv.InvalidArgument('Invalid event config'); var n = o(e, ew, function () { for (var e = arguments.length, t = new Array(e); e--;)t[e] = arguments[e]; n.subscribers.forEach(function (e) { mv(function () { e.apply(null, t) }) }) }) } }) } } function P_ (e, t) { return uv(t).from({ prototype: e }), t } function C_ (e, t) { return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter) } function B_ (e, t) { e.filter = x_(e.filter, t) } function L_ (e, t, n) { const r = e.replayFilter; e.replayFilter = r ? () => x_(r(), t()) : t, e.justLimit = n && !r } function j_ (e, t) { if (e.isPrimKey) return t.primaryKey; const n = t.getIndexByKeyPath(e.index); if (!n) throw new Zv.Schema('KeyPath ' + e.index + ' on object store ' + t.name + ' is not indexed'); return n } function D_ (e, t, n) { const r = j_(e, t.schema); return t.openCursor({ trans: n, values: !e.keysOnly, reverse: e.dir === 'prev', unique: !!e.unique, query: { index: r, range: e.range } }) } function U_ (e, t, n, r) { const i = e.replayFilter ? x_(e.filter, e.replayFilter()) : e.filter; if (e.or) { const o = {}; const a = (e, n, r) => { if (!i || i(n, r, e => n.stop(e), e => n.fail(e))) { const a = n.primaryKey; let s = '' + a; s === '[object ArrayBuffer]' && (s = '' + new Uint8Array(a)), ov(o, s) || (o[s] = !0, t(e, n, r)) } }; return Promise.all([e.or._iterate(a, n), M_(D_(e, r, n), e.algorithm, a, !e.keysOnly && e.valueMapper)]) } return M_(D_(e, r, n), x_(e.algorithm, i), t, !e.keysOnly && e.valueMapper) } function M_ (e, t, n, r) { const i = Vw(r ? (e, t, i) => n(r(e), t, i) : n); return e.then(e => { if (e) return e.start(() => { let n = () => e.continue(); t && !t(e, e => n = e, t => { e.stop(t), n = Qv }, t => { e.fail(t), n = Qv }) || i(e.value, e, e => n = e), n() }) }) } function z_ (e, t) { try { const n = F_(e); const r = F_(t); if (n !== r) return n === 'Array' ? 1 : r === 'Array' ? -1 : n === 'binary' ? 1 : r === 'binary' ? -1 : n === 'string' ? 1 : r === 'string' ? -1 : n === 'Date' ? 1 : r !== 'Date' ? NaN : -1; switch (n) { case 'number':case 'Date':case 'string':return e > t ? 1 : e < t ? -1 : 0; case 'binary':return (function (e, t) { const n = e.length; const r = t.length; const i = n < r ? n : r; for (let n = 0; n < i; ++n) if (e[n] !== t[n]) return e[n] < t[n] ? -1 : 1; return n === r ? 0 : n < r ? -1 : 1 }(H_(e), H_(t))); case 'Array':return (function (e, t) { const n = e.length; const r = t.length; const i = n < r ? n : r; for (let n = 0; n < i; ++n) { const r = z_(e[n], t[n]); if (r !== 0) return r } return n === r ? 0 : n < r ? -1 : 1 }(e, t)) } } catch (e) {} return NaN } function F_ (e) { const t = typeof e; if (t !== 'object') return t; if (ArrayBuffer.isView(e)) return 'binary'; const n = Nv(e); return n === 'ArrayBuffer' ? 'binary' : n } function H_ (e) { return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e) } class q_ {_read (e, t) { const n = this._ctx; return n.error ? n.table._trans(null, f_.bind(null, n.error)) : n.table._trans('readonly', e).then(t) }_write (e) { const t = this._ctx; return t.error ? t.table._trans(null, f_.bind(null, t.error)) : t.table._trans('readwrite', e, 'locked') }_addAlgorithm (e) { const t = this._ctx; t.algorithm = x_(t.algorithm, e) }_iterate (e, t) { return U_(this._ctx, e, t, this._ctx.table.core) }clone (e) { const t = Object.create(this.constructor.prototype); const n = Object.create(this._ctx); return e && nv(n, e), t._ctx = n, t }raw () { return this._ctx.valueMapper = null, this }each (e) { const t = this._ctx; return this._read(n => U_(t, e, n, t.table.core)) }count (e) { return this._read(e => { const t = this._ctx; const n = t.table.core; if (C_(t, !0)) return n.count({ trans: e, query: { index: j_(t, n.schema), range: t.range } }).then(e => Math.min(e, t.limit)); let r = 0; return U_(t, () => (++r, !1), e, n).then(() => r) }).then(e) }sortBy (e, t) { const n = e.split('.').reverse(); const r = n[0]; const i = n.length - 1; function o (e, t) { return t ? o(e[n[t]], t - 1) : e[r] } const a = this._ctx.dir === 'next' ? 1 : -1; function s (e, t) { const n = o(e, i); const r = o(t, i); return n < r ? -a : n > r ? a : 0 } return this.toArray(function (e) { return e.sort(s) }).then(t) }toArray (e) { return this._read(e => { const t = this._ctx; if (t.dir === 'next' && C_(t, !0) && t.limit > 0) { const { valueMapper: n } = t; const r = j_(t, t.table.core.schema); return t.table.core.query({ trans: e, limit: t.limit, values: !0, query: { index: r, range: t.range } }).then(({ result: e }) => n ? e.map(n) : e) } { const n = []; return U_(t, e => n.push(e), e, t.table.core).then(() => n) } }, e) }offset (e) { const t = this._ctx; return e <= 0 || (t.offset += e, C_(t) ? L_(t, () => { let t = e; return (e, n) => t === 0 || (t === 1 ? (--t, !1) : (n(() => { e.advance(t), t = 0 }), !1)) }) : L_(t, () => { let t = e; return () => --t < 0 })), this }limit (e) { return this._ctx.limit = Math.min(this._ctx.limit, e), L_(this._ctx, () => { let t = e; return function (e, n, r) { return --t <= 0 && n(r), t >= 0 } }, !0), this }until (e, t) { return B_(this._ctx, function (n, r, i) { return !e(n.value) || (r(i), t) }), this }first (e) { return this.limit(1).toArray(function (e) { return e[0] }).then(e) }last (e) { return this.reverse().first(e) }filter (e) { let t, n; return B_(this._ctx, function (t) { return e(t.value) }), t = this._ctx, n = e, t.isMatch = x_(t.isMatch, n), this }and (e) { return this.filter(e) }or (e) { return new this.db.WhereClause(this._ctx.table, e, this) }reverse () { return this._ctx.dir = this._ctx.dir === 'prev' ? 'next' : 'prev', this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this }desc () { return this.reverse() }eachKey (e) { const t = this._ctx; return t.keysOnly = !t.isMatch, this.each(function (t, n) { e(n.key, n) }) }eachUniqueKey (e) { return this._ctx.unique = 'unique', this.eachKey(e) }eachPrimaryKey (e) { const t = this._ctx; return t.keysOnly = !t.isMatch, this.each(function (t, n) { e(n.primaryKey, n) }) }keys (e) { const t = this._ctx; t.keysOnly = !t.isMatch; const n = []; return this.each(function (e, t) { n.push(t.key) }).then(function () { return n }).then(e) }primaryKeys (e) { const t = this._ctx; if (t.dir === 'next' && C_(t, !0) && t.limit > 0) return this._read(e => { const n = j_(t, t.table.core.schema); return t.table.core.query({ trans: e, values: !1, limit: t.limit, query: { index: n, range: t.range } }) }).then(({ result: e }) => e).then(e); t.keysOnly = !t.isMatch; const n = []; return this.each(function (e, t) { n.push(t.primaryKey) }).then(function () { return n }).then(e) }uniqueKeys (e) { return this._ctx.unique = 'unique', this.keys(e) }firstKey (e) { return this.limit(1).keys(function (e) { return e[0] }).then(e) }lastKey (e) { return this.reverse().firstKey(e) }distinct () { const e = this._ctx; const t = e.index && e.table.schema.idxByName[e.index]; if (!t || !t.multi) return this; const n = {}; return B_(this._ctx, function (e) { const t = e.primaryKey.toString(); const r = ov(n, t); return n[t] = !0, !r }), this }modify (e) { const t = this._ctx; return this._write(n => { let r; if (typeof e === 'function')r = e; else { const i = ev(e); const o = i.length; r = function (t) { for (var n = !1, r = 0; r < o; ++r) { const a = i[r]; const s = e[a]; bv(t, a) !== s && (vv(t, a, s), n = !0) } return n } } const a = t.table.core; const { outbound: s, extractKey: c } = a.schema.primaryKey; const u = this.db._options.modifyChunkSize || 200; const l = []; let d = 0; const f = []; const h = (e, t) => { const { failures: n, numFailures: r } = t; d += e - r; for (const e of ev(n))l.push(n[e]) }; return this.clone().primaryKeys().then(i => { const o = l => { const d = Math.min(u, i.length - l); return a.getMany({ trans: n, keys: i.slice(l, l + d), cache: 'immutable' }).then(f => { const p = []; const g = []; const m = s ? [] : null; const y = []; for (let e = 0; e < d; ++e) { const t = f[e]; const n = { value: Ov(t), primKey: i[l + e] }; !1 !== r.call(n, n.value, n) && (n.value == null ? y.push(i[l + e]) : s || z_(c(t), c(n.value)) === 0 ? (g.push(n.value), s && m.push(i[l + e])) : (y.push(i[l + e]), p.push(n.value))) } const b = C_(t) && t.limit === 1 / 0 && (typeof e !== 'function' || e === K_) && { index: t.index, range: t.range }; return Promise.resolve(p.length > 0 && a.mutate({ trans: n, type: 'add', values: p }).then(e => { for (const t in e.failures)y.splice(parseInt(t), 1); h(p.length, e) })).then(() => (g.length > 0 || b && typeof e === 'object') && a.mutate({ trans: n, type: 'put', keys: m, values: g, criteria: b, changeSpec: typeof e !== 'function' && e }).then(e => h(g.length, e))).then(() => (y.length > 0 || b && e === K_) && a.mutate({ trans: n, type: 'delete', keys: y, criteria: b }).then(e => h(y.length, e))).then(() => i.length > l + d && o(l + u)) }) }; return o(0).then(() => { if (l.length > 0) throw new Wv('Error modifying one or more objects', l, d, f); return i.length }) }) }) }delete () { const e = this._ctx; const t = e.range; return C_(e) && (e.isPrimKey && !E_ || t.type === 3) ? this._write(n => { const { primaryKey: r } = e.table.core.schema; const i = t; return e.table.core.count({ trans: n, query: { index: r, range: i } }).then(t => e.table.core.mutate({ trans: n, type: 'deleteRange', range: i }).then(({ failures: e, lastResult: n, results: r, numFailures: i }) => { if (i) throw new Wv('Could not delete some values', Object.keys(e).map(t => e[t]), t - i); return t - i })) }) : this.modify(K_) }} const K_ = (e, t) => t.value = null; function V_ (e, t) { return e < t ? -1 : e === t ? 0 : 1 } function W_ (e, t) { return e > t ? -1 : e === t ? 0 : 1 } function $_ (e, t, n) { const r = e instanceof Q_ ? new e.Collection(e) : e; return r._ctx.error = n ? new n(t) : new TypeError(t), r } function G_ (e) { return new e.Collection(e, () => X_('')).limit(0) } function Y_ (e, t, n, r, i, o) { for (var a = Math.min(e.length, r.length), s = -1, c = 0; c < a; ++c) { const u = t[c]; if (u !== r[c]) return i(e[c], n[c]) < 0 ? e.substr(0, c) + n[c] + n.substr(c + 1) : i(e[c], r[c]) < 0 ? e.substr(0, c) + r[c] + n.substr(c + 1) : s >= 0 ? e.substr(0, s) + t[s] + n.substr(s + 1) : null; i(e[c], u) < 0 && (s = c) } return a < r.length && o === 'next' ? e + n.substr(e.length) : a < e.length && o === 'prev' ? e.substr(0, n.length) : s < 0 ? null : e.substr(0, s) + r[s] + n.substr(s + 1) } function Z_ (e, t, n, r) { let i; let o; let a; let s; let c; let u; let l; const d = n.length; if (!n.every(e => typeof e === 'string')) return $_(e, b_); function f (e) { i = (function (e) { return e === 'next' ? e => e.toUpperCase() : e => e.toLowerCase() }(e)), o = (function (e) { return e === 'next' ? e => e.toLowerCase() : e => e.toUpperCase() }(e)), a = e === 'next' ? V_ : W_; const t = n.map(function (e) { return { lower: o(e), upper: i(e) } }).sort(function (e, t) { return a(e.lower, t.lower) }); s = t.map(function (e) { return e.upper }), c = t.map(function (e) { return e.lower }), u = e, l = e === 'next' ? '' : r }f('next'); const h = new e.Collection(e, () => J_(s[0], c[d - 1] + r)); h._ondirectionchange = function (e) { f(e) }; let p = 0; return h._addAlgorithm(function (e, n, r) { const i = e.key; if (typeof i !== 'string') return !1; const f = o(i); if (t(f, c, p)) return !0; for (var h = null, g = p; g < d; ++g) { const m = Y_(i, f, s[g], c[g], a, u); m === null && h === null ? p = g + 1 : (h === null || a(h, m) > 0) && (h = m) } return n(h !== null ? function () { e.continue(h + l) } : r), !1 }), h } function J_ (e, t, n, r) { return { type: 2, lower: e, upper: t, lowerOpen: n, upperOpen: r } } function X_ (e) { return { type: 1, lower: e, upper: e } } class Q_ {get Collection () { return this._ctx.table.db.Collection }between (e, t, n, r) { n = !1 !== n, r = !0 === r; try { return this._cmp(e, t) > 0 || this._cmp(e, t) === 0 && (n || r) && (!n || !r) ? G_(this) : new this.Collection(this, () => J_(e, t, !n, !r)) } catch (e) { return $_(this, y_) } }equals (e) { return e == null ? $_(this, y_) : new this.Collection(this, () => X_(e)) }above (e) { return e == null ? $_(this, y_) : new this.Collection(this, () => J_(e, void 0, !0)) }aboveOrEqual (e) { return e == null ? $_(this, y_) : new this.Collection(this, () => J_(e, void 0, !1)) }below (e) { return e == null ? $_(this, y_) : new this.Collection(this, () => J_(void 0, e, !1, !0)) }belowOrEqual (e) { return e == null ? $_(this, y_) : new this.Collection(this, () => J_(void 0, e)) }startsWith (e) { return typeof e !== 'string' ? $_(this, b_) : this.between(e, e + g_, !0, !0) }startsWithIgnoreCase (e) { return e === '' ? this.startsWith(e) : Z_(this, (e, t) => e.indexOf(t[0]) === 0, [e], g_) }equalsIgnoreCase (e) { return Z_(this, (e, t) => e === t[0], [e], '') }anyOfIgnoreCase () { const e = Cv.apply(Pv, arguments); return e.length === 0 ? G_(this) : Z_(this, (e, t) => t.indexOf(e) !== -1, e, '') }startsWithAnyOfIgnoreCase () { const e = Cv.apply(Pv, arguments); return e.length === 0 ? G_(this) : Z_(this, (e, t) => t.some(t => e.indexOf(t) === 0), e, g_) }anyOf () { const e = Cv.apply(Pv, arguments); let t = this._cmp; try { e.sort(t) } catch (e) { return $_(this, y_) } if (e.length === 0) return G_(this); const n = new this.Collection(this, () => J_(e[0], e[e.length - 1])); n._ondirectionchange = n => { t = n === 'next' ? this._ascending : this._descending, e.sort(t) }; let r = 0; return n._addAlgorithm((n, i, o) => { const a = n.key; for (;t(a, e[r]) > 0;) if (++r, r === e.length) return i(o), !1; return t(a, e[r]) === 0 || (i(() => { n.continue(e[r]) }), !1) }), n }notEqual (e) { return this.inAnyRange([[m_, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 }) }noneOf () { const e = Cv.apply(Pv, arguments); if (e.length === 0) return new this.Collection(this); try { e.sort(this._ascending) } catch (e) { return $_(this, y_) } const t = e.reduce((e, t) => e ? e.concat([[e[e.length - 1][1], t]]) : [[m_, t]], null); return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 }) }inAnyRange (e, t) { const n = this._cmp; const r = this._ascending; const i = this._descending; const o = this._min; const a = this._max; if (e.length === 0) return G_(this); if (!e.every(e => void 0 !== e[0] && void 0 !== e[1] && r(e[0], e[1]) <= 0)) return $_(this, 'First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower', Zv.InvalidArgument); const s = !t || !1 !== t.includeLowers; const c = t && !0 === t.includeUppers; let u; let l = r; function d (e, t) { return l(e[0], t[0]) } try { u = e.reduce(function (e, t) { let r = 0; const i = e.length; for (;r < i; ++r) { const i = e[r]; if (n(t[0], i[1]) < 0 && n(t[1], i[0]) > 0) { i[0] = o(i[0], t[0]), i[1] = a(i[1], t[1]); break } } return r === i && e.push(t), e }, []), u.sort(d) } catch (e) { return $_(this, y_) } let f = 0; const h = c ? e => r(e, u[f][1]) > 0 : e => r(e, u[f][1]) >= 0; const p = s ? e => i(e, u[f][0]) > 0 : e => i(e, u[f][0]) >= 0; let g = h; const m = new this.Collection(this, () => J_(u[0][0], u[u.length - 1][1], !s, !c)); return m._ondirectionchange = e => { e === 'next' ? (g = h, l = r) : (g = p, l = i), u.sort(d) }, m._addAlgorithm((e, t, n) => { for (var i = e.key; g(i);) if (++f, f === u.length) return t(n), !1; return !!(function (e) { return !h(e) && !p(e) }(i)) || (this._cmp(i, u[f][1]) === 0 || this._cmp(i, u[f][0]) === 0 || t(() => { l === r ? e.continue(u[f][0]) : e.continue(u[f][1]) }), !1) }), m }startsWithAnyOf () { const e = Cv.apply(Pv, arguments); return e.every(e => typeof e === 'string') ? e.length === 0 ? G_(this) : this.inAnyRange(e.map(e => [e, e + g_])) : $_(this, 'startsWithAnyOf() only works with strings') }} function eE (e) { return Vw(function (t) { return tE(t), e(t.target.error), !1 }) } function tE (e) { e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault() } const nE = 'storagemutated'; const rE = 'x-storagemutated-1'; const iE = R_(null, nE); class oE {_lock () { return gv(!Ow.global), ++this._reculock, this._reculock !== 1 || Ow.global || (Ow.lockOwnerFor = this), this }_unlock () { if (gv(!Ow.global), --this._reculock == 0) for (Ow.global || (Ow.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) { const e = this._blockedFuncs.shift(); try { a_(e[1], e[0]) } catch (e) {} } return this }_locked () { return this._reculock && Ow.lockOwnerFor !== this }create (e) { if (!this.mode) return this; const t = this.db.idbdb; const n = this.db._state.dbOpenError; if (gv(!this.idbtrans), !e && !t) switch (n && n.name) { case 'DatabaseClosedError':throw new Zv.DatabaseClosed(n); case 'MissingAPIError':throw new Zv.MissingAPI(n.message, n); default:throw new Zv.OpenFailed(n) } if (!this.active) throw new Zv.TransactionInactive(); return gv(this._completion._state === null), (e = this.idbtrans = e || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : t.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }))).onerror = Vw(t => { tE(t), this._reject(e.error) }), e.onabort = Vw(t => { tE(t), this.active && this._reject(new Zv.Abort(e.error)), this.active = !1, this.on('abort').fire(t) }), e.oncomplete = Vw(() => { this.active = !1, this._resolve(), 'mutatedParts' in e && iE.storagemutated.fire(e.mutatedParts) }), this }_promise (e, t, n) { if (e === 'readwrite' && this.mode !== 'readwrite') return f_(new Zv.ReadOnly('Transaction is readonly')); if (!this.active) return f_(new Zv.TransactionInactive()); if (this._locked()) return new Tw((r, i) => { this._blockedFuncs.push([() => { this._promise(e, t, n).then(r, i) }, Ow]) }); if (n) return Xw(() => { const e = new Tw((e, n) => { this._lock(); const r = t(e, n, this); r && r.then && r.then(e, n) }); return e.finally(() => this._unlock()), e._lib = !0, e }); const r = new Tw((e, n) => { const r = t(e, n, this); r && r.then && r.then(e, n) }); return r._lib = !0, r }_root () { return this.parent ? this.parent._root() : this }waitFor (e) { const t = this._root(); const n = Tw.resolve(e); if (t._waitingFor)t._waitingFor = t._waitingFor.then(() => n); else { t._waitingFor = n, t._waitingQueue = []; const r = t.idbtrans.objectStore(t.storeNames[0]); !(function e () { for (++t._spinCount; t._waitingQueue.length;)t._waitingQueue.shift()(); t._waitingFor && (r.get(-1 / 0).onsuccess = e) }()) } const i = t._waitingFor; return new Tw((e, r) => { n.then(n => t._waitingQueue.push(Vw(e.bind(null, n))), e => t._waitingQueue.push(Vw(r.bind(null, e)))).finally(() => { t._waitingFor === i && (t._waitingFor = null) }) }) }abort () { this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Zv.Abort())) }table (e) { const t = this._memoizedTables || (this._memoizedTables = {}); if (ov(t, e)) return t[e]; const n = this.schema[e]; if (!n) throw new Zv.NotFound('Table ' + e + ' not part of transaction'); const r = new this.db.Table(e, n, this); return r.core = this.db.core.table(e), t[e] = r, r }} function aE (e, t, n, r, i, o, a) { return { name: e, keyPath: t, unique: n, multi: r, auto: i, compound: o, src: (n && !a ? '&' : '') + (r ? '*' : '') + (i ? '++' : '') + sE(t) } } function sE (e) { return typeof e === 'string' ? e : e ? '[' + [].join.call(e, '+') + ']' : '' } function cE (e, t, n) { return { name: e, primKey: t, indexes: n, mappedClass: null, idxByName: yv(n, e => [e.name, e]) } } let uE = e => { try { return e.only([[]]), uE = () => [[]], [[]] } catch (e) { return uE = () => g_, g_ } }; function lE (e) { return e == null ? () => {} : typeof e === 'string' ? (function (e) { return e.split('.').length === 1 ? t => t[e] : t => bv(t, e) }(e)) : t => bv(t, e) } function dE (e) { return [].slice.call(e) } let fE = 0; function hE (e) { return e == null ? ':id' : typeof e === 'string' ? e : `[${e.join('+')}]` } function pE ({ _novip: e }, t) { const n = t.db; const r = (function (e, t, { IDBKeyRange: n, indexedDB: r }, i) { const o = (function (e, t) { return t.reduce((e, { create: t }) => ({ ...e, ...t(e) }), e) }((function (e, t, n) { function r (e) { if (e.type === 3) return null; if (e.type === 4) throw new Error('Cannot convert never type to IDBKeyRange'); const { lower: n, upper: r, lowerOpen: i, upperOpen: o } = e; return void 0 === n ? void 0 === r ? null : t.upperBound(r, !!o) : void 0 === r ? t.lowerBound(n, !!i) : t.bound(n, r, !!i, !!o) } const { schema: i, hasGetAll: o } = (function (e, t) { const n = dE(e.objectStoreNames); return { schema: { name: e.name, tables: n.map(e => t.objectStore(e)).map(e => { const { keyPath: t, autoIncrement: n } = e; const r = tv(t); const i = t == null; const o = {}; const a = { name: e.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: i, compound: r, keyPath: t, autoIncrement: n, unique: !0, extractKey: lE(t) }, indexes: dE(e.indexNames).map(t => e.index(t)).map(e => { const { name: t, unique: n, multiEntry: r, keyPath: i } = e; const a = { name: t, compound: tv(i), keyPath: i, unique: n, multiEntry: r, extractKey: lE(i) }; return o[hE(i)] = a, a }), getIndexByKeyPath: e => o[hE(e)] }; return o[':id'] = a.primaryKey, t != null && (o[hE(t)] = a.primaryKey), a }) }, hasGetAll: n.length > 0 && 'getAll' in t.objectStore(n[0]) && !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) } }(e, n)); const a = i.tables.map(e => (function (e) { const t = e.name; return { name: t, schema: e, mutate: function ({ trans: e, type: n, keys: i, values: o, range: a }) { return new Promise((s, c) => { s = Vw(s); const u = e.objectStore(t); const l = u.keyPath == null; const d = n === 'put' || n === 'add'; if (!d && n !== 'delete' && n !== 'deleteRange') throw new Error('Invalid operation type: ' + n); const { length: f } = i || o || { length: 1 }; if (i && o && i.length !== o.length) throw new Error('Given keys array must have same length as given values array.'); if (f === 0) return s({ numFailures: 0, failures: {}, results: [], lastResult: void 0 }); let h; const p = []; const g = []; let m = 0; const y = e => { ++m, tE(e) }; if (n === 'deleteRange') { if (a.type === 4) return s({ numFailures: m, failures: g, results: [], lastResult: void 0 }); a.type === 3 ? p.push(h = u.clear()) : p.push(h = u.delete(r(a))) } else { const [e, t] = d ? l ? [o, i] : [o, null] : [i, null]; if (d) for (let r = 0; r < f; ++r)p.push(h = t && void 0 !== t[r] ? u[n](e[r], t[r]) : u[n](e[r])), h.onerror = y; else for (let t = 0; t < f; ++t)p.push(h = u[n](e[t])), h.onerror = y } const b = e => { const t = e.target.result; p.forEach((e, t) => e.error != null && (g[t] = e.error)), s({ numFailures: m, failures: g, results: n === 'delete' ? i : p.map(e => e.result), lastResult: t }) }; h.onerror = e => { y(e), b(e) }, h.onsuccess = b }) }, getMany: ({ trans: e, keys: n }) => new Promise((r, i) => { r = Vw(r); const o = e.objectStore(t); const a = n.length; const s = new Array(a); let c; let u = 0; let l = 0; const d = e => { const t = e.target; s[t._pos] = t.result, ++l === u && r(s) }; const f = eE(i); for (let e = 0; e < a; ++e)n[e] != null && (c = o.get(n[e]), c._pos = e, c.onsuccess = d, c.onerror = f, ++u); u === 0 && r(s) }), get: ({ trans: e, key: n }) => new Promise((r, i) => { r = Vw(r); const o = e.objectStore(t).get(n); o.onsuccess = e => r(e.target.result), o.onerror = eE(i) }), query: (function (e) { return n => new Promise((i, o) => { i = Vw(i); const { trans: a, values: s, limit: c, query: u } = n; const l = c === 1 / 0 ? void 0 : c; const { index: d, range: f } = u; const h = a.objectStore(t); const p = d.isPrimaryKey ? h : h.index(d.name); const g = r(f); if (c === 0) return i({ result: [] }); if (e) { const e = s ? p.getAll(g, l) : p.getAllKeys(g, l); e.onsuccess = e => i({ result: e.target.result }), e.onerror = eE(o) } else { let e = 0; const t = s || !('openKeyCursor' in p) ? p.openCursor(g) : p.openKeyCursor(g); const n = []; t.onsuccess = r => { const o = t.result; return o ? (n.push(s ? o.value : o.primaryKey), ++e === c ? i({ result: n }) : void o.continue()) : i({ result: n }) }, t.onerror = eE(o) } }) }(o)), openCursor: function ({ trans: e, values: n, query: i, reverse: o, unique: a }) { return new Promise((s, c) => { s = Vw(s); const { index: u, range: l } = i; const d = e.objectStore(t); const f = u.isPrimaryKey ? d : d.index(u.name); const h = o ? a ? 'prevunique' : 'prev' : a ? 'nextunique' : 'next'; const p = n || !('openKeyCursor' in f) ? f.openCursor(r(l), h) : f.openKeyCursor(r(l), h); p.onerror = eE(c), p.onsuccess = Vw(t => { const n = p.result; if (!n) return void s(null); n.___id = ++fE, n.done = !1; const r = n.continue.bind(n); let i = n.continuePrimaryKey; i && (i = i.bind(n)); const o = n.advance.bind(n); const a = () => { throw new Error('Cursor not stopped') }; n.trans = e, n.stop = n.continue = n.continuePrimaryKey = n.advance = () => { throw new Error('Cursor not started') }, n.fail = Vw(c), n.next = function () { let e = 1; return this.start(() => e-- ? this.continue() : this.stop()).then(() => this) }, n.start = e => { const t = new Promise((e, t) => { e = Vw(e), p.onerror = eE(t), n.fail = t, n.stop = t => { n.stop = n.continue = n.continuePrimaryKey = n.advance = a, e(t) } }); const s = () => { if (p.result) try { e() } catch (e) { n.fail(e) } else n.done = !0, n.start = () => { throw new Error('Cursor behind last entry') }, n.stop() }; return p.onsuccess = Vw(e => { p.onsuccess = s, s() }), n.continue = r, n.continuePrimaryKey = i, n.advance = o, s(), t }, s(n) }, c) }) }, count ({ query: e, trans: n }) { const { index: i, range: o } = e; return new Promise((e, a) => { const s = n.objectStore(t); const c = i.isPrimaryKey ? s : s.index(i.name); const u = r(o); const l = u ? c.count(u) : c.count(); l.onsuccess = Vw(t => e(t.target.result)), l.onerror = eE(a) }) } } }(e))); const s = {}; return a.forEach(e => s[e.name] = e), { stack: 'dbcore', transaction: e.transaction.bind(e), table (e) { if (!s[e]) throw new Error(`Table '${e}' not found`); return s[e] }, MIN_KEY: -1 / 0, MAX_KEY: uE(t), schema: i } }(t, n, i)), e.dbcore)); return { dbcore: o } }(e._middlewares, n, e._deps, t)); e.core = r.dbcore, e.tables.forEach(t => { const n = t.name; e.core.schema.tables.some(e => e.name === n) && (t.core = e.core.table(n), e[n] instanceof e.Table && (e[n].core = t.core)) }) } function gE ({ _novip: e }, t, n, r) { n.forEach(n => { const i = r[n]; t.forEach(t => { const r = dv(t, n); (!r || 'value' in r && void 0 === r.value) && (t === e.Transaction.prototype || t instanceof e.Transaction ? cv(t, n, { get () { return this.table(n) }, set (e) { sv(this, n, { value: e, writable: !0, configurable: !0, enumerable: !0 }) } }) : t[n] = new e.Table(n, i)) }) }) } function mE ({ _novip: e }, t) { t.forEach(t => { for (const n in t)t[n] instanceof e.Table && delete t[n] }) } function yE (e, t) { return e._cfg.version - t._cfg.version } function bE (e, t) { const n = { del: [], add: [], change: [] }; let r; for (r in e)t[r] || n.del.push(r); for (r in t) { const i = e[r]; const o = t[r]; if (i) { const e = { name: r, def: o, recreate: !1, del: [], add: [], change: [] }; if ('' + (i.primKey.keyPath || '') != '' + (o.primKey.keyPath || '') || i.primKey.auto !== o.primKey.auto && !w_)e.recreate = !0, n.change.push(e); else { const t = i.idxByName; const r = o.idxByName; let a; for (a in t)r[a] || e.del.push(a); for (a in r) { const n = t[a]; const i = r[a]; n ? n.src !== i.src && e.change.push(i) : e.add.push(i) }(e.del.length > 0 || e.add.length > 0 || e.change.length > 0) && n.change.push(e) } } else n.add.push([r, o]) } return n } function vE (e, t, n, r) { const i = e.db.createObjectStore(t, n.keyPath ? { keyPath: n.keyPath, autoIncrement: n.auto } : { autoIncrement: n.auto }); return r.forEach(e => wE(i, e)), i } function wE (e, t) { e.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi }) } function _E (e, t, n) { const r = {}; return hv(t.objectStoreNames, 0).forEach(e => { const t = n.objectStore(e); let i = t.keyPath; const o = aE(sE(i), i || '', !1, !1, !!t.autoIncrement, i && typeof i !== 'string', !0); const a = []; for (let e = 0; e < t.indexNames.length; ++e) { const n = t.index(t.indexNames[e]); i = n.keyPath; const s = aE(n.name, i, !!n.unique, !!n.multiEntry, !1, i && typeof i !== 'string', !1); a.push(s) }r[e] = cE(e, o, a) }), r } function EE ({ _novip: e }, t, n) { const r = n.db.objectStoreNames; for (let i = 0; i < r.length; ++i) { const o = r[i]; const a = n.objectStore(o); e._hasGetAll = 'getAll' in a; for (let e = 0; e < a.indexNames.length; ++e) { const n = a.indexNames[e]; const r = a.index(n).keyPath; const i = typeof r === 'string' ? r : '[' + hv(r).join('+') + ']'; if (t[o]) { const e = t[o].idxByName[i]; e && (e.name = n, delete t[o].idxByName[i], t[o].idxByName[n] = e) } } } typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && Qb.WorkerGlobalScope && Qb instanceof Qb.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1) } class kE {_parseStoresSpec (e, t) { ev(e).forEach(n => { if (e[n] !== null) { const r = e[n].split(',').map((e, t) => { const n = (e = e.trim()).replace(/([&*]|\+\+)/g, ''); const r = /^\[/.test(n) ? n.match(/^\[(.*)\]$/)[1].split('+') : n; return aE(n, r || null, /\&/.test(e), /\*/.test(e), /\+\+/.test(e), tv(r), t === 0) }); const i = r.shift(); if (i.multi) throw new Zv.Schema('Primary key cannot be multi-valued'); r.forEach(e => { if (e.auto) throw new Zv.Schema('Only primary key can be marked as autoIncrement (++)'); if (!e.keyPath) throw new Zv.Schema('Index must have a name and cannot be an empty string') }), t[n] = cE(n, i, r) } }) }stores (e) { const t = this.db; this._cfg.storesSource = this._cfg.storesSource ? nv(this._cfg.storesSource, e) : e; const n = t._versions; const r = {}; let i = {}; return n.forEach(e => { nv(r, e._cfg.storesSource), i = e._cfg.dbschema = {}, e._parseStoresSpec(r, i) }), t._dbSchema = i, mE(t, [t._allTables, t, t.Transaction.prototype]), gE(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], ev(i), i), t._storeNames = ev(i), this }upgrade (e) { return this._cfg.contentUpgrade = sw(this._cfg.contentUpgrade || Qv, e), this }} function SE (e, t) { let n = e._dbNamesDB; return n || (n = e._dbNamesDB = new WE(S_, { addons: [], indexedDB: e, IDBKeyRange: t }), n.version(1).stores({ dbnames: 'name' })), n.table('dbnames') } function AE (e) { return e && typeof e.databases === 'function' } function OE (e) { return Xw(function () { return Ow.letThrough = !0, e() }) } function xE () { let e; return !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function (t) { const n = function () { return indexedDB.databases().finally(t) }; e = setInterval(n, 100), n() }).finally(function () { return clearInterval(e) }) : Promise.resolve() } function IE (e) { const t = e._state; const { indexedDB: n } = e._deps; if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then(() => t.dbOpenError ? f_(t.dbOpenError) : e); Lv && (t.openCanceller._stackHolder = Mv()), t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1; const r = t.openCanceller; function i () { if (t.openCanceller !== r) throw new Zv.DatabaseClosed('db.open() was cancelled') } const o = t.dbReadyResolve; let a = null; let s = !1; return Tw.race([r, (typeof navigator === 'undefined' ? Tw.resolve() : xE()).then(() => new Tw((r, o) => { if (i(), !n) throw new Zv.MissingAPI(); const c = e.name; const u = t.autoSchema ? n.open(c) : n.open(c, Math.round(10 * e.verno)); if (!u) throw new Zv.MissingAPI(); u.onerror = eE(o), u.onblocked = Vw(e._fireOnBlocked), u.onupgradeneeded = Vw(r => { if (a = u.transaction, t.autoSchema && !e._options.allowEmptyDB) { u.onerror = tE, a.abort(), u.result.close(); const e = n.deleteDatabase(c); e.onsuccess = e.onerror = Vw(() => { o(new Zv.NoSuchDatabase(`Database ${c} doesnt exist`)) }) } else { a.onerror = eE(o); const i = r.oldVersion > Math.pow(2, 62) ? 0 : r.oldVersion; s = i < 1, e._novip.idbdb = u.result, (function (e, t, n, r) { const i = e._dbSchema; const o = e._createTransaction('readwrite', e._storeNames, i); o.create(n), o._completion.catch(r); const a = o._reject.bind(o); const s = Ow.transless || Ow; Xw(() => { Ow.trans = o, Ow.transless = s, t === 0 ? (ev(i).forEach(e => { vE(n, e, i[e].primKey, i[e].indexes) }), pE(e, n), Tw.follow(() => e.on.populate.fire(o)).catch(a)) : (function ({ _novip: e }, t, n, r) { const i = []; const o = e._versions; let a = e._dbSchema = _E(0, e.idbdb, r); let s = !1; const c = o.filter(e => e._cfg.version >= t); return c.forEach(o => { i.push(() => { const i = a; const c = o._cfg.dbschema; EE(e, i, r), EE(e, c, r), a = e._dbSchema = c; const u = bE(i, c); u.add.forEach(e => { vE(r, e[0], e[1].primKey, e[1].indexes) }), u.change.forEach(e => { if (e.recreate) throw new Zv.Upgrade('Not yet support for changing primary key'); { const t = r.objectStore(e.name); e.add.forEach(e=>wE(t,e)), e.change.forEach(e=>{t.deleteIndex(e.name),wE(t,e)}), e.del.forEach(e=>t.deleteIndex(e)) } }); const l = o._cfg.contentUpgrade; if (l && o._cfg.version > t) { pE(e, r), n._memoizedTables = {}, s = !0; const t = wv(c); u.del.forEach(e => { t[e] = i[e] }), mE(e, [e.Transaction.prototype]), gE(e, [e.Transaction.prototype], ev(t), t), n.schema = t; const o = Bv(l); let a; o && Qw(); const d = Tw.follow(() => { if (a = l(n), a && o) { var e = e_.bind(null, null); a.then(e, e) } }); return a && 'function'===typeof a.then ? Tw.resolve(a) : d.then(() => a) } }), i.push(t => { s && __ || (function (e, t) { [].slice.call(t.db.objectStoreNames).forEach(n=>null==e[n]&&t.db.deleteObjectStore(n)) }(o._cfg.dbschema, t)), mE(e, [e.Transaction.prototype]), gE(e, [e.Transaction.prototype], e._storeNames, e._dbSchema), n.schema = e._dbSchema }) }), (function e () { return i.length ? Tw.resolve(i.shift()(n.idbtrans)).then(e) : Tw.resolve() }()).then(() => { let e, t; t = r, ev(e = a).forEach(n => { t.db.objectStoreNames.contains(n) || vE(t, n, e[n].primKey, e[n].indexes) }) }) }(e, t, o, n)).catch(a) }) }(e, i / 10, a, o)) } }, o), u.onsuccess = Vw(() => { a = null; const n = e._novip.idbdb = u.result; const i = hv(n.objectStoreNames); if (i.length > 0) try { const r = n.transaction((o = i).length === 1 ? o[0] : o, 'readonly'); t.autoSchema ? (function ({ _novip: e }, t, n) { e.verno = t.version / 10; const r = e._dbSchema = _E(0, t, n); e._storeNames = hv(t.objectStoreNames, 0), gE(e, [e._allTables], ev(r), r) }(e, n, r)) : (EE(e, e._dbSchema, r), (function (e, t) { const n = bE(_E(0, e.idbdb, t), e._dbSchema); return !(n.add.length || n.change.some(e => e.add.length || e.change.length)) }(e, r)) || console.warn('Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.')), pE(e, r) } catch (e) {} let o; v_.push(e), n.onversionchange = Vw(n => { t.vcFired = !0, e.on('versionchange').fire(n) }), n.onclose = Vw(t => { e.on('close').fire(t) }), s && (function ({ indexedDB: e, IDBKeyRange: t }, n) { !AE(e) && n !== S_ && SE(e, t).put({ name: n }).catch(Qv) }(e._deps, c)), r() }, o) }))]).then(() => (i(), t.onReadyBeingFired = [], Tw.resolve(OE(() => e.on.ready.fire(e.vip))).then(function n () { if (t.onReadyBeingFired.length > 0) { const r = t.onReadyBeingFired.reduce(sw, Qv); return t.onReadyBeingFired = [], Tw.resolve(OE(() => r(e.vip))).then(n) } }))).finally(() => { t.onReadyBeingFired = null, t.isBeingOpened = !1 }).then(() => e).catch(n => { t.dbOpenError = n; try { a && a.abort() } catch (e) {} return r === t.openCanceller && e._close(), f_(n) }).finally(() => { t.openComplete = !0, o() }) } function NE (e) { const t = t => e.next(t); const n = i(t); const r = i(t => e.throw(t)); function i (e) { return t => { const i = e(t); const o = i.value; return i.done ? o : o && typeof o.then === 'function' ? o.then(n, r) : tv(o) ? Promise.all(o).then(n, r) : n(o) } } return i(t)() } function TE (e, t, n) { let r = arguments.length; if (r < 2) throw new Zv.InvalidArgument('Too few arguments'); for (var i = new Array(r - 1); --r;)i[r - 1] = arguments[r]; return n = i.pop(), [e, Ev(i), n] } function RE (e, t, n, r, i) { return Tw.resolve().then(() => { const o = Ow.transless || Ow; const a = e._createTransaction(t, n, e._dbSchema, r); const s = { trans: a, transless: o }; if (r)a.idbtrans = r.idbtrans; else try { a.create(), e._state.PR1398_maxLoop = 3 } catch (r) { return r.name === Gv.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn('Dexie: Need to reopen db'), e._close(), e.open().then(() => RE(e, t, n, null, i))) : f_(r) } const c = Bv(i); let u; c && Qw(); const l = Tw.follow(() => { if (u = i.call(a, a), u) if (c) { const e = e_.bind(null, null); u.then(e, e) } else typeof u.next === 'function' && typeof u.throw === 'function' && (u = NE(u)) }, s); return (u && typeof u.then === 'function' ? Tw.resolve(u).then(e => a.active ? e : f_(new Zv.PrematureCommit('Transaction committed too early. See http://bit.ly/2kdckMn'))) : l.then(() => u)).then(e => (r && a._resolve(), a._completion.then(() => e))).catch(e => (a._reject(e), f_(e))) }) } function PE (e, t, n) { const r = tv(e) ? e.slice() : [e]; for (let e = 0; e < n; ++e)r.push(t); return r } const CE = { stack: 'dbcore', name: 'VirtualIndexMiddleware', level: 1, create: function (e) { return { ...e, table (t) { const n = e.table(t); const { schema: r } = n; const i = {}; const o = []; function a (e, t, n) { const r = hE(e); const s = i[r] = i[r] || []; const c = e == null ? 0 : typeof e === 'string' ? 1 : e.length; const u = t > 0; const l = { ...n, isVirtual: u, keyTail: t, keyLength: c, extractKey: lE(e), unique: !u && n.unique }; return s.push(l), l.isPrimaryKey || o.push(l), c > 1 && a(c === 2 ? e[0] : e.slice(0, c - 1), t + 1, n), s.sort((e, t) => e.keyTail - t.keyTail), l } const s = a(r.primaryKey.keyPath, 0, r.primaryKey); i[':id'] = [s]; for (const e of r.indexes)a(e.keyPath, 0, e); function c (t) { const n = t.query.index; return n.isVirtual ? { ...t, query: { index: n, range: (r = t.query.range, i = n.keyTail, { type: r.type === 1 ? 2 : r.type, lower: PE(r.lower, r.lowerOpen ? e.MAX_KEY : e.MIN_KEY, i), lowerOpen: !0, upper: PE(r.upper, r.upperOpen ? e.MIN_KEY : e.MAX_KEY, i), upperOpen: !0 }) } } : t; let r, i } const u = { ...n, schema: { ...r, primaryKey: s, indexes: o, getIndexByKeyPath: function (e) { const t = i[hE(e)]; return t && t[0] } }, count: e => n.count(c(e)), query: e => n.query(c(e)), openCursor (t) { const { keyTail: r, isVirtual: i, keyLength: o } = t.query.index; return i ? n.openCursor(c(t)).then(n => n && (function (n) { const i = Object.create(n, { continue: { value: function (i) { i != null ? n.continue(PE(i, t.reverse ? e.MAX_KEY : e.MIN_KEY, r)) : t.unique ? n.continue(n.key.slice(0, o).concat(t.reverse ? e.MIN_KEY : e.MAX_KEY, r)) : n.continue() } }, continuePrimaryKey: { value (t, i) { n.continuePrimaryKey(PE(t, e.MAX_KEY, r), i) } }, primaryKey: { get: () => n.primaryKey }, key: { get () { const e = n.key; return o === 1 ? e[0] : e.slice(0, o) } }, value: { get: () => n.value } }); return i }(n))) : n.openCursor(t) } }; return u } } } }; function BE (e, t, n, r) { return n = n || {}, r = r || '', ev(e).forEach(i => { if (ov(t, i)) { const o = e[i]; const a = t[i]; if (typeof o === 'object' && typeof a === 'object' && o && a) { const e = Nv(o); e !== Nv(a) ? n[r + i] = t[i] : e === 'Object' ? BE(o, a, n, r + i + '.') : o !== a && (n[r + i] = t[i]) } else o !== a && (n[r + i] = t[i]) } else n[r + i] = void 0 }), ev(t).forEach(i => { ov(e, i) || (n[r + i] = t[i]) }), n } const LE = { stack: 'dbcore', name: 'HooksMiddleware', level: 2, create: e => ({ ...e, table (t) { const n = e.table(t); const { primaryKey: r } = n.schema; const i = { ...n, mutate (e) { const i = Ow.trans; const { deleting: o, creating: a, updating: s } = i.table(t).hook; switch (e.type) { case 'add':if (a.fire === Qv) break; return i._promise('readwrite', () => c(e), !0); case 'put':if (a.fire === Qv && s.fire === Qv) break; return i._promise('readwrite', () => c(e), !0); case 'delete':if (o.fire === Qv) break; return i._promise('readwrite', () => c(e), !0); case 'deleteRange':if (o.fire === Qv) break; return i._promise('readwrite', () => (function (e) { return u(e.trans, e.range, 1e4) }(e)), !0) } return n.mutate(e); function c (e) { const t = Ow.trans; const i = e.keys || (function (e, t) { return t.type === 'delete' ? t.keys : t.keys || t.values.map(e.extractKey) }(r, e)); if (!i) throw new Error('Keys missing'); return (e = e.type === 'add' || e.type === 'put' ? { ...e, keys: i } : { ...e }).type !== 'delete' && (e.values = [...e.values]), e.keys && (e.keys = [...e.keys]), (function (e, t, n) { return t.type === 'add' ? Promise.resolve([]) : e.getMany({ trans: t.trans, keys: n, cache: 'immutable' }) }(n, e, i)).then(c => { const u = i.map((n, i) => { const u = c[i]; const l = { onerror: null, onsuccess: null }; if (e.type === 'delete')o.fire.call(l, n, u, t); else if (e.type === 'add' || void 0 === u) { const o = a.fire.call(l, n, e.values[i], t); n == null && o != null && (n = o, e.keys[i] = n, r.outbound || vv(e.values[i], r.keyPath, n)) } else { const r = BE(u, e.values[i]); const o = s.fire.call(l, r, n, u, t); if (o) { const t = e.values[i]; Object.keys(o).forEach(e => { ov(t, e) ? t[e] = o[e] : vv(t, e, o[e]) }) } } return l }); return n.mutate(e).then(({ failures: t, results: n, numFailures: r, lastResult: o }) => { for (let r = 0; r < i.length; ++r) { const o = n ? n[r] : i[r]; const a = u[r]; o == null ? a.onerror && a.onerror(t[r]) : a.onsuccess && a.onsuccess(e.type === 'put' && c[r] ? e.values[r] : o) } return { failures: t, results: n, numFailures: r, lastResult: o } }).catch(e => (u.forEach(t => t.onerror && t.onerror(e)), Promise.reject(e))) }) } function u (e, t, i) { return n.query({ trans: e, values: !1, query: { index: r, range: t }, limit: i }).then(({ result: n }) => c({ type: 'delete', keys: n, trans: e }).then(r => r.numFailures > 0 ? Promise.reject(r.failures[0]) : n.length < i ? { failures: [], numFailures: 0, lastResult: void 0 } : u(e, { ...t, lower: n[n.length - 1], lowerOpen: !0 }, i))) } } }; return i } }) }; function jE (e, t, n) { try { if (!t) return null; if (t.keys.length < e.length) return null; const r = []; for (let i = 0, o = 0; i < t.keys.length && o < e.length; ++i)z_(t.keys[i], e[o]) === 0 && (r.push(n ? Ov(t.values[i]) : t.values[i]), ++o); return r.length === e.length ? r : null } catch (e) { return null } } const DE = { stack: 'dbcore', level: -1, create: e => ({ table: t => { const n = e.table(t); return { ...n, getMany: e => { if (!e.cache) return n.getMany(e); const t = jE(e.keys, e.trans._cache, e.cache === 'clone'); return t ? Tw.resolve(t) : n.getMany(e).then(t => (e.trans._cache = { keys: e.keys, values: e.cache === 'clone' ? Ov(t) : t }, t)) }, mutate: e => (e.type !== 'add' && (e.trans._cache = null), n.mutate(e)) } } }) }; function UE (e) { return !('from' in e) } const ME = function (e, t) { if (!this) { const t = new ME(); return e && 'd' in e && nv(t, e), t }nv(this, arguments.length ? { d: 1, from: e, to: arguments.length > 1 ? t : e } : { d: 0 }) }; function zE (e, t, n) { const r = z_(t, n); if (isNaN(r)) return; if (r > 0) throw RangeError(); if (UE(e)) return nv(e, { from: t, to: n, d: 1 }); const i = e.l; const o = e.r; if (z_(n, e.from) < 0) return i ? zE(i, t, n) : e.l = { from: t, to: n, d: 1, l: null, r: null }, qE(e); if (z_(t, e.to) > 0) return o ? zE(o, t, n) : e.r = { from: t, to: n, d: 1, l: null, r: null }, qE(e); z_(t, e.from) < 0 && (e.from = t, e.l = null, e.d = o ? o.d + 1 : 1), z_(n, e.to) > 0 && (e.to = n, e.r = null, e.d = e.l ? e.l.d + 1 : 1); const a = !e.r; i && !e.l && FE(e, i), o && a && FE(e, o) } function FE (e, t) { UE(t) || (function e (t, { from: n, to: r, l: i, r: o }) { zE(t, n, r), i && e(t, i), o && e(t, o) }(e, t)) } function HE (e) { let t = UE(e) ? null : { s: 0, n: e }; return { next (e) { const n = arguments.length > 0; for (;t;) switch (t.s) { case 0:if (t.s = 1, n) for (;t.n.l && z_(e, t.n.from) < 0;)t = { up: t, n: t.n.l, s: 1 }; else for (;t.n.l;)t = { up: t, n: t.n.l, s: 1 }; case 1:if (t.s = 2, !n || z_(e, t.n.to) <= 0) return { value: t.n, done: !1 }; case 2:if (t.n.r) { t.s = 3, t = { up: t, n: t.n.r, s: 0 }; continue } case 3:t = t.up } return { done: !0 } } } } function qE (e) { let t, n; const r = (((t = e.r) === null || void 0 === t ? void 0 : t.d) || 0) - (((n = e.l) === null || void 0 === n ? void 0 : n.d) || 0); const i = r > 1 ? 'r' : r < -1 ? 'l' : ''; if (i) { const t = i === 'r' ? 'l' : 'r'; const n = { ...e }; const r = e[i]; e.from = r.from, e.to = r.to, e[i] = r[i], n[i] = r[t], e[t] = n, n.d = KE(n) }e.d = KE(e) } function KE ({ r: e, l: t }) { return (e ? t ? Math.max(e.d, t.d) : e.d : t ? t.d : 0) + 1 }av(ME.prototype, { add (e) { return FE(this, e), this }, addKey (e) { return zE(this, e, e), this }, addKeys (e) { return e.forEach(e => zE(this, e, e)), this }, [Tv] () { return HE(this) } }); const VE = { stack: 'dbcore', level: 0, create: e => { const t = e.schema.name; const n = new ME(e.MIN_KEY, e.MAX_KEY); return { ...e, table: r => { const i = e.table(r); const { schema: o } = i; const { primaryKey: a } = o; const { extractKey: s, outbound: c } = a; const u = { ...i, mutate: e => { const a = e.trans; const s = a.mutatedParts || (a.mutatedParts = {}); const c = e => { const n = `idb://${t}/${r}/${e}`; return s[n] || (s[n] = new ME()) }; const u = c(''); const l = c(':dels'); const { type: d } = e; let [f, h] = e.type === 'deleteRange' ? [e.range] : e.type === 'delete' ? [e.keys] : e.values.length < 50 ? [[], e.values] : []; const p = e.trans._cache; return i.mutate(e).then(e => { if (tv(f)) { d !== 'delete' && (f = e.results), u.addKeys(f); const t = jE(f, p); t || d === 'add' || l.addKeys(f), (t || h) && (function (e, t, n, r) { t.indexes.forEach(function (t) { const i = e(t.name || ''); function o (e) { return e != null ? t.extractKey(e) : null } const a = e => t.multiEntry && tv(e) ? e.forEach(e => i.addKey(e)) : i.addKey(e); (n || r).forEach((e, t) => { const i = n && o(n[t]); const s = r && o(r[t]); z_(i, s) !== 0 && (i != null && a(i), s != null && a(s)) }) }) }(c, o, t, h)) } else if (f) { const e = { from: f.lower, to: f.upper }; l.add(e), u.add(e) } else u.add(n), l.add(n), o.indexes.forEach(e => c(e.name).add(n)); return e }) } }; const l = ({ query: { index: t, range: n } }) => { let r, i; return [t, new ME((r = n.lower) !== null && void 0 !== r ? r : e.MIN_KEY, (i = n.upper) !== null && void 0 !== i ? i : e.MAX_KEY)] }; const d = { get: e => [a, new ME(e.key)], getMany: e => [a, (new ME()).addKeys(e.keys)], count: l, query: l, openCursor: l }; return ev(d).forEach(e => { u[e] = function (o) { const { subscr: a } = Ow; if (a) { const u = e => { const n = `idb://${t}/${r}/${e}`; return a[n] || (a[n] = new ME()) }; const l = u(''); const f = u(':dels'); const [h, p] = d[e](o); if (u(h.name || '').add(p), !h.isPrimaryKey) { if (e !== 'count') { const t = e === 'query' && c && o.values && i.query({ ...o, values: !1 }); return i[e].apply(this, arguments).then(n => { if (e === 'query') { if (c && o.values) return t.then(({ result: e }) => (l.addKeys(e), n)); const e = o.values ? n.result.map(s) : n.result; o.values ? l.addKeys(e) : f.addKeys(e) } else if (e === 'openCursor') { const e = n; const t = o.values; return e && Object.create(e, { key: { get: () => (f.addKey(e.primaryKey), e.key) }, primaryKey: { get () { const t = e.primaryKey; return f.addKey(t), t } }, value: { get: () => (t && l.addKey(e.primaryKey), e.value) } }) } return n }) }f.add(n) } } return i[e].apply(this, arguments) } }), u } } } }; class WE {constructor (e, t) { this._middlewares = {}, this.verno = 0; const n = WE.dependencies; this._options = t = { addons: WE.addons, autoOpen: !0, indexedDB: n.indexedDB, IDBKeyRange: n.IDBKeyRange, ...t }, this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }; const { addons: r } = t; this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this; const i = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Qv, dbReadyPromise: null, cancelOpen: Qv, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 }; let o; i.dbReadyPromise = new Tw(e => { i.dbReadyResolve = e }), i.openCanceller = new Tw((e, t) => { i.cancelOpen = t }), this._state = i, this.name = e, this.on = R_(this, 'populate', 'blocked', 'versionchange', 'close', { ready: [sw, Qv] }), this.on.ready.subscribe = pv(this.on.ready.subscribe, e => (t, n) => { WE.vip(() => { const r = this._state; if (r.openComplete)r.dbOpenError || Tw.resolve().then(t), n && e(t); else if (r.onReadyBeingFired)r.onReadyBeingFired.push(t), n && e(t); else { e(t); const r = this; n || e(function e () { r.on.ready.unsubscribe(t), r.on.ready.unsubscribe(e) }) } }) }), this.Collection = (o = this, P_(q_.prototype, function (e, t) { this.db = o; let n = I_; let r = null; if (t) try { n = t() } catch (e) { r = e } const i = e._ctx; const a = i.table; const s = a.hook.reading.fire; this._ctx = { table: a, index: i.index, isPrimKey: !i.index || a.schema.primKey.keyPath && i.index === a.schema.primKey.name, range: n, keysOnly: !1, dir: 'next', unique: '', algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: r, or: i.or, valueMapper: s !== ew ? s : null } })), this.Table = (function (e) { return P_(T_.prototype, function (t, n, r) { this.db = e, this._tx = r, this.name = t, this.schema = n, this.hook = e._allTables[t] ? e._allTables[t].hook : R_(null, { creating: [rw, Qv], reading: [tw, ew], updating: [ow, Qv], deleting: [iw, Qv] }) }) }(this)), this.Transaction = (function (e) { return P_(oE.prototype, function (t, n, r, i, o) { this.db = e, this.mode = t, this.storeNames = n, this.schema = r, this.chromeTransactionDurability = i, this.idbtrans = null, this.on = R_(this, 'complete', 'error', 'abort'), this.parent = o || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Tw((e, t) => { this._resolve = e, this._reject = t }), this._completion.then(() => { this.active = !1, this.on.complete.fire() }, e => { const t = this.active; return this.active = !1, this.on.error.fire(e), this.parent ? this.parent._reject(e) : t && this.idbtrans && this.idbtrans.abort(), f_(e) }) }) }(this)), this.Version = (function (e) { return P_(kE.prototype, function (t) { this.db = e, this._cfg = { version: t, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null } }) }(this)), this.WhereClause = (function (e) { return P_(Q_.prototype, function (t, n, r) { this.db = e, this._ctx = { table: t, index: n === ':id' ? null : n, or: r }; const i = e._deps.indexedDB; if (!i) throw new Zv.MissingAPI(); this._cmp = this._ascending = i.cmp.bind(i), this._descending = (e, t) => i.cmp(t, e), this._max = (e, t) => i.cmp(e, t) > 0 ? e : t, this._min = (e, t) => i.cmp(e, t) < 0 ? e : t, this._IDBKeyRange = e._deps.IDBKeyRange }) }(this)), this.on('versionchange', e => { e.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close() }), this.on('blocked', e => { !e.newVersion || e.newVersion < e.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${e.oldVersion / 10}`) }), this._maxKey = uE(t.IDBKeyRange), this._createTransaction = (e, t, n, r) => new this.Transaction(e, t, n, this._options.chromeTransactionDurability, r), this._fireOnBlocked = e => { this.on('blocked').fire(e), v_.filter(e => e.name === this.name && e !== this && !e._state.vcFired).map(t => t.on('versionchange').fire(e)) }, this.use(CE), this.use(LE), this.use(VE), this.use(DE), this.vip = Object.create(this, { _vip: { value: !0 } }), r.forEach(e => e(this)) }version (e) { if (isNaN(e) || e < 0.1) throw new Zv.Type('Given version is not a positive number'); if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new Zv.Schema('Cannot add version when database is open'); this.verno = Math.max(this.verno, e); const t = this._versions; let n = t.filter(t => t._cfg.version === e)[0]; return n || (n = new this.Version(e), t.push(n), t.sort(yE), n.stores({}), this._state.autoSchema = !1, n) }_whenReady (e) { return this.idbdb && (this._state.openComplete || Ow.letThrough || this._vip) ? e() : new Tw((e, t) => { if (this._state.openComplete) return t(new Zv.DatabaseClosed(this._state.dbOpenError)); if (!this._state.isBeingOpened) { if (!this._options.autoOpen) return void t(new Zv.DatabaseClosed()); this.open().catch(Qv) } this._state.dbReadyPromise.then(e, t) }).then(e) }use ({ stack: e, create: t, level: n, name: r }) { r && this.unuse({ stack: e, name: r }); const i = this._middlewares[e] || (this._middlewares[e] = []); return i.push({ stack: e, create: t, level: n == null ? 10 : n, name: r }), i.sort((e, t) => e.level - t.level), this }unuse ({ stack: e, name: t, create: n }) { return e && this._middlewares[e] && (this._middlewares[e] = this._middlewares[e].filter(e => n ? e.create !== n : !!t && e.name !== t)), this }open () { return IE(this) }_close () { const e = this._state; const t = v_.indexOf(this); if (t >= 0 && v_.splice(t, 1), this.idbdb) { try { this.idbdb.close() } catch (e) {} this._novip.idbdb = null }e.dbReadyPromise = new Tw(t => { e.dbReadyResolve = t }), e.openCanceller = new Tw((t, n) => { e.cancelOpen = n }) }close () { this._close(); const e = this._state; this._options.autoOpen = !1, e.dbOpenError = new Zv.DatabaseClosed(), e.isBeingOpened && e.cancelOpen(e.dbOpenError) }delete () { const e = arguments.length > 0; const t = this._state; return new Tw((n, r) => { const i = () => { this.close(); const e = this._deps.indexedDB.deleteDatabase(this.name); e.onsuccess = Vw(() => { !(function ({ indexedDB: e, IDBKeyRange: t }, n) { !AE(e) && n !== S_ && SE(e, t).delete(n).catch(Qv) }(this._deps, this.name)), n() }), e.onerror = eE(r), e.onblocked = this._fireOnBlocked }; if (e) throw new Zv.InvalidArgument('Arguments not allowed in db.delete()'); t.isBeingOpened ? t.dbReadyPromise.then(i) : i() }) }backendDB () { return this.idbdb }isOpen () { return this.idbdb !== null }hasBeenClosed () { const e = this._state.dbOpenError; return e && e.name === 'DatabaseClosed' }hasFailed () { return this._state.dbOpenError !== null }dynamicallyOpened () { return this._state.autoSchema } get tables () { return ev(this._allTables).map(e => this._allTables[e]) }transaction () { const e = TE.apply(this, arguments); return this._transaction.apply(this, e) }_transaction (e, t, n) { let r = Ow.trans; r && r.db === this && e.indexOf('!') === -1 || (r = null); const i = e.indexOf('?') !== -1; let o, a; e = e.replace('!', '').replace('?', ''); try { if (a = t.map(e => { const t = e instanceof this.Table ? e.name : e; if (typeof t !== 'string') throw new TypeError('Invalid table argument to Dexie.transaction(). Only Table or String are allowed'); return t }), e == 'r' || e === A_)o = A_; else { if (e != 'rw' && e != O_) throw new Zv.InvalidArgument('Invalid transaction mode: ' + e); o = O_ } if (r) { if (r.mode === A_ && o === O_) { if (!i) throw new Zv.SubTransaction('Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY'); r = null }r && a.forEach(e => { if (r && r.storeNames.indexOf(e) === -1) { if (!i) throw new Zv.SubTransaction('Table ' + e + ' not included in parent transaction.'); r = null } }), i && r && !r.active && (r = null) } } catch (e) { return r ? r._promise(null, (t, n) => { n(e) }) : f_(e) } const s = RE.bind(null, this, o, a, r, n); return r ? r._promise(o, s, 'lock') : Ow.trans ? a_(Ow.transless, () => this._whenReady(s)) : this._whenReady(s) }table (e) { if (!ov(this._allTables, e)) throw new Zv.InvalidTable(`Table ${e} does not exist`); return this._allTables[e] }} const $E = typeof Symbol !== 'undefined' && 'observable' in Symbol ? Symbol.observable : '@@observable'; class GE {constructor (e) { this._subscribe = e }subscribe (e, t, n) { return this._subscribe(e && typeof e !== 'function' ? e : { next: e, error: t, complete: n }) }[$E] () { return this }} function YE (e, t) { return ev(t).forEach(n => { FE(e[n] || (e[n] = new ME()), t[n]) }), e } let ZE; try { ZE = { indexedDB: Qb.indexedDB || Qb.mozIndexedDB || Qb.webkitIndexedDB || Qb.msIndexedDB, IDBKeyRange: Qb.IDBKeyRange || Qb.webkitIDBKeyRange } } catch (Qb) { ZE = { indexedDB: null, IDBKeyRange: null } } const JE = WE; function XE (e) { const t = QE; try { QE = !0, iE.storagemutated.fire(e) } finally { QE = t } }av(JE, { ...Xv, delete: e => new JE(e, { addons: [] }).delete(), exists: e => new JE(e, { addons: [] }).open().then(e => (e.close(), !0)).catch('NoSuchDatabaseError', () => !1), getDatabaseNames (e) { try { return (function ({ indexedDB: e, IDBKeyRange: t }) { return AE(e) ? Promise.resolve(e.databases()).then(e => e.map(e => e.name).filter(e => e !== S_)) : SE(e, t).toCollection().primaryKeys() }(JE.dependencies)).then(e) } catch (e) { return f_(new Zv.MissingAPI()) } }, defineClass: () => function (e) { nv(this, e) }, ignoreTransaction: e => Ow.trans ? a_(Ow.transless, e) : e(), vip: OE, async: function (e) { return function () { try { const t = NE(e.apply(this, arguments)); return t && typeof t.then === 'function' ? t : Tw.resolve(t) } catch (e) { return f_(e) } } }, spawn: function (e, t, n) { try { const r = NE(e.apply(n, t || [])); return r && typeof r.then === 'function' ? r : Tw.resolve(r) } catch (e) { return f_(e) } }, currentTransaction: { get: () => Ow.trans || null }, waitFor: function (e, t) { const n = Tw.resolve(typeof e === 'function' ? JE.ignoreTransaction(e) : e).timeout(t || 6e4); return Ow.trans ? Ow.trans.waitFor(n) : n }, Promise: Tw, debug: { get: () => Lv, set: e => { jv(e, e === 'dexie' ? () => !0 : k_) } }, derive: uv, extend: nv, props: av, override: pv, Events: R_, on: iE, liveQuery: function (e) { let t; let n = !1; const r = new GE(r => { const i = Bv(e); let o = !1; let a = {}; let s = {}; const c = { get closed () { return o }, unsubscribe: () => { o = !0, iE.storagemutated.unsubscribe(f) } }; r.start && r.start(c); let u = !1; let l = !1; function d () { return ev(s).some(e => a[e] && (function (e, t) { const n = HE(t); let r = n.next(); if (r.done) return !1; let i = r.value; const o = HE(e); let a = o.next(i.from); let s = a.value; for (;!r.done && !a.done;) { if (z_(s.from, i.to) <= 0 && z_(s.to, i.from) >= 0) return !0; z_(i.from, s.from) < 0 ? i = (r = n.next(s.from)).value : s = (a = o.next(i.from)).value } return !1 }(a[e], s[e]))) } const f = e => { YE(a, e), d() && h() }; const h = () => { if (u || o) return; a = {}; const p = {}; const g = (function (t) { i && Qw(); const n = () => Xw(e, { subscr: t, trans: null }); const r = Ow.trans ? a_(Ow.transless, n) : n(); return i && r.then(e_, e_), r }(p)); l || (iE(nE, f), l = !0), u = !0, Promise.resolve(g).then(e => { n = !0, t = e, u = !1, o || (d() ? h() : (a = {}, s = p, r.next && r.next(e))) }, e => { u = !1, n = !1, r.error && r.error(e), c.unsubscribe() }) }; return h(), c }); return r.hasValue = () => n, r.getValue = () => t, r }, extendObservabilitySet: YE, getByKeyPath: bv, setByKeyPath: vv, delByKeyPath: function (e, t) { typeof t === 'string' ? vv(e, t, void 0) : 'length' in t && [].map.call(t, function (t) { vv(e, t, void 0) }) }, shallowClone: wv, deepClone: Ov, getObjectDiff: BE, cmp: z_, asap: mv, minKey: m_, addons: [], connections: v_, errnames: Gv, dependencies: ZE, semVer: p_, version: p_.split('.').map(e => parseInt(e)).reduce((e, t, n) => e + t / Math.pow(10, 2 * n)) }), JE.maxKey = uE(JE.dependencies.IDBKeyRange), typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined' && (iE(nE, e => { if (!QE) { let t; w_ ? (t = document.createEvent('CustomEvent'), t.initCustomEvent(rE, !0, !0, e)) : t = new CustomEvent(rE, { detail: e }), QE = !0, dispatchEvent(t), QE = !1 } }), addEventListener(rE, ({ detail: e }) => { QE || XE(e) })); let QE = !1; if (typeof BroadcastChannel !== 'undefined') { const e = new BroadcastChannel(rE); typeof e.unref === 'function' && e.unref(), iE(nE, t => { QE || e.postMessage(t) }), e.onmessage = e => { e.data && XE(e.data) } } else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') { iE(nE, e => { try { QE || (typeof localStorage !== 'undefined' && localStorage.setItem(rE, JSON.stringify({ trig: Math.random(), changedParts: e })), typeof self.clients === 'object' && [...self.clients.matchAll({ includeUncontrolled: !0 })].forEach(t => t.postMessage({ type: rE, changedParts: e }))) } catch (e) {} }), typeof addEventListener !== 'undefined' && addEventListener('storage', e => { if (e.key === rE) { const t = JSON.parse(e.newValue); t && XE(t.changedParts) } }); const e = self.document && navigator.serviceWorker; e && e.addEventListener('message', function ({ data: e }) { e && e.type === rE && XE(e.changedParts) }) }Tw.rejectionMapper = function (e, t) { if (!e || e instanceof Kv || e instanceof TypeError || e instanceof SyntaxError || !e.name || !Jv[e.name]) return e; const n = new Jv[e.name](t || e.message, e); return 'stack' in e && cv(n, 'stack', { get: function () { return this.inner.stack } }), n }, jv(Lv, k_); const ek = 'A request was aborted, for example through a call to IDBTransaction.abort.'; const tk = 'A mutation operation in the transaction failed because a constraint was not satisfied. For example, an object such as an object store or index already exists and a request attempted to create a new one.'; const nk = 'The data being stored could not be cloned by the internal structured cloning algorithm.'; const rk = 'Data provided to an operation does not meet requirements.'; const ik = 'An invalid operation was performed on an object. For example transaction creation attempt was made, but an empty scope was provided.'; const ok = 'An operation was called on an object on which it is not allowed or at a time when it is not allowed. Also occurs if a request is made on a source object that has been deleted or removed. Use TransactionInactiveError or ReadOnlyError when possible, as they are more specific variations of InvalidStateError.'; const ak = 'The operation failed because the requested database object could not be found. For example, an object store did not exist but was being opened.'; const sk = 'The mutating operation was attempted in a "readonly" transaction.'; const ck = 'A request was placed against a transaction which is currently not active, or which is finished.'; const uk = 'An attempt was made to open a database using a lower version than the existing version.'; class lk extends Error {constructor (e = ek) { super(), this.name = 'AbortError', this.message = e }} class dk extends Error {constructor (e = tk) { super(), this.name = 'ConstraintError', this.message = e }} class fk extends Error {constructor (e = nk) { super(), this.name = 'DataCloneError', this.message = e }} class hk extends Error {constructor (e = rk) { super(), this.name = 'DataError', this.message = e }} class pk extends Error {constructor (e = ik) { super(), this.name = 'InvalidAccessError', this.message = e }} class gk extends Error {constructor (e = ok) { super(), this.name = 'InvalidStateError', this.message = e }} class mk extends Error {constructor (e = ak) { super(), this.name = 'NotFoundError', this.message = e }} class yk extends Error {constructor (e = sk) { super(), this.name = 'ReadOnlyError', this.message = e }} class bk extends Error {constructor (e = ck) { super(), this.name = 'TransactionInactiveError', this.message = e }} class vk extends Error {constructor (e = uk) { super(), this.name = 'VersionError', this.message = e }} const wk = (e, t) => { if (typeof e === 'number') { if (isNaN(e)) throw new hk(); return e } if (e instanceof Date) { const t = e.valueOf(); if (isNaN(t)) throw new hk(); return new Date(t) } if (typeof e === 'string') return e; if (e instanceof ArrayBuffer || typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView && ArrayBuffer.isView(e)) return e instanceof ArrayBuffer ? new Uint8Array(e).buffer : new Uint8Array(e.buffer).buffer; if (Array.isArray(e)) { if (void 0 === t)t = new Set(); else if (t.has(e)) throw new hk(); t.add(e); const n = []; for (let r = 0; r < e.length; r++) { if (!e.hasOwnProperty(r)) throw new hk(); const i = e[r]; const o = wk(i, t); n.push(o) } return n } throw new hk() }; const _k = wk; const Ek = e => { if (typeof e === 'number') return 'Number'; if (e instanceof Date) return 'Date'; if (Array.isArray(e)) return 'Array'; if (typeof e === 'string') return 'String'; if (e instanceof ArrayBuffer) return 'Binary'; throw new hk() }; const kk = (e, t) => { if (void 0 === t) throw new TypeError(); e = _k(e), t = _k(t); const n = Ek(e); const r = Ek(t); if (n !== r) return n === 'Array' ? 1 : (n !== 'Binary' || r !== 'String' && r !== 'Date' && r !== 'Number') && (n !== 'String' || r !== 'Date' && r !== 'Number') ? n === 'Date' && r === 'Number' ? 1 : -1 : 1; if (n === 'Binary' && (e = new Uint8Array(e), t = new Uint8Array(t)), n === 'Array' || n === 'Binary') { const n = Math.min(e.length, t.length); for (let r = 0; r < n; r++) { const n = kk(e[r], t[r]); if (n !== 0) return n } return e.length > t.length ? 1 : e.length < t.length ? -1 : 0 } if (n === 'Date') { if (e.getTime() === t.getTime()) return 0 } else if (e === t) return 0; return e > t ? 1 : -1 }; const Sk = kk; class Ak {static only (e) { if (arguments.length === 0) throw new TypeError(); return e = _k(e), new Ak(e, e, !1, !1) } static lowerBound (e, t = !1) { if (arguments.length === 0) throw new TypeError(); return e = _k(e), new Ak(e, void 0, t, !0) } static upperBound (e, t = !1) { if (arguments.length === 0) throw new TypeError(); return e = _k(e), new Ak(void 0, e, !0, t) } static bound (e, t, n = !1, r = !1) { if (arguments.length < 2) throw new TypeError(); const i = Sk(e, t); if (i === 1 || i === 0 && (n || r)) throw new hk(); return e = _k(e), t = _k(t), new Ak(e, t, n, r) }constructor (e, t, n, r) { this.lower = e, this.upper = t, this.lowerOpen = n, this.upperOpen = r }includes (e) { if (arguments.length === 0) throw new TypeError(); if (e = _k(e), void 0 !== this.lower) { const t = Sk(this.lower, e); if (t === 1 || t === 0 && this.lowerOpen) return !1 } if (void 0 !== this.upper) { const t = Sk(this.upper, e); if (t === -1 || t === 0 && this.upperOpen) return !1 } return !0 }toString () { return '[object IDBKeyRange]' }} const Ok = Ak; const xk = (e, t) => { if (Array.isArray(e)) { const n = []; for (let r of e)r != null && typeof r !== 'string' && r.toString && (r = r.toString()), n.push(_k(xk(r, t))); return n } if (e === '') return t; let n = e; let r = t; for (;n !== null;) { let e; const t = n.indexOf('.'); if (t >= 0 ? (e = n.slice(0, t), n = n.slice(t + 1)) : (e = n, n = null), r == null || !r.hasOwnProperty(e)) return; r = r[e] } return r }; const Ik = xk; const Nk = a(3694); const Tk = e => { if (typeof structuredClone !== 'undefined') return structuredClone(e); try { return Nk(e) } catch (e) { throw new fk() } }; const Rk = e => e.source instanceof eS ? e.source : e.source.objectStore; const Pk = (e, t, n) => { let r = void 0 !== e ? e.lower : void 0; let i = void 0 !== e ? e.upper : void 0; for (const e of t) void 0 !== e && (void 0 !== r && Sk(r, e) !== 1 || (r = e)); for (const e of n) void 0 !== e && (void 0 !== i && Sk(i, e) !== -1 || (i = e)); return void 0 !== r && void 0 !== i ? Ok.bound(r, i) : void 0 !== r ? Ok.lowerBound(r) : void 0 !== i ? Ok.upperBound(i) : void 0 }; const Ck = class {_gotValue = !1; _position = void 0; _objectStorePosition = void 0; _keyOnly = !1; _key = void 0; _primaryKey = void 0; constructor (e, t, n = 'next', r, i = !1) { this._range = t, this._source = e, this._direction = n, this._request = r, this._keyOnly = i } get source () { return this._source } set source (e) {} get request () { return this._request } set request (e) {} get direction () { return this._direction } set direction (e) {} get key () { return this._key } set key (e) {} get primaryKey () { return this._primaryKey } set primaryKey (e) {}_iterate (e, t) { const n = this.source instanceof eS; const r = this.source instanceof eS ? this.source._rawObjectStore.records : this.source._rawIndex.records; let i, o; if (this.direction === 'next') { const o = Pk(this._range, [e, this._position], []); for (const a of r.values(o)) { const r = void 0 !== e ? Sk(a.key, e) : void 0; const o = void 0 !== this._position ? Sk(a.key, this._position) : void 0; if (void 0 === e || r !== -1) { if (void 0 !== t) { if (r === -1) continue; const e = Sk(a.value, t); if (r === 0 && e === -1) continue } if (void 0 === this._position || !n || o === 1) { if (void 0 !== this._position && !n) { if (o === -1) continue; if (o === 0 && Sk(a.value, this._objectStorePosition) !== 1) continue } if (void 0 === this._range || this._range.includes(a.key)) { i = a; break } } } } } else if (this.direction === 'nextunique') { const t = Pk(this._range, [e, this._position], []); for (const n of r.values(t)) if ((void 0 === e || Sk(n.key, e) !== -1) && (void 0 === this._position || Sk(n.key, this._position) === 1) && (void 0 === this._range || this._range.includes(n.key))) { i = n; break } } else if (this.direction === 'prev') { const o = Pk(this._range, [], [e, this._position]); for (const a of r.values(o, 'prev')) { const r = void 0 !== e ? Sk(a.key, e) : void 0; const o = void 0 !== this._position ? Sk(a.key, this._position) : void 0; if (void 0 === e || r !== 1) { if (void 0 !== t) { if (r === 1) continue; const e = Sk(a.value, t); if (r === 0 && e === 1) continue } if (void 0 === this._position || !n || o === -1) { if (void 0 !== this._position && !n) { if (o === 1) continue; if (o === 0 && Sk(a.value, this._objectStorePosition) !== -1) continue } if (void 0 === this._range || this._range.includes(a.key)) { i = a; break } } } } } else if (this.direction === 'prevunique') { let t; const n = Pk(this._range, [], [e, this._position]); for (const i of r.values(n, 'prev')) if ((void 0 === e || Sk(i.key, e) !== 1) && (void 0 === this._position || Sk(i.key, this._position) === -1) && (void 0 === this._range || this._range.includes(i.key))) { t = i; break }t && (i = r.get(t.key)) } if (i) { if (this._position = i.key, n || (this._objectStorePosition = i.value), this._key = i.key, n) this._primaryKey = Tk(i.key), this._keyOnly || this.toString() !== '[object IDBCursorWithValue]' || (this.value = Tk(i.value)); else if (this._primaryKey = Tk(i.value), !this._keyOnly && this.toString() === '[object IDBCursorWithValue]') { if (this.source instanceof eS) throw new Error('This should never happen'); const e = this.source.objectStore._rawObjectStore.getValue(i.value); this.value = Tk(e) } this._gotValue = !0, o = this } else this._key = void 0, n || (this._objectStorePosition = void 0), this._keyOnly || this.toString() !== '[object IDBCursorWithValue]' || (this.value = void 0), o = null; return o }update (e) { if (void 0 === e) throw new TypeError(); const t = Rk(this); const n = this.source.hasOwnProperty('_rawIndex') ? this.primaryKey : this._position; const r = t.transaction; if (r._state !== 'active') throw new bk(); if (r.mode === 'readonly') throw new yk(); if (t._rawObjectStore.deleted) throw new gk(); if (!(this.source instanceof eS) && this.source._rawIndex.deleted) throw new gk(); if (!this._gotValue || !this.hasOwnProperty('value')) throw new gk(); const i = Tk(e); if (t.keyPath !== null) { let e; try { e = Ik(t.keyPath, i) } catch (e) {} if (Sk(e, n) !== 0) throw new hk() } const o = { key: n, value: i }; return r._execRequestAsync({ operation: t._rawObjectStore.storeRecord.bind(t._rawObjectStore, o, !1, r._rollbackLog), source: this }) }advance (e) { if (!Number.isInteger(e) || e <= 0) throw new TypeError(); const t = Rk(this); const n = t.transaction; if (n._state !== 'active') throw new bk(); if (t._rawObjectStore.deleted) throw new gk(); if (!(this.source instanceof eS) && this.source._rawIndex.deleted) throw new gk(); if (!this._gotValue) throw new gk(); this._request && (this._request.readyState = 'pending'), n._execRequestAsync({ operation: () => { let t; for (let n = 0; n < e && (t = this._iterate(), t); n++);return t }, request: this._request, source: this.source }), this._gotValue = !1 }continue (e) { const t = Rk(this); const n = t.transaction; if (n._state !== 'active') throw new bk(); if (t._rawObjectStore.deleted) throw new gk(); if (!(this.source instanceof eS) && this.source._rawIndex.deleted) throw new gk(); if (!this._gotValue) throw new gk(); if (void 0 !== e) { e = _k(e); const t = Sk(e, this._position); if (t <= 0 && (this.direction === 'next' || this.direction === 'nextunique') || t >= 0 && (this.direction === 'prev' || this.direction === 'prevunique')) throw new hk() } this._request && (this._request.readyState = 'pending'), n._execRequestAsync({ operation: this._iterate.bind(this, e), request: this._request, source: this.source }), this._gotValue = !1 }continuePrimaryKey (e, t) { const n = Rk(this); const r = n.transaction; if (r._state !== 'active') throw new bk(); if (n._rawObjectStore.deleted) throw new gk(); if (!(this.source instanceof eS) && this.source._rawIndex.deleted) throw new gk(); if (this.source instanceof eS || this.direction !== 'next' && this.direction !== 'prev') throw new pk(); if (!this._gotValue) throw new gk(); if (void 0 === e || void 0 === t) throw new hk(); e = _k(e); const i = Sk(e, this._position); if (i === -1 && this.direction === 'next' || i === 1 && this.direction === 'prev') throw new hk(); const o = Sk(t, this._objectStorePosition); if (i === 0 && (o <= 0 && this.direction === 'next' || o >= 0 && this.direction === 'prev')) throw new hk(); this._request && (this._request.readyState = 'pending'), r._execRequestAsync({ operation: this._iterate.bind(this, e, t), request: this._request, source: this.source }), this._gotValue = !1 }delete () { const e = Rk(this); const t = this.source.hasOwnProperty('_rawIndex') ? this.primaryKey : this._position; const n = e.transaction; if (n._state !== 'active') throw new bk(); if (n.mode === 'readonly') throw new yk(); if (e._rawObjectStore.deleted) throw new gk(); if (!(this.source instanceof eS) && this.source._rawIndex.deleted) throw new gk(); if (!this._gotValue || !this.hasOwnProperty('value')) throw new gk(); return n._execRequestAsync({ operation: e._rawObjectStore.deleteRecord.bind(e._rawObjectStore, t, n._rollbackLog), source: this }) }toString () { return '[object IDBCursor]' }}; const Bk = class extends Ck {value = void 0; constructor (e, t, n, r) { super(e, t, n, r) }toString () { return '[object IDBCursorWithValue]' }}; const Lk = (e, t) => e.immediatePropagationStopped || e.eventPhase === e.CAPTURING_PHASE && !1 === t.capture || e.eventPhase === e.BUBBLING_PHASE && !0 === t.capture; const jk = (e, t) => { e.currentTarget = t; for (const n of t.listeners.slice())e.type !== n.type || Lk(e, n) || n.callback.call(e.currentTarget, e); const n = { abort: 'onabort', blocked: 'onblocked', complete: 'oncomplete', error: 'onerror', success: 'onsuccess', upgradeneeded: 'onupgradeneeded', versionchange: 'onversionchange' }[e.type]; if (void 0 === n) throw new Error(`Unknown event type: "${e.type}"`); const r = e.currentTarget[n]; if (r) { const t = { callback: r, capture: !1, type: e.type }; Lk(e, t) || t.callback.call(e.currentTarget, e) } }; const Dk = class {listeners = []; addEventListener (e, t, n = !1) { this.listeners.push({ callback: t, capture: n, type: e }) }removeEventListener (e, t, n = !1) { const r = this.listeners.findIndex(r => r.type === e && r.callback === t && r.capture === n); this.listeners.splice(r, 1) }dispatchEvent (e) { if (e.dispatched || !e.initialized) throw new gk('The object is in an invalid state.'); e.isTrusted = !1, e.dispatched = !0, e.target = this, e.eventPhase = e.CAPTURING_PHASE; for (const t of e.eventPath)e.propagationStopped || jk(e, t); if (e.eventPhase = e.AT_TARGET, e.propagationStopped || jk(e, e.target), e.bubbles) { e.eventPath.reverse(), e.eventPhase = e.BUBBLING_PHASE; for (const t of e.eventPath)e.propagationStopped || jk(e, t) } return e.dispatched = !1, e.eventPhase = e.NONE, e.currentTarget = null, !e.canceled }}; const Uk = class extends Dk {_result = null; _error = null; source = null; transaction = null; readyState = 'pending'; onsuccess = null; onerror = null; get error () { if (this.readyState === 'pending') throw new gk(); return this._error } set error (e) { this._error = e } get result () { if (this.readyState === 'pending') throw new gk(); return this._result } set result (e) { this._result = e }toString () { return '[object IDBRequest]' }}; const Mk = (e, t) => { const n = t === 'unsigned long' ? 4294967295 : 9007199254740991; if (isNaN(e) || e < 0 || e > n) throw new TypeError(); if (e >= 0) return Math.floor(e) }; const zk = class extends Array {contains (e) { for (const t of this) if (e === t) return !0; return !1 }item (e) { return e < 0 || e >= this.length ? null : this[e] }_push (...e) { return Array.prototype.push.call(this, ...e) }_sort (...e) { return Array.prototype.sort.call(this, ...e) }}; const Fk = (e, t = !1) => { if (e instanceof Ok) return e; if (e == null) { if (t) throw new hk(); return new Ok(void 0, void 0, !1, !1) } const n = _k(e); return Ok.only(n) }; const Hk = e => { if (e._rawIndex.deleted || e.objectStore._rawObjectStore.deleted) throw new gk(); if (e.objectStore.transaction._state !== 'active') throw new bk() }; const qk = class {constructor (e, t) { this._rawIndex = t, this._name = t.name, this.objectStore = e, this.keyPath = t.keyPath, this.multiEntry = t.multiEntry, this.unique = t.unique } get name () { return this._name } set name (e) { const t = this.objectStore.transaction; if (!t.db._runningVersionchangeTransaction) throw new gk(); if (t._state !== 'active') throw new bk(); if (this._rawIndex.deleted || this.objectStore._rawObjectStore.deleted) throw new gk(); if ((e = String(e)) === this._name) return; if (this.objectStore.indexNames.contains(e)) throw new dk(); const n = this._name; const r = [...this.objectStore.indexNames]; this._name = e, this._rawIndex.name = e, this.objectStore._indexesCache.delete(n), this.objectStore._indexesCache.set(e, this), this.objectStore._rawObjectStore.rawIndexes.delete(n), this.objectStore._rawObjectStore.rawIndexes.set(e, this._rawIndex), this.objectStore.indexNames = new zk(...Array.from(this.objectStore._rawObjectStore.rawIndexes.keys()).filter(e => { const t = this.objectStore._rawObjectStore.rawIndexes.get(e); return t && !t.deleted }).sort()), t._rollbackLog.push(() => { this._name = n, this._rawIndex.name = n, this.objectStore._indexesCache.delete(e), this.objectStore._indexesCache.set(n, this), this.objectStore._rawObjectStore.rawIndexes.delete(e), this.objectStore._rawObjectStore.rawIndexes.set(n, this._rawIndex), this.objectStore.indexNames = new zk(...r) }) }openCursor (e, t) { Hk(this), e === null && (e = void 0), void 0 === e || e instanceof Ok || (e = Ok.only(_k(e))); const n = new Uk(); n.source = this, n.transaction = this.objectStore.transaction; const r = new Bk(this, e, t, n); return this.objectStore.transaction._execRequestAsync({ operation: r._iterate.bind(r), request: n, source: this }) }openKeyCursor (e, t) { Hk(this), e === null && (e = void 0), void 0 === e || e instanceof Ok || (e = Ok.only(_k(e))); const n = new Uk(); n.source = this, n.transaction = this.objectStore.transaction; const r = new Ck(this, e, t, n, !0); return this.objectStore.transaction._execRequestAsync({ operation: r._iterate.bind(r), request: n, source: this }) }get (e) { return Hk(this), e instanceof Ok || (e = _k(e)), this.objectStore.transaction._execRequestAsync({ operation: this._rawIndex.getValue.bind(this._rawIndex, e), source: this }) }getAll (e, t) { arguments.length > 1 && void 0 !== t && (t = Mk(t, 'unsigned long')), Hk(this); const n = Fk(e); return this.objectStore.transaction._execRequestAsync({ operation: this._rawIndex.getAllValues.bind(this._rawIndex, n, t), source: this }) }getKey (e) { return Hk(this), e instanceof Ok || (e = _k(e)), this.objectStore.transaction._execRequestAsync({ operation: this._rawIndex.getKey.bind(this._rawIndex, e), source: this }) }getAllKeys (e, t) { arguments.length > 1 && void 0 !== t && (t = Mk(t, 'unsigned long')), Hk(this); const n = Fk(e); return this.objectStore.transaction._execRequestAsync({ operation: this._rawIndex.getAllKeys.bind(this._rawIndex, n, t), source: this }) }count (e) { return Hk(this), e === null && (e = void 0), void 0 === e || e instanceof Ok || (e = Ok.only(_k(e))), this.objectStore.transaction._execRequestAsync({ operation: () => { let t = 0; const n = new Ck(this, e); for (;n._iterate() !== null;)t += 1; return t }, source: this }) }toString () { return '[object IDBIndex]' }}; const Kk = (e, t) => { if (Array.isArray(e)) throw new Error('The key paths used in this section are always strings and never sequences, since it is not possible to create a object store which has a key generator and also has a key path that is a sequence.'); const n = e.split('.'); if (n.length === 0) throw new Error('Assert: identifiers is not empty'); n.pop(); for (const e of n) { if (typeof t !== 'object' && !Array.isArray(t)) return !1; if (!t.hasOwnProperty(e)) return !0; t = t[e] } return typeof t === 'object' || Array.isArray(t) }; function Vk (e, t) { let n; let r = 0; let i = e.length; for (;r < i;)n = r + i >>> 1, Sk(e[n].key, t) < 0 ? r = n + 1 : i = n; return r } function Wk (e, t) { const n = Vk(e, t); const r = e[n]; return r && Sk(r.key, t) === 0 ? n : -1 } function $k (e, t) { const n = void 0 === t.lower ? 0 : Vk(e, t.lower); const r = void 0 === t.upper ? e.length - 1 : Vk(e, t.upper); for (let i = n; i <= r; i++) { const n = e[i]; if (n && t.includes(n.key)) return i } return -1 } const Gk = class {records = []; get (e) { return e instanceof Ok ? (t = this.records)[$k(t, e)] : (function (e, t) { return e[Wk(e, t)] }(this.records, e)); let t }add (e) { let t; if (this.records.length === 0)t = 0; else if (t = (function (e, t) { const n = Vk(e, t); const r = e[n]; return r && Sk(r.key, t) >= 0 ? n : -1 }(this.records, e.key)), t === -1)t = this.records.length; else for (;t < this.records.length && Sk(this.records[t].key, e.key) === 0 && Sk(this.records[t].value, e.value) === -1;)t += 1; this.records.splice(t, 0, e) }delete (e) { const t = []; const n = e instanceof Ok; for (;;) { const r = n ? $k(this.records, e) : Wk(this.records, e); if (r === -1) break; t.push(this.records[r]), this.records.splice(r, 1) } return t }deleteByValue (e) { const t = e instanceof Ok ? e : Ok.only(e); const n = []; return this.records = this.records.filter(e => { const r = t.includes(e.value); return r && n.push(e), !r }), n }clear () { const e = this.records.slice(); return this.records = [], e }values (e, t = 'next') { return { [Symbol.iterator]: () => { let n; if (t === 'next') { if (n = 0, void 0 !== e && void 0 !== e.lower) for (;void 0 !== this.records[n];) { const t = Sk(this.records[n].key, e.lower); if (t === 1 || t === 0 && !e.lowerOpen) break; n += 1 } } else if (n = this.records.length - 1, void 0 !== e && void 0 !== e.upper) for (;void 0 !== this.records[n];) { const t = Sk(this.records[n].key, e.upper); if (t === -1 || t === 0 && !e.upperOpen) break; n -= 1 } return { next: () => { let r, i; if (t === 'next') { if (i = this.records[n], r = n >= this.records.length, n += 1, !r && void 0 !== e && void 0 !== e.upper) { const t = Sk(i.key, e.upper); r = t === 1 || t === 0 && e.upperOpen, r && (i = void 0) } } else if (i = this.records[n], r = n < 0, n -= 1, !r && void 0 !== e && void 0 !== e.lower) { const t = Sk(i.key, e.lower); r = t === -1 || t === 0 && e.lowerOpen, r && (i = void 0) } return { done: r, value: i } } } } } }}; const Yk = class {deleted = !1; initialized = !1; records = new Gk(); constructor (e, t, n, r, i) { this.rawObjectStore = e, this.name = t, this.keyPath = n, this.multiEntry = r, this.unique = i }getKey (e) { const t = this.records.get(e); return void 0 !== t ? t.value : void 0 }getAllKeys (e, t) { void 0 !== t && t !== 0 || (t = 1 / 0); const n = []; for (const r of this.records.values(e)) if (n.push(Tk(r.value)), n.length >= t) break; return n }getValue (e) { const t = this.records.get(e); return void 0 !== t ? this.rawObjectStore.getValue(t.value) : void 0 }getAllValues (e, t) { void 0 !== t && t !== 0 || (t = 1 / 0); const n = []; for (const r of this.records.values(e)) if (n.push(this.rawObjectStore.getValue(r.value)), n.length >= t) break; return n }storeRecord (e) { let t; try { t = Ik(this.keyPath, e.value) } catch (e) { if (e.name === 'DataError') return; throw e } if (this.multiEntry && Array.isArray(t)) { const e = []; for (const n of t) if (e.indexOf(n) < 0) try { e.push(_k(n)) } catch (e) {}t = e } else try { _k(t) } catch (e) { return } if (this.multiEntry && Array.isArray(t)) { if (this.unique) for (const e of t) { if (this.records.get(e)) throw new dk() } } else if (this.unique) { if (this.records.get(t)) throw new dk() } if (this.multiEntry && Array.isArray(t)) for (const n of t) this.records.add({ key: n, value: e.key }); else this.records.add({ key: t, value: e.key }) }initialize (e) { if (this.initialized) throw new Error('Index already initialized'); e._execRequestAsync({ operation: () => { try { for (const e of this.rawObjectStore.records.values()) this.storeRecord(e); this.initialized = !0 } catch (t) { e._abort(t.name) } }, source: null }) }}; const Zk = (e, t) => { if (e == null || typeof e === 'string' || !e.toString || t !== 'array' && Array.isArray(e) || (e = e.toString()), typeof e === 'string') { if (e === '' && t !== 'string') return; try { const t = /^(?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])(?:[\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])*$/; if (e.length >= 1 && t.test(e)) return } catch (e) { throw new SyntaxError(e.message) } if (e.indexOf(' ') >= 0) throw new SyntaxError('The keypath argument contains an invalid key path (no spaces allowed).') } if (Array.isArray(e) && e.length > 0) { if (t) throw new SyntaxError('The keypath argument contains an invalid key path (nested arrays).'); for (const t of e)Zk(t, 'array') } else { if (!(typeof e === 'string' && e.indexOf('.') >= 0)) throw new SyntaxError(); e = e.split('.'); for (const t of e)Zk(t, 'string') } }; const Jk = Zk; const Xk = e => { if (e._rawObjectStore.deleted) throw new gk(); if (e.transaction._state !== 'active') throw new bk() }; const Qk = (e, t, n) => { if (Xk(e), e.transaction.mode === 'readonly') throw new yk(); if (e.keyPath !== null && void 0 !== n) throw new hk(); const r = Tk(t); if (e.keyPath !== null) { const t = Ik(e.keyPath, r); if (void 0 !== t)_k(t); else { if (!e._rawObjectStore.keyGenerator) throw new hk(); if (!Kk(e.keyPath, r)) throw new hk() } } if (e.keyPath === null && e._rawObjectStore.keyGenerator === null && void 0 === n) throw new hk(); return void 0 !== n && (n = _k(n)), { key: n, value: r } }; const eS = class {_indexesCache = new Map(); constructor (e, t) { this._rawObjectStore = t, this._name = t.name, this.keyPath = t.keyPath, this.autoIncrement = t.autoIncrement, this.transaction = e, this.indexNames = new zk(...Array.from(t.rawIndexes.keys()).sort()) } get name () { return this._name } set name (e) { const t = this.transaction; if (!t.db._runningVersionchangeTransaction) throw new gk(); if (Xk(this), (e = String(e)) === this._name) return; if (this._rawObjectStore.rawDatabase.rawObjectStores.has(e)) throw new dk(); const n = this._name; const r = [...t.db.objectStoreNames]; this._name = e, this._rawObjectStore.name = e, this.transaction._objectStoresCache.delete(n), this.transaction._objectStoresCache.set(e, this), this._rawObjectStore.rawDatabase.rawObjectStores.delete(n), this._rawObjectStore.rawDatabase.rawObjectStores.set(e, this._rawObjectStore), t.db.objectStoreNames = new zk(...Array.from(this._rawObjectStore.rawDatabase.rawObjectStores.keys()).filter(e => { const t = this._rawObjectStore.rawDatabase.rawObjectStores.get(e); return t && !t.deleted }).sort()); const i = new Set(t._scope); const o = [...t.objectStoreNames]; this.transaction._scope.delete(n), t._scope.add(e), t.objectStoreNames = new zk(...Array.from(t._scope).sort()), t._rollbackLog.push(() => { this._name = n, this._rawObjectStore.name = n, this.transaction._objectStoresCache.delete(e), this.transaction._objectStoresCache.set(n, this), this._rawObjectStore.rawDatabase.rawObjectStores.delete(e), this._rawObjectStore.rawDatabase.rawObjectStores.set(n, this._rawObjectStore), t.db.objectStoreNames = new zk(...r), t._scope = i, t.objectStoreNames = new zk(...o) }) }put (e, t) { if (arguments.length === 0) throw new TypeError(); const n = Qk(this, e, t); return this.transaction._execRequestAsync({ operation: this._rawObjectStore.storeRecord.bind(this._rawObjectStore, n, !1, this.transaction._rollbackLog), source: this }) }add (e, t) { if (arguments.length === 0) throw new TypeError(); const n = Qk(this, e, t); return this.transaction._execRequestAsync({ operation: this._rawObjectStore.storeRecord.bind(this._rawObjectStore, n, !0, this.transaction._rollbackLog), source: this }) }delete (e) { if (arguments.length === 0) throw new TypeError(); if (Xk(this), this.transaction.mode === 'readonly') throw new yk(); return e instanceof Ok || (e = _k(e)), this.transaction._execRequestAsync({ operation: this._rawObjectStore.deleteRecord.bind(this._rawObjectStore, e, this.transaction._rollbackLog), source: this }) }get (e) { if (arguments.length === 0) throw new TypeError(); return Xk(this), e instanceof Ok || (e = _k(e)), this.transaction._execRequestAsync({ operation: this._rawObjectStore.getValue.bind(this._rawObjectStore, e), source: this }) }getAll (e, t) { arguments.length > 1 && void 0 !== t && (t = Mk(t, 'unsigned long')), Xk(this); const n = Fk(e); return this.transaction._execRequestAsync({ operation: this._rawObjectStore.getAllValues.bind(this._rawObjectStore, n, t), source: this }) }getKey (e) { if (arguments.length === 0) throw new TypeError(); return Xk(this), e instanceof Ok || (e = _k(e)), this.transaction._execRequestAsync({ operation: this._rawObjectStore.getKey.bind(this._rawObjectStore, e), source: this }) }getAllKeys (e, t) { arguments.length > 1 && void 0 !== t && (t = Mk(t, 'unsigned long')), Xk(this); const n = Fk(e); return this.transaction._execRequestAsync({ operation: this._rawObjectStore.getAllKeys.bind(this._rawObjectStore, n, t), source: this }) }clear () { if (Xk(this), this.transaction.mode === 'readonly') throw new yk(); return this.transaction._execRequestAsync({ operation: this._rawObjectStore.clear.bind(this._rawObjectStore, this.transaction._rollbackLog), source: this }) }openCursor (e, t) { Xk(this), e === null && (e = void 0), void 0 === e || e instanceof Ok || (e = Ok.only(_k(e))); const n = new Uk(); n.source = this, n.transaction = this.transaction; const r = new Bk(this, e, t, n); return this.transaction._execRequestAsync({ operation: r._iterate.bind(r), request: n, source: this }) }openKeyCursor (e, t) { Xk(this), e === null && (e = void 0), void 0 === e || e instanceof Ok || (e = Ok.only(_k(e))); const n = new Uk(); n.source = this, n.transaction = this.transaction; const r = new Ck(this, e, t, n, !0); return this.transaction._execRequestAsync({ operation: r._iterate.bind(r), request: n, source: this }) }createIndex (e, t, n = {}) { if (arguments.length < 2) throw new TypeError(); const r = void 0 !== n.multiEntry && n.multiEntry; const i = void 0 !== n.unique && n.unique; if (this.transaction.mode !== 'versionchange') throw new gk(); if (Xk(this), this.indexNames.contains(e)) throw new dk(); if (Jk(t), Array.isArray(t) && r) throw new pk(); const o = [...this.indexNames]; this.transaction._rollbackLog.push(() => { const t = this._rawObjectStore.rawIndexes.get(e); t && (t.deleted = !0), this.indexNames = new zk(...o), this._rawObjectStore.rawIndexes.delete(e) }); const a = new Yk(this._rawObjectStore, e, t, r, i); return this.indexNames._push(e), this.indexNames._sort(), this._rawObjectStore.rawIndexes.set(e, a), a.initialize(this.transaction), new qk(this, a) }index (e) { if (arguments.length === 0) throw new TypeError(); if (this._rawObjectStore.deleted || this.transaction._state === 'finished') throw new gk(); const t = this._indexesCache.get(e); if (void 0 !== t) return t; const n = this._rawObjectStore.rawIndexes.get(e); if (!this.indexNames.contains(e) || void 0 === n) throw new mk(); const r = new qk(this, n); return this._indexesCache.set(e, r), r }deleteIndex (e) { if (arguments.length === 0) throw new TypeError(); if (this.transaction.mode !== 'versionchange') throw new gk(); Xk(this); const t = this._rawObjectStore.rawIndexes.get(e); if (void 0 === t) throw new mk(); this.transaction._rollbackLog.push(() => { t.deleted = !1, this._rawObjectStore.rawIndexes.set(e, t), this.indexNames._push(e), this.indexNames._sort() }), this.indexNames = new zk(...Array.from(this.indexNames).filter(t => t !== e)), t.deleted = !0, this.transaction._execRequestAsync({ operation: () => { const n = this._rawObjectStore.rawIndexes.get(e); t === n && this._rawObjectStore.rawIndexes.delete(e) }, source: this }) }count (e) { return Xk(this), e === null && (e = void 0), void 0 === e || e instanceof Ok || (e = Ok.only(_k(e))), this.transaction._execRequestAsync({ operation: () => { let t = 0; const n = new Ck(this, e); for (;n._iterate() !== null;)t += 1; return t }, source: this }) }toString () { return '[object IDBObjectStore]' }}; const tS = class {eventPath = []; NONE = 0; CAPTURING_PHASE = 1; AT_TARGET = 2; BUBBLING_PHASE = 3; propagationStopped = !1; immediatePropagationStopped = !1; canceled = !1; initialized = !0; dispatched = !1; target = null; currentTarget = null; eventPhase = 0; defaultPrevented = !1; isTrusted = !1; timeStamp = Date.now(); constructor (e, t = {}) { this.type = e, this.bubbles = void 0 !== t.bubbles && t.bubbles, this.cancelable = void 0 !== t.cancelable && t.cancelable }preventDefault () { this.cancelable && (this.canceled = !0) }stopPropagation () { this.propagationStopped = !0 }stopImmediatePropagation () { this.propagationStopped = !0, this.immediatePropagationStopped = !0 }}; const nS = globalThis.setImmediate || (function () { if (typeof navigator !== 'undefined' && /jsdom/.test(navigator.userAgent)) { return new (0, Node.constructor)('return setImmediate')() } }()) || (e => setTimeout(e, 0)); const rS = class extends Dk {_state = 'active'; _started = !1; _rollbackLog = []; _objectStoresCache = new Map(); error = null; onabort = null; oncomplete = null; onerror = null; _requests = []; constructor (e, t, n) { super(), this._scope = new Set(e), this.mode = t, this.db = n, this.objectStoreNames = new zk(...Array.from(this._scope).sort()) }_abort (e) { for (const e of this._rollbackLog.reverse())e(); if (e !== null) { const t = new Error(); t.name = e, this.error = t } for (const { request: e } of this._requests) if (e.readyState !== 'done' && (e.readyState = 'done', e.source)) { e.result = void 0, e.error = new lk(); const t = new tS('error', { bubbles: !0, cancelable: !0 }); t.eventPath = [this.db, this], e.dispatchEvent(t) }nS(() => { const e = new tS('abort', { bubbles: !0, cancelable: !1 }); e.eventPath = [this.db], this.dispatchEvent(e) }), this._state = 'finished' }abort () { if (this._state === 'committing' || this._state === 'finished') throw new gk(); this._state = 'active', this._abort(null) }objectStore (e) { if (this._state !== 'active') throw new gk(); const t = this._objectStoresCache.get(e); if (void 0 !== t) return t; const n = this.db._rawDatabase.rawObjectStores.get(e); if (!this._scope.has(e) || void 0 === n) throw new mk(); const r = new eS(this, n); return this._objectStoresCache.set(e, r), r }_execRequestAsync (e) { const t = e.source; const n = e.operation; let r = e.hasOwnProperty('request') ? e.request : null; if (this._state !== 'active') throw new bk(); return r || (t ? (r = new Uk(), r.source = t, r.transaction = t.transaction) : r = new Uk()), this._requests.push({ operation: n, request: r }), r }_start () { let e, t; for (this._started = !0; this._requests.length > 0;) { const n = this._requests.shift(); if (n && n.request.readyState !== 'done') { t = n.request, e = n.operation; break } } if (t && e) { if (t.source) { let n, r; try { const n = e(); t.readyState = 'done', t.result = n, t.error = void 0, this._state === 'inactive' && (this._state = 'active'), r = new tS('success', { bubbles: !1, cancelable: !1 }) } catch (e) { t.readyState = 'done', t.result = void 0, t.error = e, this._state === 'inactive' && (this._state = 'active'), r = new tS('error', { bubbles: !0, cancelable: !0 }), n = this._abort.bind(this, e.name) } try { r.eventPath = [this.db, this], t.dispatchEvent(r) } catch (e) { throw this._state !== 'committing' && this._abort('AbortError'), e }r.canceled || n && n() } else e(); nS(this._start.bind(this)) } else if (this._state !== 'finished' && (this._state = 'finished', !this.error)) { const e = new tS('complete'); this.dispatchEvent(e) } }commit () { if (this._state !== 'active') throw new gk(); this._state = 'committing' }toString () { return '[object IDBRequest]' }}; const iS = 9007199254740992; const oS = class {num = 0; next () { if (this.num >= iS) throw new dk(); return this.num += 1, this.num }setIfLarger (e) { const t = Math.floor(Math.min(e, iS)) - 1; t >= this.num && (this.num = t + 1) }}; const aS = class {deleted = !1; records = new Gk(); rawIndexes = new Map(); constructor (e, t, n, r) { this.rawDatabase = e, this.keyGenerator = !0 === r ? new oS() : null, this.deleted = !1, this.name = t, this.keyPath = n, this.autoIncrement = r }getKey (e) { const t = this.records.get(e); return void 0 !== t ? Tk(t.key) : void 0 }getAllKeys (e, t) { void 0 !== t && t !== 0 || (t = 1 / 0); const n = []; for (const r of this.records.values(e)) if (n.push(Tk(r.key)), n.length >= t) break; return n }getValue (e) { const t = this.records.get(e); return void 0 !== t ? Tk(t.value) : void 0 }getAllValues (e, t) { void 0 !== t && t !== 0 || (t = 1 / 0); const n = []; for (const r of this.records.values(e)) if (n.push(Tk(r.value)), n.length >= t) break; return n }storeRecord (e, t, n) { if (this.keyPath !== null) { const t = Ik(this.keyPath, e.value); void 0 !== t && (e.key = t) } if (this.keyGenerator !== null && void 0 === e.key) { if (n) { const e = this.keyGenerator.num; n.push(() => { this.keyGenerator && (this.keyGenerator.num = e) }) } if (e.key = this.keyGenerator.next(), this.keyPath !== null) { if (Array.isArray(this.keyPath)) throw new Error('Cannot have an array key path in an object store with a key generator'); let t; let n = this.keyPath; let r = e.value; let i = 0; for (;i >= 0;) { if (typeof r !== 'object') throw new hk(); i = n.indexOf('.'), i >= 0 && (t = n.slice(0, i), n = n.slice(i + 1), r.hasOwnProperty(t) || (r[t] = {}), r = r[t]) }t = n, r[t] = e.key } } else this.keyGenerator !== null && typeof e.key === 'number' && this.keyGenerator.setIfLarger(e.key); if (this.records.get(e.key)) { if (t) throw new dk(); this.deleteRecord(e.key, n) } this.records.add(e), n && n.push(() => { this.deleteRecord(e.key) }); for (const t of this.rawIndexes.values())t.initialized && t.storeRecord(e); return e.key }deleteRecord (e, t) { const n = this.records.delete(e); if (t) for (const e of n)t.push(() => { this.storeRecord(e, !0) }); for (const t of this.rawIndexes.values())t.records.deleteByValue(e) }clear (e) { const t = this.records.clear(); if (e) for (const n of t)e.push(() => { this.storeRecord(n, !0) }); for (const e of this.rawIndexes.values())e.records.clear() }}; const sS = e => { if (!e._runningVersionchangeTransaction) throw new gk(); const t = e._rawDatabase.transactions.filter(e => e.mode === 'versionchange'); const n = t[t.length - 1]; if (!n || n._state === 'finished') throw new gk(); if (n._state !== 'active') throw new bk(); return n }; const cS = e => { e._closePending = !0; e._rawDatabase.transactions.every(e => e._state === 'finished') ? (e._closed = !0, e._rawDatabase.connections = e._rawDatabase.connections.filter(t => e !== t)) : nS(() => { cS(e) }) }; const uS = class extends Dk {_closePending = !1; _closed = !1; _runningVersionchangeTransaction = !1; constructor (e) { super(), this._rawDatabase = e, this._rawDatabase.connections.push(this), this.name = e.name, this.version = e.version, this.objectStoreNames = new zk(...Array.from(e.rawObjectStores.keys()).sort()) }createObjectStore (e, t = {}) { if (void 0 === e) throw new TypeError(); const n = sS(this); const r = t !== null && void 0 !== t.keyPath ? t.keyPath : null; const i = t !== null && void 0 !== t.autoIncrement && t.autoIncrement; if (r !== null && Jk(r), this._rawDatabase.rawObjectStores.has(e)) throw new dk(); if (i && (r === '' || Array.isArray(r))) throw new pk(); const o = [...this.objectStoreNames]; n._rollbackLog.push(() => { const t = this._rawDatabase.rawObjectStores.get(e); t && (t.deleted = !0), this.objectStoreNames = new zk(...o), n._scope.delete(e), this._rawDatabase.rawObjectStores.delete(e) }); const a = new aS(this._rawDatabase, e, r, i); return this.objectStoreNames._push(e), this.objectStoreNames._sort(), n._scope.add(e), this._rawDatabase.rawObjectStores.set(e, a), n.objectStoreNames = new zk(...this.objectStoreNames), n.objectStore(e) }deleteObjectStore (e) { if (void 0 === e) throw new TypeError(); const t = sS(this); const n = this._rawDatabase.rawObjectStores.get(e); if (void 0 === n) throw new mk(); this.objectStoreNames = new zk(...Array.from(this.objectStoreNames).filter(t => t !== e)), t.objectStoreNames = new zk(...this.objectStoreNames), t._rollbackLog.push(() => { n.deleted = !1, this._rawDatabase.rawObjectStores.set(e, n), this.objectStoreNames._push(e), this.objectStoreNames._sort() }), n.deleted = !0, this._rawDatabase.rawObjectStores.delete(e), t._objectStoresCache.delete(e) }transaction (e, t) { if ((t = void 0 !== t ? t : 'readonly') !== 'readonly' && t !== 'readwrite' && t !== 'versionchange') throw new TypeError('Invalid mode: ' + t); if (this._rawDatabase.transactions.some(e => e._state === 'active' && e.mode === 'versionchange' && e.db === this)) throw new gk(); if (this._closePending) throw new gk(); if (Array.isArray(e) || (e = [e]), e.length === 0 && t !== 'versionchange') throw new pk(); for (const t of e) if (!this.objectStoreNames.contains(t)) throw new mk('No objectStore named ' + t + ' in this database'); const n = new rS(e, t, this); return this._rawDatabase.transactions.push(n), this._rawDatabase.processTransactions(), n }close () { cS(this) }toString () { return '[object IDBDatabase]' }}; const lS = class extends Uk {onupgradeneeded = null; onblocked = null; toString () { return '[object IDBOpenDBRequest]' }}; const dS = class extends tS {constructor (e, t = {}) { super(e), this.newVersion = void 0 !== t.newVersion ? t.newVersion : null, this.oldVersion = void 0 !== t.oldVersion ? t.oldVersion : 0 }toString () { return '[object IDBVersionChangeEvent]' }}; const fS = class {deletePending = !1; transactions = []; rawObjectStores = new Map(); connections = []; constructor (e, t) { this.name = e, this.version = t, this.processTransactions = this.processTransactions.bind(this) }processTransactions () { nS(() => { if (!this.transactions.some(e => e._started && e._state !== 'finished')) { const e = this.transactions.find(e => !e._started && e._state !== 'finished'); e && (e.addEventListener('complete', this.processTransactions), e.addEventListener('abort', this.processTransactions), e._start()) } }) }}; const hS = (e, t, n, r) => { n.some(e => !e._closed && !e._closePending) ? nS(() => hS(e, t, n, r)) : (e.delete(t), r(null)) }; const pS = (e, t, n, r, i) => { let o = e.get(t); if (void 0 === o && (o = new fS(t, 0), e.set(t, o)), void 0 === n && (n = o.version !== 0 ? o.version : 1), o.version > n) return i(new vk()); const a = new uS(o); o.version < n ? ((e, t, n, r) => { e._runningVersionchangeTransaction = !0; const i = e.version; const o = e._rawDatabase.connections.filter(t => e !== t); for (const e of o) if (!e._closed && !e._closePending) { const n = new dS('versionchange', { newVersion: t, oldVersion: i }); e.dispatchEvent(n) } if (o.some(e => !e._closed && !e._closePending)) { const e = new dS('blocked', { newVersion: t, oldVersion: i }); n.dispatchEvent(e) } const a = () => { if (o.some(e => !e._closed && !e._closePending)) return void nS(a); e._rawDatabase.version = t, e.version = t; const s = e.transaction(e.objectStoreNames, 'versionchange'); n.result = e, n.readyState = 'done', n.transaction = s, s._rollbackLog.push(() => { e._rawDatabase.version = i, e.version = i }); const c = new dS('upgradeneeded', { newVersion: t, oldVersion: i }); n.dispatchEvent(c), s.addEventListener('error', () => { e._runningVersionchangeTransaction = !1 }), s.addEventListener('abort', () => { e._runningVersionchangeTransaction = !1, n.transaction = null, nS(() => { r(new lk()) }) }), s.addEventListener('complete', () => { e._runningVersionchangeTransaction = !1, n.transaction = null, nS(() => { e._closePending ? r(new lk()) : r(null) }) }) }; a() })(a, n, r, e => { if (e) return i(e); i(null, a) }) : i(null, a) }; const gS = class {cmp = Sk; _databases = new Map(); deleteDatabase (e) { const t = new lS(); return t.source = null, nS(() => { const n = this._databases.get(e); const r = void 0 !== n ? n.version : 0; ((e, t, n, r) => { try { const i = e.get(t); if (void 0 === i) return void r(null); i.deletePending = !0; const o = i.connections.filter(e => !e._closed && !e._closePending); for (const e of o) if (!e._closePending) { const t = new dS('versionchange', { newVersion: null, oldVersion: i.version }); e.dispatchEvent(t) } const a = o.some(e => !e._closed && !e._closePending); if (n && a) { const e = new dS('blocked', { newVersion: null, oldVersion: i.version }); n.dispatchEvent(e) }hS(e, t, o, r) } catch (e) { r(e) } })(this._databases, e, t, e => { if (e) { t.error = new Error(), t.error.name = e.name, t.readyState = 'done'; const n = new tS('error', { bubbles: !0, cancelable: !0 }); return n.eventPath = [], void t.dispatchEvent(n) }t.result = void 0, t.readyState = 'done'; const n = new dS('success', { newVersion: null, oldVersion: r }); t.dispatchEvent(n) }) }), t }open (e, t) { if (arguments.length > 1 && void 0 !== t && (t = Mk(t, 'MAX_SAFE_INTEGER')), t === 0) throw new TypeError(); const n = new lS(); return n.source = null, nS(() => { pS(this._databases, e, t, n, (e, t) => { if (e) { n.result = void 0, n.readyState = 'done', n.error = new Error(), n.error.name = e.name; const t = new tS('error', { bubbles: !0, cancelable: !0 }); return t.eventPath = [], void n.dispatchEvent(t) }n.result = t, n.readyState = 'done'; const r = new tS('success'); r.eventPath = [], n.dispatchEvent(r) }) }), n }databases () { return new Promise(e => { const t = []; for (const [e, n] of this._databases)t.push({ name: e, version: n.version }); e(t) }) }toString () { return '[object IDBFactory]' }}; const mS = new gS(); const yS = new class extends WE {allowances; payments; blocklist; permissions; constructor () { super('LBE'), this.version(1).stores({ allowances: '++id,&host,name,imageURL,tag,enabled,totalBudget,remainingBudget,lastPaymentAt,lnurlAuth,createdAt', payments: '++id,allowanceId,host,location,name,description,totalAmount,totalFees,preimage,paymentRequest,paymentHash,destination,createdAt' }), this.version(2).stores({ blocklist: '++id,host,name,imageURL,isBlocked,createdAt' }), this.version(3).stores({ permissions: '++id,allowanceId,host,method,enabled,blocked,createdAt' }), this.version(4).stores({ permissions: '++id,accountId,allowanceId,host,method,enabled,blocked,createdAt' }), this.version(5).stores({ payments: '++id,accountId,allowanceId,host,location,name,description,totalAmount,totalFees,preimage,paymentRequest,paymentHash,destination,createdAt' }), this.on('ready', this.loadFromStorage.bind(this)), this.allowances = this.table('allowances'), this.payments = this.table('payments'), this.blocklist = this.table('blocklist'), this.permissions = this.table('permissions') } async openWithInMemoryDB () { return console.info('Opening DB using fake indexedDB'), this._options.indexedDB = mS, this._options.IDBKeyRange = Ok, this._deps.indexedDB = mS, this._deps.IDBKeyRange = Ok, this.open() } async saveToStorage () { const e = await this.allowances.toArray(); const t = await this.payments.toArray(); const n = await this.blocklist.toArray(); const r = await this.permissions.toArray(); return await i().storage.local.set({ allowances: e, payments: t, blocklist: n, permissions: r }), !0 } async clearAllTables () { return Promise.all(this.tables.map(e => e.clear())) } async loadFromStorage () { return console.info(`Current DB version: ${this.verno}`), console.info('Loading DB data from storage'), i().storage.local.get(['allowances', 'payments', 'blocklist', 'permissions']).then(e => { const t = this.allowances.count().then(t => { if (!(t > 0)) return e.allowances && e.allowances.length > 0 ? this.allowances.bulkAdd(e.allowances).catch(WE.BulkError, function (e) { console.error('Failed to add allowances; ignoring', e) }) : void 0; console.info(`Found ${t} allowances already in the DB`) }); const n = this.payments.count().then(t => { if (!(t > 0)) return e.payments && e.payments.length > 0 ? this.payments.bulkAdd(e.payments).catch(WE.BulkError, function (e) { console.error('Failed to add payments; ignoring', e) }) : void 0; console.info(`Found ${t} payments already in the DB`) }); const r = this.blocklist.count().then(t => { if (!(t > 0)) return e.blocklist && e.blocklist.length > 0 ? this.blocklist.bulkAdd(e.blocklist).catch(WE.BulkError, function (e) { console.error('Failed to add blocklist; ignoring', e) }) : void 0; console.info(`Found ${t} blocklist already in the DB`) }); const i = this.permissions.count().then(t => { if (!(t > 0)) return e.permissions && e.permissions.length > 0 ? this.permissions.bulkAdd(e.permissions).catch(WE.BulkError, function (e) { console.error('Failed to add permissions; ignoring', e) }) : void 0; console.info(`Found ${t} permissions already in the DB`) }); return Promise.all([t, n, r, i]) }).catch(e => { console.error('Failed to load DB data from storage', e) }) }}(); const bS = yS; async function vS (e, t) { if (!t) return !1; const n = await bS.allowances.where('host').equalsIgnoreCase(t).first(); if (!n?.id) return Promise.reject(new Error('Could not find an allowance for this host')); const r = NS.getState().currentAccountId; if (!r) return Promise.reject(new Error("Account doesn't exist")); const i = await bS.permissions.get({ host: t, method: e, accountId: r }); return !!i?.enabled } async function wS (e, t) { const n = NS.getState().currentAccountId; const r = await bS.allowances.get({ host: t }); if (!r?.id || !n) return !1; return !!await bS.permissions.add({ createdAt: Date.now().toString(), accountId: n, allowanceId: r.id, host: t, method: e, enabled: !0, blocked: !1 }) && await bS.saveToStorage() } function _S (e) { if (!(e instanceof Object)) return !1; if (typeof e.kind !== 'number') return !1; if (typeof e.content !== 'string') return !1; if (typeof e.created_at !== 'number') return !1; if (!Array.isArray(e.tags)) return !1; for (let t = 0; t < e.tags.length; t++) { const n = e.tags[t]; if (!Array.isArray(n)) return !1; for (let e = 0; e < n.length; e++) if (typeof n[e] === 'object') return !1 } return !0 } function ES (e) { return ol()(function (e) { if (!_S(e)) throw new Error("can't serialize event with wrong or missing properties"); return JSON.stringify([0, e.pubkey, e.created_at, e.kind, e.tags, e.content]) }(e)).toString(rl()) } const kS = class {privateKey; constructor (e) { this.privateKey = e }getPublicKey () { const e = Lu.getPublicKey(wn.hexToBytes(this.privateKey)); return wn.bytesToHex(e) } async signEvent (e) { const t = await (async function (e, t) { const n = await Lu.sign(ES(e), t); return wn.bytesToHex(n) }(e, this.privateKey)); return e.sig = t, e } async signSchnorr (e) { const t = await Lu.sign($g.Buffer.from(wn.hexToBytes(e)), wn.hexToBytes(this.privateKey)); return wn.bytesToHex(t) }encrypt (e, t) { const n = bn(this.privateKey, '02' + e); const r = $g.Buffer.from(n.slice(1, 33)); const i = wn.bytesToHex(r); const o = rl().parse(i); const a = v.AES.encrypt(t, o, { iv: v.lib.WordArray.random(16) }); return `${a.toString()}?iv=${a.iv.toString(v.enc.Base64)}` } async decrypt (e, t) { const [n, r] = t.split('?iv='); const i = bn(this.privateKey, '02' + e); const o = $g.Buffer.from(i.slice(1, 33)); const a = wn.bytesToHex(o); const s = rl().parse(a); const c = v.AES.decrypt(n, s, { iv: eb().parse(r) }); return ng().stringify(c) }getEventHash (e) { return ES(e) }}; const SS = { settings: { ...xt }, accounts: {}, currentAccountId: null, migrations: [], nostrPrivateKey: null }; const AS = Object.keys(SS); let OS = 'sync'; const xS = () => ({ connector: null, account: null, settings: { ...xt }, migrations: [], accounts: {}, currentAccountId: null, nostr: null, nostrPrivateKey: null, mnemonic: null, bitcoin: null, mv2Password: null }); const IS = (function (e) { const t = typeof e === 'function' ? y(e) : e; const n = (e = t.getState, n = Object.is) => { const [, r] = (0, m.useReducer)(e => e + 1, 0); const i = t.getState(); const o = (0, m.useRef)(i); const a = (0, m.useRef)(e); const s = (0, m.useRef)(n); const c = (0, m.useRef)(!1); const u = (0, m.useRef)(); let l; void 0 === u.current && (u.current = e(i)); let d = !1; (o.current !== i || a.current !== e || s.current !== n || c.current) && (l = e(i), d = !n(u.current, l)), b(() => { d && (u.current = l), o.current = i, a.current = e, s.current = n, c.current = !1 }); const f = (0, m.useRef)(i); b(() => { const e = () => { try { const e = t.getState(); const n = a.current(e); s.current(u.current, n) || (o.current = e, u.current = n, r()) } catch (e) { c.current = !0, r() } }; const n = t.subscribe(e); return t.getState() !== f.current && e(), n }, []); const h = d ? l : u.current; return (0, m.useDebugValue)(h), h }; return Object.assign(n, t), n[Symbol.iterator] = function () { console.warn('[useStore, api] = create() is deprecated and will be removed in v4'); const e = [n, t]; return { next () { const t = e.length <= 0; return { value: e.shift(), done: t } } } }, n }((e, t) => ({ ...xS(), password: async n => { if (d) { n && await i().storage.session.set({ password: n }); return (await i().storage.session.get('password')).password } return n && e({ mv2Password: n }), t().mv2Password }, getAccount: () => { const e = t().currentAccountId; let n = null; return e && (n = t().accounts[e]), n }, getConnector: async () => { if (t().connector) { return await t().connector } const n = (async () => { const e = t().currentAccountId; const n = t().accounts[e]; const r = await t().password(); if (!r) throw new Error('Password is not set'); const i = _(n.config, r); const o = new Xb[n.connector](n, i); return await o.init(), o })(); e({ connector: n }); return await n }, getNostr: async () => { const n = t().nostr; if (n) return n; const r = t().currentAccountId; const i = t().accounts[r]; const o = await t().password(); if (!o) throw new Error('Password is not set'); const a = _(i.nostrPrivateKey, o); const s = new kS(a); return e({ nostr: s }), s }, getMnemonic: async () => { const n = t().mnemonic; if (n) return n; const r = t().currentAccountId; const i = t().accounts[r]; const o = await t().password(); if (!o) throw new Error('Password is not set'); const a = _(i.mnemonic, o); const s = new al(a); return e({ mnemonic: s }), s }, getBitcoin: async () => { const n = t().bitcoin; if (n) return n; const r = await t().getMnemonic(); const i = t().currentAccountId; const o = t().accounts[i].bitcoinNetwork || 'bitcoin'; const a = new tc(r, o); return e({ bitcoin: a }), a }, lock: async () => { d ? await i().storage.session.set({ password: null }) : e({ mv2Password: null }); const n = await i().tabs.query({ title: 'Alby' }); const r = Array.from(n, e => e.id).filter(e => typeof e === 'number'); if (i().tabs.remove(r), t().connector) { const e = await t().connector; await e.unload() }e({ connector: null, account: null, nostr: null, mnemonic: null, bitcoin: null }) }, isUnlocked: async () => !!await await t().password(), init: () => i().storage.sync.get(AS).then(t => { const n = h()(SS, t); e(n) }).catch(t => (console.info('storage.sync is not available. using storage.local'), OS = 'local', i().storage.local.get('__sync').then(t => { const n = h()(SS, t.mockSync); e(n) }))), reset: async () => { try { await i().storage.session.clear() } catch (e) { console.error('Failed to clear session storage', e) }OS === 'sync' ? await i().storage.sync.clear() : await i().storage.local.clear(), e({ ...xS() }), await t().saveToStorage() }, saveToStorage: () => { const e = t(); const n = { ...SS, ...g()(e, AS) }; return OS === 'sync' ? i().storage.sync.set(n) : i().storage.local.set({ __sync: n }) } }))); const NS = IS; const TS = new Map(); let RS; !(function (e) { e.Default = 'alby_icon_yellow', e.Tipping = 'alby_icon_blue', e.Active = 'alby_icon_green' }(RS || (RS = {}))); const PS = async (e, t) => { const n = TS.get(t); if (n && n === RS.Active && e === RS.Tipping) return Promise.resolve(); TS.set(t, e); const r = NS.getState().settings.theme == 'dark' ? '_dark' : ''; const o = { path: { 16: `../assets/icons/${e}${r}_16x16.png`, 32: `../assets/icons/${e}${r}_32x32.png`, 48: `../assets/icons/${e}${r}_48x48.png`, 128: `../assets/icons/${e}${r}_128x128.png` }, tabId: t }; return d ? i().action.setIcon(o) : i().browserAction.setIcon(o) }; const CS = a(1798); const BS = a.n(CS); const LS = async (e, t) => { if (!t.origin || !t.origin.host) return; const n = t.origin.host; const r = t.response; if ('error' in r) return; const i = r.data.route; const { total_amt: o } = i; const a = await bS.allowances.where('host').equalsIgnoreCase(n).first(); if (!a || !a.id) return; const s = a.remainingBudget || 0; const c = Math.max(s - o, 0); return await bS.allowances.update(a.id, { remainingBudget: c, lastPaymentAt: Date.now() }), await bS.saveToStorage(), !0 }; const jS = a(7484); const DS = a.n(jS); const US = a(6121); const MS = a.n(US); DS().extend(MS()); const zS = async ({ rate: e, currency: t }) => { const n = { currency: t, rate: e, timestamp: Date.now() }; await i().storage.local.set({ currencyRate: JSON.stringify(n) }) }; const FS = async e => { const { settings: t } = NS.getState(); const { exchange: n } = t; let r; if (n === 'yadio') { r = await rb().get(`https://api.yadio.io/exrates/${e.toLowerCase()}`, { adapter: db }); return (await (r?.data)).BTC / yb } if (n === 'coindesk') { r = await rb().get(`https://api.coindesk.com/v1/bpi/currentprice/${e.toLowerCase()}.json`, { adapter: db }); return (await (r?.data)).bpi[e].rate_float / yb }r = await rb().get(`https://getalby.com/api/rates/${e.toLowerCase()}.json`, { adapter: db }); return (await (r?.data))[e].rate_float / yb }; const HS = async e => { let t = {}; const n = await i().storage.local.get(['currencyRate']); if (n.currencyRate && (t = JSON.parse(n.currencyRate), t.currency === e)) { if (DS()().isSameOrBefore(DS()(t?.timestamp).add(10, 'minute')) && t.rate) return t.rate; const n = await FS(e); return await zS({ rate: n, currency: e }), n } const r = await FS(e); return await zS({ currency: e, rate: r }), r }; const qS = async e => { const { currency: t } = NS.getState().settings; return { data: { rate: await HS(t) } } }; const KS = e => { if (!NS.getState().settings.browserNotifications) return; const t = { type: 'basic', iconUrl: '../assets/icons/alby_icon_yellow_48x48.png', ...e }; return i().notifications.create(t) }; const VS = async (e, t) => { const n = t?.origin?.name; const r = t.response; let i; if ('error' in r) return; const o = r?.data.route; const { total_amt: a, total_fees: s } = o; const c = a - s; const { settings: u } = NS.getState(); const { showFiat: l, currency: d, locale: f } = u; if (l) { const e = await HS(d); i = vb({ amount: c, rate: e, currency: d, locale: f }) } let h = ' Successfully paid'; n && (h = `${h} to ${n}`); let p = `Amount: ${wb({ amount: c, locale: f })}`; return l && (p = `${p} (${i})`), p = `${p}\nFee: ${wb({ amount: s, locale: f })}`, KS({ title: h, message: p }) }; const WS = (e, t) => { let n; const r = t.response; return 'error' in r && (n = r.error), KS({ title: ' Payment failed', message: `Error: ${n}` }) }; const $S = (e, t) => { let n = ' Login'; return t?.origin?.name && (n = `${n} to ${t.origin.name}`), KS({ title: n, message: `Successfully logged in to ${t.lnurlDetails.domain}` }) }; const GS = (e, t) => KS({ title: ' Login failed', message: `${t.error}` }); const YS = async (e, t) => { const n = t?.origin?.name; const r = t?.origin?.host || ''; const i = t?.origin?.location; const o = t.accountId; const a = t.response; if ('error' in a) return; const s = await bS.allowances.where('host').equalsIgnoreCase(r).first(); const c = a.data.route; const { total_amt: u, total_fees: l } = c; return await bS.payments.add({ accountId: o, host: r, location: i, name: n, description: t.details.description, preimage: a.data.preimage, paymentHash: a.data.paymentHash, destination: t.details.destination, totalAmount: u, totalFees: l, createdAt: Date.now().toString(), allowanceId: s ? (s.id ?? '').toString() : '', paymentRequest: '' }), await bS.saveToStorage(), console.info(`Persisted payment ${a.data.paymentHash}`), !0 }; const ZS = async () => {}; const JS = async e => { const t = e.args; const n = { ...NS.getState().accounts }; const r = await NS.getState().password(); if (!r) return { error: 'Password is missing' }; const i = NS.getState().currentAccountId; const o = Jy(); return t.config = w(t.config, r), n[o] = { ...t, id: o }, NS.setState({ accounts: n }), i || NS.setState({ currentAccountId: o }), await NS.getState().saveToStorage(), { data: { accountId: o } } }; const XS = async e => ({ data: await NS.getState().accounts }); const QS = async e => { const t = NS.getState().accounts; const n = await NS.getState().password(); if (!n) return { error: 'Password is missing' }; const r = e.args.id; if (r in t) { return { data: _(t[r].config, n) } } return { error: `Account not found: ${r}` } }; const eA = async e => { const t = NS.getState().accounts; const n = e.args.id; return n in t ? (e.args.name && (t[n].name = e.args.name), e.args.bitcoinNetwork && (t[n].bitcoinNetwork = e.args.bitcoinNetwork, NS.setState({ bitcoin: null })), void 0 !== e.args.useMnemonicForLnurlAuth && (t[n].useMnemonicForLnurlAuth = e.args.useMnemonicForLnurlAuth), NS.setState({ accounts: t }), await NS.getState().saveToStorage(), {}) : { error: `Account not found: ${n}` } }; const tA = async e => { const t = e?.args?.id || NS.getState().currentAccountId; if (!t) return { error: 'No account selected.' }; const n = NS.getState().accounts[t]; if (!n) return; return { data: { id: n.id, connectorType: n.connector, name: n.name, nostrEnabled: !!n.nostrPrivateKey, hasMnemonic: !!n.mnemonic, hasImportedNostrKey: !1 !== n.hasImportedNostrKey, bitcoinNetwork: n.bitcoinNetwork || 'bitcoin', useMnemonicForLnurlAuth: n.useMnemonicForLnurlAuth || !1 } } }; const nA = async e => { const t = await NS.getState().getConnector(); const n = NS.getState().currentAccountId; const r = NS.getState().getAccount(); const i = await t.getInfo(); const o = await t.getBalance(); if (!r || !n) return { error: 'No current account set' }; return { data: { currentAccountId: n, name: r.name, avatarUrl: r.avatarUrl, info: i.data, connectorType: r.connector, balance: { balance: o.data.balance, currency: o.data.currency || 'BTC' } } } }; const rA = async e => (await NS.getState().lock(), { data: { unlocked: !1 } }); const iA = async e => { const t = NS.getState().accounts; let n = NS.getState().currentAccountId; let r = e?.args?.id; if (r || n === null || (r = n), typeof r === 'string' || typeof r === 'number') { delete t[r], NS.setState({ accounts: t }); const e = NS.getState().accounts; const i = Object.keys(e); return r === n && i.length > 0 && (n = i[0], NS.setState({ currentAccountId: n })), await NS.getState().saveToStorage(), { data: { removed: r } } } return { error: `Account not found: ${r}` } }; const oA = async e => { const t = NS.getState(); const n = e.args.id; const r = t.accounts[n]; if (r) { if (t.connector) { console.info('Unloading connector'); const e = await t.connector; await e.unload() } return NS.setState({ account: r, nostr: null, mnemonic: null, bitcoin: null, connector: null, currentAccountId: n }), await NS.getState().getConnector(), await NS.getState().saveToStorage(), { data: { unlocked: !0 } } } return console.error(`Account not found: ${n}`), { error: `Account not found: ${n}` } }; const aA = async e => { const t = e.args.password; const n = typeof t === 'number' ? `${t}` : t; const r = NS.getState().getAccount(); const i = NS.getState().currentAccountId; if (!r) return console.error('No account configured'), Promise.resolve({ error: 'No account configured' }); if (typeof r.config !== 'string') return console.error('Config must be a string'), Promise.resolve({ error: 'Config must be a string' }); try { _(r.config, n) } catch (e) { return console.error('Invalid password'), Promise.resolve({ error: Ot.t('translation:unlock.errors.invalid_password') }) } await NS.getState().password(n); try { await NS.getState().getConnector() } catch (e) { console.error(e) } return { data: { unlocked: !0, currentAccountId: i } } }; const sA = async e => { const t = e.args.host; const n = e.args.name; const r = e.args.imageURL; const i = e.args.totalBudget; const o = await bS.allowances.where('host').equalsIgnoreCase(t).first(); if (o) { if (!o.id) return { error: 'id is missing' }; await bS.allowances.update(o.id, { enabled: !0, imageURL: r, name: n, remainingBudget: i, totalBudget: i }) } else { const e = { createdAt: Date.now().toString(), enabled: !0, host: t, imageURL: r, lastPaymentAt: 0, lnurlAuth: !1, name: n, remainingBudget: i, tag: '', totalBudget: i }; await bS.allowances.add(e) } return await bS.saveToStorage(), { data: { allowance: o } } }; const cA = async e => { const t = e.args.id; return t ? (await bS.allowances.delete(t), await bS.permissions.where({ allowanceId: t }).delete(), await bS.saveToStorage(), { data: !0 }) : { error: 'id is missing' } }; const uA = a(7715); const lA = a(8764).Buffer; function dA (e, t = 'utf-8') { const { words: n } = uA.bech32.decode(e, 2e3); const r = uA.bech32.fromWords(n); return lA.from(r).toString(t) } function fA (e) { return e.origin ? new URL(e.origin).host : e.url ? new URL(e.url).host : null } const hA = async (e, t) => { const n = fA(t); if (!n) return; const r = await NS.getState().isUnlocked(); const i = await bS.allowances.where('host').equalsIgnoreCase(n).first(); if (r && i && i.enabled) return { data: { enabled: !0 } }; try { const r = await l.openPrompt(e); if (r.data.enabled && t.tab && await PS(RS.Active, t.tab.id), r.data.enabled && r.data.remember) { if (i) { if (!i.id) return { data: { error: 'id is missing' } }; await bS.allowances.update(i.id, { enabled: !0, name: e.origin.name, imageURL: e.origin.icon }) } else await bS.allowances.add({ host: n, name: e.origin.name, imageURL: e.origin.icon, enabled: !0, lastPaymentAt: 0, totalBudget: 0, remainingBudget: 0, createdAt: Date.now().toString(), lnurlAuth: !1, tag: '' }); await bS.saveToStorage() } return { data: { enabled: r.data.enabled, remember: r.data.remember } } } catch (e) { if (console.error(e), e instanceof Error) return { error: e.message } } }; const pA = async e => { const t = e.args.host; const n = await bS.allowances.where('host').equalsIgnoreCase(t).first(); if (n && n.id) { const { id: e } = n; const t = { ...n, id: e, payments: [], paymentsAmount: 0, paymentsCount: 0, percentage: '0', usedBudget: 0 }; t.usedBudget = n.totalBudget - n.remainingBudget, t.percentage = (t.usedBudget / n.totalBudget * 100).toFixed(0), t.paymentsCount = await bS.payments.where('host').equalsIgnoreCase(n.host).count(); const r = await bS.payments.where('host').equalsIgnoreCase(n.host).reverse().toArray(); return t.payments = r.reduce((e, t) => { if (!t?.id) return e; const { id: n } = t; return e.push({ ...t, id: n }), e }, []), t.paymentsAmount = t.payments.map(e => typeof e.totalAmount === 'string' ? parseInt(e.totalAmount) : e.totalAmount).reduce((e, t) => e + t, 0), { data: t } } return { data: { enabled: !1 } } }; const gA = async e => { const { id: t } = e.args; const n = await bS.allowances.get({ id: t }); if (n) { const e = { ...n, id: t, payments: [], paymentsAmount: 0, paymentsCount: 0, percentage: '0', usedBudget: 0 }; e.usedBudget = n.totalBudget - n.remainingBudget, e.percentage = (e.usedBudget / n.totalBudget * 100).toFixed(0), e.paymentsCount = await bS.payments.where('host').equalsIgnoreCase(n.host).count(); const r = await bS.payments.where('host').equalsIgnoreCase(n.host).reverse().toArray(); return e.payments = r.reduce((e, t) => { if (!t?.id) return e; const { id: n } = t; return e.push({ ...t, id: n }), e }, []), e.paymentsAmount = e.payments.map(e => typeof e.totalAmount === 'string' ? parseInt(e.totalAmount) : e.totalAmount).reduce((e, t) => e + t, 0), { data: e } } return { data: { enabled: !1 } } }; const mA = async e => { const t = await bS.allowances.toCollection().reverse().sortBy('lastPaymentAt'); const n = []; for (const e of t) if (e.id) { const { id: t } = e; const r = { ...e, id: t, payments: [], paymentsAmount: 0, paymentsCount: 0, percentage: '0', usedBudget: 0 }; r.usedBudget = r.totalBudget - r.remainingBudget, r.percentage = (r.usedBudget / r.totalBudget * 100).toFixed(0), r.paymentsCount = await bS.payments.where('host').equalsIgnoreCase(r.host).count(); const i = await bS.payments.where('host').equalsIgnoreCase(r.host).reverse().toArray(); r.paymentsAmount = i.map(e => typeof e.totalAmount === 'string' ? parseInt(e.totalAmount) : e.totalAmount).reduce((e, t) => e + t, 0), n.push(r) } return { data: { allowances: n } } }; const yA = async e => { const t = e.args.id; if (!t) return { error: 'id is missing' }; const n = {}; Object.prototype.hasOwnProperty.call(e.args, 'totalBudget') && (n.totalBudget = e.args.totalBudget, n.remainingBudget = e.args.totalBudget), Object.prototype.hasOwnProperty.call(e.args, 'enabled') && (n.enabled = e.args.enabled), Object.prototype.hasOwnProperty.call(e.args, 'lnurlAuth') && (n.lnurlAuth = e.args.lnurlAuth); const r = await bS.allowances.update(t, n); return await bS.saveToStorage(), { data: r } }; const bA = async e => { const { host: t, name: n, imageURL: r } = e.args; return await bS.blocklist.add({ host: t, name: n, imageURL: r, isBlocked: !0 }), await bS.saveToStorage(), { data: !0 } }; const vA = async e => { const t = e.args.host; const n = await bS.blocklist.where('host').equalsIgnoreCase(t).first(); return n?.id && (await bS.blocklist.delete(n.id), await bS.saveToStorage()), { data: !0 } }; const wA = async e => { const t = e.args.host; return await bS.blocklist.where('host').equalsIgnoreCase(t).first() ? { data: { blocked: !0 } } : { data: { blocked: !1 } } }; const _A = async e => ({ data: { blocklist: await bS.blocklist.toArray() } }); const EA = async e => { if (typeof e.args.paymentHash !== 'string') return { error: 'Payment hash missing.' }; const t = await NS.getState().getConnector(); try { return await t.checkPayment({ paymentHash: e.args.paymentHash }) } catch (e) { if (e instanceof Error) return { error: e.message } } }; const kA = async e => { const { pubkey: t, host: n } = e.args; if (typeof t !== 'string' || typeof n !== 'string') return { error: 'Peer data missing.' }; const r = await NS.getState().getConnector(); const i = { pubkey: t, host: n }; let o; try { o = await r.connectPeer(i) } catch (e) { console.error(e), o = { error: e instanceof Error ? e.message : 'Something went wrong' } } return o }; const SA = async e => { const t = await NS.getState().getConnector(); const n = await t.getInfo(); return { data: { version: 'Alby', supports: ['lightning'], methods: t.supportedMethods, node: { alias: n.data.alias, pubkey: n.data.pubkey, color: n.data.color } } } }; const AA = async e => { const t = e.args.isSettled; const n = e.args.limit; const r = await NS.getState().getConnector(); try { let e = (await r.getInvoices()).data.invoices.filter(e => t ? e.settled : !e.settled).map(e => { const t = l.getBoostagramFromInvoiceCustomRecords(e.custom_records); return { ...e, boostagram: t } }); return n && (e = e.slice(0, n)), { data: { invoices: e } } } catch (e) { if (console.error(e), e instanceof Error) return { error: e.message } } }; const OA = { publishPaymentNotification: (e, t, n) => { let r = 'success'; 'error' in n.response && (r = 'failed'), BS().publish(`ln.${e}.${r}`, { accountId: n.accountId, response: n.response, details: n.details, paymentRequestDetails: n.paymentRequestDetails, origin: t.origin }) } }; async function xA (e) { BS().publish('ln.keysend.start', e); const { destination: t, amount: n, customRecords: r } = e.args; const i = await NS.getState().currentAccountId; if (!i) return { error: 'Select an account.' }; if (typeof t !== 'string' || typeof n !== 'string' && typeof n !== 'number') return { error: 'Destination or amount missing.' }; const o = await NS.getState().getConnector(); let a; try { a = await o.keysend({ pubkey: t, amount: parseInt(n), customRecords: r }) } catch (e) { a = { error: e instanceof Error ? e.message : 'Something went wrong' } } return OA.publishPaymentNotification('keysend', e, { accountId: i, response: a, details: { destination: t } }), a } const IA = async e => { let t; BS().publish('ln.makeInvoice.start', e); const n = e.args.memo || e.args.defaultMemo || 'Alby invoice'; if (!e.args.amount) return await l.openPrompt({ ...e, action: 'makeInvoice', args: { invoiceAttributes: { ...e.args } } }); { t = parseInt(e.args.amount); const r = await NS.getState().getConnector(); try { return await r.makeInvoice({ amount: t, memo: n }) } catch (e) { if (e instanceof Error) return { error: e.message } } } }; const NA = async e => { const t = await NS.getState().getConnector(); const n = NS.getState().currentAccountId; const { origin: r, args: i } = e; try { if (!i.method || typeof i.method !== 'string') throw new Error('Request method is missing or not correct'); const e = i.method.toLowerCase(); const o = t.supportedMethods || []; if (!t.requestMethod || !o.includes(e)) throw new Error(`${e} is not supported by your account`); const a = await bS.allowances.where('host').equalsIgnoreCase(r.host).first(); if (!a?.id) throw new Error('Could not find an allowance for this host'); if (!n) throw new Error('Could not find a selected account'); const s = t.constructor.name.toLowerCase(); const c = `webln/${s}/${e}`; const u = await bS.permissions.where('host').equalsIgnoreCase(r.host).and(e => e.accountId === n && e.method === c).first(); if (u && u.enabled && o.includes(e)) { return await t.requestMethod(e, i.params) } { const o = await l.openPrompt({ args: { requestPermission: { method: e, description: `${s}.${e}` } }, origin: r, action: 'public/confirmRequestPermission' }); const u = await t.requestMethod(e, i.params); if (o.data.enabled) { await bS.permissions.add({ createdAt: Date.now().toString(), accountId: n, allowanceId: a.id, host: r.host, method: c, enabled: o.data.enabled, blocked: o.data.blocked }) && await bS.saveToStorage() } return u } } catch (e) { return console.error(e), { error: e instanceof Error ? e.message : `Something went wrong with request ${i?.method}` } } }; async function TA (e) { BS().publish('ln.sendPayment.start', e); const t = await NS.getState().currentAccountId; if (!t) return { error: 'Select an account.' }; const { paymentRequest: n } = e.args; if (typeof n !== 'string') return { error: 'Payment request missing.' }; const r = await NS.getState().getConnector(); let i, o; try { o = gb().decode(n), i = await r.sendPayment({ paymentRequest: n }) } catch (e) { let t; t = typeof e === 'string' ? e : e.message ? e.message : 'Something went wrong', i = { error: t } } return OA.publishPaymentNotification('sendPayment', e, { accountId: t, paymentRequestDetails: o, response: i, details: { ...o && { description: o.tagsObject.description, destination: o.payeeNodeKey } } }), i } const RA = async e => { BS().publish('ln.signMessage.start', e); const t = e.args.message; if (typeof t !== 'string') return { error: 'Message missing.' }; if (t.startsWith('DO NOT EVER SIGN THIS TEXT')) return { error: 'forbidden' }; const n = await NS.getState().getConnector(); try { return await n.signMessage({ message: t, key_loc: { key_family: 0, key_index: 0 } }) } catch (n) { if (console.error(n), n instanceof Error) return BS().publish('ln.signMessage.failed', { error: n.message, message: t, origin: e.origin }), { error: n.message } } }; const PA = e => 'status' in e && e.status.toUpperCase() === 'ERROR'; const CA = e => { if (e.match(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-_0-9]+\.)+[a-zA-Z]{2,}))$/)) { let [t, n] = e.split('@'); return t = t.replace(/[^ -~]+/g, ''), n = n.replace(/[^ -~]+/g, ''), `https://${n}/.well-known/lnurlp/${t}` } return null }; const BA = { isLightningAddress: e => Boolean(CA(e)), findLnurl (e) { const t = e.trim(); let n; return (n = t.match(/lnurl[pwc]:(\S+)/i)) || (n = t.match(/(lnurl[a-zA-HJ-NP-Z0-9]+)/i)) ? n[1] : null }, async getDetails (e) { const t = (e => { try { const t = dA(e); return new URL(t) } catch (e) { console.info('ignoring bech32 parsing error', e) } const t = CA(e); return t ? new URL(t) : new URL(`https://${e.replace(/^lnurl[pwc]/i, '')}`) })(e); const n = t.searchParams.get('tag'); const r = t.searchParams.get('k1'); const i = t.searchParams.get('action'); if (n && n === 'login' && r) { return { ...i && { action: i }, domain: t.hostname, k1: r, tag: n, url: t.toString() } } try { const { data: e } = await rb().get(t.toString(), { adapter: db }); const n = e; if (PA(n)) throw new Error(`LNURL Error: ${n.reason}`); return n.domain = t.hostname, n.url = t.toString(), n } catch (e) { throw new Error(`Connection problem or invalid lnurl / lightning address: ${e instanceof Error ? e.message : ''}`) } }, verifyInvoice ({ paymentInfo: e, payerdata: t, metadata: n, amount: r }) { const i = gb().decode(e.pr); let o = ''; try { const e = t ? n + JSON.stringify(t) : n; o = ol()(e).toString(rl()) } catch (e) { console.error() } switch (!0) { case i.tagsObject.purpose_commit_hash !== o:case i.millisatoshis !== String(r):case e.successAction && !['url', 'message', 'aes'].includes(e.successAction.tag):return !1; default:return !0 } } }; const LA = BA; const jA = 'DO NOT EVER SIGN THIS TEXT WITH YOUR PRIVATE KEYS! IT IS ONLY USED FOR DERIVATION OF LNURL-AUTH HASHING-KEY, DISCLOSING ITS SIGNATURE WILL COMPROMISE YOUR LNURL-AUTH IDENTITY AND MAY LEAD TO LOSS OF FUNDS!'; async function DA ({ lnurlDetails: e, origin: t }) { if (e.tag !== 'login') throw new Error(`LNURL-AUTH FAIL: incorrect tag: ${e.tag} was used`); const n = await NS.getState().getAccount(); if (!n) throw new Error('LNURL-AUTH FAIL: no account selected'); const r = new URL(e.url); if (!r.host) throw new Error('Invalid input'); let i; if (n.mnemonic && n.useMnemonicForLnurlAuth) { const e = await NS.getState().getMnemonic(); const t = e.deriveKey("m/138'/0").privateKey; const n = (function (e, t) { const n = Hb()(ng().parse(e), rl().parse(t)).toString(rl()); const r = $g.Buffer.from(n, 'hex'); const i = []; for (let e = 0; e < 4; e++)i.push(r.readUint32BE(4 * e)); return i }(r.host, wn.bytesToHex(t))); let o = e.deriveKey("m/138'"); for (const e of n)o = o.deriveChild(e); i = wn.bytesToHex(o.privateKey) } else { const e = await NS.getState().getConnector(); const t = (await e.signMessage({ message: jA, key_loc: { key_family: 0, key_index: 0 } })).data.signature; if (!t) throw new Error('Invalid Signature'); const n = ol()(t).toString(rl()); const { settings: o } = NS.getState(); i = o.isUsingLegacyLnurlAuthKey ? Hb()(r.host, n).toString(rl()) : Hb()(r.host, rl().parse(n)).toString(rl()) } if (!i) throw new Error('Invalid linkingKey'); const o = new Ab(i); const a = l.hexToUint8Array(e.k1); if (!e.k1 || !a) throw new Error('Invalid K1'); const s = o.sign(a).toDER('hex'); const c = r; c.searchParams.set('sig', s), c.searchParams.set('key', o.pkHex), c.searchParams.set('t', Date.now().toString()); try { const n = await rb().get(c.toString(), { adapter: db }); if (n?.data.status?.toUpperCase() !== 'OK') throw new Error(n?.data?.reason || 'Auth: Something went wrong'); BS().publish('lnurl.auth.success', { authResponse: n, lnurlDetails: e, origin: t }); return { success: !0, status: n.data.status, reason: n.data.reason, authResponseData: n.data } } catch (n) { if (rb().isAxiosError(n)) { console.error('LNURL-AUTH FAIL:', n); const r = (n.response?.data)?.reason || n.message; throw BS().publish('lnurl.auth.failed', { error: r, lnurlDetails: e, origin: t }), new Error(r) } if (n instanceof Error) throw BS().publish('lnurl.auth.failed', { error: n.message, lnurlDetails: e, origin: t }), n } } const UA = async e => { const { lnurlDetails: t, origin: n } = e.args; return { data: await DA({ lnurlDetails: t, origin: n }) } }; const MA = async function (e, t, n) { const r = fA(t); if (!r) return; if (!('host' in e.origin)) return; BS().publish('lnurl.auth.start', { message: e, lnurlDetails: n }); const i = await bS.allowances.where('host').equalsIgnoreCase(r).first(); if (await NS.getState().isUnlocked() && i && i.enabled && i.lnurlAuth) return await DA({ lnurlDetails: n, origin: e.origin }); try { const t = { ...e, action: 'lnurlAuth', args: { ...e.args, lnurlDetails: n } }; return await l.openPrompt(t) } catch (e) { return { error: e instanceof Error ? e.message : e } } }; const zA = async function (e, t) { try { return await l.openPrompt({ origin: e.origin, action: 'lnurlChannel', args: { ...e.args, lnurlDetails: t } }) } catch (e) { return { error: e instanceof Error ? e.message : e } } }; const FA = async function (e, t) { try { return await l.openPrompt({ origin: e.origin, action: 'lnurlPay', args: { ...e.args, lnurlDetails: t } }) } catch (e) { return { error: e instanceof Error ? e.message : e } } }; const HA = async function (e, t) { try { return await l.openPrompt({ origin: e.origin, action: 'lnurlWithdraw', args: { ...e.args, lnurlDetails: t } }) } catch (e) { return { error: e instanceof Error ? e.message : e } } }; const qA = async function (e, t) { if (typeof e.args.lnurlEncoded !== 'string') return; let n; try { if (n = await LA.getDetails(e.args.lnurlEncoded), PA(n)) return { error: n.reason } } catch (e) { return { error: e instanceof Error ? e.message : 'Failed to parse LNURL' } } switch (n.tag) { case 'channelRequest':return zA(e, n); case 'login':return MA(e, t, n); case 'payRequest':return FA(e, n); case 'withdrawRequest':return HA(e, n); default:return { error: 'not implemented' } } }; const KA = 'abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo'.split('\n'); const VA = async e => ({ data: Ju(KA, 128) }); const WA = async e => { const t = e.args?.id || NS.getState().currentAccountId; const n = NS.getState().accounts; if (t && Object.keys(n).includes(t)) { const e = await NS.getState().password(); if (!e) return { error: 'Password is missing.' }; const r = n[t]; if (!r.mnemonic) return { data: null }; return { data: _(r.mnemonic, e) } } return { error: 'Account does not exist.' } }; const $A = async e => { const t = e.args?.id || NS.getState().currentAccountId; const n = await NS.getState().password(); if (!n) return { error: 'Password is missing.' }; const r = e.args.mnemonic; const i = NS.getState().accounts; if (t && Object.keys(i).includes(t)) { const e = i[t]; if (e.mnemonic = r ? w(r, n) : null, r && !e.nostrPrivateKey) { const t = new al(r).deriveNostrPrivateKeyHex(); e.nostrPrivateKey = w(t, n), e.hasImportedNostrKey = !1 } else e.hasImportedNostrKey = !0; return i[t] = e, NS.setState({ accounts: i, mnemonic: null, bitcoin: null }), await NS.getState().saveToStorage(), { data: { accountId: t } } } return { error: 'No account selected.' } }; const GA = async e => { const t = e.args.id; const n = NS.getState().accounts; if (Object.keys(n).includes(t)) { const e = await NS.getState().password(); if (!e) return { error: 'Password is missing.' }; const r = n[t]; if (!r.nostrPrivateKey) return { data: null }; const i = _(r.nostrPrivateKey, e); return { data: new kS(i).getPublicKey() } } return { error: 'Account does not exist.' } }; let YA; !(function (e) { e.NOSTR_SIGNMESSAGE = 'nostr/signMessage', e.NOSTR_SIGNSCHNORR = 'nostr/signSchnorr', e.NOSTR_GETPUBLICKEY = 'nostr/getPublicKey', e.NOSTR_NIP04DECRYPT = 'nostr/nip04decrypt', e.NOSTR_NIP04ENCRYPT = 'nostr/nip04encrypt' }(YA || (YA = {}))); const ZA = async (e, t) => { const n = fA(t); if (n) try { if (await vS(YA.NOSTR_NIP04DECRYPT, n)) { const t = await NS.getState().getNostr(); return { data: await t.decrypt(e.args.peer, e.args.ciphertext) } } { const t = await l.openPrompt({ ...e, action: 'public/nostr/confirm', args: { description: Ot.t('permissions:nostr.nip04decrypt') } }); if (t.data.rememberPermission && await wS(YA.NOSTR_NIP04DECRYPT, n), t.data.confirm) { const t = await NS.getState().getNostr(); return { data: await t.decrypt(e.args.peer, e.args.ciphertext) } } return { error: o } } } catch (e) { if (console.error('decrypt failed', e), e instanceof Error) return { error: e.message } } }; const JA = async (e, t) => { const n = fA(t); if (n) try { if (await vS(YA.NOSTR_NIP04ENCRYPT, n)) { return { data: (await NS.getState().getNostr()).encrypt(e.args.peer, e.args.plaintext) } } { const t = await l.openPrompt({ ...e, action: 'public/nostr/confirm', args: { description: Ot.t('permissions:nostr.nip04encrypt') } }); if (t.data.rememberPermission && await wS(YA.NOSTR_NIP04ENCRYPT, n), t.data.confirm) { return { data: (await NS.getState().getNostr()).encrypt(e.args.peer, e.args.plaintext) } } return { error: o } } } catch (e) { if (console.error('encrypt failed', e), e instanceof Error) return { error: e.message } } }; const XA = async (e, t) => { const n = fA(t); if (n) try { if (await vS(YA.NOSTR_GETPUBLICKEY, n)) { return { data: (await NS.getState().getNostr()).getPublicKey() } } { const t = await l.openPrompt({ args: {}, ...e, action: 'public/nostr/confirmGetPublicKey' }); if (t.data.rememberPermission && await wS(YA.NOSTR_GETPUBLICKEY, n), t.data.confirm) { return { data: (await NS.getState().getNostr()).getPublicKey() } } return { error: 'User rejected' } } } catch (e) { if (console.error('getPublicKey failed', e), e instanceof Error) return { error: e.message } } }; const QA = { normalizeToHex (e) { const t = e.substring(0, 4); if (['npub', 'nsec', 'note'].includes(t)) try { return dA(e, 'hex') } catch (e) { console.info('ignoring bech32 parsing error', e) } return e }, hexToNip19: (e, t = 'nsec') => (function (e, t) { const n = wn.hexToBytes(t); const r = uA.bech32.toWords(n); return uA.bech32.encode(e, r, 1e3) }(t, e)), derivePublicKey (e) { const t = Lu.getPublicKey(wn.hexToBytes(e)); const n = wn.bytesToHex(t); return eO.hexToNip19(n, 'npub') } }; const eO = QA; const tO = async (e, t) => { const n = fA(t); if (!n) return; const r = await NS.getState().getNostr(); const i = e.args.event; try { if (!_S(i)) return console.error('Invalid event'), { error: 'Invalid event.' }; if (!await vS(YA.NOSTR_SIGNMESSAGE, n)) { (await l.openPrompt({ ...e, action: 'public/nostr/confirmSignMessage' })).data.enabled && await wS(YA.NOSTR_SIGNMESSAGE, n) }i.pubkey || (i.pubkey = r.getPublicKey()), i.id || (i.id = r.getEventHash(i)); return { data: await r.signEvent(i) } } catch (e) { if (console.error('signEvent cancelled', e), e instanceof Error) return { error: e.message } } }; const nO = async (e, t) => { const n = fA(t); if (!n) return; const r = await NS.getState().getNostr(); const i = e.args.sigHash; try { if (!i || typeof i !== 'string') throw new Error('sigHash is missing or not correct'); if (!await vS(YA.NOSTR_SIGNSCHNORR, n)) { (await l.openPrompt({ ...e, action: 'public/nostr/confirmSignSchnorr' })).data.enabled && await wS(YA.NOSTR_SIGNSCHNORR, n) } return { data: await r.signSchnorr(i) } } catch (e) { if (console.error('signSchnorr cancelled', e), e instanceof Error) return { error: e.message } } }; const rO = async e => { const { accountId: t } = e.args; const n = e?.args?.limit || 2121; const r = await bS.payments.toCollection().filter(e => e.accountId === t).limit(n).reverse().sortBy('createdAt'); return { data: { payments: r } } }; const iO = async e => { const { host: t, method: n, accountId: r } = e.args; const i = await bS.permissions.where('host').equalsIgnoreCase(t).and(e => e.accountId === r && e.method === n).delete(); return await bS.saveToStorage(), { data: !!i } }; const oO = async e => { const { ids: t, accountId: n } = e.args; return n ? (await bS.permissions.where('id').anyOf(t).and(e => e.accountId === n).delete(), await bS.saveToStorage(), { data: !0 }) : { error: 'Missing account id to delete permission(s).' } }; const aO = async (e, t) => { const n = e.args; const r = new Xb[n.connector](n, n.config); await r.init(); try { const e = await r.getInfo(); return await r.unload(), { data: { valid: !0, info: e, oAuthToken: r.getOAuthToken?.() } } } catch (e) { return console.error(e), { data: { valid: !1, error: e.message } } } }; const sO = async e => { try { const e = await NS.getState().getBitcoin(); return { data: e.getTaprootAddress() } } catch (e) { return console.error('getAddress failed: ', e), { error: 'getAddress failed: ' + e } } }; const cO = async e => { try { return await l.openPrompt({ ...e, action: 'confirmGetAddress' }) } catch (e) { if (console.error('getAddress cancelled', e), e instanceof Error) return { error: e.message } } }; async function uO (e, t) { const n = await bS.allowances.where('host').equalsIgnoreCase(e).first(); return n && n.remainingBudget > t } const lO = async (e, t) => { const n = fA(t); if (!n) return; const r = e.args.destination; const i = e.args.amount; return typeof r !== 'string' || typeof i !== 'string' && typeof i !== 'number' ? { error: 'Destination or amount missing.' } : await uO(n, parseInt(i)) ? (async function (e) { try { return await xA(e) } catch (e) { if (console.error(e), e instanceof Error) return { error: e.message } } }(e)) : (async function (e) { try { return await l.openPrompt({ ...e, action: 'confirmKeysend' }) } catch (e) { if (console.error('Payment cancelled', e), e instanceof Error) return { error: e.message } } }(e)) }; const dO = async e => { const t = e.args.amount || e.args.defaultAmount; const n = e.args.memo || e.args.defaultMemo; const r = !e.args.amount; const i = !e.args.memo || e.args.memo === ''; try { return await l.openPrompt({ origin: e.origin, action: 'makeInvoice', args: { amountEditable: r, memoEditable: i, invoiceAttributes: { amount: t, memo: n, minimumAmount: e.args.minimumAmount, maximumAmount: e.args.maximumAmount } } }) } catch (e) { return { error: e instanceof Error ? e.message : e } } }; const fO = async e => typeof e.args.message !== 'string' ? { error: 'Message missing.' } : (async function (e) { try { return await l.openPrompt({ ...e, action: 'confirmSignMessage' }) } catch (e) { if (console.error('SignMessage cancelled', e), e instanceof Error) return { error: e.message } } }(e)); const hO = { addAllowance: sA, getAllowance: pA, getAllowanceById: gA, listAllowances: mA, deleteAllowance: cA, updateAllowance: yA, addPermission: async e => { const { host: t, method: n, enabled: r, blocked: i } = e.args; const o = NS.getState().currentAccountId; const a = await bS.allowances.where('host').equalsIgnoreCase(t).first(); if (!a?.id) return { error: 'No Allowance set for this host' }; if (!o) return { error: 'No Account selected' }; const s = await bS.permissions.add({ createdAt: Date.now().toString(), allowanceId: a.id, accountId: o, host: t, method: n, enabled: r, blocked: i }); return await bS.saveToStorage(), { data: s } }, deletePermission: iO, deletePermissionsById: oO, listPermissions: async e => { const { id: t, accountId: n } = e.args; if (!n) return { error: 'Missing account id to fetch permissions.' }; const r = await bS.permissions.where({ allowanceId: t, accountId: n }).toArray(); const i = []; for (const e of r) if (e.id) { const { id: t } = e; const n = { ...e, id: t }; i.push(n) } return { data: { permissions: i } } }, lock: rA, unlock: aA, getInfo: SA, getInvoices: AA, sendPayment: TA, keysend: xA, checkPayment: EA, signMessage: RA, makeInvoice: IA, connectPeer: kA, getPayments: async e => { const t = e?.args?.limit || 2121; return { data: { payments: await bS.payments.toCollection().limit(t).reverse().sortBy('createdAt') } } }, getPaymentsByAccount: rO, accountInfo: nA, accountDecryptedDetails: QS, addAccount: JS, editAccount: eA, getAccounts: XS, getAccount: tA, removeAccount: iA, selectAccount: oA, setPassword: async e => { const t = e.args.password; return await NS.getState().password(t), Promise.resolve({ data: { unlocked: !0 } }) }, reset: async e => (await NS.getState().reset(), await bS.clearAllTables(), { data: { reset: !0 } }), status: async e => { const t = await NS.getState().isUnlocked(); const n = NS.getState().getAccount(); const r = NS.getState().currentAccountId; const i = n != null; return Promise.resolve({ data: { unlocked: t, configured: i, currentAccountId: r } }) }, validateAccount: aO, setIcon: async (e, t) => t.tab?.id ? (await PS(e.args.icon, t.tab.id), Promise.resolve({ data: !0 })) : Promise.resolve({ data: !1 }), changePassword: async e => { const t = NS.getState().accounts; const n = await NS.getState().password(); if (!n) return { error: 'Password is missing' }; const r = e.args.password; const i = { ...t }; for (const e in i) { const o = _(t[e].config, n); if (i[e].config = w(o, r), t[e].nostrPrivateKey) { const o = _(t[e].nostrPrivateKey, n); i[e].nostrPrivateKey = w(o, r) } if (t[e].mnemonic) { const o = _(t[e].mnemonic, n); i[e].mnemonic = w(o, r) } } return await NS.getState().password(r), NS.setState({ accounts: i }), await NS.getState().saveToStorage(), {} }, setSetting: async e => { const { settings: t } = NS.getState(); const { setting: n } = e.args; if (typeof n === 'object') { const e = { ...t, ...n }; return NS.setState({ settings: e }), await NS.getState().saveToStorage(), Promise.resolve({ data: e }) } return Promise.reject(new Error('Incorrect setting')) }, getSettings: async () => ({ data: NS.getState().settings }), addBlocklist: bA, deleteBlocklist: vA, getBlocklist: wA, listBlocklist: _A, lnurl: qA, lnurlAuth: UA, getCurrencyRate: qS, getAddress: sO, setMnemonic: $A, getMnemonic: WA, generateMnemonic: VA, nostr: { generatePrivateKey: async e => { const t = e.args?.id || NS.getState().currentAccountId; const n = await NS.getState().password(); if (!n) return { error: 'Password is missing.' }; const r = NS.getState().accounts; if (t && Object.keys(r).includes(t)) { const e = r[t]; if (!e.mnemonic) return { error: 'Secret key is missing.' }; return { data: new al(_(e.mnemonic, n)).deriveNostrPrivateKeyHex() } } return { error: 'Error generating private key.' } }, getPrivateKey: async e => { const t = e?.args?.id; if (!t) return { data: (await NS.getState().getNostr()).privateKey }; const n = NS.getState().accounts; if (Object.keys(n).includes(t)) { const e = await NS.getState().password(); if (!e) return { error: 'Password is missing.' }; const r = n[t]; if (!r.nostrPrivateKey) return { data: null }; return { data: _(r.nostrPrivateKey, e) } } return { error: 'Account does not exist.' } }, getPublicKey: GA, removePrivateKey: async e => { const t = e.args?.id || NS.getState().currentAccountId; const n = NS.getState().accounts; if (t && Object.keys(n).includes(t)) { const e = n[t]; return e.nostrPrivateKey && delete e.nostrPrivateKey, e.hasImportedNostrKey = !0, n[t] = e, NS.setState({ accounts: n, nostr: null }), await NS.getState().saveToStorage(), { data: { accountId: t } } } return { error: 'No account selected.' } }, setPrivateKey: async e => { const t = e.args?.id || NS.getState().currentAccountId; const n = await NS.getState().password(); if (!n) return { error: 'Password is missing.' }; let r; try { r = eO.normalizeToHex(e.args.privateKey), eO.derivePublicKey(r), eO.hexToNip19(r, 'nsec') } catch (e) { return { error: 'Invalid private key' } } const i = NS.getState().accounts; if (t && Object.keys(i).includes(t)) { const e = i[t]; return e.nostrPrivateKey = r ? w(r, n) : null, e.hasImportedNostrKey = !e.mnemonic || new al(_(e.mnemonic, n)).deriveNostrPrivateKeyHex() !== r, i[t] = e, NS.setState({ accounts: i, nostr: null }), await NS.getState().saveToStorage(), { data: { accountId: t } } } return { error: 'No account selected.' } } }, public: { webbtc: { enable: hA, getInfo: async e => ({ data: { version: 'Alby', supports: ['bitcoin'], methods: ['getInfo', 'getAddress'] } }), getAddressWithPrompt: cO }, alby: { enable: hA, addAccount: async function (e) { if (typeof e.args.name !== 'string') return { error: 'Name missing.' }; if (typeof e.args.connector !== 'string') return { error: 'Connector missing.' }; if (typeof e.args.config !== 'object') return { error: 'Config missing.' }; try { return await l.openPrompt({ ...e, action: 'confirmAddAccount' }), { data: { success: !0 } } } catch (e) { return console.error('Adding account cancelled', e), e instanceof Error ? { success: !1, error: e.message } : { success: !1 } } } }, webln: { enable: hA, getInfo: SA, sendPaymentOrPrompt: async (e, t) => { const n = fA(t); if (!n) return; const r = e.args.paymentRequest; if (typeof r !== 'string') return { error: 'Payment request missing.' }; const i = gb().decode(r); return await uO(n, i.satoshis || 0) ? (async function (e) { try { return await TA(e) } catch (e) { if (console.error(e), e instanceof Error) return { error: e.message } } }(e)) : (async function (e) { try { return await l.openPrompt({ ...e, action: 'confirmPayment' }) } catch (e) { if (console.error('Payment cancelled', e), e instanceof Error) return { error: e.message } } }(e)) }, keysendOrPrompt: lO, signMessageOrPrompt: fO, lnurl: qA, makeInvoice: async e => dO(e), request: NA }, nostr: { enable: hA, getPublicKeyOrPrompt: XA, signEventOrPrompt: tO, signSchnorrOrPrompt: nO, getRelays: async (e, t) => { const n = fA(t); if (!n) return; const r = await bS.allowances.get({ host: n }); return r?.id ? { data: { 'wss://relay.damus.io': { read: !0, write: !0 }, 'wss://nostr1.tunnelsats.com': { read: !0, write: !0 }, 'wss://nostr-pub.wellorder.net': { read: !0, write: !0 }, 'wss://relay.nostr.info': { read: !0, write: !0 }, 'wss://nostr-relay.wlvs.space': { read: !0, write: !0 }, 'wss://nostr.bitcoiner.social': { read: !0, write: !0 }, 'wss://nostr-01.bolt.observer': { read: !0, write: !0 }, 'wss://relayer.fiatjaf.com': { read: !0, write: !0 } } } : { error: 'Could not find an allowance for this host' } }, encryptOrPrompt: JA, decryptOrPrompt: ZA } } }; let pO = !1; let gO = !1; const { promise: mO, resolve: yO, reject: bO } = l.deferredPromise(); i().runtime.onMessage.addListener((e, t) => { false }), i().runtime.onMessage.addListener(async (e, t) => { if (e.application !== 'LBE' || !e.prompt) return; e.type && console.error('Invalid message, using type: ', e), await mO; const n = e.action || e.type; console.info(`Routing call: ${n}`); const r = (e => { if (!e) throw new Error('No action path provided to router'); const t = e.split('/').reduce((e, t) => e[t], hO); return t || (console.warn(`Route not found: ${e}`), () => Promise.reject({ error: `${e} not found` })) })(n)(e, t); return await r }), i().tabs.onUpdated.addListener(async (e, t, n) => { if (t.status !== 'complete' || !n.url?.startsWith('http')) return; const r = new URL(n.url); const i = await yS.allowances.where('host').equalsIgnoreCase(r.host).first(); await PS(i ? RS.Active : RS.Default, e) }), i().tabs.onUpdated.addListener((e, t, n) => { t.status === 'complete' && n.url?.startsWith('http') && setTimeout(() => { i().tabs.sendMessage(e, { action: 'extractLightningData' }) }, 150) }), i().runtime.onInstalled.addListener(e => { console.info(`Handle installed: ${e.reason}`), e.reason === 'install' && (pO = !0), e.reason === 'update' && (console.info('Alby was recently updated'), gO = !0) }), console.info('Welcome to Alby'), (async function () { console.info('Loading background script'), await NS.getState().init(), console.info('State loaded'), await ('indexedDB' in globalThis ? new Promise(e => { const t = globalThis.indexedDB.open('LBE-AVAILABILITY-CHECK', 1); t.onsuccess = () => { e(!0) }, t.onerror = () => { e(!1) } }) : Promise.resolve(!1)) ? (console.info('Using indexedDB'), await yS.open()) : (console.info('Using in memory DB'), await yS.openWithInMemoryDB()), console.info('DB opened'), ['sendPayment', 'keysend'].forEach(e => { BS().subscribe(`ln.${e}.success`, VS), BS().subscribe(`ln.${e}.failed`, WS), BS().subscribe(`ln.${e}.success`, YS), BS().subscribe(`ln.${e}.success`, LS) }), BS().subscribe('lnurl.auth.success', $S), BS().subscribe('lnurl.auth.failed', GS), console.info('Event subscriptions registered'), console.info('Events subscribed'), gO && (console.info('Running any pending migrations'), await ZS()), console.info('Loading completed') }()).then(() => { yO && yO(), pO && !NS.getState().getAccount() && l.openUrl('welcome.html') }).catch(e => { console.error(e), bO && bO() }), i().runtime.setUninstallURL('https://getalby.com/goodbye') })() })()
