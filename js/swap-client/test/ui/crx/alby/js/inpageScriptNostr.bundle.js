(() => { 'use strict'; class e {nip04 = new t(this); enabled; constructor () { this.enabled = !1 } async enable () { if (this.enabled) return { enabled: !0 }; const e = await this.execute('enable'); return typeof e.enabled === 'boolean' && (this.enabled = e.enabled), e } async getPublicKey () { return await this.enable(), await this.execute('getPublicKeyOrPrompt') } async signEvent (e) { return await this.enable(), this.execute('signEventOrPrompt', { event: e }) } async signSchnorr (e) { return await this.enable(), this.execute('signSchnorrOrPrompt', { sigHash: e }) } async getRelays () { return await this.enable(), this.execute('getRelays') }execute (e, t) { return (function (e, t, a) { return new Promise((r, n) => { const i = Math.random().toString().slice(4); window.postMessage({ id: i, application: 'LBE', prompt: !0, action: `${e}/${t}`, scope: e, args: a }, '*'), window.addEventListener('message', function t (a) { a.data && a.data.response && a.data.application === 'LBE' && a.data.scope === e && a.data.id === i && (a.data.data.error ? n(new Error(a.data.data.error)) : r(a.data.data.data), window.removeEventListener('message', t)) }) }) }('nostr', e, t)) }} class t {provider; constructor (e) { this.provider = e } async encrypt (e, t) { return await this.provider.enable(), this.provider.execute('encryptOrPrompt', { peer: e, plaintext: t }) } async decrypt (e, t) { return await this.provider.enable(), this.provider.execute('decryptOrPrompt', { peer: e, ciphertext: t }) }}document && (window.nostr = new e()) })()
