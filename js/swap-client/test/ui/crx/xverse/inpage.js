(() => { 'use strict'; let e; !(function (e) { e.authenticationRequest = 'stacksAuthenticationRequest', e.signatureRequest = 'signatureRequest', e.structuredDataSignatureRequest = 'structuredDataSignatureRequest', e.transactionRequest = 'stacksTransactionRequest', e.getAddressRequest = 'SatsAddressRequest', e.signPsbtRequest = 'SatsPsbtRequest', e.signMessageRequest = 'SatsSignMessage', e.sendBtcRequest = 'SatsSendBtcRequest' }(e || (e = {}))); const s = 'xverse-wallet'; let t, n, a; !(function (e) { e.transactionRequest = 'transactionRequest', e.transactionResponse = 'transactionResponse', e.authenticationRequest = 'authenticationRequest', e.authenticationResponse = 'authenticationResponse', e.signatureRequest = 'signatureRequest', e.signatureResponse = 'signatureResponse', e.structuredDataSignatureRequest = 'structuredDataSignatureRequest', e.structuredDataSignatureResponse = 'structuredDataSignatureResponse' }(t || (t = {}))), (function (e) { e.RequestDerivedStxAccounts = 'RequestDerivedStxAccounts', e.ShareInMemoryKeyToBackground = 'ShareInMemoryKeyToBackground', e.RequestInMemoryKeys = 'RequestInMemoryKeys', e.RemoveInMemoryKeys = 'RemoveInMemoryKeys', e.OriginatingTabClosed = 'OriginatingTabClosed' }(n || (n = {}))), (function (e) { e.getAddressRequest = 'getAddressRequest', e.getAddressResponse = 'getAddressResponse', e.signPsbtRequest = 'signPsbtRequest', e.signPsbtResponse = 'signPsbtResponse', e.signMessageRequest = 'signMessageRequest', e.signMessageResponse = 'signMessageResponse', e.sendBtcRequest = 'sendBtcRequest', e.sendBtcResponse = 'sendBtcResponse' }(a || (a = {}))); const o = (e, t) => { const { data: n } = e; const a = n.source === s; const o = n.method === t; return a && o && !!n.payload }; const d = { getURL: async () => { const { url: e } = await (async (e, s = {}) => new Promise((t, n) => { const a = setTimeout(() => { n(new Error('Unable to get response from xverse extension')) }, 1e3); const o = s => { s.data.source === 'xverse-extension' && s.data.method === `${e}Response` && (clearTimeout(a), window.removeEventListener('message', o), t(s.data)) }; window.addEventListener('message', o), window.postMessage({ method: e, source: 'xverse-app', ...s }, window.location.origin) }))('getURL'); return e }, structuredDataSignatureRequest: async s => { const n = new CustomEvent(e.structuredDataSignatureRequest, { detail: { signatureRequest: s } }); return document.dispatchEvent(n), new Promise((e, n) => { const a = d => { o(d, t.signatureResponse) && d.data.payload?.signatureRequest === s && (window.removeEventListener('message', a), d.data.payload.signatureResponse !== 'cancel' ? typeof d.data.payload.signatureResponse !== 'string' && e(d.data.payload.signatureResponse) : n(d.data.payload.signatureResponse)) }; window.addEventListener('message', a) }) }, signatureRequest: async s => { const n = new CustomEvent(e.signatureRequest, { detail: { signatureRequest: s } }); return document.dispatchEvent(n), new Promise((e, n) => { const a = d => { o(d, t.signatureResponse) && d.data.payload?.signatureRequest === s && (window.removeEventListener('message', a), d.data.payload.signatureResponse !== 'cancel' ? typeof d.data.payload.signatureResponse !== 'string' && e(d.data.payload.signatureResponse) : n(d.data.payload.signatureResponse)) }; window.addEventListener('message', a) }) }, authenticationRequest: async s => { const n = new CustomEvent(e.authenticationRequest, { detail: { authenticationRequest: s } }); return document.dispatchEvent(n), new Promise((e, n) => { const a = d => { o(d, t.authenticationResponse) && d.data.payload?.authenticationRequest === s && (window.removeEventListener('message', a), d.data.payload.authenticationResponse !== 'cancel' ? e(d.data.payload.authenticationResponse) : n(d.data.payload.authenticationResponse)) }; window.addEventListener('message', a) }) }, transactionRequest: async s => { const n = new CustomEvent(e.transactionRequest, { detail: { transactionRequest: s } }); return document.dispatchEvent(n), new Promise((e, n) => { const a = d => { o(d, t.transactionResponse) && d.data.payload?.transactionRequest === s && (window.removeEventListener('message', a), d.data.payload.transactionResponse !== 'cancel' ? typeof d.data.payload.transactionResponse !== 'string' && e(d.data.payload.transactionResponse) : n(d.data.payload.transactionResponse)) }; window.addEventListener('message', a) }) }, getProductInfo: () => ({ version: '0.15.0', name: 'Xverse Wallet' }), request () { throw new Error('`request` function is not implemented') } }; const i = (e, t) => { const { data: n } = e; const a = n.source === s; const o = n.method === t; return a && o && !!n.payload }; const r = { connect: async s => { const t = new CustomEvent(e.getAddressRequest, { detail: { btcAddressRequest: s } }); return document.dispatchEvent(t), new Promise((e, t) => { const n = o => { i(o, a.getAddressResponse) && o.data.payload?.addressRequest === s && (window.removeEventListener('message', n), o.data.payload.addressResponse !== 'cancel' ? typeof o.data.payload.addressResponse !== 'string' && e(o.data.payload.addressResponse) : t(o.data.payload.addressResponse)) }; window.addEventListener('message', n) }) }, signTransaction: async s => { const t = new CustomEvent(e.signPsbtRequest, { detail: { signPsbtRequest: s } }); return document.dispatchEvent(t), new Promise((e, t) => { const n = o => { i(o, a.signPsbtResponse) && o.data.payload?.signPsbtRequest === s && (window.removeEventListener('message', n), o.data.payload.signPsbtResponse !== 'cancel' ? typeof o.data.payload.signPsbtResponse !== 'string' && e(o.data.payload.signPsbtResponse) : t(o.data.payload.signPsbtResponse)) }; window.addEventListener('message', n) }) }, signMessage: async s => { const t = new CustomEvent(e.signMessageRequest, { detail: { signMessageRequest: s } }); return document.dispatchEvent(t), new Promise((e, t) => { const n = o => { i(o, a.signMessageResponse) && o.data.payload?.signMessageRequest === s && (window.removeEventListener('message', n), o.data.payload.signMessageResponse !== 'cancel' ? typeof o.data.payload.signMessageResponse === 'string' && e(o.data.payload.signMessageResponse) : t(o.data.payload.signMessageResponse)) }; window.addEventListener('message', n) }) }, sendBtcTransaction: async s => { const t = new CustomEvent(e.sendBtcRequest, { detail: { sendBtcRequest: s } }); return document.dispatchEvent(t), new Promise((e, t) => { const n = o => { i(o, a.sendBtcResponse) && o.data.payload?.sendBtcRequest === s && (window.removeEventListener('message', n), o.data.payload.sendBtcResponse !== 'cancel' ? typeof o.data.payload.sendBtcResponse === 'string' && e(o.data.payload.sendBtcResponse) : t(o.data.payload.sendBtcResponse)) }; window.addEventListener('message', n) }) }, call (e) { throw new Error('`call` function is not implemented') } }; window.StacksProvider = d, window.BitcoinProvider = r })()
